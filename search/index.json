[{"content":"距离的定义 在机器学习中，我们通过计算不同样本在特征空间中的距离来评估样本间的相似度，进而为其进行分类。根据样本特征空间的不同，我们需要选择合适的距离度量方法。一般而言，对于距离度量函数$d(x,y)$，其需要满足如下性质：\n非负性：$d(x,y)\\geq 0$ 同一性：$d(x,y)=0\\Leftrightarrow x=y$ 对称性：$d(x,y)=d(y,x)$ 三角不等式：$d(x,y)\\leq d(x,z)+d(z,y)$ 根据样本特征空间的不同，我们把度量的距离分为：空间距离、字符距离、集合距离、分布距离。\n空间距离 欧几里得距离（Euclidean Distance） 欧几里得距离用于描述欧式空间中任意两点间的直线距离，常被称作欧几里得范数，或$\\mathcal{L}_2$范数。对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的欧几里得距离定义为：\n$$d=\\sqrt{\\sum_{i=1}^{n}{\\left(x_i-y_i\\right)^2}}$$\n在 Python 中用于计算任意两点间欧几里得距离的代码如下：\n1 2 3 4 5 6 import numpy as np def EuclideanDistance(x, y): x = np.array(x) y = np.array(y) return np.sqrt(np.sum(np.square(x - y))) 曼哈顿距离（Manhattan Distance） 曼哈顿距离用于描述标准坐标系中任意两点间的绝对轴距之和，常被称作曼哈顿范数，或$\\mathcal{L}_1$范数。对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的曼哈顿距离定义为：\n$$d=\\sqrt{\\sum_{i=1}^{n}{\\left|x_i-y_i\\right|}}$$\n下图所示红色路径为曼哈顿距离，绿色路径为欧几里得距离，蓝色路径和黄色路径为等价曼哈顿距离。曼哈顿距离的发明是为了应对早期计算图形学领域中浮点运算代价高的情况，采用曼哈顿距离代替欧几里得距离进行图形渲染。\n曼哈顿距离（Manhattan Distance）\n在 Python 中用于计算任意两点间曼哈顿距离的代码如下：\n1 2 3 4 5 6 import numpy as np def ManhattanDistance(x, y): x = np.array(x) y = np.array(y) return np.sum(np.abs(x - y)) 切比雪夫距离（Chebyschev Distance） 切比雪夫距离用于描述标准坐标系中任意两点间的绝对轴距最大值，常被称作切比雪夫范数，或$\\mathcal{L}_\\infty$范数。对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的切比雪夫距离定义为：\n$$d=\\max\\left|x_i-y_i\\right|$$\n以下图所示位于 F6 的“王”为例，其到棋盘上任意一点的切比雪夫距离即为它需要移动的步数。需要注意的是，在国际象棋中“王”每次可以朝任意方向移动一格。\n切比雪夫距离（Chebyschev Distance）\n在 Python 中用于计算任意两点间切比雪夫距离的代码如下：\n1 2 3 4 5 6 import numpy as np def ChebyshevDistance(x, y): x = np.array(x) y = np.array(y) return np.max(np.abs(x - y)) 闵可夫斯基距离（Minkowski Distance） 闵可夫斯基距离并非一种新型的距离度量方式，而是一种对于多种不同距离度量的概括性表述。对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的闵可夫斯基距离定义为：\n$$d=\\left(\\sum_{i=1}^{n}{\\left|x_i-y_i\\right|^p}\\right)^{1/p}$$\n其中，$p$为闵可夫斯基距离参数。当$p=1$时，闵可夫斯基距离退化为曼哈顿距离；当$p=2$时，闵可夫斯基距离退化为欧几里得距离；当$p\\rightarrow\\infty$时，闵可夫斯基距离退化为切比雪夫距离，如下图所示：\n闵可夫斯基距离（Minkowski Distance）\n在 Python 中用于计算任意两点间闵可夫斯基距离的代码如下：\n1 2 3 4 5 6 import math import numpy as np def MinkowskiDistance(x, y, p): zipped_coordinate = zip(x, y) return math.pow(np.sum(math.pow(np.abs(x - y), p)), 1 / p) 标准化欧几里得距离（Standardized Euclidean Distance） 标准化欧几里得距离是将欧式空间中任意两点的分量都“标准化”到均值、方差一致的区间，记每个分量的均值为$\\mu$，方差为$\\sigma_i^2$，“标准化”结果为$X^*$：\n$$X^*=\\frac{X-\\mu}{\\sigma^2}$$\n对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的标准化欧几里得距离定义为：\n$$d=\\sqrt{\\sum_{i=1}^{n}{\\left(\\frac{x_i-y_i}{\\sigma_i^2}\\right)^2}}$$\n如果将$1/\\sigma^2$看做权重，则标准化欧几里得距离可以被认为是加权欧几里得距离。\n在 Python 中用于计算任意两点间标准化欧几里得距离的代码如下（需要注意 sigma ≠ 0）：\n1 2 3 4 5 6 7 8 9 10 import numpy as np def StandardizedEuclideanDistance(x, y): x = np.array(x) y = np.array(y) X = np.vstack([x,y]) sigma = np.var(X, axis=0, ddof=1) return np.sqrt(((x - y) ** 2 /sigma).sum()) 马氏距离（Mahalanobis Distance） 马氏距离由印度统计学家马哈拉诺比斯（P. C. Mahalanobis）提出，用于表示数据的协方差距离，它可以有效地表示两个未知样本集之间的相似度。对于$n$维空间中的任意两个样本集$\\textbf{X}$和$\\textbf{Y}$的马氏距离定义为：\n$$d=\\sqrt{\\left(\\textbf{X}-\\textbf{Y}\\right)^T\\Sigma^{-1}\\left(\\textbf{X}-\\textbf{Y}\\right)}$$\n其中，$\\Sigma$为样本集$X$和$Y$的协方差矩阵。若协方差矩阵为单位矩阵，则马氏距离退化为欧几里得距离；若协方差矩阵为对角矩阵，则马氏距离退化为标准化欧几里得距离。\n需要注意的是，马氏距离的计算需要确保$\\Sigma$的逆矩阵存在，否则可以直接采用欧几里得距离进行计算。此外，马氏距离不受量纲的影响，它可以排除变量之间相关性的干扰，但同时也夸大了微小变化量的作用。例如，若将两个相同的样本放入两个不同的总体中，经计算的到的马氏距离也是不同的（除非它们的$\\Sigma$恰巧相同）。\n在 Python 中用于计算任意两个样本集间马氏距离的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import numpy as np def MahalanobisDistance(x, y): x = np.array(x) y = np.array(y) X = np.vstack([x,y]) X_T = X.T sigma_inverse = np.linalg.inv(np.cov(X)) d = [] for i in range(0, X_T.shape[0]): for j in range(i + 1, X_T.shape[0]): delta = X_T[i] - X_T[j] d.append(np.sqrt(np.dot(np.dot(delta,sigma_inverse),delta.T))) return d 兰氏距离（Lance and Williams Distance） 兰氏距离又被称为堪培拉距离（Canberra Distance），可以理解为加权曼哈顿距离。对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的兰氏距离定义为：\n$$d=\\sum_{i=1}^{n}{\\frac{\\left|x_i-y_i\\right|}{\\left|x_i\\right|+\\left|y_i\\right|}}$$\n在 Python 中用于计算任意两点间兰氏距离的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import numpy as np def CanberraDistance(x, y): x = np.array(x) y = np.array(y) d = 0 for i in range(len(x)): if x[i] == 0 and y[i] == 0: d += 0 else: d += abs(x[i] - y[i]) / (abs(x[i]) + abs(y[i])) return d 余弦相似度（Cosine Similarity） 在几何学中，通常采用余弦相似度来度量两个向量间的夹角，其取值为$[-1,1]$。对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的余弦相似度定义为：\n$$\\cos{\\left(\\vec{x},\\vec{y}\\right)}=\\frac{\\vec{x}\\cdot\\vec{y}}{\\left|\\vec{x}\\right|\\cdot\\left|\\vec{y}\\right|}=\\frac{\\displaystyle\\sum_{i=1}^{n}{x_i\\cdot y_i}}{\\sqrt{\\displaystyle\\sum_{i=1}^{n}{x_i^2}}\\cdot\\sqrt{\\displaystyle\\sum_{i=1}^{n}{y_i^2}}}$$\n当$\\cos{\\left(\\vec{x},\\vec{y}\\right)}\\rightarrow0$时，两向量完全正交；当$\\cos{\\left(\\vec{x},\\vec{y}\\right)}\\rightarrow1$时，两向量完全重合；当$\\cos{\\left(\\vec{x},\\vec{y}\\right)}\\rightarrow -1$时，两向量完全相反。在 Python 中用于计算任意两点间余弦相似度的代码如下：\n1 2 3 4 5 6 import numpy as np def CosineDistance(x, y): x = np.array(x) y = np.array(y) return np.dot(x,y) / (np.linalg.norm(x) * np.linalg.norm(y)) 测地距离（Geodesic Distance） 测地距离原指球体表面上两点间的最短距离，后来被推广到其它领域。在图论中，测地距离为两顶点间的最短路径；在欧式空间中，测地距离为欧几里得距离；在非欧空间中，测地距离为连接两点间的最短圆弧。如下图所示：\n测地距离（Geodesic Distance）\n布雷柯蒂斯距离（Bray Curtis Distance） 布雷柯蒂斯距离主要用于生态学和环境科学领域，用于计算不同样本间的差异。对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的布雷柯蒂斯距离定义为：\n$$d=\\frac{\\displaystyle \\sum_{i=1}^{n}{\\left|x_i-y_i\\right|}}{\\displaystyle \\sum_{i=1}^{n}{x_i}+\\sum_{i=1}^{n}{y_i}}$$\n在 Python 中用于计算任意两点间布雷柯蒂斯距离的代码如下：\n1 2 3 4 5 6 import numpy as np def BrayCurtisDistance(x, y): x = np.array(x) y = np.array(y) return np.sum(np.abs(x - y)) / (np.sum(x) + np.sum(y)) 半正矢距离（Haversine Distance） 半正矢距离用于计算任意两经纬点间的距离，对于空间中的任意两经纬点$A(\\mathrm{lon}_1,\\mathrm{lat}_1)$和$B(\\mathrm{lon}_2,\\mathrm{lat}_2)$的半正矢距离定义为：\n$$d=2r\\cdot\\arcsin{\\sqrt{\\sin^2{\\frac{\\mathrm{lat}_2-\\mathrm{lat}_1}{2}}+\\cos{(\\mathrm{lat}_1)}\\cos{(\\mathrm{lat}_2)}\\sin^2{\\frac{\\mathrm{lon}_2-\\mathrm{lon}_1}{2}}}}$$\n其中，$r$为半径。在 Python 中用于计算任意两经纬点间半正矢距离的代码如下：\n1 2 3 4 5 import numpy as np def HaversineDistance(lon1, lat1, lon2, lat2): lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2]) c = 2 * 6367 * 1000 *np.arcsin(np.sqrt(np.sin((lat2 - lat1) / 2.0) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin((lon2 - lon1) / 2.0) ** 2)) 字符距离 汉明距离（Hamming Distance） 汉明距离由两个字符串对应位不同的数量决定，通常用于数据传输差错控制编码领域。对于长度为$n$的任意两个字符串$A=x_1x_2\\cdots x_n$和$B=y_1y_2\\cdots y_n$的汉明距离定义为：\n$$d=\\sum_{i=0}^{n}{x_i\\otimes y_i}$$\n汉明距离也可以理解为将$A$变为$B$的最小操作次数。在 Python 中用于计算任意两个字符串间汉明距离的代码如下：\n1 2 def HammingDistance(x, y): return sum(x_ch != y_ch for x_ch, y_ch in zip(x, y)) 莱文斯坦距离（Levenshtein Distance） 莱文斯坦距离又被称为编辑距离（Edit Distance），用于度量两个字符串之间的差异，定义为：将字符串$A$转化为字符串$B$所需的最少单字符编辑（插入、删除或替换）次数。对于长度为$n$的任意两个字符串$A=x_1x_2\\cdots x_n$和$B=y_1y_2\\cdots y_n$，$A$的前$i$个字符和$B$的前$j$个字符的莱文斯坦距离定义为：\n$$d(i,j) = \\begin{align*} \\left{\\begin{matrix} \\max{\\left(i,j\\right)}, \u0026amp; \\min{\\left(i,j\\right)}=0 \\ \\min{\\left[d(i-1,j),d(i,j-1), d(i,j)\\right]} + I(i,j), \u0026amp; \\min{\\left(i,j\\right)\\neq 0} \\end{matrix}\\right. \\end{align*}$$\n其中，$I(\\cdot)$为指示函数，当$x_i=y_j$时，$I(i,j)=0$；当$x_i\\neq y_j$时，$I(i,j)=1$。在 Python 中用于计算任意两个字符串间莱文斯坦距离的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 def LevenshteinDistance(x, y): dp = np.zeros((len(x) + 1,len(y) + 1)) for i in range(len(x) + 1): dp[i][0] = i for j in range(len(y) + 1): dp[0][j] = j for i in range(1, len(x) + 1): for j in range(1, len(y) + 1): delta = 0 if x[i-1] == y[j-1] else 1 dp[i][j] = min(dp[i - 1][j - 1] + delta, min(dp[i-1][j] + 1, dp[i][j - 1] + 1)) return int(dp[len(x)][len(y)]) 归一化 Google 距离（Normalized Google Distance） 归一化 Google 距离是由给定一组关键词集合的 Google 搜索引擎所返回的命中数量决定的，它是一种语义相似度量方法。对于长度为$n$的任意两个字符串$A=x_1x_2\\cdots x_n$和$B=y_1y_2\\cdots y_n$的归一化 Google 距离定义为：\n$$d=\\frac{\\max{\\left[\\log{f(A)},\\log{f(B)}\\right]}-\\log{f(A,B)}}{\\log{M}-\\min{\\left[\\log{f(A)}, \\log{f(B)}\\right]}}$$\n其中，$M$为 Google 搜索引擎所返回的网页总数；$f(x)$和$f(y)$分别为 Google 搜索引擎返回关于字符串$A$和字符串$B$的命中数量；$f(A,B)$为 Google 搜索引擎返回关于字符串$A$和字符串$B$同时出现的命中数量。\nJaro-Winkler 相似度（Jaro-Winkler Similarity） Jaro 相似度用于评估两个字符串间的相似度，对于长度为$n$的任意两个字符串$A=x_1x_2\\cdots x_n$和$B=y_1y_2\\cdots y_n$的 Jaro 相似度定义为：\n$$d_j=\\frac{1}{3}\\cdot\\left(\\frac{m}{|A|}+\\frac{m}{|B|}+\\frac{m-t}{m}\\right)$$\n其中，$m$是匹配的字符数，$t$是替换的字符数。\nJaro-Winkler 相似度在 Jaro 相似度的基础上引入了前缀的概念，对于长度为$n$的任意两个字符串$A=x_1x_2\\cdots x_n$和$B=y_1y_2\\cdots y_n$的 Jaro-Winkler 相似度定义为：\n$$d_w=d_j+l\\cdot p\\cdot(1-d_j)$$\n其中，$l$为字符串$A$和字符串$B$的共同前缀的字符数；$p$为缩放因子（常取$p=0.1$）。\n李距离（Lee Distance） 李距离是编码理论中用于描述字符串距离的方案，对于使用包含$q$个字母的字母表且长度为$n$的任意两个字符串$A=x_1x_2\\cdots x_n$和$B=y_1y_2\\cdots y_n$的李距离定义为：\n$$d=\\sum_{i=0}^{n}{\\min{\\left(\\left|x_i-y_i\\right|,q-\\left|x_i-y_i\\right|\\right)}}$$\n当$q=2$或$q=3$时，李距离退化为汉明距离。\n集合距离 杰卡德相似系数（Jaccard Similarity Coefficient） 杰卡德相似系数是指两个集合$A$和$B$中相同元素在所有元素中的占比，定义为$J(A,B)$：\n$$J(A,B)=\\frac{\\left|A\\cap B\\right|}{\\left|A\\cup B\\right|}$$\n杰卡德距离（Jaccard Distance）是指两个集合$A$和$B$中不同元素在所有元素中的占比，定义为$J_\\delta(A,B)$：\n$$J_\\delta(A,B)=1-J(A,B)=1-\\frac{\\left|A\\cap B\\right|}{\\left|A\\cup B\\right|}$$\n在 Python 中用于计算任意两个集合间杰卡德相似系数的代码如下：\n1 2 3 4 5 6 7 import numpy as np def JaccardSimilarityCoefficient(x, y): x = np.asarray(x, np.int32) y = np.asarray(y, np.int32) return np.double(np.bitwise_and((x != y), np.bitwise_or(x != 0, y != 0)).sum()) / np.double(np.bitwise_or(x != 0, y != 0).sum()) 奥奇亚系数（Ochiia Coefficient） 奥奇亚系数是指两个集合$A$和$B$中相同元素与两集合大小几何平均值的比值，定义为$K(A,B)$：\n$$K(A,B)=\\frac{\\left|A\\cap B\\right|}{\\sqrt{\\left|A\\right|\\times\\left|B\\right|}}$$\n戴斯系数（Dice Coefficient） 戴斯系数除了可以用来衡量两个集合间的距离，还可以用来衡量两个字符串间的距离，定义为$D(A,B)$：\n$$D(A,B)=\\frac{2\\left|A\\cap B\\right|}{\\left|A\\right|+\\left|B\\right|}$$\n豪斯多夫距离（Hausdorff Distance） 豪斯多夫距离用于度量两个集合$A$和$B$间的距离，定义为$H(A,B)$：\n$$H(A,B)=\\max{\\left[h(A,B),h(B,A)\\right]}$$\n其中，$h(\\cdot)$为双向豪斯多夫距离，定义为：\n$$h(A,B)=\\max_{a\\in A}{\\min_{b\\in B}{\\left |a-b\\right|}}$$\n其中，$h(A,B)$为从集合$A$到集合$B$的单向豪斯多夫距离，$h(B,A)$为从集合$B$到集合$A$的单向豪斯多夫距离。\n分布距离 皮尔逊相关系数（Pearson Correlation Coefficient） 皮尔逊相关系数又被称为皮尔逊积矩相关技术（Pearson Product Moment Correlation Coefficient，PPMCC/PCC），用于度量两个变量$X$和$Y$之间的线性相关性。与上文提到的余弦相似度不同，皮尔逊相关系数不受平移变换的影响。对于$n$维空间中的任意两个分布$X$和$Y$的皮尔逊相关系数定义为：\n$$\\rho(X,Y)=\\frac{\\mathrm{cov}(X,Y)}{\\sigma(X)\\cdot\\sigma(Y)}=\\frac{\\mathrm{E}\\left[\\left(X-X_\\mu\\right)\\left(Y-Y_\\mu\\right)\\right]}{\\sigma(X)\\cdot\\sigma(Y)}$$\n皮尔逊相关系数与余弦相似度的关系为：\n$$\\rho(X,Y)=\\frac{\\mathrm{E}\\left[\\left(X-X_\\mu\\right)\\left(Y-Y_\\mu\\right)\\right]}{\\sigma(X)\\cdot\\sigma(Y)}=\\frac{\\displaystyle\\sum_{i=1}^{n}{\\left(X-X_\\mu\\right)\\cdot\\left(Y-Y_\\mu\\right)}}{\\left|X-X_\\mu\\right|\\cdot\\left|Y-Y_\\mu\\right|}=\\cos{\\left(X-X_\\mu,Y-Y_\\mu\\right)}$$\n在 Python 中用于计算任意两个分布间皮尔逊相关系数的代码如下：\n1 2 3 4 5 6 7 8 9 10 import numpy as np def PearsonCorrelationCoefficient(x, y): x = np.array(x) y = np.array(y) x_ = x - np.mean(x) y_ = y - np.mean(y) return np.dot(x_, y_) / (np.linalg.norm(x_) * np.linalg.norm(y_)) 卡方度量（Chi-square Measure） $\\mathcal{X}^2$检验通常用于检验某一观测分布是否符合典型理论分布。若观测频数与期望频数差异越小，则$\\mathcal{X}^2$值越小；若观测频数与期望频数差异越大，则$\\mathcal{X}^2$值越大。因此，$\\mathcal{X}^2$值可以用于描述观测分布与理论分布的差异。对于$n$维空间中的任意两个分布$X$和$Y$的$\\mathcal{X}^2$统计量定义为：\n$$\\mathcal{X}^2=\\sum_{i=1}^{n}{\\frac{\\left(x_i-y_i\\right)^2}{y_i}}=\\sum_{i=1}^{k}{\\frac{\\left(x_i-n\\cdot p_i\\right)^2}{k\\cdot p_i}}$$\n其中，$x_i$为$X$在$i$的频数，$y_i$为$Y$在$i$的频数，$k$为总频数，$p_i$为$Y$在$i$的概率。在 Python 中用于计算任意两个分布间卡方度量的代码如下：\n1 2 3 4 5 6 7 import numpy as np def ChiSquareMeasure(x, y): x = np.asarray(x, np.int32) y = np.asarray(y, np.int32) return np.sum(np.square(x - y) / y) 交叉熵（Cross Entropy） 交叉熵是香农信息论中的重要概念，用于度量两个分布之间的差异信息。对于$n$维空间中的任意两个分布$X$和$Y$的交叉熵定义为：\n$$H(X,Y)=-\\int_{p}{X(p)\\cdot Y(p)\\mathrm{d}p}$$\n若基于分布$X$对分布$X$进行编码，其编码长度的期望为：\n$$H(X)=-\\int_{p}{X(p)\\mathrm{d}p}$$\n若基于分布$Y$对分布$X$进行编码，其编码长度的期望即为交叉熵$H(X,Y)$。在 Python 中用于计算任意两个分布间交叉熵的代码如下：\n1 2 3 4 import numpy as np def CrossEntropy(x, y): return -np.sum(x * np.log(y)) KL 散度（Kullback-Leibler Divergence） KL 散度又被称为相对熵（Relative Entropy）或信息散度（Information Divergence），用于度量两个分布间的差异，对于$n$维空间中的任意两个分布$X$和$Y$的 KL 散度定义为：\n$$\\mathrm{KL}(X|Y)=\\int_{p}{X(p)\\cdot\\log{\\frac{X(p)}{Y(p)}}\\mathrm{d}p}$$\n若基于分布$X$对分布$X$进行编码，其编码长度的期望为：\n$$H(X)=-\\int_{p}{X(p)\\log{X(p)}\\mathrm{d}p}$$\n若基于分布$Y$对分布$X$进行编码，其编码长度的期望即为交叉熵$H(X,Y)$，其多出的编码长度为：\n$$\\mathrm{KL}(X|Y)=H(X)-H(X,Y)$$\n在 Python 中用于计算任意两个分布间 KL 散度的代码如下：\n1 2 3 4 5 6 import numpy as np def KullbackLeiblerDivergence(p, q): p = np.array(p) q = np.array(q) return np.sum(p * np.log(p / q)) JS 散度（Jensen-Shannon Divergence） JS 散度是 KL 散度的变体，解决了 KL 散度非对称的问题，对于$n$维空间中的任意两个分布$X$和$Y$的 JS 散度定义为：\n$$\\mathrm{JS}(X|Y)=\\frac{1}{2}\\cdot\\mathrm{KL}(X|\\frac{X+Y}{2})+\\frac{1}{2}\\cdot\\mathrm{KL}(Y|\\frac{X+Y}{2})$$\n在 Python 中用于计算任意两个分布间 JS 散度的代码如下：\n1 2 3 4 5 6 import numpy as np def JensenShannonDivergence(p, q): p = np.array(p) q = np.array(q) return 0.5 * np.sum(p * np.log(2 * p/(p + q))) + 0.5 * np.sum(q * np.log(2 * q/(p + q))) 海林格距离（Hellinger Distance） 对于$n$维空间中的任意两个分布$X$和$Y$的海林格距离定义为：\n$$d={\\frac{1}{\\sqrt{2}}\\cdot\\sqrt{\\sum_{i=1}^{n}{\\left(\\sqrt{x_i}-\\sqrt{y_i}\\right)^2}}}$$\n在 Python 中用于计算任意两个分布间海林格距离的代码如下：\n1 2 3 4 5 6 7 import numpy as np def HellingerDistance(p, q): p = np.array(p) q = np.array(q) return 1 / np.sqrt(2) * np.linalg.norm(np.sqrt(p) - np.sqrt(q)) α 散度（α Divergence） 对于$n$维空间中的任意两个分布$X$和$Y$的 α 散度被定义为：\n$$d=\\frac{4}{1-\\alpha^2}\\cdot\\left[1-\\int_p{X(p)^{(1+\\alpha)/2}\\cdot Y(p)^{(1-\\alpha)/2}}\\mathrm{d}x\\right]$$\n其中，$-\\infty\u0026lt;\\alpha\u0026lt;+\\infty$为连续参数。当$\\alpha\\rightarrow 1$时，α 散度退化为 KL 散度；当$\\alpha\\rightarrow 0$时，α 散度退化为海林格距离（仅相差常系数）。\nF 散度（F Divergence） 对于$n$维空间中的任意两个分布$X$和$Y$的 F 散度被定义为：\n$$\\mathrm{D}(X|Y)=\\int_p{Y(p)\\cdot f\\left[\\frac{X(p)}{Y(p)}\\right]\\mathrm{d}p}$$\n其中，函数$f(\\cdot)$需满足：（1）$f(\\cdot)$为凸函数；（2）$f(1)=0$。下表给出了$f(\\cdot)$取不同值时，F 散度对应的结果。\n散度 $f(\\cdot)$ 卡方距离 $(t-1)^2$ KL 散度 $x\\log{x}$ 逆 KL 散度 $-\\log{x}$ 海林格距离 $\\left(\\sqrt{x}-1\\right)^2$ α 散度 $4/(1-\\alpha)^2\\cdot\\left(1-x^{(1+\\alpha)/2}\\right)$ 在 Python 中用于计算任意两个分布间 F 散度（海林格距离）的代码如下：\n1 2 3 4 5 6 7 8 9 import numpy as np def f(t): return t * np.log(t) def FDivergence(p, q): p = np.array(p) q = np.array(q) return np.sum(q * f(p / q)) 布雷格曼散度（Bregman Divergence） 对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的欧几里得距离定义为：\n$$d(x,y)=\\sqrt{\\sum_{i=1}^{n}{\\left(x_i-y_i\\right)^2}}$$\n将上式两侧平方后，得到：\n$$d^2(x,y)=\\sum_{i=1}^{n}{\\left(x_i-y_i\\right)^2}$$\n定义$\u0026lt;x,y\u0026gt;=\\sum_{i=1}^{n}{x_i\\cdot y_i}$，$\\left|x\\right|=\\sqrt{\u0026lt;x,x\u0026gt;}$，上式可改写为：\n$$d^2(x,y)=\\sum_{i=1}^{n}{\\left(x_i-y_i\\right)^2}=\u0026lt;x-y,x-y\u0026gt;=\\left|x\\right|^2-\\left(\\left|y\\right|^2+\u0026lt;2y,x-y\u0026gt;\\right)$$\n此处的距离即为欧几里得模函数和其在$x$处切线在$y$处的点估计差。推广该概念后，对于$n$维空间中的任意两点$A(x_1,x_2,\\cdots,x_n)$和$B(y_1,y_2,\\cdots,y_n)$的布雷格曼散度定义为：\n$$d(x,y)=f(x)-\\left[f(y)+\u0026lt;\\nabla f(x),x-y \u0026gt;\\right]$$\n表给出了$f(\\cdot)$取不同值时，布雷格曼散度对应的结果。\n散度 $f(\\cdot)$ 平方损失 $x^2$ / $x\\log{x}$ Logistic 损失 $x\\log{x}+(1-x)\\log{(1-x)}$ Itakura-Saito 距离 $-\\log{x}$ / $e^x$ 平方欧几里得距离 $\\left|x\\right|^2$ 马氏距离 $\\mathbf{X}^TA\\mathbf{X}$ KL 散度 $\\sum_{i=1}^{n}{x_i\\log{x_i}}$ Wasserstein 距离（Wasserstein Distance） Wasserstein 距离被称为推土机距离，用于表示两个分布的相似度。Wasserstein 距离定义为把分布$X$转变成分布$Y$所需移动的平均距离的最小值，如下图所示：\nWasserstein 距离（Wasserstein Distance）\n对于$n$维空间中的任意两个分布$X$和$Y$的 Wasserstein 距离定义为：\n$$d=\\inf_{\\gamma\\sim\\Pi(X,Y)}{\\mathrm{E}_{p,q\\sim\\gamma}\\left|p-q\\right|}$$\n其中，$\\Pi(X,Y)$为分布$X$和分布$Y$构成的联合分布的集合，$\\gamma$为$\\Pi(X,Y)$中任意分布，$p$和$q$是分布$\\gamma$中的样本。\n巴氏距离（Bhattacharyya Distance） 巴氏系数可以用来度量两个分布的相似性，对于$n$维空间中的任意两个分布$X$和$Y$的巴氏系数定义为：\n$$c_b=\\int_{p}{\\sqrt{X(p)\\cdot Y(p)}\\mathrm{d}p}$$\n巴氏距离定义为：\n$$d_b=-\\ln{c_b}$$\n需要注意的是，海林格距离$d=\\sqrt{1-d_b}$。在 Python 中用于计算任意两个分布间巴氏距离的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import numpy as np def BhattacharyyaCoefficient(p,q): p = np.array(p) q = np.array(q) return np.sum(np.sqrt(p * q)) def HellingerDistance(p, q): return np.sqrt(1 - BhattacharyyaCoefficient(p, q)) def BhattacharyyaDistance(p, q): return np.log(BhattacharyyaCoefficient(p, q)) 最大均值差异（Maximum Mean Discrepancy） 最大均值差异是迁移学习领域中最为广泛使用的一种损失函数，它度量了再生希尔伯特空间中两个不同分布间的距离。通过在样本空间寻找连续函数$f:X\\rightarrow R$随机投影后，分别求这两个分布在$f$上函数值的均值，并通过做差得到均值差异（Mean Discrepancy）。最大化均值差异即为寻找一个$f$使得均值差异最大。对于$n$维空间中的任意两个分布$X$和$Y$的最大均值差异定义为：\n$$d=\\sup_{|f|_\\mathrm{H} \\leq 1}{\\mathrm{E}_p[f(X)]-\\mathrm{E}_q[f(Y)]}$$\n点间互信息（Pointwise Mutual Information） 点间互信息用来衡量两个分布的相关性，对于$n$维空间中的任意两个分布$X$和$Y$的点间互信息定义为：\n$$d=\\log{\\frac{p(X,Y)}{p(X)\\cdot p(Y)}}=\\log{\\frac{p(X|Y)}{p(X)}}=\\log{\\frac{p(Y|X)}{p(Y)}}$$\n若$X$和$Y$不相关，则$P(X,Y)=P(X)\\cdot P(Y)$。\n","date":"2023-08-18T11:27:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F%E6%B1%87%E6%80%BB/","title":"机器学习中常用的距离度量汇总"},{"content":"Step 1 生成 SSH 私钥/公钥 打开终端，使用 ssh-keygen 工具生成 SSH 私钥（GitHub 推荐方法）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [kwang@Slave02 ~]$ ssh-keygen -t ecdsa -b 521 -C \u0026#34;prc.wkai@gmail.com\u0026#34; Generating public/private ecdsa key pair. Enter file in which to save the key (/home/kwang/.ssh/id_ecdsa): /home/kwang/.ssh/id_ecdsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/kwang/.ssh/id_ecdsa. Your public key has been saved in /home/kwang/.ssh/id_ecdsa.pub. The key fingerprint is: 14:21:b7:06:4c:e4:cd:39:c8:1f:bd:09:64:42:80:3b prc.wkai@gmail.com The key\u0026#39;s randomart image is: +--[ECDSA 521]---+ | ..*B *. | | . o.@ = | | . + @ . | | E + + o | | . S o | | | | | | | | | +-----------------+ Step 2 配置 SSH 公钥 登录 GitHub 主页，在个人设置中选择“SSH and GPG keys”，单击“New SSH key”，将上一步中生成的公钥（id_ecdsa.pub）复制进来（下图）。\nGitHub 配置 SSH 公钥\nStep 3 克隆 Repo 在服务器终端运行 git 配置账号和对应的 repo：\n1 2 3 4 5 6 7 8 [kwang@Slave02 ~]$ git clone \u0026#34;git@github.com:Ivy-End/Prometheus.git\u0026#34; Cloning into \u0026#39;Prometheus\u0026#39;... remote: Enumerating objects: 4, done. remote: Counting objects: 100% (4/4), done. remote: Compressing objects: 100% (4/4), done. remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (4/4), 12.50 KiB | 0 bytes/s, done. Checking connectivity... done. Step 4 配置 Git 用户 1 2 [kwang@Slave02 ~/Prometheus]$ git config --global user.name \u0026#34;Ivy-End\u0026#34; [kwang@Slave02 ~/Prometheus]$ git config --global user.email \u0026#34;prc.wkai@gmail.com\u0026#34; Step 5 上传文件 1 2 3 4 5 6 7 8 9 10 11 12 [kwang@Slave02 ~/Prometheus]$ git add * [kwang@Slave02 ~/Prometheus]$ git commit -m \u0026#39;Prometheus Project Initialization\u0026#39; [main 544218b] Prometheus Project Initialization 1 file changed, 2 insertions(+), 1 deletion(-) [kwang@Slave02 ~/Prometheus]$ git push Counting objects: 3, done. Delta compression using up to 192 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 405 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To github.com:Ivy-End/Prometheus.git 2ed25ef..544218b main -\u0026gt; main Step 6 下传文件 1 2 [kwang@Slave02 ~/Prometheus]$ git pull Already up-to-date. ","date":"2022-08-23T11:27:00+08:00","permalink":"https://ivy-end.github.io/p/linux-%E9%85%8D%E7%BD%AE-github-%E8%B4%A6%E5%8F%B7/","title":"Linux 配置 GitHub 账号"},{"content":"v2lvs 主要用于将 Verilog 网表转成 Spice 网表，一个典型的 v2lvs 例子如下所示。其中，第 2 ~ 3 行为 Verilog 代码输入，第 4 ~ 7 行为 Spice 网表输入，第 8 行为 Spice 网表输出。\n1 2 3 4 5 6 7 8 v21vs -64 -sn \\ -v ../../../../0UTPUT/TOP_TSCam.pg.v\\ -v ./Pixel.pg.v \\ -s /TOOLS/PDK/SMIC/SMIC55LL/SPDK55LL_ULP_09121825_OA_CDS_V1.16_2/smic5511_ulp_09121825_1P8M_6Ic_2TMc_ALPA1_oa_cds_v1.16_2/Calibre/LVS/empty_subckt.sp \\ -s /TOOLS/STD_CELL/SMIC-55/SCC55NLL_HD_LVT_V2.0b/SCC55NLL_HD_LVT_V2p0b/cdl/SCC55NLL_HD_LVT_V2p0.cdl \\ -s /TOOLS/STD CELL/SMIC-55/I0/SP55NLLD2RP OV3 VOp7/1vs/SP55NLLD2RP_OV3_VOp7.sp \\ -s./SPAD.cdl \\ -o TOP_TSCam.cdl 关于 v2lvs 更详细的指令介绍如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 -a \u0026lt;c1\u0026gt;[\u0026lt;c2\u0026gt;] : Change array delimiters from the default \u0026#34;[]\u0026#34;. : c1 replaces left side \u0026#39;[\u0026#39;. : c2 optionally replaces right side \u0026#39;]\u0026#39;. -addpin \u0026lt;pin\u0026gt; : Add \u0026lt;pin\u0026gt; to the signature of any Verilog module that does not have it. Connect \u0026lt;pin\u0026gt; to port \u0026lt;pin\u0026gt; in all instances that do not already have a connection specified. Spice libraries parsed with -lsr and -lsp will not have pins added -addpin is not compatitble with -i. -b : Preserve backslash character in escaped identifiers. -cb : Prefer CALDRCLVSEVE(Calibre CB) license during license search. -c \u0026lt;c1\u0026gt;\u0026lt;c2\u0026gt; : Change illegal spice characters c1 to c2. -cfg \u0026lt;filename\u0026gt; : Config file for passing IP blocks related information. This will bring a custom spice file in to the Verilog and call a top level subckt from the Verilog. -e : Generate empty .SUBCKT statements (no instances are translated) -e is useful for generating \u0026#34;black box\u0026#34; subcircuits from library files -h[elp] : Help. Prints this message. -i : Make calls using pins in order (traditional spice) not with $PINS. For non-Calibre use only, avoid using -i option for LVS. -ictrace : Prefer ICTRACE license during license search. -incvdir : Add INCLUDE path for files `include\u0026#39;ed from verilog files. -l \u0026lt;filename\u0026gt; : Defines the Verilog library file name (the library is not translated). The library file is parsed for interface pin configurations(see -s). -lsp \u0026lt;filename\u0026gt; : Spice library file name, pin mode. The Spice file is parsed for interface configurations. Pins with pin select ([]) annotation are kept as individual pins using escaped identifiers. See also -lsr and -l. -lsr \u0026lt;filename\u0026gt; : Spice library file name, range mode. The Spice file is parsed for interface configurations. Pins with pin select ([]) annotation are assembled into Verilog ranges. See also -lsp and -l. -n : Causes unconnected pins to get numbered connections starting at 1000. -o \u0026lt;filename\u0026gt; : Defines the file for the resulting Spice-like netlist to be used in the LVS (layout versus schematic) application. This result will include a translation of the Verilog netlist. -s \u0026lt;filename\u0026gt; : Causes the string .INCLUDE \u0026#34;filename\u0026#34; to be put at the beginning of the generated spice file (-o). -s does not cause v2lvs to read the SPICE file (see -lsr and -lsp). -s0 \u0026lt;string\u0026gt; : Default global ground is changed to \u0026lt;string\u0026gt;. -s1 \u0026lt;string\u0026gt; : Default global power is changed to \u0026lt;string\u0026gt;. -sk : \u0026#34;supply0\u0026#34; and \u0026#34;supply1\u0026#34; nets are not connected to default power/ground. -sl : \u0026#34;supply0\u0026#34; and \u0026#34;supply1\u0026#34; nets are not connected to globals. -sn : Default power and ground nets are not connected to globals. -so \u0026lt;filename\u0026gt; : Filename provides instance or module specific power/ground overrides. -t \u0026lt;svdb_dir\u0026gt; : Causes an Calibre/XRC source template file to be written to an svdb database. -p \u0026lt;string\u0026gt; : Defines a prefix to be used for primitive gate instantiations. -u \u0026lt;string\u0026gt; : Defines a prefix for the naming of unnamed pins in module instantiations. -v \u0026lt;filename\u0026gt; : Defines the Verilog design netlist file name. -werror : Treat Warnings as Errors (-w \u0026lt;n\u0026gt; applies). -w \u0026lt;n\u0026gt; : Defines a warning messaged level 0-4. 2 is the default. 0 - no warnings. 1 - level 0 + warn skipped modules and multiple declarations of modules. 2 - level 1 warnings + calls to undeclared modules. 3 - level 2 warnings + called port array width mismatches. + unsupported compiler directives. 4 - level 3 warnings + all ignored constructs. (i.e. delays, charges etc) -log \u0026lt;filename\u0026gt; : Defines the log file which contains the error and warning messages. -undef_mod : This switch tells v2lvs not to do special handling for undefined modules. -version : Show v2lvs version. -- \u0026lt;a0\u0026gt; \u0026lt;a1\u0026gt; ... : Pass arguments to the TCL script as an $argv list, access by \u0026#34;[lindex $argv $n]\u0026#34;. Only one \u0026#34;--\u0026#34; switch is allowed. Take care to properly escape special shell characters. ","date":"2022-06-27T17:37:00+08:00","permalink":"https://ivy-end.github.io/p/verilog-%E8%BD%AC-spice-%E7%BD%91%E8%A1%A8/","title":"Verilog 转 Spice 网表"},{"content":"当需要在网络上传递敏感数据时，通常需要对文件和目录进行加密，而普通的加密方法又非常容易被破解。为了应对这一难题，我们可以采用 RedHat 系统中的 TAR 打包工具和 OpenSSL 实现数据的加密。\n加密 1 2 3 4 5 6 7 8 9 10 11 # 1. 切换到需要进行加密的文件目录下 [user@Server ~]$ cd \u0026lt;Directory to be encrypted\u0026gt; # 2. 使用下列语句对文件目录进行加密 # enc 表示使用加密进行编码 # -e 表示使用加密选项 # -aes256 表示使用 aes256 加密算法 # -out 表示加密输出的文件 [user@Server ~]$ tar -czf - * | openssl enc -e -aes256 -out File.tar.gz # 3. 输入秘钥 enter aes-256-cbc encryption password: Verifying -enter aes-256-cbc-encryption password: 解密 1 2 3 4 5 6 7 8 # 1. 使用下列语句对加密文件进行解密 # enc 表示使用加密进行编码 # -e 表示使用加密选项 # -aes256 表示使用 aes256 加密算法 # -out 表示加密输出的文件 [user@Server ~]$ openssl enc -d -aes256 -in \u0026lt;Filename\u0026gt; | tar -xzv # 3. 输入秘钥 enter aes-256-cbc encryption password: ","date":"2022-06-27T17:22:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%BB%93%E5%90%88-tar-%E5%92%8C-openssl-%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95/","title":"结合 TAR 和 OpenSSL 加密文件及目录"},{"content":"一年一度中秋佳节，看着天上的月亮，思乡之情涌上心头，写下了这篇《西江月·望月怀远》\n西江月·望月怀远\n邈邈蟾宫玉兔，溶溶亭畔平湖。披衣行尽夜阑徐，松竹秋声齐舞。\n皓月梅花尺素，尽传阡陌归途。寄情不必待望舒，且看金风星赴。\n西江月·望月怀远\n","date":"2021-09-21T22:10:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%802021/","title":"中秋望月感怀（2021）"},{"content":"已不知是何时起，开始作诗。或许是受大学老友的影响，或许只是为了附庸风雅。断断续续，已写了多首，但总觉得还缺些朗朗上口的节奏感和的身临其境的意境美。乘此闲暇，将一年前所做诗句放到博客，与诸君共赏。\n在朋友圈看到一位大学同学作了一首《又过凤凰街》，回忆起大学时期的青葱岁月，遂和诗一首，作于 2020 年 12 月 5 日。\n又过凤凰街\n一树金黄摇落日，满街古旧暗荒魂。\n嘻言怡笑说来说，终岁霜风送故人。\n和《又过凤凰街》\n故人寂寂辞街去，古道依依迎新人。\n历历往昔终难忘，随风夜半叩君门。\n凤凰街是本科学校边上的一条古街，曾几何时，每天晚上都会和同学一起徜徉其中，消食解乏，谈天说地，可以说是大学生涯中承载着许多记忆的地方。\n凤凰街·冬至夜（图片来源网络）\n","date":"2021-09-16T00:38:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%BF%86%E5%87%A4%E5%87%B0%E8%A1%97/","title":"忆凤凰街"},{"content":"个人博客，这个若干年前曾风靡一时的词，到如今却逐渐淡出大众视野。我还记得多年前注册了新浪博客、CSDN 和博客园等各大博客门户网站的账号，现如今却早已将它们抛诸脑后了，只有搜索引擎还记得我那稚嫩的文字与满腔的热情。再往后，我自学了 WordPress 建站，开始在本地搭建博客。当时仅仅是为了记录自己 NOIP 的刷题经历。随着我 2016 年退出竞赛圈后，博客的更新频率也便降低了，甚至到了一年一更的地步。\n细想之下，我也能为之找寻到合理的解释：开通博客的目的是为了分享算法竞赛的点点滴滴，现如今我已投入到集成电路产业之中，自然也就无法分享算法竞赛的内容。然而，当我如此为自己找寻借口之时，当年 ACM-ICPC 教练徐汀荣教授在我退役之际的赠言在我耳边回响：\n希望你一直热爱算法！\n从思想上来看，我并没有辜负他的期望，我目前的研究内容甚至还能和算法扯上关系；但在行动上，我却早已不如当年那样对绝大部分算法了如指掌，运指如风了。诚然，我在集成电路方面有所涉猎，但却一直没有分享太多相关的内容。究其根源，还是“懒”字当头，怠于下笔。我想，徐汀荣教授的本意应当不是让我长年累月的投身算法竞赛，应当是找寻到生命中所热爱的事业，并为之奋斗和努力。\n当今社会，自媒体、短视频大行其道，早已没有了个人博客的生存空间。人们更倾向于观看短视频，刷微信公众号，去碎片化的获取知识；而不是上网冲浪，博客交游。但我认为，个人博客依旧有其存在的必要性。它能够给博主提供一方天地，去记录自己的所见、所思、所想。本着这样的想法，趁腾讯云打折之际，我迁移并部署了这一博客，希望能够让它重焕生机，成为我学业和生活的记录者与见证者。\n","date":"2021-09-01T22:52:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%8D%9A%E5%AE%A2%E5%86%8D%E5%87%BA%E5%8F%91/","title":"博客，再出发"},{"content":"本文主要讲解如何在 VMware Worksataion 环境下基于 CentOS 7.9 安装 Cadence IC617。\n本文所用到的软件资源，可单击此处下载，提取码为：njup。\n安装 VMware Workstation 安装 Microsoft VC Redistributable 双击运行 VC_redist.x64.exe 文件，开始安装 Microsoft Visual C++ Redistributable for Visual Studio 2015, 2017 and 2019。\n安装 Microsoft VC Redistributable\n勾选“我同意许可条款和条件”后，单击“安装”。稍等片刻后，即可完成 Microsoft Visual C++ Redistributable for Visual Studio 2015, 2017 and 2019 的安装。\n安装 Microsoft VC Redistributable\n正式安装 VMware Workstation 双击运行 VMware-workstation-full-16.1.1-17801498.exe 文件，开始安装 Vmware Workstation。\n正式安装 VMware Workstation\n单击“下一步”。\n正式安装 VMware Workstation\n勾选“我接受许可协议中的条款”，单击“下一步”。\n正式安装 VMware Workstation\n配置“安装位置”，并勾选“增强型键盘驱动程序”，单击“下一步”。\n正式安装 VMware Workstation\n单击“下一步”，此处可根据自己的需求配置。\n正式安装 VMware Workstation\n单击“下一步”，此处可根据自己的需求配置。\n正式安装 VMware Workstation\n稍等片刻后，即可完成 Vmware Workstation 的安装。\n正式安装 VMware Workstation\n单击“许可证”，输入网络上找到的许可证后，单击“输入”。\n正式安装 VMware Workstation\n单击“完成”。\n正式安装 VMware Workstation\n安装程序提示重新启动操作系统，单击“是”。\n正式安装 VMware Workstation\n至此，我们已经完成了 VMware WorkStation Pro 16 的安装。\n安装 CentOS 7.9 配置 VMware WorkStation 虚拟机环境 打开 VMware WorkStation Pro 16，单击“创建新的虚拟机”。\n配置 VMware WorkStation 虚拟机环境\n勾选“自定义（高级）”，并单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n保持默认设置，并单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n勾选“稍后安装操作系统”，并单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n在“客户机操作系统”栏中勾选“Linux”，并在“版本”栏中选择“CentOS 8 64位”，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n输入“虚拟机名称”，并设置虚拟机存储“位置”，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n根据系统配置，设置“处理器数量”及“每个处理器的内核数量”，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n根据系统配置，设置“该虚拟机的内存”，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n此处保持默认配置即可，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n此处保持默认配置即可，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n此处保持默认配置即可，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n此处保持默认配置即可，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n将“最大磁盘大小”调整为“128 GB\u0026quot;，以确保 Cadence IC617 能正常使用。其余选项保持默认配置即可，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n此处保持默认配置即可，单击“下一步”。\n配置 VMware WorkStation 虚拟机环境\n此处为虚拟机设置的摘要页面，单击“完成”。\n配置 VMware WorkStation 虚拟机环境\n正式安装CentOS 7.9 此时，我们已经成功创建了名为“IC Design”的虚拟机环境，单击“编辑虚拟机设置”。\n正式安装CentOS 7.9\n在“硬件”选项卡中单击“CD/DVD (SATA)”，在右侧勾选“使用ISO映像文件”，并单击“浏览”打开 CentOS 7.9 安装文件 CentOS-7-x86_64-Everything-2009.iso，最后单击“确定”。\n正式安装CentOS 7.9\n单击“开启此虚拟机”。\n正式安装CentOS 7.9\n首先单击左下角的“×”以关闭黄色提示框，此时屏幕中央出现三个选项，分别为：\nInstall CentOS 7 Test this media \u0026amp; install CentOS 7 Troubleshooting 我们单击屏幕中央以进入虚拟机操作模式（按 Ctrl + Alt 可退出虚拟机操作模式），选中第一项，并按下回车键。\n正式安装CentOS 7.9\n稍等片刻，即可看到 CentOS 7.9 的安装界面。保持默认设置，单击“Continue”。\n正式安装CentOS 7.9\n单击“DATE \u0026amp; TIME”。\n正式安装CentOS 7.9\n在“Region”和“City”下拉框中分别选择“Asia”和“Shanghai”，并将时间调整为系统时间，单击“Done”。\n正式安装CentOS 7.9\n单击“SOFTWARE SELECTION”，在左侧“Base Environment”中选中“Server with GUI”，单击“Done”。\n正式安装CentOS 7.9\n单击“INSTALLATION DESTINATION”，单击“Done”。\n正式安装CentOS 7.9\n单击“NETWORK \u0026amp; HOST NAME”，将“Ethernet”调整为“ON”，单击“Done”。\n正式安装CentOS 7.9\n单击“Begin Installation”。\n正式安装CentOS 7.9\n单击“ROOT PASSWORD”。\n正式安装CentOS 7.9\n在“Root Password”和“Confirm”中输入密码“icdesign”，单击“Done”。\n正式安装CentOS 7.9\n单击“USER CREATION”，在“Full name”、“User name”、“Password”和“Confirm password”中均输入“icdesign”，单击“Done”。\n正式安装CentOS 7.9\n稍等片刻，即可完成CentOS 7.9的安装，单击“Reboot”。\n正式安装CentOS 7.9\n稍等片刻，单击“LICENSE INFORMATION”。\n正式安装CentOS 7.9\n勾选“I accept the license agreement.”，单击“Done”。\n正式安装CentOS 7.9\n单击“Finish Configuration”。\n正式安装CentOS 7.9\n单击“icdesign”。\n正式安装CentOS 7.9\n输入密码，单击“Sign In”。\n正式安装CentOS 7.9\n单击“Next”。\n正式安装CentOS 7.9\n单击“Next”。\n正式安装CentOS 7.9\n单击“Next”。\n正式安装CentOS 7.9\n单击“Skip”。\n正式安装CentOS 7.9\n单击“Starting Using CentOS Linux”。\n正式安装CentOS 7.9\n关闭弹出的“Getting Started”窗口。\n正式安装CentOS 7.9\n安装Cadence IC617 配置 yum 源 在桌面空白处右键，选择“Open Terminal”。\n配置 yum 源\n在终端输入su，按下回车键（每次输入完命令后均需要按下回车键）。\n输入icdesign，按下回车键。\n在终端输入 cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 备份现有 yum 源。\n在终端输入 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 下载阿里云的 yum 源。\n在终端输入 yum clean all，清空 yum 缓存。\n在终端输入 yum makecache，重建 yum 缓存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 [icdesign@localhost ~]$ su Password: [root@localhost icdesign]# cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup [root@localhost icdesign]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo --2021-04-04 09:10:17-- http://mirrors.aliyun.com/repo/Centos-7.repo Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 61.160.204.243, 61.160.228.242, 58.222.29.238, ... Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|61.160.204.243|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 2523 (2.5K) [application/octet-stream] Saving to: ‘/etc/yum.repos.d/CentOS-Base.repo’ 100%[======================================\u0026gt;] 2,523 --.-K/s in 0s 2021-04-04 09:10:17 (394 MB/s) - ‘/etc/yum.repos.d/CentOS-Base.repo’ saved [2523/2523] [root@localhost icdesign]# yum clean all Loaded plugins: fastestmirror, langpacks Cleaning repos: base extras updates Cleaning up list of fastest mirrors [root@localhost icdesign]# yum makecache Loaded plugins: fastestmirror, langpacks Determining fastest mirrors * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com base | 3.6 kB 00:00 extras | 2.9 kB 00:00 updates | 2.9 kB 00:00 (1/10): base/7/x86_64/group_gz | 153 kB 00:00 (2/10): base/7/x86_64/filelists_db | 7.2 MB 00:02 (3/10): base/7/x86_64/primary_db | 6.1 MB 00:02 (4/10): extras/7/x86_64/filelists_db | 228 kB 00:00 (5/10): base/7/x86_64/other_db | 2.6 MB 00:00 (6/10): extras/7/x86_64/primary_db | 230 kB 00:00 (7/10): extras/7/x86_64/other_db | 137 kB 00:00 (8/10): updates/7/x86_64/filelists_db | 3.9 MB 00:01 (9/10): updates/7/x86_64/primary_db | 6.5 MB 00:01 (10/10): updates/7/x86_64/other_db | 517 kB 00:00 Metadata Cache Created 安装支持库 在终端输入，yum install -y ksh，当看到“Complete!”时表示安装完成，如果看到“Nothing to do”则表示已安装了该支持库，无需再次安装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [root@localhost icdesign]# yum install -y ksh Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com Resolving Dependencies --\u0026gt; Running transaction check ---\u0026gt; Package ksh.x86_64 0:20120801-142.el7 will be installed --\u0026gt; Finished Dependency Resolution Dependencies Resolved ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: ksh x86_64 20120801-142.el7 base 884 k Transaction Summary ================================================================================ Install 1 Package Total download size: 884 k Installed size: 3.1 M Downloading packages: warning: /var/cache/yum/x86_64/7/base/packages/ksh-20120801-142.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY Public key for ksh-20120801-142.el7.x86_64.rpm is not installed ksh-20120801-142.el7.x86_64.rpm | 884 kB 00:00 Retrieving key from http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 Importing GPG key 0xF4A80EB5: Userid : \u0026#34;CentOS-7 Key (CentOS 7 Official Signing Key) \u0026lt;security@centos.org\u0026gt;\u0026#34; Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5 From : http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : ksh-20120801-142.el7.x86_64 1/1 Verifying : ksh-20120801-142.el7.x86_64 1/1 Installed: ksh.x86_64 0:20120801-142.el7 Complete! 在终端输入，yum install -y libXext.so.6。\n在终端输入，yum install -y libXtst.so.6。\n在终端输入，yum install -y libXt.so.6。\n在终端输入，yum install -y libGLU.so.1 --setopt=protected_multilib=false。\n在终端输入，yum install -y libelf.so.1。\n在终端输入，yum install -y libXrender.so.1。\n在终端输入，yum install -y libXp.so.6。\n在终端输入，yum install -y libXrandr.so.2。\n在终端输入，yum install -y *xorg*。\n在终端输入，yum install -y libXp。\n在终端输入，yum install -y ld-linux.so.2。\n在终端输入，yum install -y openmotif。\n在终端输入，yum install -y libstdc++.so.5。\n在终端输入，yum install -y xterm。\n在终端输入，yum install -y gcc gcc-c++ ksh csh libXp *xorg-X11-fonts* compat-libstdc++-33.i686，此处*xorg-X11-fonts*会提示No package available，可忽略。\n在终端输入，yum install -y alliance-libs alliance glibc-2.12-1.107.el6.i686 glibc-devel.i686 glibc，此处alliance-libs、alliance、glibc-2.12-1.107.el6.i686会提示No package available，可忽略。\n在终端输入，yum install -y compat-readline5-5.2-17.1.el6.i686，此处会提示No package available，可忽略。\n在终端输入，yum install -y xterm-253-1，此处会提示No package available，可忽略。\n在终端输入，yum install -y mesa-libGLU。\n配置软链接 在终端输入，ln -s /usr/bin/awk /bin/awk。\n在终端输入，ln -s /usr/lib/libstdc++-3-libc6.2-2-2.10.0.so /usr/lib/libstdc++-libc6.1-1.so.2。\n在终端输入，ln -s /bin/gunzip /bin/uncompress。\n在终端输入，cd /lib64。\n在终端输入，ln -s libreadline.so.6 libreadline.so.5。\n在终端输入，cd /usr/lib64。\n在终端输入，ln -s libhistory.so.6 libhistory.so.5。\n在终端输入，chmod 755 /usr/tmp。\n1 2 3 4 5 6 7 8 9 10 [root@localhost icdesign]# ln -s /usr/bin/awk /bin/awk ln: failed to create symbolic link ‘/bin/awk’: File exists [root@localhost icdesign]# ln -s /usr/lib/libstdc++-3-libc6.2-2-2.10.0.so /usr/lib/libstdc++-libc6.1-1.so.2 [root@localhost icdesign]# ln -s /bin/gunzip /bin/uncompress ln: failed to create symbolic link ‘/bin/uncompress’: File exists [root@localhost icdesign]# cd /lib64/ [root@localhost lib64]# ln -s libreadline.so.6 libreadline.so.5 [root@localhost lib64]# cd /usr/lib64 [root@localhost lib64]# ln -s libhistory.so.6 libhistory.so.5 [root@localhost lib64]# chmod 755 /usr/tmp 配置回环地址 在终端输入，hostnamectl set-hostname ICDesign。\n在终端输入，vim /etc/hosts，在打开的文件中按下 i，并在最后一行添加 127.0.0.1 ICDesign，按下 ESC 后，输入 :x 保存。\n1 2 3 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 127.0.0.1 ICDesign 在终端输入，yum update，中途会提示 Is this ok [y/d/N]:，输入 y 后，按下回车。\n在终端输入，reboot，重启虚拟机。\n配置共享文件夹 关闭虚拟机，单击“编辑虚拟机配置”，在“选项”选项卡内，选择“共享文件夹”项，勾选“总是启用”，单击“添加”。\n配置共享文件夹\n单击“下一步”。\n配置共享文件夹\n根据系统情况，设置“主机路径”，并将“名称”设置为“Shared\u0026quot;，单击“下一步”。\n配置共享文件夹\n此处保留默认设置，单击“完成”。\n配置共享文件夹\n单击“确认”。\n配置共享文件夹\n安装 InstallScape 接着，将压缩包内 Cadence/IScape04.23-s010lnx86.t.Z 文件复制到刚刚建立的共享文件夹目录下。\n开启虚拟机后打开终端，并进入 root 账户，输入 vmware-hgfsclient，返回 Shared 即为我们刚刚建立的共享文件夹名称。\n在终端输入 vmhgfs-fuse .host:/Shared /mnt/hgfs，手动挂载共享文件夹。\n1 2 3 4 5 [icdesign@icdesign ~]$ su Password: [root@icdesign icdesign]# vmware-hgfsclient Shared [root@icdesign icdesign]# vmhgfs-fuse .host:/Shared /mnt/hgfs 在终端输入 mkdir -p /TOOLS/Cadence/InstallScape 和 mkdir -p /TOOLS/Mentor/Calibre2015 建立安装目录。\n在终端输入 cp /mnt/hgfs/IScape04.23-s010lnx86.t.Z /TOOLS/Cadence/InstallScape 将 InstallScape 安装包拷贝至 /TOOLS/Cadence/InstallScape 文件夹内。\n在终端输入 cd /TOOLS/Cadence/InstallScape。\n在终端输入 zcat IScape04.23-s010lnx86.t.Z | tar -xvf-，解压 IScape04.23-s010lnx86.t.Z 文件。\n在终端输入 rm IScape04.23-s010lnx86.t.Z，删除压缩包。\n在终端输入 sh ./iscape/bin/iscape.sh，打开 InstallScape 软件，并单击“Preferences”菜单栏中的“InstallScape”项。\n安装 InstallScape\n切换到“Directories”选项卡，将“Default Install Directory”和“Default Download Directory”均设置为“/TOOLS/Cadence”，单击“OK”。\n安装 InstallScape\n安装 IC617 将 Cadence/IC06.17.700_Base.7z 解压到共享文件夹。\n切换到“Local directory/Media Install”，单击“Browser”，选择 /mnt/hgfs/IC06.17.700_Base，单击“Continue”。\n安装 IC617\n勾选“1 results for ALL”列表中的项目，单击“Next”。\n安装 IC617\n单击“Start”。\n安装 IC617\n稍等片刻，将会弹出多个对话框，直到弹出下面的对话框时，输入 y，按下回车键。\n安装 IC617\n输入 y，按下回车键。\n安装 IC617\n输入 2，按下回车键。\n安装 IC617\n按下回车键。\n安装 IC617\n输入 n，按下回车键。\n安装 IC617\n单击“Done”。\n安装 IC617\n单击“Cancel”\n安装 IC617\n安装 MMSIM151 将 Cadence/MMSIM15.10.284_Hotfix.7z 解压到共享文件夹。\n单击“Browser”，选择 /mnt/hgfs/MMSIM15.10.284_Hotfix，单击“Continue”。\n安装 MMSIM151\n勾选“1 results for ALL”列表中的项目，单击“Next”。\n安装 MMSIM151\n单击“Start”。\n安装 MMSIM151\n稍等片刻，在弹出的对话框中按下回车键。\n安装 MMSIM151\n输入 y，按下回车键。\n安装 MMSIM151\n输入 /TOOLS/Cadence/IC617/oa_v22.50.036，按下回车键。\n单击“Done”。\n安装 MMSIM151\n关闭 InstallScape。\n在终端输入 rm IScape04.23-s010lnx86.t.Z，删除 InstallScap 压缩包，在弹出的提示后输入 y 并按下回车键。\n1 2 [root@icdesign InstallScape]# rm IScape04.23-s010lnx86.t.Z rm: remove regular file ‘IScape04.23-s010lnx86.t.Z’? y 安装 Calibre 将 Cadence/aoi_cal_2015.2_36.27_mib.7z 解压到共享文件夹。\n在终端输入 cd /TOOLS/Mentor/Calibre2015。\n在终端输入 cp /mnt/hgfs/aoi_cal_2015.2_36.27_mib.exe ./。\n在终端输入 chmod 777 aoi_cal_2015.2_36.27_mib.exe。\n在终端输入 ./aoi_cal_2015.2_36.27_mib.exe。\n输入 D，按下回车键。\n安装 Calibre\n输入 yes，按下回车键。\n安装 Calibre\n稍等片刻，提示安装完成。\n在终端输入 rm aoi_cal_2015.2_36.27_mib.exe，在弹出的提示后输入 y 并按下回车键。\n安装补丁 将 Cadence/Patch.7z 解压到共享文件夹。\n在终端输入 cd /mnt/hgfs/Patch/Cadence/。\n在终端输入 ./cadence_patch.sh /TOOLS/Cadence/IC617。\n在终端输入 ./cadence_patch.sh /TOOLS/Cadence/MMSIM151。\n在终端输入 cd /TOOLS/Mentor/Calibre2015。\n在终端输入 cp /mnt/hgfs/Patch/Calibre/patch_calibre ./。\n在终端输入 cp /mnt/hgfs/Patch/Calibre/sfk ./。\n在终端输入 ./patch_calibre aoi_cal_2015.2_36.27，此处会有个别 Error，可以直接忽略。\n在终端输入 rm .patch_calibre sfk，在弹出的提示后输入 y 并按下回车键。\n配置 License 将 Cadence/License.7z 解压到共享文件夹。\n在本地计算机上双击 Cadence/License/Cadence/licgen.bat，生成 license.dat。\n右击 license.dat，选择“打开方式”，选择“记事本”，单击“确定”。打开后，将前四行删去后保存。\n配置 License\n在虚拟机终端中输入 ifconfig，找到连接网络的 MAC 地址，此处为 ether 00:0c:29:06:6e:62，由此得到 HOSTID 为 000c29066e62。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [root@icdesign icdesign]# ifconfig ens33: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.222.128 netmask 255.255.255.0 broadcast 192.168.222.255 inet6 fe80::5bdf:abf2:2e32:18c0 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 00:0c:29:06:6e:62 txqueuelen 1000 (Ethernet) RX packets 48 bytes 7413 (7.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 50 bytes 7010 (6.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 1000 (Local Loopback) RX packets 48 bytes 4080 (3.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 48 bytes 4080 (3.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 virbr0: flags=4099\u0026lt;UP,BROADCAST,MULTICAST\u0026gt; mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:53:dc:60 txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 在本地计算机上用记事本打开 Cadence/License/Calibre/licgen.bat，将 HOSTID 改为 000c29066e62，保存并关闭。\n双击运行 Cadence/License/Calibre/licgen.bat，生成 license.dat。\n在虚拟机终端中输入 cp /mnt/hgfs/License/Cadence/license.dat /TOOLS/Cadence/IC617/share/license/license.dat。\n在终端中输 入cp /mnt/hgfs/License/Calibre/license.dat /TOOLS/Mentor/Calibre2015/license.dat。\n配置运行脚本 将 Cadence/Scripts.7z 解压到共享文件夹。\n在终端中输入 cp /mnt/hgfs/Scripts/.bashrc /home/icdesign/，在弹出的提示后输入 y 并按下回车键。\n在终端中输入 cp /mnt/hgfs/Scripts/.cdsinit /home/icdesign/。\n在终端中输入 cd /home/icdesign/。\n在终端中输入 vim .bashrc，按下 i 进入修改模式，找到下列内容并修改，并在最后一行添加 csh，修改完毕后按下 ESC，输入 :x 后保存并退出。\n1 2 3 4 5 6 7 8 9 10 export CADHOME=/TOOLS/Cadence export CDS_LIC_FILE=$CADHOME/share/license/license.dat # . $SOCV_KIT_HOME/env.sh export MGC_HOME=/TOOLS/Mentor export MGC_CALIBRE_SCHEMATIC_SERVER=ICDesign export MGC_CALIBRE_LAYOUT_SERVER=ICDesign 在终端中输入 reboot，重启虚拟机。\n配置 PDK 略。\n启动 Virtuoso 首先确定好自己所需使用的工艺库，本虚拟机中有 XMC FL 65nm、SMIC 55nm 和 SMIC 0.18μm 三个工艺库。\nXMC FL 65nm 工艺库 SMIC 55nm 工艺库 SMIC 0.18μm 工艺库 疑难解答 迁移虚拟机 将虚拟机的压缩包 IC Design.7z 解压到本地计算机 C:\\Users\\用户名\\Documents\\Virtual Machines\\ 目录下。\n打开 VMware Workstation Pro 16。\n迁移虚拟机\n单击“文件”菜单，选择“打开”，找到 C:\\Users\\用户名\\Documents\\Virtual Machines\\IC Design\\IC Design.vmx 文件，单击“打开”。\n迁移虚拟机\n此时可以看到，虚拟机“IC Design”已经打开，单击“开启此虚拟机”，即可打开该虚拟机。\n迁移虚拟机\n共享文件夹无法挂载 自动挂载共享文件夹 ","date":"2021-04-03T11:00:00+08:00","permalink":"https://ivy-end.github.io/p/vmware-%E7%8E%AF%E5%A2%83%E4%B8%8B-centos-7.9-%E5%AE%89%E8%A3%85-cadence-ic617/","title":"VMware 环境下 CentOS 7.9 安装 Cadence IC617"},{"content":"东风入夜散琼芳，拂晓金柯玉满妆。吹面寒风方识冷，回望庚子忆华章。\n阳春流片苦烦思，点点清辉伴露滋。纸上得来不觉浅，可叹践履又稽迟。\n尽收专利几何多，满载新知且放歌。今日还乡同把酒，明朝加国赴秋波。\n平明走马浦东场，行道依依口罩扬。漫漫乘风几万里，披星戴月遇他乡。\n银装素裹兴徜徉，灯火阑珊夜未央。玉碗珍馐风露洗，银灯缱绻话寻常。\n迎春贺岁觅唐人，向晚班春弄八珍。巷尾街头烹炸久，芬治约克蟹虾频。\n新冠突袭众心惶，战疫纷抢更慌忙。踏破铁鞋无处觅，屋堂影视菜肴香。\n春风秋月等闲时，痒序开期屡屡迟。网络重逢终复学，高谈阔论夜宵时。\n和风信步绕安湖，晴日开怀品骏图。细雨遣兴看博物，晚风拂面踏归途。\n盛筵华席有时休，校馆呼来未雨绸。细语涓涓思不尽，柔情款款似漪流。\n寻春返校不能居，东北一园暂作庐。晨起暮归奔走疾，三餐难觅当何如。\n此间听闻叔姨劳，日日驱车美味熬。至此飨飧无所虑，更添小食并清醪。\n返庠流片再重提，昔日谋划却寖迷。雨急风狂阶抚曲，嘈嘈切切键盘啼。\n夜阑不寐晓晨藏，错讶茫茫几欲狂。待到版图梨枣付，庐园小径踏春行。\n渐闻宇内祟邪平，岂止加疆气正嚣。海外纷然一似昨，中原遍购驭风行。\n朱明渺渺近归期，清夜悠悠寤寐思。课业更加新冠扰，惶惶不得展凝眉。\n千呼万唤赴归程，山水迢迢路未平。辗转留连宁沪地，独居难寐日萦萦。\n小园红烛弄清香，并蒂花开忆徜徉。今凤求凰期与行，明朝比翼绕当阳。\n新元复始迎新人，结伴熙熙密室巡。魄动心惊难自抑，夜来海错味香珍。\n迷蒙烟雨三秋时，风露临安草木悲。舟行西湖天地阔，水连灵隐斗牛宜。\n恍然流月白驹过，但闻长途趣颇多。辞旧喜迎庚子岁，民安国泰雨风和。\n","date":"2019-12-31T21:46:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%BA%9A%E5%AD%90%E5%BF%972020-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"庚子志（2020 年度总结）"},{"content":"前岁戊戌作志姑苏，今岁负笈求学金陵。时日之易逝兮，若川上流水，须臾已逾一载矣。回首己亥，所历之事皆历历在目，故作志以记之——曰游，曰学，曰情。\n戊戌霜月，余赴南京大学攻硕。其时河海大学曹公往谒吾师纪公共研太赫兹芯片一事，席间谓其欲得一优生以作数字集成电路。吾因伶俐聪颖，见拜于曹公，方知其欲为真随机数芯片，作文以刊，与会东瀛 ISCAS2019。余涉学尚浅，好作文，喜言说，曹公之言深中吾意，遂以诚事之。其间曹公尝发文余，要余详其制以假。历数月，竟成。至流片，已近除夕；然流片期已定，余不得已作图于年关之际，奔忙于交通之间，及近元宵，初成。然陡逢难事，遂赴梁溪研究院求教。此间受益匪浅，乃诸多典籍未有录之。\n事毕，余作讲演文稿以备 ISCAS2019，几番删改，终成。至己亥五月，经禄口，赴东瀛，奔札幌。至海关，始觉言语不通之弊病，幸纪公工于日语，方致客栈。群贤毕至，少长咸集，论于札幌会议中心，凡五日。会四海洋人，以洋文与其争高下、论短长，所获颇丰。及予登台讲演，但有万全之备，亦变色怅然矣。言毕，诸君问难，幸得南洋理工大学曾公从旁助余，不致见笑。\n此番会晤，甚矣吾之新识。科研实非象牙之内，乃江湖尔。为讲师者，必先积其资历，拓其人脉，聚众以谋其私，然后文章乃出，而后项目、基金不可胜数，终至教授。\n己亥六月，得纪公举荐，其大人闫公邀余攻博，治器件。因无心此道，故假言推辞。再邀，复辞之。又邀，余始察攻博事。吾尝思攻博之事，欲赴重洋，师夷长技以制夷。又吾爱海泓攻硕加国，若余得攻博其校，则两全其美也。然细考知其几微，故攻博于闫公。其因凡四：一，闫公其人仓廪实，结交广，利培养；二，西洋学仅滞于其表，海内学可深入其里；三，攻研期短，无利治学；四，余欲工器件也。此余攻博四因也。\n攻博至今半年有余，所治之学自太赫兹至器件，需识器件之学甚多，凡三月乃成。及至项目，方知不可拘泥，自器件至算法，个中条理，需了然于胸。予尝欲学贯微电，此道几近吾志也。因所学甚深，常思以忘食；因乐于其中，故无所迫。\n今岁要事实乃与吾爱海泓偕旅山河，一曰梁溪拈花湾，一曰齐鲁胶澳。拈花之行仓促成于海泓归宁之途；及至家，辄为通行、客栈诸事。三日之行纵览浮生闲趣，除杂思，弃案牍，园中静坐，邑里漫步，赏五灯湖景，徜梵天花海，拈花福点制糕点，惠山泥人绘泥人。\n己亥八月，乘休假隙，偕海泓往适胶澳以避暑。初至，凉风送爽，宛若金秋。旅居民宿，自为烹饪，仿佛兮若久居之侣，淡然闲适。小青岛上风习习，金沙滩头浪汹汹；驿外栈桥日栖栖，古堡钟鸣声重重；啤酒博物工序奇，晚市宵夜意兴融；海底世界鲸豚戏，情人坝上晚风浓。寥寥五日，所游甚欢。\n未几海泓赴加国深造，至此分离两地，情愈笃，思愈切。尝有视讯之便朝夕与闻，聊慰吾心；又有古人驿寄梅花、鱼传尺素，以藉吾情。\n旧岁将去，新元复始，愿国泰民安，风调雨顺。\n","date":"2019-12-31T16:04:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%B7%B1%E4%BA%A5%E5%BF%972019-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"己亥志（2019 年度总结）"},{"content":"树枝在风儿的吹奏下，飘出了一串美妙的音符；雪花在大地的构思下，描绘了一幅绝佳的画作。临窗眺望的我不觉看得出神，恍惚间，一年来的点点滴滴仿佛就在眼前。\n这一年，我找寻到了那个相识、相知、相爱、相守的人。不论是静谧的校园漫步、沉浸的电影欣赏、醉人的美味品鉴；还是热闹的厨房烹饪、愉快的景点探索、完美的手工配合……处处都留下了我们的欢声笑语。你的出现，让我领略了爱与被爱的美好，也让我的生命变得完整。\n这一年，我经历了从本科到研究生的转变。这可以说是一个较大的转折，也让我产生了很多思考。\n春，我开始了本科毕业论文的撰写。跟随着现在的研究生导师，做的校外毕设。虽说着实学到了不少，也接触到了实验室的相关内容，但感觉较之原本轻松的毕业论文，平添了几分繁琐。临近毕业，大家都对所谓的头衔、获奖失去了兴趣，为了避免评为优秀毕设后冗长的优秀毕设论文，纷纷将分数控制在了 89，既保住了学分，又落得了清闲。细想来，这才是看透荣誉后该有的状态吧。\n夏，我结束了本科阶段最有价值的经历之一——助理导师。在此过程中，我逐渐学会了更多与人相处的方式与技巧，更不断地磨练自己的口头表达和书面表达能力。在此过程中，也对“背锅”有了更深刻的理解与认识。或许，那些只知埋头苦干，熬夜背锅的人，并不会得到他们所想要的；取而代之，是更多的埋头苦干，与更多的熬夜背锅。这，也许只是在象牙塔中管中规豹。但却让我明白应当早日抛弃学生身份，开始更多的以社会人的角度思考问题。毕竟，我们终将成为社会的一份子，或者说，我们早已是社会的一份子。认识到这一点，这一切似乎也就更容易令人接受了。如若拒不接受，继续以读书的理由来逃避它，最终必将无路可退，或守着读书人的身份自欺欺人式的了此残生，或被社会予以打击后被迫的融入其中。\n秋，我开始了研究生的生活。总的来说，研究方向应该是数模混合集成电路设计。刚入学时，跟随着河海大学的老师进行真随机数生成器的电路仿真。从一开始的一窍不通，到后来的融会贯通，前前后后忙了一两个月，终于熟悉了 Cadence，摸清了电路的原理，也得到了仿真的结果。与此同时，还完成了第一篇全英文的学术论文，正焦急地等待着录用的结果。紧接着，便开始了下一阶段的研究工作，主要是关于 THz 雷达方向的内容。目前仅仅是开展了一个单元模块的仿真设计工作，预计元月底进行流片验证。\n冬，我开始了对研究生的思考。这主要包含两个问题，首先什么是研究生，其次读完研究生后干什么。\n研究生，表面上看和本科生没有太大的区别，无非是接触到了所谓的科研，领到了部分的工资。乍一看，既能学到知识，又能收获金钱，简直是求之不得的美事。实际上，研究生是不受劳动法保护的廉价劳动力。试想，在公司工作月薪 5k~10k 的优秀本科生，不仅能够得到专业的工程训练，得到高薪的报酬，还能维护自己的合法权益。而同等学力的研究生，却只能拿着 1k 不到的补助，没日没夜的干着苦力，还不能有任何抱怨，加班说加就加，工资说减就减，戏说之下，又与“奴隶”何异。唯一能让人欣慰的，或许是那张毕业证书和学位证书吧。想到这层，或许方能明白，为何研究生将自己的导师称作“老板”，而非“老师”。失之毫厘，谬以千里。却偏有人每天 8:30 来到实验室，奋战到 22:30 才回宿舍洗洗睡觉，日复一日，老师非常高兴，将其作为模范人物进行宣传，号召大家向其学习，争取早日毕业。埋头苦干，只会让老师觉得你是个很好地劳动力，却不能保证你学到更多的知识；而好吃懒做，也会让老师觉得你不过是个不求上进之徒，因而虚度了光阴。或许，应该找寻一个平衡点，在学到知识的同时，也不能沦为为学阀卖命的廉价劳动力。\n很多人说，读完研后当然是继续读博，然后博士后，接着当大学老师，努力搞科研。不得不承认，这是一条不错的道路。但细细想来，却并不如外人所想的那么光鲜亮丽。首先，是难以有成就感，不论是高校、研究所，大部分研究都算不上先进，只能说是为了拿一些经费。其次，是压力过大，大部分的底层的高校教师、研究所研究人员，几乎全年无休，随叫随到；看似摆脱了读博时导师的压迫，且多年媳妇熬成婆，却没曾想被大老板压迫的无处藏生；此外，每天还需顶着来自各方面的压力，拿着微乎其微的报酬，艰苦的推进着科研。最后，学阀制度的存在，一定程度上使得所谓的学术净土变得不那么的纯碎，更像是魏晋时期的九品中正。与其如此，不如跳将出来，以更广大的视角去探索生命的意义。\n或许，那就是“养天地正气，法古今完人”吧。记得刚进校园时，这句话便给我留下了深刻的印象。再加之书院学科交叉、文理互补的理念，使我培养了些许文学的气息。正如孔老夫子所言：“文胜质则史，质胜文则野，文质彬彬，然后君子。”相较于现在较为单调的工科环境，以往饱含人文关怀的自由环境则更令我向往。我们不应被眼下枯燥乏味的工作束缚了手脚，更应看到美好的诗和远方。\n掩卷遐思，不知东方之既白。\n","date":"2018-12-31T11:25:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%88%8A%E6%88%8C%E5%BF%972018-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"戊戌志（2018 年度总结）"},{"content":"此乃余首篇文言，因查重，今日乃详。\n时维四月，序属清夏，余负笈姑苏三载有余矣。感韶光之易逝兮，恐年岁之不吾与。懵懵间已逾弱冠之年，惶惶兮尚无功名傍身。值此掩卷遐思之际，忆往昔峥嵘岁月，不禁悲喜交集。凯，三尺微命，一介书生，得助四方，略有小成，感念之情，列叙如下。\n今天下学子皆得安其学而亲其师，乐其友而信其道，皆因无内外忧患之扰。寻其根，实乃中共领导之功。此吾拜谢者一也。\n吾本草芥寒门，今日所成，皆赖椿萱。家严襟怀洒落，博闻强识，昔日趋庭，叨陪鲤对；家慈温良恭俭，教余以严。虽结草衔环，无以报之万一。此吾拜谢者二也。\n三江既入，震泽底定，百年东吴，荟萃中西。养天地正气，巍巍然大学之道尽在其中；法古今完人，赫赫然为人之德皆存其里。书院敬文，明德至善，博学笃行，为国储才，自助助人，为砺成国器而上下求索。此吾拜谢者三也。\n余师从纪公讳小丽、马公讳强，其修业贞谨、微言大义、德才兼备、温恭和蔼，蒙先生之不弃，忝列师门。导吾以狭径，示吾以通途。坐聆教语，如金玉之良言，茅塞顿开；凝听诲言，似甘霖之灌顶，豁然开朗。倘无先生言传身教，鄙之愚钝，恐贻笑大方之家。此吾拜谢者四也。\n吾辈同侪皆四海菁英，陶君睿杰、蒋君毅等，同窗三秋，论人生之理想，评行业之得失，争学问于课堂，赏风光于山野。众人发余之蒙昧浅陋，助余之穷途落魄，广余之胸怀视界，消余之烦恼疑虑。此吾拜谢者五也。\n佳人缪君海泓，髣髴兮若轻云之蔽月，飘飖兮若流风之回雪。素手调羮，慰余求学艰辛；红袖添香，助余撰述此文。前路漫漫，与尔偕行，同游春花秋月，共赏夏风冬雪，甘苦与共，忧乐相随。此吾拜谢者六也。\n嗟乎！拳拳之恩，似穹隆之峰，明吾心而砺吾志也；绵绵之情，若太湖之水，照吾颜而昭吾天也。一言均赋，四韵具成，临辞涕零，不知所云：\n那岁清秋谈笑里，披星踏露向东堂。\n新枝全凭春泥护，凤阁门前翠竹昌。\n碌碌三秋藏颖处，茫茫万里夏虫乡。\n舍郎当有登堂志，青史留名后世扬。\n戊戌年清夏\n于天赐庄\n","date":"2018-12-30T22:13:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E8%87%B4%E8%B0%A2/","title":"本科毕业论文致谢"},{"content":"今阅前文，偶见于丁酉六月应《院刊》约稿所著之文。读毕愈觉其实为吾大学向之三秋一概述，现列叙如下。\n依稀记得三年前刚刚步入大学时的懵懂无知，如今却已成大四，凝眸回望来时的道路，曾经留下的足迹亦如沙滩上的脚印，在潮涨潮落中渐渐模糊不清。\n那是在姑苏的第一个秋天，人行道上金黄的落叶在夕阳下显得别有一番景致。当时的我第一次与当年苏州大学 ACM-ICPC 集训队队长在咖啡厅内相遇，却不曾料到此后一年多的时间内，我会全身心的投入到 ACM-ICPC 集训队的训练之中。\n那无数个在实验室的日日日夜夜，让我体会到了较高三更为枯燥的生活，却也带给了我许多快乐。此时的我，依然记得苦思冥想后推导出题目结论时的欣喜，记得奋笔疾书后证明出算法原理时的顿悟，记得那无数个奉献给数据结构和算法的日日夜夜，记得一遍遍的 WA 和随之而来的 AC，记得那一个个打训练赛的下午，匆匆忙忙地胡乱吃完从后庄带回来的晚饭，便投入下一场比赛。记得水平日渐提高时的欣喜以及发挥失常后的焦急。\n四场比赛，始于上海，北上长春，辗转北京，终于上海，两铜两银，曾创下苏州大学的历史最佳。那个小小的实验室，承载着一群人的梦想，大家不断的奋斗，只为接近更广阔的天空。\n在竞赛场上厮杀了一年有余之后，便思忖着能否体验一下别样的大学生活。一次偶然的机会，我有幸遇到了曲波老师，并在她的指导下，开始接触本科生科研。自此以后，我大学生活的重心便开始由竞赛转向科研。\n起先只是在实验室照着给定的图纸焊接电路，根据他人给出的思路编写代码；接着慢慢接触到了各类项目，利用周末前往企业进行设备的调试与安装；然后逐步参与到项目方案的设计之中，通过对现场的实地考察，分析客户的具体需求，给出项目的解决方案。在这一系列的锻炼之中，不论是方案的设计，还是现场的调试，亦或是与员工的沟通，各方面的能力都得到了极大的提升。\n在此期间还参与了“䇹政基金”项目、大学生课外学术科研基金项目、书院“3I”工程这些科研项目，均顺利结项。可以说，科研使得我的生活目标不再那么世俗，而多了一丝能使方寸得以安宁的纯粹。\n回顾这短暂的三年，感念于书院院长、指导老师、辅导员们的深深教诲，以及各位同窗好友的帮助。一路跌跌撞撞的走来，曾以为自己羸弱无能，也曾以为自己战无不胜，到如今才真正知晓人外有人，天外有天。故作诗叹道：\n那岁清秋谈笑里，披星踏露向东堂。\n新枝全凭春泥护，凤阁门前翠竹昌。\n碌碌三秋藏颖处，茫茫天地夏虫乡。\n舍郎当有登堂志，青史留名后世扬。\n丁酉年六月廿九\n","date":"2018-02-02T20:18:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/","title":"恰同学少年"},{"content":"呼吸着芬芳的空气，欣赏着眼前静谧的冬景，午后的我漫无目的行走在姑苏城的小巷之中，猛然发现丁酉年已匆匆走过，慌乱之中，赶忙打开尘封已久的博客，准备好好总结一下这一年的经历，就叫它《丁酉志》吧。\n翻阅着一年的照片，过去的一幕幕仿佛又浮现在了眼前，这一年做了很多事情，也做了许多决定，到目前为止，也很难说孰是孰非，且听我慢慢道来。\n隆冬时节，在曲老师的指导下，应苏州市第三中学的要求，帮对方制作了“基于重锤地倾的地震信号检测系统”，前后多次前往苏州市第三中学进行现场调试以及项目需求的沟通协商，面对甲方时不时冒出来的新想法、新需求，也算是体验了一下乙方的苦楚与无奈。在此过程中不仅增加了一定的项目经验，更多的是窥见了一些与甲方进行有效沟通的方法。\n仲春时节，迎来了“莙政基金”项目的结项工作，一年的工作凝结成了 8 分钟 36 页的汇报，而这短短一年的研修经历，对于我来说，不论是在学术方面，亦或是眼界方面都是一次绝妙的体验。结项后，学校会遴选一部分学生前往各个学校进行交流，由于当时想着出国读研，也就没有考虑境内的交流项目，而是选择了台湾国立清华大学。还有一个考量就是从入学开始到大三也没有好好的给自己放个假，也想利用这次难得的经历让自己远离各种事务，好好的放松放松，思考一些平时没有时间去思考的问题。\n初夏时节，参加了党校读书会的活动，选择了一本《历代经济变革得失》，以期可以学到一些经济学的基础理论。在活动进行过程中，得益于党建共建活动的开展，有幸能够与银行的党员们就该书中的一些内容进行交流讨论，她们用专业的眼光结合工作的经验，为作为大学生的我们解答了许多关于经济学的疑虑。我认为这种大家共同阅读，然后一起交流的学习方式，要比课堂教学、自我消化这两种极端的方法是都要有效果的多，然而在目前的情况下，却很难推行此种教育模式，也只是在小范围内学习交流时比较适用。\n仲夏时节，在学校的组织下，前往台湾国立清华大学进行为期两个月的学术交流，同时我也被任命为队长，负责全程的各类事务。在交流期间，终于得到了片刻的喘息，得以放空身心好好的休息一阵子。在整个交流的过程中，我们住在交流生宿舍，周围有来自各个国家的同龄人，其中最多的是印度人，每次来到走廊里，总能闻到一股刺鼻的咖喱味。偶尔也会去隔壁宿舍，找同样是电子系的马来西亚的朋友聊聊天，看看他正在做的项目，惊人的发现很多平时中文里创造出来的常用语，在马来西亚也有类似的表述。在逐渐习惯了当地的风土人情后，慢慢发现，在一群来自各个国家的留学生当中生活，可能并不是非常适合自己，也由此开始渐渐打消了留学的念头，开始咨询往届学长各类保研的事宜。在外出游玩的时候，才发现天地之间有如此多的美景，而自己以前拍摄的照片是那么的不堪入目，并由此萌生了自学摄影的念头。此外，交流期间，无意中看到了《毛泽东选集》，于是便一发不可收拾，废寝忘食的看了起来，每每看完一篇，总是不禁感叹太祖看问题实在是一针见血，非常的透彻。关于台湾游学的更多内容，请参考《福尔摩沙游学有感》。\n夏暮时节，回到学校以后，便开始了紧张的保研面试，经过准备材料、联系导师、面试等一系列环节，最终确定了一所高校，一所研究所，犹豫不决。后来去了一趟研究所以后，发现里面的研究虽然非常高端，但气氛实在太过沉闷、单调，可能不是很适合自己，最终选择了南京大学微电子科学与工程专业，与指导老师沟通以后决定走 THz 传感器的方向。如今再来回顾读研的整个过程，一开始想着的是出国读集成电路设计，而最后却是在国内读 THz 传感器，理想与现实真是天差地别。究其根本，还是制定计划的时候不够对目标还不够了解，从而在实施的过程中发现预定的目标并不如自己之前所想的那么好，从而又开始调整目标，进而调整计划，然后又调整目标，从而陷入了一个死循环。例如在《丙申志（2016 年度总结）》中所讲到的想要走集成电路设计方向，当时只想着要设计各种各样的集成电路，最后能走上设计 CPU 的岗位，而保研时才知道，集成电路设计方向还分了很多门类，例如模拟、数字两大类，其中模拟又有电源、滤波器、射频、传感器等，数字又分加密芯片、锁相环、DSP 等。正是由于一开始对于既定目标的分析不够明确，才导致了这些问题的出现。这样想来，“莙政基金”项目的申请流程要求申请人不仅对于项目整体有一个较为全面的认识，同时对于它的实施步骤，各流程的预期结果，可能遇到的各种问题等均有一定的理解，并能给出一些应对方案是较为科学的方法论，也值得日后在学习生活中进行实践。\n初秋时节，保研已经告一段落，想着再过一年就要离开姑苏了，一定要好好的再看一遍姑苏的秋冬春夏。于是办理了一张园林卡，先后去了网师园、艺圃、耦园、穹窿山、沧浪亭、可园、怡园、狮子林、虎丘、留园、石湖等景点。有时看着古代的石碑，想着古人的故事，不经意间仿佛自己也穿越到了古代，在那风雨莫测的年代里，隐居于姑苏这座小城。在游览风景的过程中，也练习着摄影的技术，发现“读万卷书，行万里路。”古人诚不我欺也。\n仲秋时节，成为了书院的一名助理导师，协助处理各类日常事务。在此之前，这类行政工作是我最不愿意去做的工作，一来感觉毫无难度，二来感觉每天重复着一样的工作非常无趣。但是当我真正去做了之后才发现，这份工作并不像想象中的那么简单。在整个工作过程中，发现自己办事的水平不断提高，办文的能力也得到了锻炼，学到了很多书本上从来没有的知识，也发掘了自己在这方面的潜力。\n仲冬时节，担任助理导师后，每天中午都有一段休息的空闲时间，一直没想到什么打发的方法，直到有一天看见书架上的《古文观止》还没碰过，便萌生了每天读一篇的想法。刚开始的时候感觉非常枯燥，毕竟时隔多年再一次看古文，还是非常吃力的。但坚持了几天下来以后，便发现已经停不下来了，书中记载的一篇篇文章中都体现了古人精妙绝伦的智慧，解答了很多自己曾经苦思不得的困惑。\n旧往凝怀，新元复始，言辞粗糙，不求顺达，值此搁笔，衷盼列君，诸端顺意，祺祥永驻。\n","date":"2017-12-31T23:13:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%B8%81%E9%85%89%E5%BF%972017-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"丁酉志（2017 年度总结）"},{"content":"最近整理旧时的读书笔记，偶然间看到 2016 年 3 月写的一篇文章，读完之后感觉非常契合此时心境，遂将其发布出来。\n适逢金庸 92 岁大寿，写下这篇文章，聊表敬畏之心。\n我记得接触的第一本武侠小说，便是射雕三部曲之一的《射雕英雄传》，当时的我少不更事，无法理解东邪身上的邪气，也理解不了南帝为何遁入空门，更不明白西毒如此作恶多端，只是敬佩七公的行侠仗义，同时也笑郭靖的傻里傻气。以为所谓江湖，就是刀光剑影，向往着自己武功盖世，全下无敌。\n接下来接触到的便是《神雕侠侣》，不理解杨过年少的苦，自然也不明白他成年后待人接物的姿态，不理解十六年后的杨过为何两鬓斑白，自创了黯然销魂掌，武学已臻化境，却依旧如此失落。只是非常喜欢郭靖的那一句“侠之大者，为国为民。”，想着江湖应该不只有刀光剑影，还有行侠仗义，向往这自己有朝一日能够以盖世之功，为国为民，有一番建树。\n此后细细品味了《笑傲江湖》，看到了令狐冲的无依无靠，任盈盈的身不由己，看到了君子剑的小人之心，名门正派的邪魔歪道，魔教的如水之交。当时一直盘旋在脑海的一个问题——何为正？何为邪？当我三读《笑傲江湖》的时候，方证大师的一句偈语道破天机——心佛即佛，心魔即魔。而江湖，亦邪亦正，邪中有正，正中有邪，而不像当初那般纯粹。此时的我，已慢慢失去了当初天下无敌的想法，只想着一管清箫，一把古韵，退隐江湖。\n然后翻阅了《天龙八部》，印象最深处，当属扫地僧让乔、慕容二人皈依佛门。想着江湖中腥风血雨，即便孑然一身，也难免遭人陷害，又如退隐山林，却不免旁人寻上门来，何不放下执念，遁入空门。天下第一又如何，一统江湖又如何，百年之后，不过是一抔黄土。何况高处不胜寒，真正天下第一，一统江湖以后，又有何乐趣可言，江湖即空，空即江湖。\n后来，又陆陆续续的接触了《倚天屠龙记》、《书剑恩仇录》、《碧血剑》、《侠客行》等，但看来看去，虽然主旨不同，但却没有改变我对于江湖的理解，一个独立于现实生活的想象世界。\n直到寒假品读了《鹿鼎记》，才算略窥其中的门径——有人的地方，就有江湖。它不再是一个想象出来的地方。而它不一定必须以武力决胜负，可以是财富，也可以是权利，但唯一不变的是无处不在的腥风血雨。既然避无可避，逃无可逃，那何不融入其中，不一定需要盖世无双、富甲天下，亦或权倾朝野，但求无愧于天，无愧于心。\n","date":"2017-11-10T13:44:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%BD%95%E4%B8%BA%E6%B1%9F%E6%B9%96/","title":"何为江湖？"},{"content":"五百多年前，葡萄牙人在大航海的过程中发现了台湾这个美丽的岛屿，将其命名为“Formosa”（福尔摩沙）。此次有幸在台湾停留多日，领略了与姑苏不一样的风情。而今游学之旅已近尾声，便将此行所见所感记录下来。\n搭乘了延误的航班、坐了接机的大巴，风尘仆仆地赶到国立清华大学，迎接我们的是连绵的细雨和位居山顶的宿舍。在校外奔波了一个晚上，终于采购完了各类生活用品，做好了迎接不一样的暑期生活的准备。\n在来之前，对于研究生的方向做了很多规划，最后锁定在了集成电路设计、机器学习这两个方向，但一直犹豫不决。由于在大陆接触了很多电路设计方面的内容，因此对于集成电路设计有着一个较为清晰的了解；而机器学习作为新兴产业，对于我来说仍然较为陌生的，借此机会正好接触一下，于是便进入了一个机器学习方向的实验室进行暑期学术交流。\n刚进实验室的时候，接待的学长让我脱鞋进入，并告诉我实验室开门的时间是上午十点，这对于我来说是较为震惊的。经过一番简单的交流后，确定了最后的研究方向——语者辨识，由于曾经做过类似的工作，因此并不是那么困难。\n但在整个研究的过程中，慢慢发现，整个实验室的研究过程大多是特征的选取、模型的选取、参数的调整这类隔靴搔痒的操作；偶或有一些自己搭建网络结构的创新，但却说不出一个所以然；再者就是找了很多篇论文，选一个最优的方法进行实现。再结合与大陆认识的机器学习方向的研究生聊天的过程中所表达出的对于调参现象的普遍性的问题，慢慢开始更加全面的认识了这个方向。对于我个人来说，似乎更想做的是研究其背后的原理，而不是仅仅调个参数，选个方案。虽然最后汇报的时候说的头头是道，但对机器学习这个方向也慢慢失去了兴趣，或许我真正喜欢的就是集成电路设计吧。\n学习之余，更多的是感受不同的文化，接触不一样的人。在与接待家庭的交流过程中发现接待家庭的叔叔曾就职于台积电，从事集成电路的工作，对于我准备走这个困难的方向表示了极大的鼓励。在与接待家庭游玩的过程中，也建立了一定的情谊。看到对方与上一届的学长、学姐仍然联系紧密，互赠礼品，有着些许感动；在感受到对方无微不至的关怀和无私的奉献时心里满是感激与惊喜。\n此外，还完成了环岛一圈的小目标，体验了台湾各地不同的风土人情，欣赏了大海的雄壮与美丽，感叹大自然的鬼斧神工。深入到美术馆中去欣赏那一幅幅摄影、画卷，感受到了不同于烦闷工科的轻松、愉悦。参观了各类纪念堂，看到了许多历史上文件的手稿、复刻版，其中印象最深的莫过于一代名臣李鸿章在《马关条约》上签名，耳边回响起了那位沧桑老人在签订《辛丑条约》时对庆王说的那句话：”庆王爷，天下最难写的是自己的名字，你还年轻，仕途无量，这个卖国贼的骂名，还是让我来当吧。”大清虽然亡了，但我泱泱华夏致力于民族复兴的脚步，却一刻也未曾停歇。\n一转眼已来到了分别的时刻，人生总是不停的相遇与离别，看着空中的明月，不禁赋诗一首：\n夜半残灯花不语，白藏冷月水空吟。\n清华相逢应如昨，水木惜别忽至今。\n碌碌三旬求正道，茫茫万里觅佳音。\n此间邂逅终须散，高山流水冷伯琴。\n","date":"2017-08-24T23:31:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%A6%8F%E5%B0%94%E6%91%A9%E6%B2%99%E6%B8%B8%E5%AD%A6%E6%9C%89%E6%84%9F/","title":"福尔摩沙游学有感"},{"content":"一直想写年终总结，却总是忙于应付各种事务，导致一拖再拖。适逢今天立春之际，写下这篇文章，权当是对过去一年的反思与总结。\n时间真是个猝不及防的东西，不知不觉中高中时创建的这个博客已经在巨大的互联网世界中立足四年了，而我也已经从当时特别无知的高中生变成了如今比较无知的大学生了，年龄总是一年一年的增加，但是真正的智慧却不会随着时间线性的增长，总是需要及时的去反思总结并且在实践中进行运用才能真正的内化成智慧。\n如果说 2015 年的关键词是“比赛”，那么 2016 年的关键词一定是“项目”。虽然许多人习惯在“项目”前面加上“科研”二字，但是当真正的深入进去才会发现，你一个普普通通的本科生，又怎么可能做的了什么科研呢？无非是导师看你骨骼惊奇，想锻炼锻炼你，顺便让你搬搬砖罢了。再说那么多本科发顶会的同学，又有多少人是凭借着自己的研究成果呢，大多数都是导师研究出来挂个名而已。\n当时为了接触更多的研究方向，所以申报了很多各方面的课题，回想过去一年，从基础的 STM32 写到 FPGA 最后转到机器学习习，涉猎也算不窄，但是写完这么多东西以后却发现这些都不是我所喜欢的方向，似乎自己更喜欢的是集成电路设计方面的内容，而不是从小就开始学的编程。经常会有学长和我交流的时候问我，为什么代码基础这么好，不报就可以，或者说不走计算机科学（CS）方向。我感觉当遇到大量重复工作的时候写个程序来代替是我做喜欢的工作，但是现在国内的底层码农基本都在沉迷在各类企业管理软件的制作之中，偏重业务逻辑也不是算法逻辑，对于这方面却没有很多的兴趣。\n通过过去一年的磨练，我发现自己对于未知的内容有着较深厚的兴趣。对于编程方面，如若让我使用别人的算法实现各种各样的系统，那我一开始都会去拒绝这样搬砖的体力活的（当然砖还是要搬）；如若让我去改进或者设计一个种全新的算法，却能够让我感到非常 excited。对于电子方面，如若面对的是一个根据理论可以得到很明确结果并且与实际相符的电路时，我是非常乐意去制作的；但是如果遇到一些比较玄学的电路或者理论与实际相差甚远的电路时，我却愿意去探索其中的原因以及奥秘。\n但是未知的内容钻研多了就会产生一种疲累感以及无力感，当解决这些未知内容的时间限制越少时，这种感觉越强烈。往往这个时候就想什么事情都不做，好好的放空一下自己。但是生活怎么可能这么顺心如意，更加常见的剧情便是紧接而来的无数的事务忙的晕头转向。难得的闲暇便是刚刚考完试的几天吧，可以没有任何顾虑的娱乐一番。\n在大学学习已经两年有余了，对于大学课程也找到了应对其的套路：平时翻翻书，考前做做题。说起来轻巧，但是却因课程难度而异。对于简单的课程，考前两个小时背个重点就能应付；对于较难的考试，考前可能要看上一个礼拜才能勉强应对。但是考完以后却发现书上所教授的内容已经忘得一干二净，因此年末时想到一个方法：将输入式学习向输出式学习进行转型。于是就有了知乎专栏上面的内容，通过综合大学所学的知识和课外的知识，从根源上解释如何制造一套计算机。\n但是，光学习仍然不够。想想已经是半只脚踏出校门的人了，同学之间讨论的话题也从大一时如何上大学、为什么上大学变成了毕业以后读研还是读博，国内深造还是出国深造，读什么方向。当然偶尔也会调侃道房价为什么这么贵，连个厕所都买不起。去年一年所做的项目就是为了确定研究生到底应该读什么方向，目前粗略的定了两个（集成电路设计以及机器学习）或许随着以后的学习会发生一些变化。虽然想读博，但是看着那么多博士哭天抢地，却又有点犹豫。去年下半年开始尝试着出国的准备，最终以 1217 事件悲惨收尾，或许这个应该就是今年的重点吧。虽说开始进行出国的准备，但是却还有很多的未知，到底要不要出国读？读不读博士？先硕士后博士还是直接博士？读完以后要不要回国？回国了又该如何发展？这无数的念头在脑海中挣扎，或许应该安慰自己“船到桥头自然直”吧。\n除了这些内容外，去年还利用空余时间接触了乐理方面的知识，自学了 Ukulele。虽然只会一些基本的曲目，但是发现当身心烦躁时弹上一曲却能使自己平静下来。此外还接触了中医的知识，感到了中华传统文化的博大精深，在中医养生的道路上迈出了第一步。最后重拾了中学时期的《周易》，研究起了八字算命，在玄学的道路上更进了一步。对于玄学方面的内容，可以引申出很多有趣的内容，希望日后有机会可以写出了与大家分享。\n在过去的一年里经历过很多的困顿、艰辛，但是我相信这一切都值得。明天还有新的梦想等着我们去追逐。\n","date":"2016-12-31T19:57:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%B8%99%E7%94%B3%E5%BF%972016-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"丙申志（2016 年度总结）"},{"content":"终于还是来到了这一天，当双手在键盘上敲下这些文字的时候，竟有些颤抖。尽管曾经不止一次的思考过退役后的场景，也做足了充分的思想准备，但当这一刻真的到来，却有些不知所措。看着 ACM 交流群里热烈的讨论，关上窗口，退出该群；将 ACM 资料小心翼翼的放置在移动硬盘的角落，不小心瞥见 NOIP 退役时存放的资料，记忆一下子席卷而来。在算法竞赛的道路上跌跌撞撞的行走了将近五年，从 NOIP 到 ICPC，是时候说再见了。\n此时的我，依然记得多年前第一次提交 A+B 时的激动，记得思索半天推导出 Segment Tree 时的满足，记得苦思冥想理解 Dancing Links 时的欣喜，记得写完几本草稿本后证明 Binary Indexed Tree 时的顿悟，记得那无数个奉献给《数据结构》和《算法导论》的日日夜夜，记得一遍遍的 WA 和随之而来的 AC。记得那一个个打训练赛的下午，匆匆忙忙地胡乱吃完从后庄带来了晚饭，便投入下一场比赛。记得水平日渐提高时的欣喜以及发挥失常后的焦急。\n那无数在实验室刷题的时光，除了让我体会到了较之高三更为枯燥的生活，却也给我带来了些许快乐。一群人讨论时事热点时的激烈，徐老师突击检查时的尴尬，准备题目汇报时的担心，为新生赛出题的忙碌，准备新生授课的紧张以及北疆饭店里的谈笑风生都将成为珍贵的记忆，小小的实验室，承载着一群人的梦想，不断的奋斗，只为接近更广阔的天空。\n四场比赛，从上海开始，再到长春，辗转北京，最后回到上海，两铜两银，在最后的 EC-Final 中夺得银牌，虽然无缘 World Final，但也算是个不错的成绩。\n第一场比赛是华东理工大学承办的上海邀请赛，铜牌，身为常年铁牌的弱校选手，第一次参赛拿到一块铜牌也是意料之外。回来以后便和队友商量，区域赛一定要拿到苏州大学的首枚银牌。第二场比赛是东北师范大学承办的亚洲区域赛（长春站），在我们奋力拼搏五个小时以后成功收获一枚铜牌，为此队友们都低落了许久，徐老师却安慰我们好好准备，还有机会。第三场比赛是北京大学承办的亚洲区域赛（北京站），银牌，不负所望，成功晋级 EC-Final。最后一场便是上海大学承办的 EC-Final，以银牌收尾。\n我的算法竞赛道路也就到此结束了，退役的原因很多，一方面作为一名电院的学生，本身课业压力较大，无暇分心；另一方面也是想多接触一些工程，将所学的算法竞赛知识运用于实践。\n故事很长，就像一场长长的宴会，大家说说笑笑，戛然而止，来不及一一道别。\n感谢一路帮助过我的父母、老师和朋友，陪伴我度过快乐的 ACM 生涯。\n感谢曾经的队友，我会记得你们 CARRY 过我的每一场比赛。\n感谢 ACM 交流群，和大家谈笑风生是我的荣幸。\n最后，愿我们都前程似锦。\n春回大地，万物复苏，时值交配，黯闻吾凯退役，悲恸难舍。\nwuli 凯凯，伟大的哲♂学家，算法家，数学家，无产阶级手速学家，双蛋炒饭鉴赏家，曾以 22 发 hack 一举闻名于世，聪慧厉行，为人果断，擅长 a 题，世所罕见，虽偶遇坎坷，非十多发而不能 a 者，然刚烈之精神永存。\n嗟乎，写作王凯，读作 dān shēng gǒu，与君谈笑风生，恍在昨日。荣辱浮沉，皆明日黄花，望君行趁早，唯约不得的妹子与舍友，不可辜负。\n——高可攀\n","date":"2016-04-05T22:40:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%86%8D%E8%A7%81%E4%BA%86acm-icpc/","title":"再见了，ACM-ICPC"},{"content":"细细想来，已经有近四个月没有更新过博客，上一次还是在 7 月份。既然这样，那就从那时候讲起吧。\n整个暑假，绝大部分时间在参加 ACM 训练，除此之外，还参加了全国大学生电子设计竞赛，拿了个一般的奖项；去英国走了一遭，体会了不同的风土人情。一直想好好记录这两件事情，但总是由于各种各样的原因搁置了。\n这学期自从开学以来就一直非常的忙，刚开始备战 ACM，上个月在长春拿了一块铜牌，上星期在北京拿了一块银牌，周三刚刚把 FPGA 设计邀请赛的作品完成，明天一大早赶往上海交通大学参加微软 Hackthon 大赛，下周需要提交全国移动互联网开发大赛的作品，再加上最近期中考试周，几乎忙的没日没夜。\n这几天难得有个喘息的机会来，却发现自己已难以适应如此清闲的生活了。思来想去，不如把这两次比赛过程中的所见所闻写下来，权当回忆罢。虽然前往北方这两个城市的目的是比赛，但是我却希望在这篇文章中淡化比赛的内容，一来比赛的内容对于大多数读者来说较为陌生，如果不是参加过类似的比赛，很难感同身受；二来比赛的情况已经反思总结过，也没有必要再拿出来写一遍。因此，我想尽可能的把整篇文章的重点放在整个旅途的过程，我所见到的、遇到的人和事。\n当暑假里进行的网络预选赛结束时，我便想去北方的赛区经历一番，主要原因是没有出过什么远门，想出去见识一番，顺便可以拿个奖回来。最终分配给我们队伍前往长春（东北师范大学）、北京（北京大学）这两个赛区。\n先来说说长春赛区，这也是我第二次坐高铁，第一次是去年的上海邀请赛，可以参阅《记 2015 ACM-ICPC 上海大都会赛》。从苏州到长春，11 个小时、1000 多公里的路途，体验了从短袖到毛衣的气候与风景。在去的途中，坐在我边上的是一位在苏州从事医疗工作的长春人，听说我是苏州大学的学生，便和我聊了起来，不停地向我推荐长春的旅游地点，使我深切的感受到了东北人民的热情。\n当然，到达长春的时候，我才发现曾经的东三省，如今是如此的破旧。可能由于气候的原因吧，晚上七八点钟在路上已经看不到什么营业的门店，大多都已打烊。所幸当时并没有暖气，所以空气质量虽然不是很好，但还能接受。\n报道的时候，专门负责接待我们学校的志愿者早已等候多时，这也不由得使我感到一阵惊喜。简单的手续后，志愿者在我们带队老师的请求下，带领我们参观了东北师范大学。学校不大，但是富有现代气息，宿舍楼更是高达二十层，此外，我们还去了隔壁吉林大学串门。第一天走下来的感觉便是破旧，即便是白天，想要在大街上找一家像模像样的超市也非常的困难。\n第二天，我们便开始了正式的比赛，从上午 9 点到下午 2 点结束，然后颁奖，闭幕式。吃完晚饭，一直到晚上 6 点才结束。接下来却无奈的强行被拉到 KTV 唱歌以庆祝比赛顺利结束。晚上 9 点多钟出来，同学叫来了吉林大学的同学，想让他带我们逛街，然而正如前文所说，所有的商店都已关门，我们就这样在黑夜中顶着零下一度的温度在东北的马路边行走，最终回到宾馆附近的一家烧烤店吃了夜宵才回去睡了。\n在归途中，由于接下来要考试，所以便一直在复习。当我准备休息一会的时候，坐在我边上的旅客突然跟我说，你解微分方程的速度真快。于是便聊了起来，对方表示已经工作，希望我能够在大学里好好学习。临走时戏谑地说，我要是再跟你聊下去，就要和你去苏州了。\n经历的第一次的失败，我们非常希望能够在北京赛区拿到一块银牌，也算是对自己过往训练的一种肯定。但是我们都知道，北京是所有赛区中难度最大的，因为所有的强队基本都会去，而奖牌是根据百分比来评定的。也就是说，同等的成绩，可能在长春可以拿到一块铜牌，到北京，可能连一个牌都拿不到。因此，这一个月大家都或多或少的有些许压力。最后两次训练赛的时候进入了银牌区或许给了我们些许宽慰。\n前往北京的旅途虽然不及长春的一半，但却更加艰难。由于比赛与一门考试冲突，在院教务主任、院长、校教务之间辗转多次，终于办完了缓考申请，院长签字的时候，语重心长的说：好好比，拿一块银牌回来。\n当我走下动车，踏上北京的土地，感受到的是帝都强烈的雾霾，直教人难以呼吸，以至于后来拍照时竟然以为自己的摄像头坏了。当我们来到宾馆，看到破烂不堪的房间和高昂的住宿费，不禁感叹帝都人民的生活。与长春类似，我们报到当天参观了北京大学，这座历史悠久的名校，在未名湖畔，眺望密檐宝塔。感受到了强烈的文化冲击，或许这就是一个学校应该积淀下来、传承下去的东西吧。\n正式比赛时，进入场馆，不禁怔住。这是 2008 年承办北京奥运会乒乓球比赛的场馆，头顶“Beijing 2008”的字样依旧一尘不染，展现着它的光辉。开幕式时，各位国际嘉宾纷纷致辞，中英对照，使人仿佛置身于国际决赛的现场。5 个小时的比赛很快便过去了，而颁奖阶段，却着实进行了两个多小时。这使得一位与我相识多年特地从北京师范大学赶来希望和我见一面的网友在寒风中等待了一个多小时，颁奖典礼结束后，我才得以从场馆出来迎接他。\n我们多年的交流虽然只是通过电磁波作为媒介传递着消息，但当我们真正见面时，却如同多年老友一样亲切。在北大艺苑餐厅吃完晚餐，稍作闲逛，便和他前往北京师范大学游玩。当我晚上 8 点多钟坐地铁返回北京大学时，在夜色中，来到一个邮筒旁，投递了近十张明信片，也算作是和朋友分享自己的所见所闻。\n今年的比赛也就随着北京赛区的结束而落幕了。\n","date":"2015-11-20T21:50:00+08:00","permalink":"https://ivy-end.github.io/p/%E8%AE%B0-2015-acm-icpc%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B%E9%95%BF%E6%98%A5%E7%AB%99%E5%8C%97%E4%BA%AC%E7%AB%99/","title":"记 2015 ACM-ICPC亚洲区域赛（长春站、北京站）"},{"content":"Description Two of the three members of the winning team of one of the ACM regional contests are going to meet in order to train for the upcoming World Finals. They decided that they will meet sometime between $X$ o\u0026rsquo;clock and $Y$ o\u0026rsquo;clock. Because they never get anywhere on time (they were late even on the day of the regional contest), they did not set an exact time when they will meet. However, they decided that the one who gets first at the meeting point will not wait more than $Z$ minutes for the other one (they calculated that, if the other one will not come within $Z$ minutes from the arrival of the first of them, then it is very probable that he will not show up at all).\nKnowing that, in the end, both of them will show up at some time between $X$ o\u0026rsquo;clock and $Y$ o\u0026rsquo;clock (not necessarily after an integer number of minutes), compute which is the probability that they will actually meet.\nInput The input will contain 2 integer numbers $X$ and $Y$ ($0\\leq X \u0026lt; Y\\leq 24$) and one real number $Z$ ($0 \u0026lt; Z\\leq 60(Y-X)$).\nOutput You should output the required probability with 7 decimal digits (rounded according to the 8th decimal digit).\nSample Input 1 11 12 20.0 Sample Output 1 0.5555556 Analysis 这是一道纯粹的数学概率题，我们可以进行公式推导。首先我们需要统一单位，将 $X$ 和 $Y$ 均以分钟为单位；其次，我们以 $X$ 点钟为计时零点；接下来做出这样一张图：\n概率分布图\n根据上图，我们可以知道相遇的概率为中间六边形的面积，即 $P = S_A / S$，由于 $S_A$ 求解起来比较困难，我们可以转换为计算总面积减去两个三角形的面积。因此，答案为 $$ P = 1 - \\frac{(Y - X - Z) ^ 2}{(Y - X) ^ 2}$$\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); double X, Y, Z; while(cin \u0026gt;\u0026gt; X \u0026gt;\u0026gt; Y \u0026gt;\u0026gt; Z) { X *= 60; Y *= 60; Y -= X; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(7) \u0026lt;\u0026lt; 1 - (Y - Z) * (Y - Z) / (Y * Y) \u0026lt;\u0026lt; endl; } return 0; } 这道题目主要考察数学中的概率知识。\n","date":"2015-07-22T20:46:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-144-meeting/","title":"SGU 144 - Meeting"},{"content":"想来放假已经好几天了，总算抽出了一些时间来总结一下这学期的经历，虽然在期末考试期间应导师要求写过一篇《学期总结》，然而由于复习紧迫，只是草草收笔，并没有点中要处。\nGrind of Courses 这学期刚开始，或许是由于上学期不错的成绩造成的盲目自信，导致了上课时间并没有特别认真的听讲，大多数时间在自己看课外书，比如《暗时间》、《浪潮之巅》等（不得不承认，这些都是不可多得的好书，前者介绍了如何高效的利用时间；后者介绍了近几十年信息技术产业作为信息产业的发展史，其中涉及了各大知名公司，例如 Apple、Microsoft、AT\u0026amp;T 等的衰亡）。当然，造成这种结果除了主观因素外，不可否认还有一部分客观因素：由于教师们不急不慢的授课速度，使得我不需要太快的思路就可以跟上甚至超前他所讲的内容，几番下来也就不想再听讲了，然而事实证明这并不是一个非常好的选择。\n期中考试的时候，就吃了不怎么听课的亏，导致节节败退；到了期末考试，通过一阵子的学习，将所有的内容全部赶上，并且在期末考试中取得了较为不错的成绩，但是由于期中考试并不是非常理想，导致最后的总评不是很好看，虽然两个学期的总评还过得去。\n还记得上学期的时候，每节课都不缺，每次都认真听课，但是发觉很多时间听课都是听老师讲过的东西，或者自己已经会的东西，真正不会的东西其实所占的比例并不是很大，再结合这一学期不怎没听课，但是通过自学，也感觉学的和上学期的扎实程度差不了太多，因此对于学习方法有了一个较为大胆的想法——全部自学。这样可以省下很大一部分的时间，可以做我感兴趣的事情，学我感兴趣的课程。\n在一次外出参观 Rigol 公司的时候，和班主任聊天的时候和他提出这样的一个想法，带有咨询的态度去和他交流，本以为班主任会有些反对，没想到班主任对于我的想法表示出了较大的赞成，并且说出了一个令我信服的理由——教师上课的时候只会挑课本中的一部分讲，而自学则会从头到尾的学习一遍，真正的做到融会贯通，同时获得的能力上的提升，也不是听课可以学来的。同时，他也希望我可以通过这样的自学，取得较好的成绩，总的来说，他非常支持我做这样的一个尝试。\n通过这一系列的思考和交流，我开始制定了自己的自学计划，希望可以在暑假期间可以自己看完《Complex Variables》。我并不认为学习一门课程非要使用我们学校规定的教材，我希望找一本深入浅出，涵盖面广的书进行学习，通过对图书馆书库进行一系列的搜寻和比对，结合之前借阅《Circuits》参考书籍的经验，感觉国外的教科书总是可以从最为基本的入手，到最后讲的也非常的深入，较国内的大部分生硬的教材来说更有吸引力，可以同时提升英语能力也是一个非常重要的因素。\nGrind of Projects 说到项目，为了体验本科生科研的感觉，这学期揽下了两个项目，其中一个是项目负责人，一个是项目参与者，然而事实证明，这个选择也是不太明智的。\n首先说说我作为负责人的项目——掌上敬文移动客户端开发。当时招募人手的时候有很多人踊跃报名，通过筛选，选出了一些有一定开发经验的人员，最后定下了一个 6 个人的开发团队，负责 Android 以及 iOS 两个移动端的开发，还从计科院找了一位指导老师。然而最后的结果就是——指导老师撒手不管；分配任务时，团队人员不是没有时间，就是以不会推诿。最终整个项目就落在了我一个人的头上。还记得当初揽下这个项目时，舍友跟我说的一句话：「当你做项目负责人的时候，就要做好一个人做完项目的准备。」现在想想这句话还是很在理的。通过这次经历，至少让我觉得项目团队中的人员实力差距不能太大，同时自学能力是科研最为基础的能力。当然，我觉得最为重要的一点是——目前的本科生科研现状大多只是为了一个名号，走一个过场，把别人发明过的东西再发明一遍，或者把国外的东西搬过来翻译一遍，而不是真正的投入科研，或许在某种程度上大部分本科生并不是非常适合做科研。\n其次是作为参与者的项目——四轴飞行器的制作。这个团队只有 3 个人，两个大三的学长再加上我。加入这个团队主要是学完了 51 系列的单片机，想继续深入学习 STM32 系列的单片机时，正好有这样一个契机，因此就和他们合作，同时还可以顺便参与一下今年的全国电子设计大赛。然而当我真正开始着手做这个项目的时候，我才发现自己知道的实在太少了，四轴飞行器的理论要求还是很高的，为此看了很多篇四轴飞行器物理模型、控制算法的论文，但是依然感到略有吃力。\n除此之外，我还需要每天坚持 ACM 训练，基本上早上出去上课，晚上在实验室呆到 11 点才回到宿舍。\n这三件事情就像三座大山一样压着我，使我喘不过气来。有时候我想放下这些事情，让自己去做一些别的事情，然而没过多久，就会发现还有一大堆事情没有处理完，但是却力不从心。以至于放暑假前学长推荐我去带薪实习，我都抽不出空来。有时候我觉得它们似乎在告诉我：你累了。\nGrind of Interests 这学期的《艺术审美》课程，虽然对于讲座内容有时候兴趣不是那么浓厚，但是却使得我作为一个毫无艺术细胞的人对音律和绘画产生了兴趣，我觉得这大抵是最大的收获吧。喜欢在书画室内临摹名家的画作，虽然一幅山水需要很长的时间，但是我却从中得到了难言的乐趣，当看到墨水在纸上化开，感到自己的心胸得到了开阔，心境得到了提升；喜欢到钢琴房去练习钢琴，当音符从指间泻出的，感到自己的心灵得到了洗涤，身心变得无比的宁静。或许这就是艺术的魅力所在吧，我也渐渐的理解了为什么那些历史上的画家、音乐家虽然生活贫瘠，但是他们好像比任何人都富有，因为他们拥有自己的本心。\nGrind of Future 在学期快结束的时候，我突然意识到，我的大学生活已经过去了四分之一，而我在这一年中，我并没有取得自己所想要得到的成绩。在这一学期的忙碌中，我似乎并没有太多的时间去思考，感觉自己就像是被推着前行。或许我需要更多的时间去思考，而不是用来平庸的忙碌。我认为 Definiter 的这句话说的非常有道理：\n每当我看到那些 20 岁的健壮的形体时，我都会想起自己孱弱的身躯；每当我看到同龄人做的那些令人惊叹的事之时，我都会想起自己的碌碌无为；每当我看到本科毕业生拥有的坚实能力时，我就会想到大学只有四年，已经没多少时间了。我明白成长不是一件急于求成的事情，焦虑之后，只能亲力亲为。\n在过去，很多事在变好；在未来，一切当然会变得更好。\n","date":"2015-07-21T09:49:00+08:00","permalink":"https://ivy-end.github.io/p/the-freshman-grind/","title":"The Freshman Grind"},{"content":"Description Let $P_1, P_2,\\cdots ,P_N,\\cdots$ be a sequence of prime numbers. Super-prime number is such a prime number that its current number in prime numbers sequence is a prime number too. For example, 3 is a super-prime number, but 7 is not. Index of super-prime for number is 0 iff it is impossible to present it as a sum of few (maybe one) super-prime numbers, and if such presentation exists, index is equal to minimal number of items in such presentation. Your task is to find index of super-prime for given numbers and find optimal presentation as a sum of super-primes.\nInput There is a positive integer number in input. Number is not more than 10000.\nOutput Write index $I$ for given number as the first number in line. Write I super-primes numbers that are items in optimal presentation for given number. Write these I numbers in order of non-increasing.\nSample Input 1 6 Sample Output 1 2 2 3 3 Analysis 首先，我们可以根据筛法求出 10000 以内的素数，接下来我们继续利用筛法，求出这些素数中，下标为素数的超级素数，这样我们就得到了题目中所需要的超级素数。\n对于寻找一个最优的组合，我们可以使用 0/1 背包来解决这个问题，同时记录路径，最后输出最优解即可。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MAX = 10240; vector\u0026lt;int\u0026gt; P, SP; int pP[MAX], pSP[MAX], nCnt; int f[MAX], pPath[MAX]; int main() { int N; P.push_back(0); SP.push_back(0); memset(pP, 0, sizeof(pP)); memset(pSP, 0, sizeof(pSP)); for(int i = 2; i \u0026lt; MAX; i++) { if(pP[i] == 0) { P.push_back(i); for(int j = i + i; j \u0026lt; MAX; j += i) { pP[j] = 1; } } } for(int i = 2; i \u0026lt; P.size(); i++) { if(pSP[i] == 0) { SP.push_back(P[i]); for(int j = i + i; j \u0026lt; P.size(); j += i) { pSP[j] = 1; } } } while(cin \u0026gt;\u0026gt; N) { memset(f, 0, sizeof(f)); memset(pPath, 0, sizeof(pPath)); f[0] = 0; for(int i = 1; i \u0026lt;= N; i++) { f[i] = 214748364; } for(int i = 1; i \u0026lt; SP.size(); i++) { for(int j = SP[i]; j \u0026lt;= N; j++) { if(f[j - SP[i]] + 1 \u0026lt; f[j]) { f[j] = f[j - SP[i]] + 1; pPath[j] = j - SP[i]; } } } if(f[N] == 214748364) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; f[N] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; N - pPath[N]; for(int i = pPath[N]; i; i = pPath[i]) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i - pPath[i]; } cout \u0026lt;\u0026lt; endl; } } return 0; 这道题目主要考察最为基本的动态规划以及记录路径。\n","date":"2015-07-20T13:39:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-116-index-of-super-prime/","title":"SGU 116 - Index of super-prime"},{"content":"很久以前刷完了 Virtual Judge 上的简单搜索专题，现总结如下：\nPOJ 1321 由于题目的数据范围比较小，可以直接 dfs 暴力。读入时记录每个空位的位置，保存在 pX[] 以及 pY[] 数组中。暴力的时候统计当前处理第几个空格以及当前处理到了第几行即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 128; long long ans; int N, K, nCnt; bool pUsed[MAX]; int pX[MAX], pY[MAX]; int pRow[MAX], pCol[MAX]; void dfs(int x, int y); int main() { char dwTmp; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K) { if(N == -1 \u0026amp;\u0026amp; K == -1) { break; } nCnt = 0; ans = 0; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; dwTmp; if(dwTmp == \u0026#39;#\u0026#39;) { nCnt++; pX[nCnt] = i; pY[nCnt] = j; } } cin.ignore(); } memset(pRow, 0, sizeof(pRow)); memset(pCol, 0, sizeof(pCol)); memset(pUsed, false, sizeof(pUsed)); dfs(1, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } void dfs(int x, int y) { if(y == K) { ans++; } else { for(int i = x; i \u0026lt;= nCnt; i++) { if(!(pUsed[i] || pRow[pX[i]] || pCol[pY[i]])) { pRow[pX[i]]++; pCol[pY[i]]++; pUsed[i] = true; dfs(i + 1, y + 1); pUsed[i] = false; pRow[pX[i]]--; pCol[pY[i]]--; } } } } POJ 2251 这是一个三维迷宫，对立体空间的六个方向进行 bfs 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 32; const int dx[] = { 1, -1, 0, 0, 0, 0 }; const int dy[] = { 0, 0, 1, -1, 0, 0 }; const int dz[] = { 0, 0, 0, 0, 1, -1 }; struct Point { Point(int _x = 0, int _y = 0, int _z = 0, int _ans = 0) { x = _x; y = _y; z = _z; ans = 0; } int x, y, z, ans; }; queue\u0026lt;Point\u0026gt; Q; Point Start, End; int pMaze[MAX][MAX][MAX]; bool pVisited[MAX][MAX][MAX]; int main() { int L, R, C; string strTmp; while(cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C) { if(L == 0 \u0026amp;\u0026amp; R == 0 \u0026amp;\u0026amp; C == 0) { break; } while(!Q.empty()) { Q.pop(); } for(int i = 1; i \u0026lt;= L; i++) { for(int j = 1; j \u0026lt;= R; j++) { cin \u0026gt;\u0026gt; strTmp; for(int k = 1; k \u0026lt;= C; k++) { if(strTmp[k - 1] == \u0026#39;S\u0026#39;) { pMaze[i][j][k] = 0; Start = Point(i, j, k); } else if(strTmp[k - 1] == \u0026#39;E\u0026#39;) { pMaze[i][j][k] = 0; End = Point(i, j, k); } else if(strTmp[k - 1] == \u0026#39;.\u0026#39;) { pMaze[i][j][k] = 0; } else if(strTmp[k - 1] == \u0026#39;#\u0026#39;) { pMaze[i][j][k] = 1; } } } } Q.push(Start); bool bFlag = false; memset(pVisited, false, sizeof(pVisited)); pVisited[Start.x][Start.y][Start.z] = true; while(!Q.empty()) { Point Now = Q.front(); Q.pop(); if(Now.x == End.x \u0026amp;\u0026amp; Now.y == End.y \u0026amp;\u0026amp; Now.z == End.z) { cout \u0026lt;\u0026lt; \u0026#34;Escaped in \u0026#34; \u0026lt;\u0026lt; Now.ans \u0026lt;\u0026lt; \u0026#34; minute(s).\u0026#34; \u0026lt;\u0026lt; endl; bFlag = true; break; } for(int i = 0; i \u0026lt; 6; i++) { Point Next; Next.x = Now.x + dx[i]; Next.y = Now.y + dy[i]; Next.z = Now.z + dz[i]; Next.ans = Now.ans + 1; if(Next.x \u0026gt;= 1 \u0026amp;\u0026amp; Next.x \u0026lt;= L \u0026amp;\u0026amp; Next.y \u0026gt;= 1 \u0026amp;\u0026amp; Next.y \u0026lt;= R \u0026amp;\u0026amp; Next.z \u0026gt;= 1 \u0026amp;\u0026amp; Next.z \u0026lt;= C \u0026amp;\u0026amp; pMaze[Next.x][Next.y][Next.z] == 0 \u0026amp;\u0026amp; !pVisited[Next.x][Next.y][Next.z]) { pVisited[Next.x][Next.y][Next.z] = true; Q.push(Next); } } } if(!bFlag) { cout \u0026lt;\u0026lt; \u0026#34;Trapped!\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } POJ 3278 同样是 bfs，一共三种状态进行转移。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 1024000; struct Pos { Pos(int _x = 0, int _ans = 0) { x = _x; ans = _ans; } int x, ans; }; queue\u0026lt;Pos\u0026gt; Q; bool pVisited[MAX]; int main() { int N, K; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K) { memset(pVisited, false, sizeof(pVisited)); while(!Q.empty()) { Q.pop(); } Q.push(Pos(N, 0)); pVisited[N] = true; while(!Q.empty()) { Pos Now = Q.front(); Q.pop(); if(Now.x == K) { cout \u0026lt;\u0026lt; Now.ans \u0026lt;\u0026lt; endl; break; } if(Now.x * 2 \u0026gt;= 0 \u0026amp;\u0026amp; Now.x * 2 \u0026lt; MAX \u0026amp;\u0026amp; !pVisited[Now.x * 2]) { Q.push(Pos(Now.x * 2, Now.ans + 1)); pVisited[Now.x * 2] = true; } if(Now.x - 1 \u0026gt;= 0 \u0026amp;\u0026amp; Now.x - 1 \u0026lt; MAX \u0026amp;\u0026amp; !pVisited[Now.x - 1]) { Q.push(Pos(Now.x - 1, Now.ans + 1)); pVisited[Now.x - 1] = true; } if(Now.x + 1 \u0026gt;= 0 \u0026amp;\u0026amp; Now.x + 1 \u0026lt; MAX \u0026amp;\u0026amp; !pVisited[Now.x + 1]) { Q.push(Pos(Now.x + 1, Now.ans + 1)); pVisited[Now.x + 1] = true; } } } return 0; } POJ 3279 考虑到第一行的状态确定以后，后面的 $N - 1$ 行的状态就确定了，因此只需要枚举第一行，由于数据范围比较小，所以使用二进制状态压缩即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 32; const int dx[] = { 1, -1, 0, 0 }; const int dy[] = { 0, 0, 1, -1 }; int M, N; int pMap[MAX][MAX]; int pAns[MAX][MAX], pTmp[MAX][MAX]; int Solve(); int IsFlip(int x, int y); int main() { while(cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N) { int ans = 2147483647; for(int i = 1; i \u0026lt;= M; i++) { for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; pMap[i][j]; } } for(int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; N); i++) { memset(pTmp, 0, sizeof(pTmp)); for(int j = 1; j \u0026lt;= N; j++) { if(i \u0026amp; (1 \u0026lt;\u0026lt; j - 1)) { pTmp[1][j] = 1; } } int nTmp = Solve(); if(nTmp == -1) { continue; } if(nTmp \u0026lt; ans) { ans = nTmp; memcpy(pAns, pTmp, sizeof(pTmp)); } } if(ans != 2147483647) { for(int i = 1; i \u0026lt;= M; i++) { for(int j = 1; j \u0026lt;= N; j++) { cout \u0026lt;\u0026lt; pAns[i][j]; if(j != N) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; } } else { cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } int Solve() { int nRet = 0; for(int i = 2; i \u0026lt;= M; i++) { for(int j = 1; j \u0026lt;= N; j++) { if(IsFlip(i - 1, j)) { pTmp[i][j] = 1; } } } for(int i = 1; i \u0026lt;= N; i++) { if(IsFlip(M, i)) { return -1; } } for(int i = 1; i \u0026lt;= M; i++) { for(int j = 1; j \u0026lt;= N; j++) { nRet += pTmp[i][j]; } } return nRet; } int IsFlip(int x, int y) { int nRet = pTmp[x][y]; for(int i = 0; i \u0026lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx \u0026gt;= 1 \u0026amp;\u0026amp; nx \u0026lt;= M \u0026amp;\u0026amp; ny \u0026gt;= 1 \u0026amp;\u0026amp; ny \u0026lt;= N) { nRet += pTmp[nx][ny]; } } nRet += pMap[x][y]; return nRet \u0026amp; 1; } POJ 1426 这道题目也是一道 bfs，只需要记录每次遍历到的结果 tmp % N，同时保存已选取的数字的内容，最后判断已选取的数字的长度是否符合题目的要求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 256; const int d[] = { 0, 1 }; struct Num { Num(int _nNum = 1, string _ans = \u0026#34;1\u0026#34;) { nNum = _nNum; ans = _ans; } int nNum; string ans; }; int N; bool pVisited[MAX]; queue\u0026lt;Num\u0026gt; Q; int main() { while(cin \u0026gt;\u0026gt; N) { if(N == 0) { break; } else { while(!Q.empty()) { Q.pop(); } memset(pVisited, false, sizeof(pVisited)); Q.push(Num(1)); pVisited[1 % N] = true; while(!Q.empty()) { Num Now = Q.front(); Q.pop(); if(Now.nNum % N == 0) { cout \u0026lt;\u0026lt; Now.ans \u0026lt;\u0026lt; endl; break; } for(int i = 0; i \u0026lt; 2; i++) { Num Next = Now; if(!pVisited[(Now.nNum * 10 + d[i]) % N]) { pVisited[(Now.nNum * 10 + d[i]) % N] = true; Q.push(Num((Now.nNum * 10 + d[i]) % N, Now.ans + (char)(d[i] + \u0026#39;0\u0026#39;))); } } } } } return 0; } POJ 3126 bfs 水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int MAX = 10240; struct Prime { Prime(int _x = 0, int _ans = 0) { x = _x; ans = _ans; } int x, ans; }; set\u0026lt;int\u0026gt; S; queue\u0026lt;Prime\u0026gt; Q; bool pVisited[MAX]; int Change(int x, int y, int z); int main() { for(int i = 1000; i \u0026lt;= 9999; i++) { bool bFlag = true; for(int j = 2; j * j \u0026lt;= i; j++) { if(i % j == 0) { bFlag = false; } } if(bFlag) { S.insert(i); } } int N, s, e; while(cin \u0026gt;\u0026gt; N) { for(int i = 1; i \u0026lt;= N; i++) { while(!Q.empty()) { Q.pop(); } memset(pVisited, false, sizeof(pVisited)); cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; Q.push(Prime(s, 0)); pVisited[s] = true; while(!Q.empty()) { Prime Now = Q.front(); Q.pop(); if(Now.x == e) { cout \u0026lt;\u0026lt; Now.ans \u0026lt;\u0026lt; endl; break; } for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt;= 9; j++) { int nNext = Change(Now.x, i, j); if(S.count(nNext) \u0026amp;\u0026amp; !pVisited[nNext]) { Q.push(Prime(nNext, Now.ans + 1)); pVisited[nNext] = true; } } } } } } return 0; } int Change(int x, int y, int z) { int nTmp = 1; while(y--) { nTmp *= 10; } x -= x / nTmp % 10 * nTmp; x += z * nTmp; return x; } POJ 3087 模拟整个过程即可，如果出现与初始情况相同的情形，就说明无解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N, C; bool bFlag; string SA, SB, S, Init; cin \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; C \u0026gt;\u0026gt; SA \u0026gt;\u0026gt; SB \u0026gt;\u0026gt; S; int nCnt = 0; Init = \u0026#34;\u0026#34;; bFlag = false; while(1) { nCnt++; string ans = \u0026#34;\u0026#34;; for(int j = 0; j \u0026lt; SA.size(); j++) { ans += SB[j]; ans += SA[j]; } if(Init == \u0026#34;\u0026#34;) { Init = ans; } SA = ans.substr(0, C); SB = ans.substr(C, C); if(nCnt != 1 \u0026amp;\u0026amp; ans == Init) { break; } if(ans == S) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; bFlag = true; break; } } if(!bFlag) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; -1\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } POJ 3414 bfs 水题。处理好倒水的过程即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 128; struct Pots { Pots(int _A = 0, int _B = 0) { A = _A; B = _B; while(!pOpt.empty()) { pOpt.pop(); } } int A, B; queue\u0026lt;string\u0026gt; pOpt; }; int A, B, C; bool pVisited[MAX][MAX]; queue\u0026lt;Pots\u0026gt; Q; Pots Opt(Pots Now, int k); Pots Fill(Pots Now, int x); Pots Drop(Pots Now, int x); Pots Pour(Pots Now, int x); int main() { bool bFlag; while(cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B \u0026gt;\u0026gt; C) { bFlag = false; while(!Q.empty()) { Q.empty(); } memset(pVisited, false, sizeof(pVisited)); Q.push(Pots(0, 0)); pVisited[0][0] = true; while(!Q.empty()) { Pots Now = Q.front(); Q.pop(); if(Now.A == C || Now.B == C) { cout \u0026lt;\u0026lt; Now.pOpt.size() \u0026lt;\u0026lt; endl; while(!Now.pOpt.empty()) { cout \u0026lt;\u0026lt; Now.pOpt.front() \u0026lt;\u0026lt; endl; Now.pOpt.pop(); } bFlag = true; break; } for(int i = 0; i \u0026lt; 6; i++) { Pots Next = Opt(Now, i); if(!pVisited[Next.A][Next.B]) { Q.push(Next); pVisited[Next.A][Next.B] = true; } } } if(!bFlag) { cout \u0026lt;\u0026lt; \u0026#34;impossible\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } Pots Opt(Pots Now, int k) { switch(k) { case 0: return Fill(Now, 0); case 1: return Fill(Now, 1); case 2: return Drop(Now, 0); case 3: return Drop(Now, 1); case 4: return Pour(Now, 0); case 5: return Pour(Now, 1); } } Pots Fill(Pots Now, int x) { if(x == 0) { Now.A = A; Now.pOpt.push(\u0026#34;FILL(1)\u0026#34;); } else { Now.B = B; Now.pOpt.push(\u0026#34;FILL(2)\u0026#34;); } return Now; } Pots Drop(Pots Now, int x) { if(x == 0) { Now.A = 0; Now.pOpt.push(\u0026#34;DROP(1)\u0026#34;); } else { Now.B = 0; Now.pOpt.push(\u0026#34;DROP(2)\u0026#34;); } return Now; } Pots Pour(Pots Now, int x) { if(x == 0) { Now.B += Now.A; if(Now.B \u0026gt; B) { Now.A = Now.B - B; Now.B = B; } else { Now.A = 0; } Now.pOpt.push(\u0026#34;POUR(1,2)\u0026#34;); } else { Now.A += Now.B; if(Now.A \u0026gt; A) { Now.B = Now.A - A; Now.A = A; } else { Now.B = 0; } Now.pOpt.push(\u0026#34;POUR(2,1)\u0026#34;); } return Now; } FZU 2150 暴力枚举两个起点，然后 bfs。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 16; const int dx[] = { 1, -1, 0, 0 }; const int dy[] = { 0, 0, 1, -1 }; struct Pos { Pos(int _x, int _y, int _ans) { x = _x; y = _y; ans = _ans; } int x, y, ans; }; int T, N, M; int pMap[MAX][MAX]; bool pVisited[MAX][MAX]; queue\u0026lt;Pos\u0026gt; Q; bool Check(); int Bfs(Pos A, Pos B); int main() { string strTmp; cin \u0026gt;\u0026gt; T; for(int k = 1; k \u0026lt;= T; k++) { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; int ans = 2147483647; bool bFlag = false; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; strTmp; for(int j = 1; j \u0026lt;= M; j++) { if(strTmp[j - 1] == \u0026#39;.\u0026#39;) { pMap[i][j] = 1; } else { pMap[i][j] = 0; } } } for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= M; j++) { for(int p = 1; p \u0026lt;= N; p++) { for(int q = 1; q \u0026lt;= M; q++) { if(pMap[i][j] || pMap[p][q]) { continue; } int nTmp = Bfs(Pos(i, j, 0), Pos(p, q, 0)); if(Check()) { ans = min(ans, nTmp); bFlag = true; } } } } } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; if(bFlag) { cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } } return 0; } int Bfs(Pos A, Pos B) { int nRet = 0; while(!Q.empty()) { Q.pop(); } memset(pVisited, false, sizeof(pVisited)); Q.push(A); pVisited[A.x][A.y] = true; Q.push(B); pVisited[B.x][B.y] = true; while(!Q.empty()) { Pos Now = Q.front(); Q.pop(); nRet = max(nRet, Now.ans); for(int i = 0; i \u0026lt; 4; i++) { Pos Next = Now; Next.ans++; Next.x += dx[i]; Next.y += dy[i]; if(Next.x \u0026gt;= 1 \u0026amp;\u0026amp; Next.x \u0026lt;= N \u0026amp;\u0026amp; Next.y \u0026gt;= 1 \u0026amp;\u0026amp; Next.y \u0026lt;= M \u0026amp;\u0026amp; !pVisited[Next.x][Next.y] \u0026amp;\u0026amp; !pMap[Next.x][Next.y]) { Q.push(Next); pVisited[Next.x][Next.y] = true; } } } return nRet; } bool Check() { for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= M; j++) { if(!pMap[i][j] \u0026amp;\u0026amp; !pVisited[i][j]) { return false; } } } return true; } UVa 11624 注意可能有多个点起火，设定一个全局时间量，用来控制人以及火的运动顺序，先处理火，再处理人。然后就是 bfs 水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 1024; const int dx[] = { 1, -1, 0, 0 }; const int dy[] = { 0, 0, 1, -1 }; struct Pos { Pos(int _x = 0, int _y = 0, int _ans = 0) { x = _x; y = _y; ans = _ans; } int x, y, ans; }; int T, R, C; int pMap[MAX][MAX]; bool pVJ[MAX][MAX], pVF[MAX][MAX]; queue\u0026lt;Pos\u0026gt; J, F; int main() { string strTmp; cin \u0026gt;\u0026gt; T; for(int k = 1; k \u0026lt;= T; k++) { cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; bool bFlag = false; while(!J.empty()) { J.pop(); } while(!F.empty()) { F.pop(); } memset(pVJ, false, sizeof(pVJ)); memset(pVF, false, sizeof(pVF)); for(int i = 1; i \u0026lt;= R; i++) { cin \u0026gt;\u0026gt; strTmp; for(int j = 1; j \u0026lt;= C; j++) { if(strTmp[j - 1] == \u0026#39;#\u0026#39;) { pMap[i][j] = 1; } else { pMap[i][j] = 0; } if(strTmp[j - 1] == \u0026#39;J\u0026#39;) { J.push(Pos(i, j)); pVJ[i][j] = true; } if(strTmp[j - 1] == \u0026#39;F\u0026#39;) { F.push(Pos(i, j)); pVF[i][j] = true; } } } int nTime = 0; while(!J.empty()) { while(!F.empty() \u0026amp;\u0026amp; F.front().ans \u0026lt;= nTime) { Pos FN = F.front(); F.pop(); for(int i = 0; i \u0026lt; 4; i++) { Pos Next = FN; Next.ans++; Next.x += dx[i]; Next.y += dy[i]; if(Next.x \u0026gt;= 1 \u0026amp;\u0026amp; Next.x \u0026lt;= R \u0026amp;\u0026amp; Next.y \u0026gt;= 1 \u0026amp;\u0026amp; Next.y \u0026lt;= C \u0026amp;\u0026amp; !pMap[Next.x][Next.y] \u0026amp;\u0026amp; !pVF[Next.x][Next.y]) { F.push(Next); pVF[Next.x][Next.y] = true; } } } while(!J.empty() \u0026amp;\u0026amp; J.front().ans \u0026lt;= nTime) { Pos JN = J.front(); J.pop(); if(JN.x == 1 || JN.x == R || JN.y == 1 || JN.y == C) { cout \u0026lt;\u0026lt; JN.ans + 1 \u0026lt;\u0026lt; endl; bFlag = true; break; } for(int i = 0; i \u0026lt; 4; i++) { Pos Next = JN; Next.ans++; Next.x += dx[i]; Next.y += dy[i]; if(Next.x \u0026gt;= 1 \u0026amp;\u0026amp; Next.x \u0026lt;= R \u0026amp;\u0026amp; Next.y \u0026gt;= 1 \u0026amp;\u0026amp; Next.y \u0026lt;= C \u0026amp;\u0026amp; !pMap[Next.x][Next.y] \u0026amp;\u0026amp; !pVF[Next.x][Next.y] \u0026amp;\u0026amp; !pVJ[Next.x][Next.y]) { J.push(Next); pVJ[Next.x][Next.y] = true; } } } if(bFlag) { break; } nTime++; } if(!bFlag) { cout \u0026lt;\u0026lt; \u0026#34;IMPOSSIBLE\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } POJ 3984 bfs 水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 8; const int dx[] = { 1, -1, 0, 0 }; const int dy[] = { 0, 0, 1, -1 }; struct Pos { Pos(int _x = 0, int _y = 0) { x = _x; y = _y; } int x, y; }; struct State { State(int _x = 0, int _y = 0) { Now = Pos(_x, _y); while(!Ans.empty()) { Ans.pop(); } } Pos Now; queue\u0026lt;Pos\u0026gt; Ans; }; int pMap[MAX][MAX]; bool pVisited[MAX][MAX]; queue\u0026lt;State\u0026gt; Q; int main() { for(int i = 1; i \u0026lt;= 5; i++) { for(int j = 1; j \u0026lt;= 5; j++) { cin \u0026gt;\u0026gt; pMap[i][j]; } } while(!Q.empty()) { Q.pop(); } memset(pVisited, false, sizeof(pVisited)); Q.push(State(1, 1)); pVisited[1][1] = true; while(!Q.empty()) { State Now = Q.front(); Q.pop(); if(Now.Now.x == 5 \u0026amp;\u0026amp; Now.Now.y == 5) { while(!Now.Ans.empty()) { Pos Cur = Now.Ans.front(); cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; Cur.x - 1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; Cur.y - 1 \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; Now.Ans.pop(); } cout \u0026lt;\u0026lt; \u0026#34;(4, 4)\u0026#34; \u0026lt;\u0026lt; endl; break; } for(int i = 0; i \u0026lt; 4; i++) { int nx = Now.Now.x + dx[i]; int ny = Now.Now.y + dy[i]; if(nx \u0026gt;= 1 \u0026amp;\u0026amp; nx \u0026lt;= 5 \u0026amp;\u0026amp; ny \u0026gt;= 1 \u0026amp;\u0026amp; ny \u0026lt;= 5 \u0026amp;\u0026amp; !pVisited[nx][ny] \u0026amp;\u0026amp; !pMap[nx][ny]) { State Next = Now; Next.Now = Pos(nx, ny); Next.Ans.push(Now.Now); Q.push(Next); pVisited[nx][ny] = true; } } } return 0; } HDU 1241 求连通块个数，直接 dfs 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 128; const int dx[] = { -1, 0, 1, -1, 1, -1, 0, 1 }; const int dy[] = { 1, 1, 1, 0, 0, -1, -1, -1 }; int N, M; int pMap[MAX][MAX]; bool pVisited[MAX][MAX]; void dfs(int x, int y); int main() { string strTmp; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M) { if(N == 0 \u0026amp;\u0026amp; M == 0) { break; } for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; strTmp; for(int j = 1; j \u0026lt;= M; j++) { if(strTmp[j - 1] == \u0026#39;*\u0026#39;) { pMap[i][j] = 1; } else { pMap[i][j] = 0; } } } int ans = 0; memset(pVisited, false, sizeof(pVisited)); for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= M; j++) { if(!pMap[i][j] \u0026amp;\u0026amp; !pVisited[i][j]) { dfs(i, j); ans++; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } void dfs(int x, int y) { pVisited[x][y] = true; for(int i = 0; i \u0026lt; 8; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx \u0026gt;= 1 \u0026amp;\u0026amp; nx \u0026lt;= N \u0026amp;\u0026amp; ny \u0026gt;= 1 \u0026amp;\u0026amp; ny \u0026lt;= M \u0026amp;\u0026amp; !pMap[nx][ny] \u0026amp;\u0026amp; !pVisited[nx][ny]) { dfs(nx, ny); } } } HDU 1495 这道题目和 POJ 3414 非常的类似，但相较来说更简单，也是一道 bfs 水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 128; struct Cola { Cola(int _S = 0, int _N = 0, int _M = 0, int _ans = 0) { S = _S; N = _N; M = _M; ans = _ans; } int S, N, M, ans; }; int S, N, M; bool pVisited[MAX][MAX][MAX]; queue\u0026lt;Cola\u0026gt; Q; Cola Opt(Cola Now, int k); bool Check(Cola Now); int main() { while(cin \u0026gt;\u0026gt; S \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M) { if(S == 0 \u0026amp;\u0026amp; N == 0 \u0026amp;\u0026amp; M == 0) { break; } if(S \u0026amp; 1) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } else { bool bFlag = false; memset(pVisited, false, sizeof(pVisited)); while(!Q.empty()) { Q.pop(); } // 队列忘记清空 Q.push(Cola(S, 0, 0, 0)); pVisited[S][0][0] = true; while(!Q.empty()) { Cola Now = Q.front(); Q.pop(); if(Check(Now)) { cout \u0026lt;\u0026lt; Now.ans \u0026lt;\u0026lt; endl; bFlag = true; break; } for(int i = 0; i \u0026lt; 6; i++) { Cola Next = Opt(Now, i); if(!pVisited[Next.S][Next.N][Next.M]) { Q.push(Cola(Next.S, Next.N, Next.M, Next.ans)); pVisited[Next.S][Next.N][Next.M] = true; } } } if(!bFlag) { cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt; endl; } } } return 0; } Cola Opt(Cola Now, int k) { if(k == 0) { Now.N += Now.S; if(Now.N \u0026gt; N) { Now.S = Now.N - N; Now.N = N; } else { Now.S = 0; } } if(k == 1) { Now.S += Now.N; Now.N = 0; } if(k == 2) { Now.M += Now.S; if(Now.M \u0026gt; M) { Now.S = Now.M - M; Now.M = M; } else { Now.S = 0; } } if(k == 3) { Now.S += Now.M; Now.M = 0; } if(k == 4) { Now.N += Now.M; if(Now.N \u0026gt; N) { Now.M = Now.N - N; Now.N = N; } else { Now.M = 0; } } if(k == 5) { Now.M += Now.N; if(Now.M \u0026gt; M) { Now.N = Now.M - M; Now.M = M; } else { Now.N = 0; } } Now.ans++; return Now; } bool Check(Cola Now) { int x = Now.S, y = Now.N, z = Now.M, p = S / 2; return (x == p \u0026amp;\u0026amp; y == p) || (x == p \u0026amp;\u0026amp; z == p) || (y == p \u0026amp;\u0026amp; z == p); } HDU 2612 首先计算 $Y$ 和 $M$ 走到地图上每个点的最小时间，然后枚举每个点，计算 $Y$ 和 $M$ 走到该点时间和的最小值，最后结果乘以 11 分钟即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 256; const int dx[] = { 1, -1, 0, 0 }; const int dy[] = { 0, 0, 1, -1 }; struct Pos { Pos(int _x = 0, int _y = 0, int _s = 0) { x = _x; y = _y; s = _s; } int x, y, s; }; Pos SY, SM; int N, M; int pMap[MAX][MAX]; int pAns[2][MAX][MAX]; bool pVisited[MAX][MAX]; queue\u0026lt;Pos\u0026gt; Q; void Solve(Pos S, int k); int main() { string strTmp; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M) { memset(pAns, -1, sizeof(pAns)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; strTmp; for(int j = 1; j \u0026lt;= M; j++) { if(strTmp[j - 1] == \u0026#39;#\u0026#39;) { pMap[i][j] = 1; } else if(strTmp[j - 1] == \u0026#39;@\u0026#39;) { pMap[i][j] = 2; } else { pMap[i][j] = 0; } if(strTmp[j - 1] == \u0026#39;Y\u0026#39;) { SY = Pos(i, j, 0); } if(strTmp[j - 1] == \u0026#39;M\u0026#39;) { SM = Pos(i, j, 0); } } } Solve(SY, 0); Solve(SM, 1); int ans = 2147483647; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= M; j++) { if(pMap[i][j] == 2 \u0026amp;\u0026amp; pAns[0][i][j] != -1 \u0026amp;\u0026amp; pAns[1][i][j] != -1) { ans = min(ans, pAns[0][i][j] + pAns[1][i][j]); } } } cout \u0026lt;\u0026lt; ans * 11 \u0026lt;\u0026lt; endl; } return 0; } void Solve(Pos S, int k) { while(!Q.empty()) { Q.pop(); } memset(pVisited, false, sizeof(pVisited)); Q.push(S); pVisited[S.x][S.y] = true; while(!Q.empty()) { Pos Now = Q.front(); Q.pop(); if(pAns[k][Now.x][Now.y] == -1) { pAns[k][Now.x][Now.y] = Now.s; } for(int i = 0; i \u0026lt; 4; i++) { int nx = Now.x + dx[i]; int ny = Now.y + dy[i]; if(nx \u0026gt;= 1 \u0026amp;\u0026amp; nx \u0026lt;= N \u0026amp;\u0026amp; ny \u0026gt;= 1 \u0026amp;\u0026amp; ny \u0026lt;= M \u0026amp;\u0026amp; !pVisited[nx][ny] \u0026amp;\u0026amp; pMap[nx][ny] != 1) { Q.push(Pos(nx, ny, Now.s + 1)); pVisited[nx][ny] = true; } } } } 刷完这个专题，感觉对 bfs 的理解更加深入透彻了。\n","date":"2015-06-08T21:57:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%B8%93%E9%A2%98%E4%B8%80%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2-virtual-judge/","title":"专题一、简单搜索 - Virtual Judge"},{"content":"到今天为止，距离 2015 ACM 国际大学生程序设计竞赛上海大都会赛结束已经快有一个星期了，趁着记忆中暂存的些许余温，将其记录下来。\n我们从上周四开始，放下手中正在做的题目，转而准备比赛所需要的材料。由于比赛是可以携带纸质材料进场，因此我们准备了一些较为常用的算法模板，并且幻想着可能会遇到类似的题目。然而事实证明，携带的这些模板并没有什么作用，当然，这是后话。\n周五晚上，我们开始整理行装。由于第二天早上需要六点半之前集合，所以便早早的入睡了。早上起来稍微打点一下，已是六点。草草地吃了一块面包，关上宿舍门便出发了。走到外面才发现宿舍大门紧闭着，原来此时舍管阿姨依然沉睡在梦乡。走近时才发现，宿舍大门是虚掩的。来到实验室已有两三个人在等候，陆陆续续地都到齐了。\n就这样，我们六名队员踏上了前往上海的征途。一路上地铁-动车-地铁-步行，费尽周折终于找到了指导老师早在一个月前为我们预定的酒店。放下行李，躺在床上休息了一会儿，便前往华东理工大学（徐汇校区）报道。无奈一开始不认识道路，以至于耽搁了很久。\n报道结束后，领了材料赶去吃中饭，饭菜只能说一般般而已。接下来的开幕式只用了短短的十分钟便结束了，然后便是热身赛（主要用来熟悉比赛场地以及比赛的系统环境）。比赛场地在体育馆内，一共将近两百台电脑，一个队伍（3 名队员）一台电脑（Linux 系统）。裁判拿着话筒选读比赛须知，志愿者则站在门口迎接我们。\n在热身赛中，一共有三道题。第一题是高精度乘法（C/C++ 语言内置的变量类型保存的数据是有一定范围限制的，如果要操作成百上千位的一个整数，就需要使用数组来模拟整数的每一位，并且结合竖式的方法，模拟加减乘除运算，称之为高精度算法），我们在短短几分钟内就 AC（Accepted，即作答正确）了。然后在接下来的一个半小时内看着其它队伍的牌子上插满了气球（做出一道题目就会有一个对应的气球），而我们却一直做不出来。第二题直觉是二分图匹配，却不会建立图论模型。第三题已经忘记了。和学长他们一样，我们两个队伍都只做出了第一题。\n热身赛结束后便去吃晚饭，一开始有一个 World Final 的选手邀请大家去吃晚饭，当我们走到校门口的时候突然感觉无颜参加这样的集会，就直接回到了宾馆。到这时候才意识到忘记在学校里顺便吃一顿晚饭，于是乎就近找了一家饭店。等到饭上来的时候才发现饭碗小的可怜，而我一连叫了三碗饭，被服务员惊诧的看了几眼。回到宾馆后，做了一场“百度之星”，准备休息的时候，我的队友过来串门，拿了一包薯片，然后发现我的门口被塞了两张卡片，写满了广告。\n第二天一大早便起床集合，指导老师徐教授也早早的到了，来到楼下的自助早餐厅，吃了一顿不错的早餐，回到房间再稍做休息便启程出发。来到比赛场馆，坐到昨天的位置上。桌面上放着一个信封，装着三份试题。等到 10 点整的时候，裁判宣布比赛开始，我们打开信封，抽出一张写有登录密码的纸条以及三份试题，开始了紧张的比赛。\n第一道做的题目是运用贪心算法的区间覆盖问题，就如热身赛中一样，短短几分钟内就 AC 了。接下来，我又发现了一道表达式求值的题目，发现和前几天做的 Basic 解释器差不多，因此没有多想就开始写代码，提交代码后返回的结果是 TLE（Time Limited Excceded，运行时间超时，题目要求在规定的时间内给出正确的答案）。在队友的提示下，发现这道题目并没有那么简单，因此就将它放到一边。（事实证明，这次的决策是正确的，使得我们在这道题目上浪费过多的事件，一直到比赛结束，只有一个队伍作出了这道题目。）我们 AC 的第二道题目是队友思索了半个小时想来的，一个简洁的公式，再配上一个高精度乘法即可。第三道 AC 的题目是由我和另外一个队友合作完成了，实现一个 Base64 的加密方法（我们使用的是 C++ 语言，而 Java 语言这一加密直接可以调用内部函数，奈何我们都不会）。第四道 AC 的题目我们整整思索了一个半小时，是一道有趣的数学期望问题，可以将它描述出来：\n给定一个 $N\\times M$ 的方格，每次可以选择这 $N\\times M$ 个方格中的任意两个（可以重合），将以这两个方格为左上、右下的矩形方格全部填充上颜色。一共进行 $K$ 次操作，求最后被填充上颜色的方格个数的数学期望。\n在此不给出具体解法，读者可以自行思考。至此，我们一共做出了 4 道题目，排名第 34 名，一度以为有银牌了，最后事实证明与银牌擦肩而过。在剩下了的两个半小时内，我们一直在思考另外一道概率题，以及一道数据结构的题目。期间志愿者过来发午餐——85°C 的面包和奶茶，然而却根本没有心思去吃，嚼了几块巧克力便继续思考。\n比赛结束以后，举行了一个讲座，主要是给赞助商做一些公司的宣传，希望应届选手前往应聘。颁奖典礼上，得知是铜牌第一的时候，只是感觉自己太弱了。在这期间，终于意识到了自己还没吃午饭，于是吃完了所有的面包。恰巧这是颁奖典礼结束，徐老师说带着我们去吃晚饭，而我刚刚才吃完一袋面包，徐老师说，你怎么吃这么一点点。接下来，地铁-动车-地铁，又踏上了铜牌滚出的路程。\n总的来说，第一次参赛给了我很多的经验，这与高中是参与的 NOIP 竞赛不同，更讲究团队合作，以及思维的巧妙，而非看完题目按照常规方法就能够按部就班的解答的。要说这次比赛还能有什么别的意义的话，我想就是圆了我一个从高中就有的参加 ACM 的梦，希望在接下来的 Reginal 中能够赛出更好的成绩吧。\n","date":"2015-05-30T09:46:00+08:00","permalink":"https://ivy-end.github.io/p/%E8%AE%B0-2015-acm-icpc-%E4%B8%8A%E6%B5%B7%E5%A4%A7%E9%83%BD%E4%BC%9A%E8%B5%9B/","title":"记 2015 ACM-ICPC 上海大都会赛"},{"content":"这一节，我们将介绍游戏界面的美化以及游戏数据的存储。\n首先创建一个 color.xml 资源文件，用来保存每个数字对应的背景色和前景色。右击 res 文件夹，选择 New，单击 Android resource file，输入 color，单击 Next 即可。\n新建资源\n修改代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;color name=\u0026#34;bg2\u0026#34;\u0026gt;#eee4da\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text2\u0026#34;\u0026gt;#776e65\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg4\u0026#34;\u0026gt;#ede0c8\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text4\u0026#34;\u0026gt;#776e65\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg8\u0026#34;\u0026gt;#f2b179\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text8\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg16\u0026#34;\u0026gt;#f59563\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text16\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg32\u0026#34;\u0026gt;#f67c5f\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text32\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg64\u0026#34;\u0026gt;#f65e3b\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text64\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg128\u0026#34;\u0026gt;#edcf72\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text128\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg256\u0026#34;\u0026gt;#edcc61\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text256\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg512\u0026#34;\u0026gt;#edc850\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text512\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg1024\u0026#34;\u0026gt;#edc53f\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text1024\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bg2048\u0026#34;\u0026gt;#edc22e\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;text2048\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;bgsuper\u0026#34;\u0026gt;#3c3a32\u0026lt;/color\u0026gt; \u0026lt;color name=\u0026#34;textsuper\u0026#34;\u0026gt;#f9f6f2\u0026lt;/color\u0026gt; \u0026lt;/resources\u0026gt; 其中 bg 表示背景色，text 表示前景色，切换到 Card 界面，在 setNumber 中添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 switch(number) { case 0: tvNumber.setBackgroundColor(0x33FFFFFF); break; case 2: tvNumber.setTextColor(getResources().getColor(R.color.text2)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg2)); break; case 4: tvNumber.setTextColor(getResources().getColor(R.color.text4)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg4)); break; case 8: tvNumber.setTextColor(getResources().getColor(R.color.text8)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg8)); break; case 16: tvNumber.setTextColor(getResources().getColor(R.color.text16)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg16)); break; case 32: tvNumber.setTextColor(getResources().getColor(R.color.text32)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg32)); break; case 64: tvNumber.setTextColor(getResources().getColor(R.color.text64)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg64)); break; case 128: tvNumber.setTextColor(getResources().getColor(R.color.text128)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg128)); break; case 256: tvNumber.setTextColor(getResources().getColor(R.color.text256)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg256)); break; case 512: tvNumber.setTextColor(getResources().getColor(R.color.text512)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg512)); break; case 1024: tvNumber.setTextColor(getResources().getColor(R.color.text1024)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg1024)); break; case 2048: tvNumber.setTextColor(getResources().getColor(R.color.text2048)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bg2048)); break; default: tvNumber.setTextColor(getResources().getColor(R.color.textsuper)); tvNumber.setBackgroundColor(getResources().getColor(R.color.bgsuper)); break; } 运行结果如下：\n阶段性效果\n游戏局面基本已经完成。接下来，我们来处理一下主界面的布局，切换到activity_main.xml的代码模式，修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:paddingTop=\u0026#34;8dp\u0026#34; android:paddingBottom=\u0026#34;8dp\u0026#34; android:layout_gravity=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;fill_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_marginLeft=\u0026#34;16dp\u0026#34; android:layout_marginRight=\u0026#34;8dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;fill_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/appname\u0026#34; android:textSize=\u0026#34;84sp\u0026#34; android:textColor=\u0026#34;#BBADA0\u0026#34; android:paddingTop=\u0026#34;8dp\u0026#34; android:paddingBottom=\u0026#34;8dp\u0026#34; android:paddingLeft=\u0026#34;16dp\u0026#34; android:paddingRight=\u0026#34;16dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;fill_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_marginLeft=\u0026#34;16dp\u0026#34; android:layout_marginRight=\u0026#34;8dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;fill_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/score\u0026#34; android:textSize=\u0026#34;42sp\u0026#34; android:textColor=\u0026#34;#BBADA0\u0026#34; android:paddingTop=\u0026#34;8dp\u0026#34; android:paddingBottom=\u0026#34;8dp\u0026#34; android:paddingLeft=\u0026#34;16dp\u0026#34; android:paddingRight=\u0026#34;16dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tvScore\u0026#34; android:layout_width=\u0026#34;fill_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;42sp\u0026#34; android:textColor=\u0026#34;#BBADA0\u0026#34; android:paddingTop=\u0026#34;8dp\u0026#34; android:paddingBottom=\u0026#34;8dp\u0026#34; android:paddingLeft=\u0026#34;16dp\u0026#34; android:paddingRight=\u0026#34;16dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;GridLayout android:id=\u0026#34;@+id/gameView\u0026#34; android:layout_width=\u0026#34;fill_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;GridLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 运行结果如下图所示：\n阶段性效果\n下面，我们需要为 Best 标签添加一些操作，切换到 MainActivity 类，定义一个变量：\n1 2 3 4 private void score = 0; private TextView tvScore; private TextView tvBest; private static MainActivity mainActivity = null; 为它添加初始化命令：\n1 2 3 4 5 6 7 8 9 10 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvScore = (TextView)findViewById(R.id.tvScore); tvBest = (TextView)findViewById(R.id.tvBest); mainActivity = this; } 添加一个方法方便外部访问这个标签，同时定义一个 bestScore 变量用来保存最高分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public void showScore() { tvScore.setText(score + \u0026#34;\u0026#34;); tvBest.setText(bestScore + \u0026#34;\u0026#34;); } public void addScore(int s) { score += s; showScore(); } public int getScore() { return score; } public void setBestScore(int s) { bestScore = s; showScore(); } private int score = 0; private int bestScore = 0; private TextView tvScore; private TextView tvBest; private static MainActivity mainActivity = null; 切换到 GameView 中添加如下方法：\n1 2 3 4 5 6 7 8 9 10 11 12 private void updateBest() { int bestScore, score; SharedPreferences sp = getContext().getSharedPreferences(\u0026#34;game2048\u0026#34;, Context.MODE_PRIVATE); SharedPreferences.Editoer editor = sp.edit(); score = MainActivity.getMainActivity().getScore(); bestScore = sp.getInt(\u0026#34;best\u0026#34;, 0); if (bestScore \u0026lt; score) { editor.putInt(\u0026#34;best\u0026#34;, score); MainActivity.getMainActivity().setBestScore(score); editor.commit(); } } 在每一次加分后都调用该函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void MoveLeft() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int y = j + 1; y \u0026lt; 4; y++) { // 从当前位置往右扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，左移 cardMap[i][y].setNumber(0); // 清空 y = j + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 左移，合并 cardMap[i][y].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 updateBest(); // 更新最高分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void MoveRight() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 3; j \u0026gt;= 0; j--) { // 列循环 for(int y = j - 1; y \u0026gt;= 0; y--) { // 从当前位置往左扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，右移 cardMap[i][y].setNumber(0); // 清空 y = j - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 右移，合并 cardMap[i][y].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 updateBest(); // 更新最高分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void MoveUp() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int x = i + 1; x \u0026lt; 4; x++) { // 从当前位置往下扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，上移 cardMap[x][j].setNumber(0); // 清空 x = i + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 上移，合并 cardMap[x][j].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 updateBest(); // 更新最高分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void MoveDown() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 3; i \u0026gt;= 0; i--) { // 行循环 for(int x = i - 1; x \u0026gt;= 0; x--) { // 从当前位置往上扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，下移 cardMap[x][j].setNumber(0); // 清空 x = i - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 下移，合并 cardMap[x][j].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 updateBest(); // 更新最高分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 最后，我们需要对最高分标签进行初始化，切换到 MainActivity 类，修改代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvScore = (TextView)findViewById(R.id.tvScore); tvBest = (TextView)findViewById(R.id.tvBest); SharedPreferences sp = getSharedPreferences(\u0026#34;game2048\u0026#34;, Contex.MODE_PRIVATE); bestScore = sp.getInt(\u0026#34;best\u0026#34;, 0); tvBest.setText(bestScore + \u0026#34;\u0026#34;); mainActivity = this; } 运行结果如下：\n运行效果\n游戏至此已经完工。当然，我们可以为它添加更多的动画特效，留给读者自行操作。\n","date":"2015-05-17T11:07:00+08:00","permalink":"https://ivy-end.github.io/p/2048-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bjava-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%94%E8%8A%82%E7%95%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/","title":"2048 游戏制作过程（Java 描述）：第五节、界面美化"},{"content":"上一节中，我们已经成功的将卡牌添加到了游戏中，但只是显示在了界面上，并没有保存下来。我们在 GameView 中定义一个二维数组用来保存游戏界面的卡牌。\n1 private Card[][] cardMap = new Card[4][4]; // 记录游戏 接下来，我们需要将初始化时候添加的卡片添加到 cardMap 数组中，如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 private void addCards(int cardSize) { Card card; for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { card = new Card(getContext()); card.setNumber(2); addView(card, cardSzie, cardSize); cardMap[i][j] = card; // 添加卡片 } } } 这样一来，我们就将游戏界面记录下来了。\n但是上一节中，我们一下子就生成了 16 张卡片，这和平时游戏的时候不一致。而且我们只能生成卡片 2。为了改进它，我们可以定义一个函数 addRandomNumber，表示每次生成的数字（这里我们设置生成 2 和 4 的概率为 9:1）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private void addRandomNumber() { emptyPoints.clear(); for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { if(cardMap[i][j].getNumber() \u0026lt;= 0) { // 用 0 表示空点 emptyPoints.add(new Point(i, j)); } } } Point point = emptyPoints.remove((int)(Math.random() * emptyPoints.size())); // 随机获取空点 cardMap[point.x][point.y].setNumber(Math.random() \u0026gt; 0.1 ? 2 : 4); // 按 9:1 的概率生成 2 和 4 } 这里用到了一个 emptyPoints 变量，我们需要定义如下：\n1 2 private Card[][] cardMap = new Card[4][4]; // 记录游戏 private ListL\u0026lt;Point\u0026gt; emptyPoints = new ArrayList\u0026lt;\u0026gt;(); // 空点列表 除此之外，我们还看到在上面的程序中，我们使用 0 表示空点，但是我们并不希望 0 显示在我们的游戏中，因此修改 Card 类的 SetNumber 函数如下：\n1 2 3 4 5 6 7 8 9 public void setNumber(int number) { this.number = number; // 设置数字 if(number \u0026gt; 0) { tvNumber.setText(number + \u0026#34;\u0026#34;); // 设置 tvNumber 文本 } else { tvNumber.setText(\u0026#34;\u0026#34;); // 空文本，不显示数字 0 } } 同时，我们需要修改 GameView 中的 addCards 函数，使得一开始都生成空点：\n1 2 3 4 5 6 7 8 9 10 11 private void addCards(int cardSize) { Card card; for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { card = new Card(getContext()); card.setNumber(0); // 生成空点 addView(card, cardSzie, cardSize); cardMap[i][j] = card; // 添加卡片 } } } 接下来，我们可以开始游戏了，首先定义一个 startGame 函数，同时在 onSizeChanged 事件中调用它，如下图所示：\n1 2 3 4 5 6 7 8 9 @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChange(w, h, oldw, oldh); int cardSize = (Math.min(w, h) -10) / 4; // 计算卡牌尺寸 addCards(cardSize); startGame(); // 开始游戏 } 同时，定义 startGame 函数如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 private void startGame() { for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { cardMap[i][j].setNumber(0); // 清空游戏界面 } } // 初始化两张卡片 addRandomNumber(); addRandomNumber(); } 运行查看结果，如下图所示：\n阶段性效果\n接下来，我们需要实现游戏的逻辑，也就是方块的合并。我们需要操作 MoveLeft 等四个函数。如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private void MoveLeft() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int y = j + 1; y \u0026lt; 4; y++) { // 从当前位置往右扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，左移 cardMap[i][y].setNumber(0); // 清空 y = j + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 左移，合并 cardMap[i][y].setNumber(0); // 清空 } } } } } 接下来的三个方向的移动只需要对上面的代码进行稍微修改即可，MoveRight 如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private void MoveRight() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 3; j \u0026gt;= 0; j--) { // 列循环 for(int y = j - 1; y \u0026gt;= 0; y--) { // 从当前位置往左扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，右移 cardMap[i][y].setNumber(0); // 清空 y = j - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 右移，合并 cardMap[i][y].setNumber(0); // 清空 } } } } } MoveUp 函数如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private void MoveUp() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int x = i + 1; x \u0026lt; 4; x++) { // 从当前位置往下扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，上移 cardMap[x][j].setNumber(0); // 清空 x = i + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 上移，合并 cardMap[x][j].setNumber(0); // 清空 } } } } } MoveDown 函数如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private void MoveDown() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 3; i \u0026gt;= 0; i--) { // 行循环 for(int x = i - 1; x \u0026gt;= 0; x--) { // 从当前位置往上扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，下移 cardMap[x][j].setNumber(0); // 清空 x = i - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 下移，合并 cardMap[x][j].setNumber(0); // 清空 } } } } } 至此，我们的移动功能已基本完成，测试如下：\n阶段性效果\n最后，我们来完成积分的模块，每次操作得分都等于合并方块的数字之和。切换到 MainActivy 类，添加以下代码以获取 tvScore 这个标签：\n1 2 3 4 5 6 7 8 9 10 11 12 public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvScore = (TextView)findViewById(R.id.tvScore); } private TextView tvScore; } 接下去，为了能够在外界操作 MainActivy 中的 tvScore，我们修改代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvScore = (TextView)findViewById(R.id.tvScore); mainActivity = this; } public static MainActivity getMainActivity() { return mainActivity; } private TextView tvScore; private static MainActivity mainActivity = null; } 最后添加计分变量以及相关的操作函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void clearScore() { score = 0; showScore(); } public void showScore() { tvScore.setText(score + \u0026#34;\u0026#34;); } public void addScore(int s) { score += s; showScore(); } private int score = 0; private TextView tvScore; private static MainActivity mainActivity = null; 接下去，切换到 GameView 中，将下面的代码添加到四个移动操作的相应位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void MoveLeft() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int y = j + 1; y \u0026lt; 4; y++) { // 从当前位置往右扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，左移 cardMap[i][y].setNumber(0); // 清空 y = j + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 左移，合并 cardMap[i][y].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void MoveRight() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 3; j \u0026gt;= 0; j--) { // 列循环 for(int y = j - 1; y \u0026gt;= 0; y--) { // 从当前位置往左扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，右移 cardMap[i][y].setNumber(0); // 清空 y = j - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 右移，合并 cardMap[i][y].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void MoveUp() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int x = i + 1; x \u0026lt; 4; x++) { // 从当前位置往下扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，上移 cardMap[x][j].setNumber(0); // 清空 x = i + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 上移，合并 cardMap[x][j].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void MoveDown() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 3; i \u0026gt;= 0; i--) { // 行循环 for(int x = i - 1; x \u0026gt;= 0; x--) { // 从当前位置往上扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，下移 cardMap[x][j].setNumber(0); // 清空 x = i - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 下移，合并 cardMap[x][j].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 } } } } } 接下来，我们需要在开始的时候清空分数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void startGame() { MainActivity.getMainActivity().clearScore(); // 清零 for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { cardMap[i][j].setNumber(0); // 清空游戏界面 } } // 初始化两张卡片 addRandomNumber(); addRandomNumber(); } 运行测试：\n阶段性效果\n接下去，我们需要在每次操作后都添加新的卡片：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void MoveLeft() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int y = j + 1; y \u0026lt; 4; y++) { // 从当前位置往右扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，左移 cardMap[i][y].setNumber(0); // 清空 y = j + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 左移，合并 cardMap[i][y].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void MoveRight() { for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int j = 3; j \u0026gt;= 0; j--) { // 列循环 for(int y = j - 1; y \u0026gt;= 0; y--) { // 从当前位置往左扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[i][y].getNumber()); // 空位，右移 cardMap[i][y].setNumber(0); // 清空 y = j - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[i][y])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 右移，合并 cardMap[i][y].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void MoveUp() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 0; i \u0026lt; 4; i++) { // 行循环 for(int x = i + 1; x \u0026lt; 4; x++) { // 从当前位置往下扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，上移 cardMap[x][j].setNumber(0); // 清空 x = i + 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 上移，合并 cardMap[x][j].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void MoveDown() { for(int j = 0; j \u0026lt; 4; j++) { // 列循环 for(int i = 3; i \u0026gt;= 0; i--) { // 行循环 for(int x = i - 1; x \u0026gt;= 0; x--) { // 从当前位置往上扫描 if(cardMap[i][j].getNumber() \u0026lt;= 0) // 当前值为 0 cardMap[i][j].setNumber(cardMap[x][j].getNumber()); // 空位，下移 cardMap[x][j].setNumber(0); // 清空 x = i - 1; // 避免 2 0 2 不合并的情况 } else if(cardMap[i][j].equals(cardMap[x][j])) { // 相同 cardMap[i][j].setNumber(cardMap[i][j].getNumber() * 2); // 下移，合并 cardMap[x][j].setNumber(0); // 清空 MainActivity.getMainActivity().addScore(cardMap[i][j].getNumber()); // 加分 move = true; // 已操作 } } } } if(move) { // 如果操作，添加新的卡片 addRandomNumber(); } } 其它三种情况请读者自行根据上述代码进行修改。测试结果如下图所示：\n阶段性效果\n最后，我们还需要判断游戏是否结束。游戏结束的条件是没有空位并且无法继续合并。定义一个函数 checkGame，checkGame 函数实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void checkGame() { boolean complete = true; // 默认游戏结束 ALL: for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { if(cardMap[i][j].getNumber() \u0026lt;= 0 || (i \u0026gt; 0 \u0026amp;\u0026amp; cardMap[i][j].equals(cardMap[i - 1][j])) || (i \u0026lt; 3 \u0026amp;\u0026amp; cardMap[i][j].equals(cardMap[i + 1][j])) || (j \u0026gt; 0 \u0026amp;\u0026amp; cardMap[i][j].equals(cardMap[i][j - 1])) || (j \u0026lt; 3 \u0026amp;\u0026amp; cardMap[i][j].equals(cardMap[i][j + 1]))) { complete = false; // 游戏未结束 break ALL; } } } if(complete) { new AlertDialog.Builder(getContext()).setTitle(\u0026#34;2048\u0026#34;).setMessage(\u0026#34;游戏结束\u0026#34;).setPositiveButton(\u0026#34;重新开始\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { startGame(); // 重新开始 } }).show(); } 至此，游戏的基本框架都已经全部完成，我们将在下一节中介绍分数的保存以及界面的美化。\n","date":"2015-05-15T19:33:00+08:00","permalink":"https://ivy-end.github.io/p/2048-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bjava-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%9B%9B%E8%8A%82%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91/","title":"2048 游戏制作过程（Java 描述）：第四节、游戏逻辑"},{"content":"首先，我们要使得我们的程序能够判断用户的手势，一共为上、下、左、右四种。在 GameView 类中添加如下代码：\n1 2 3 4 5 6 7 8 9 private void initGameView() { setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { return false; } }); } 接下来，我们来分析一下如何进行手势判断。首先，用户的手势输入应该有两个数据，一个是按下的屏幕位置，一个是放开的屏幕位置。那么我们只需要计算横向和竖向坐标差的绝对值，绝对值较大的一个方向则是用户需求的方向。至于横向中的左右和竖向中的上下，我们可以通过按下和放开的位置的大小进行比较得出。\n有了上面的分析，我们开始写代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 private void initGameView() { setOnTouchListener(new View.OnTouchListener() { private float startX, startY; // 起始位置 private float endX, endY; // 终了位置 private float offsetX, offsetY; // 偏移量 @Override public boolean onTouch(View v, MotionEvent event) { switch(event.getAction()) { case MotionEvent.ACTION_DOWN: startX = event.getX(); startY = event.getY(); break; case MotionEvent.ACTION_UP: endX = event.getX(); endY = event.getY(); offsetX = endX - startX; offsetY = endY - startY; if(Math.abs(offsetX) \u0026gt; Math.abs(offsetY)) { // 水平 if(offsetX \u0026lt; -5) { System.out.println(\u0026#34;Left\u0026#34;); } else if(offsetX \u0026gt; 5) { System.out.println(\u0026#34;Right\u0026#34;); } } else { // 垂直 if(offsetX \u0026lt; -5) { System.out.println(\u0026#34;Up\u0026#34;); } else if(offsetX \u0026gt; 5) { System.out.println(\u0026#34;Down\u0026#34;); } } } return false; } }); } 运行程序，进入调试界面，如下图所示：\n阶段性效果\n在窗口中用鼠标左滑，查看 Android Studio 中右下角 Logcat 窗口中的输出信息如下：\n方向判断\n说明我们的触摸检测已经成功了，接下来我们将四条输出语句换成四个函数。如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 if(Math.abs(offsetX) \u0026gt; Math.abs(offsetY)) { // 水平 if(offsetX \u0026lt; -5) { MoveLeft(); } else if(offsetX \u0026gt; 5) { MoveRight(); } } else { // 垂直 if(offsetX \u0026lt; -5) { MoveUp(); } else if(offsetX \u0026gt; 5) { MoveDown(); } } 除此之外，我们还需要定义这四个函数，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private void MoveLeft() { } private void MoveRight() { } private void MoveUp() { } private void MoveDown) { } 至于其中的处理方法，我们将在后续的章节中介绍。至此，我们的 GameView 框架基本能完成了。\n接下来，我们使用上一节中的方法，创建一个 Card 类（用来显示游戏中的小方块以及其上的数字），并且让它继承自 FrameLayout，同时添加构造函数。如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 package com.ivy.end.game2048; import android.content.Context; import android.widget.FrameLayout; public class Card extends FrameLayout { public Card(Context context) { super context; } } 此外，我们还需要创建几个私有成员变量，保存每张卡片上面的数字以及其它的一些信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.ivy.end.game2048; import android.content.Context; import android.widget.FrameLayout; public class Card extends FrameLayout { public Card(Context context) { super context; setNumber(0); // 初始化数字为 0 } public int getNumber() { return number; } public void setNumber(int number) { this.number = number; } private int number = 0; } 接下来，我们还需要定义一个变量，用来显示文字，这里我们选用 TextView，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package com.ivy.end.game2048; import android.content.Context; import android.widget.FrameLayout; import android.widget.TextView; public class Card extends FrameLayout { public Card(Context context) { super context; // 初始化 tvNumber tvNumber = new TextView(getContext()); tvNumber.setTextSize(32); // 添加 tvNumber LayoutParams lp = new LayoutParams(-1, -1); addView(tvNumber, lp); setNumber(0); // 初始化数字为 0 } public int getNumber() { return number; // 返回数字 } public void setNumber(int number) { this.number = number; // 设置数字 tvNumber.setText(number + \u0026#34;\u0026#34;); // 设置 tvNumber 文本 } private int number = 0; // 保存数字 private TextView tvNumber; // 显示数字 } 接下去我们需要添加一些函数用来判断两个 Card 的值是否相等，以方便后期的折叠操作：\n1 2 3 public boolean equals(Card o) { return getNumber() == o.getNumber(); } 至此，我们游戏的基本元素已经基本完成，接下来我们需要进行组装。首先，我们需要获得卡片的宽高，这是由于不同手机分辨率不同，为了适配各类型的手机。在 GameView 中添加如下代码：\n1 2 3 4 5 6 7 @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChange(w, h, oldw, oldh); int cardSize = (Math.min(w, h) -10) / 4; // 计算卡牌尺寸 addCards(cardSize); } 除此之外，我们还需要添加一个 addCards 函数，将卡片添加进来：\n1 2 3 4 5 6 7 8 9 10 11 12 private void addCards(int cardSize) { Card card; for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { card = new Card(getContext()); card.setNumber(2); addView(card, cardSzie, cardSize); } } } 接着，我们需要将这个 GameView 调整为每行四列，在 initGameView 中添加如下代码：\n1 2 3 private void initGameView() { setCOlumnCount(4); // 设置列数 此时，我们可以运行来看一下效果：\n阶段性效果\n至此，我们已经完成了加入卡片的功能，接下来，我们需要使得卡牌居中放置，切换到 Card 类，修改构造函数代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Card extends FrameLayout { public Card(Context context) { super context; // 初始化 tvNumber tvNumber = new TextView(getContext()); tvNumber.setTextSize(32); tvNumber.setGravity(Gravity.CENTER); // 居中 // 添加 tvNumber LayoutParams lp = new LayoutParams(-1, -1); addView(tvNumber, lp); setNumber(0); // 初始化数字为 0 } 再测试一下，结果如下：\n阶段性效果\n接下来，我们需要添加背景，首先在 GameView 的 initGameView 中添加如下代码：\n1 2 3 4 5 private void initGameView() { setCOlumnCount(4); // 设置列数 setBackgroundColor(0xFFBBADA0); // 设置背景 然后，我们为卡片设置背景，切换到 Card 的构造函数，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Card extends FrameLayout { public Card(Context context) { super context; // 初始化 tvNumber tvNumber = new TextView(getContext()); tvNumber.setTextSize(32); tvNumber.setBackgroundColor(0x33FFFFFF); // 设置背景 tvNumber.setGravity(Gravity.CENTER); // 居中 // 添加 tvNumber LayoutParams lp = new LayoutParams(-1, -1); addView(tvNumber, lp); setNumber(0); // 初始化数字为 0 } 运行结果如下：\n阶段性效果\n显示效果如上图，我们发现卡牌直接没有空格，看起来非常的紧凑，我们可以在 Card 类中这样修改代码：\n1 2 3 4 // 添加 tvNumber LayoutParams lp = new LayoutParams(-1, -1); lp.setMargins(10, 10, 0, 0); // 设置偏移量 addView(tvNumber, lp); 再次运行程序，如下图所示：\n阶段性效果\n在下一节中，我们将介绍游戏的内部逻辑。\n","date":"2015-05-14T20:03:00+08:00","permalink":"https://ivy-end.github.io/p/2048-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bjava-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E8%8A%82%E5%88%9B%E5%BB%BA%E7%95%8C%E9%9D%A2/","title":"2048 游戏制作过程（Java 描述）：第三节、创建界面"},{"content":"首先，我们需要修改一下应用的图标。准备一个 png 格式的图标文件。如下图所示：\nApp 图标\n接下来，找到上一节中保存项目的位置，依次展开文件夹中的 2048/Game2048/app/src/main/res 目录，如下图所示：\nApp 图标\n分别将刚才制作完成的图标文件更改名字为 ic_launcher.png，并且修改尺寸为 144×144、96×96、72×72、48×48，分别放入 drawable-xxhdip、drawable-xhdpi、drawable-hdpi、drawble-mdpi 文件夹覆盖其中的图标文件。需要用到这么多尺寸的图片，是由于 Android 应用程序需要兼容不同的客户端而引起的。接下来我们打开 Genymotion，并且运行我们的应用，可以发现图标已经被修改：\nApp 图标\n接下来，我们修改游戏显示的名称，我们希望只显示数字“2048”，切换到 Android Studio 界面，在左侧找到 values/strings.xml，双击打开该文件，将其中的 app_name 属性修改为 2048 即可，如下图所示：\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;2048\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;hello_world\u0026#34;\u0026gt;Hello world!\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;action_settings\u0026#34;\u0026gt;Settings\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; 我们再次运行程序，即可发现应用名称已经被修改为“2048”，如下图所示：\nApp 名称\n至此，我们已经完成了对该应用最基本的配置，接下来，我们需要创建最基本的游戏界面。\n首先，打开 res/layout/activity_main.xml 文件，将右下角的 Design/Text 选项卡切换到 Text 界面，并且输入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Score\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tvScore\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;GridLayout android:id=\u0026#34;@+id/gameView\u0026#34; android:layout_width=\u0026#34;fill_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;GridLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 我们看到在 andorid:text=\u0026ldquo;Score\u0026rdquo; 这段代码被深黄色包裹了起来，说明有一些修改建议，单击到上面，按下 Alt + Enter，在弹出的对话框中选择 Extract string resource，弹出下图的对话框，在 Resource Name 中输入 score，单击 OK，如下图所示：\n新建字符串\n切换到 Design 界面，可以看到，刚才定义的 Score 标签已经显示了出来，如下图所示：\nScore 标签\n接下来，我们需要新建一个 GameView 类来保存游戏的布局，并使得它继承自 GridLayout。\n首先，我们将 res 文件夹下的 layout 文件夹删除，因为我们需要自己绘制游戏界面，因此不需要用到 xml 布局文件。接下来我们需要创建一个新的类，用来显示当前的游戏界面。右击 com.ivy.end.game2048 文件夹，选择 New，单击 Java Class，输入类名 GameView，让 GameView 类继承自 GridLayout 类，并且定义它的构造函数，如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.ivy.end.game2048; import ... public class GameView extends GridLayout { public GameView(Context context) { super(context); } public GameView(Context context, AttributeSet attrs) { super(context, attrs); } public GameView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } } 接下来，我们需要定义一个初始化函数 initGameView，并且使得通过这三个构造函数进入类中都执行初始化函数，修改代码如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.ivy.end.game2048; import ... public class GameView extends GridLayout { public GameView(Context context) { super(context); } public GameView(Context context, AttributeSet attrs) { super(context, attrs); } public GameView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } private void initGameView() { } } 接下来，我们需要将这个类绑定到刚才的 GridLayout 上，切换到 activity_main.xml 文件的 Text 窗口，将 GridLayout 部分代码修改如下：\n1 2 3 4 5 6 \u0026lt;com.ivy.end.game2048.GameView android:id=\u0026#34;@+id/gameView\u0026#34; android:layout_width=\u0026#34;fill_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;/com.ivy.end.game2048.GameView\u0026gt; 至此，我们的布局代码基本完成。运行以后的界面如下图所示：\n运行效果\n下一节我们将介绍GameView的具体实现。\n","date":"2015-05-14T17:10:00+08:00","permalink":"https://ivy-end.github.io/p/2048-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bjava-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%8C%E8%8A%82%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/","title":"2048 游戏制作过程（Java 描述）：第二节、基本设置"},{"content":"自从关于扫雷游戏制作过程的文章发布后，有同学让我写一些关于移动开发的文章，并且建议以雷电这款游戏为例。然而考虑到该项目对于初学者来说代码量较大，所以暂且不涉及这部分，转而使用较为简单的 2048 游戏作为例子，可能对于初学者来说更容易上手，并且也更容易自己动手实现出来。\n本项目已根据文章进度托管在 GitHub 上：2048，读者可以自行查看。\n由于没有 Mac，因此只能介绍关于 Android 平台相关的开发知识。然而进行 Android 开发之前，需要搭建 Android 开发环境，这一步比较有难度的，主要是各个软件的配置较为麻烦，使得很多初学者望而却步。目前主流的 IDE 有 Eclipse 以及 Android Studio，本文将以 Android Studio 作为集成开发环境，对 2048 游戏的开发过程进行详细的介绍。\n然而 Android Studio 的配置并不如 Visual Studio 一样简单，下面将简单介绍一下 Android Studio 集成开发环境的部署，具体的细节步骤读者可以查阅相关资料。\n安装 JDK，根据自己的操作系统选择合适的 JDK 版本，我们常用的是 Windows x64 版本； 安装 Andorid Studio； 启动 Android Studio，配置 Gradle，该部分较为繁琐，需要自行下载对应版本的 Gradle 包，读者可以参考相关资料； （可选）安装 Genymotion，也可以使用 Android Studio 默认的模拟器，但是速度较慢。 至此，假设读者已经配置完成了 Android 开发环境并且能够正常运行了。接下来，我们进行 2048 游戏项目的创建。首先打开 Android Studio，弹出如下图所示的界面：\nAndroid Studio\n单击 Start a new Android Studio project 创建一个新的 Android Studio 项目，弹出如下界面：\nAndroid Studio 创建项目\n这里需要填写三个内容：\nApplication name，项目名称，这里我们填写\u0026quot;Game2048\u0026quot;； Company Domain，开发者信息，常小数点分割每一个部分，读者可以修改这部分的内容为自己的信息； Project location，项目地址，选择一个用以保存项目文件的位置。 单击 Next，进入下一步：\nAndroid Studio 创建项目\n这里需要我们选择该项目的使用平台，我们选择默认的 Phone and Tablet，其中的 Minimum SDK 表示所兼容的最低 API 版本，我们保持默认。单击 Next，进入下一步：\nAndroid Studio 创建项目\n接下来需要选择应用的初始界面，由于我们的界面需要自己开发，所以这里不需要进行修改，直接默认即可。单击 Next，进入下一步：\nAndroid Studio 创建项目\n这里需要我们对上一步默认选择的 Activity 进行一些属性的填写，保持默认，单击 Finish，完成项目的创建，稍作等待后，项目已经新建完成：\nAndroid Studio 项目创建完毕\n我们首先打开 Genymotion，界面如下：\nGenymotion\n单击 Start 按钮，启动 Android 模拟器，界面如下：\nGenymotion Android 模拟器\n若一开始打开时显示为横屏模式，只需要单击右侧的旋转屏幕按钮即可切换到竖屏模式。\n接下来，我们切换到 Android Studio 中，选择 Run 菜单项中的 Run \u0026lsquo;app\u0026rsquo;，也可以直接按工具栏中的快捷按钮，弹出如下的对话框：\n运行 Android App\n如果我们的 Genymotion 模拟器打开的话，Android Studio 会自动选择它作为默认的调试设备，这里我们直接单击 OK 即可，接着解锁模拟器中的 Android 系统，稍作等待，可以看到运行的 Android 应用：\n运行 Android App\n接下来，我们需要将它的标题栏去掉。切换到 Android Studio 界面，双击打开左侧的 app/manifests 文件夹下的 AndroidManifests.xml 文件，修改高亮行代码如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.ivy.end.game2048\u0026#34; \u0026gt; \u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:icon=\u0026#34;@drawable/ic_launcher\u0026#34; android:label=\u0026#34;Game2048\u0026#34; android:theme=\u0026#34;@style/Theme.Appcompat.Light.NoActionBar\u0026#34; \u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:label=\u0026#34;Game2048\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android:intent:category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 接下来找到左侧的 app/res/menu 文件夹下的 menu_main.xml，右击 Delete 将其删除，在弹出的对话框中勾选 Safe delete (with usage search) 以及 Search in comments and strings 这两个复选框，如下图所示：\n删除文件\n程序显示找到了引用项目，因为我们在主界面中调用了这个菜单，否则不会显示这个菜单。我们单击 Delete Anyway：\n删除文件\n接下来，双击打开 app/java/com.ivy.end.game2048 文件夹（并非 com.ivy.end.game2048(androidTest)）下的 MainActiviy 文件，将其中多余的代码（即刚才检测到调用了菜单的部分）全部删除，最终结果如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 package com.ivy.end.game2048; import ... public class MainActivity extends ActionBarActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } } 此时，再次运行程序，即可看到这样的效果：\n运行效果\n下一节将介绍修改 App 的应用图标以及名称，并且进行最基本的界面布局。\n","date":"2015-05-08T21:42:00+08:00","permalink":"https://ivy-end.github.io/p/2048-%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bjava-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%80%E8%8A%82%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/","title":"2048 游戏制作过程（Java 描述）：第一节、创建项目"},{"content":"这一节我们将介绍结束游戏的方法，以及一些整体方面的完善。首先考虑失败的情况，它会将所有的地雷都显示出来。我们新建一个 GameLost 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private void GameLost() { for(int i = 1; i\u0026lt;= nWidth; i++) { for(int j = 1; j\u0026lt;= nHeight; j++) { if(pMine[i, j] == -1 \u0026amp;\u0026amp; (pState[i, j] == 0 || pState[i, j] == 3)) // 未点开或者标记为问号的雷 { pState[i, j] = 1; // 点开该地雷 } } } } 在游戏结束的地方调用 GameLost 函数，因为我们上一节中讲述的游戏结束都是失败的情况：\n1 2 3 4 5 6 7 8 9 if(nFlagCnt == nSysCnt || nFlagCnt + nDoubtCnt == nSysCnt) // 打开九宫格 { bool bFlag = OpenMine(MouseFocus.X, MouseFocus.Y); if(!bFlag) // 周围有地雷 { // 结束游戏 GameLost(); } } 1 2 3 4 5 6 7 8 9 if(pMine[MouseFocus.X, MouseFocus.Y] != -1 \u0026amp;\u0026amp; pState[MouseFocus.X, MouseFocus.Y] == 0) { dfs(MouseFocus.X, MouseFocus.Y); } else { // 地雷，游戏结束 GameLost(); } 我们发现游戏结束的时候，虽然所有的格子都打开了，但是并没有显示出地雷的图标，我们将地雷的图标调整为 20×20，并且按照上一节的方法将它将入到 Resources.resx 文件中。同时修改 PaintGame 函数点开部分的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 else if(pState[i, j] == 1) // 点开 { // 绘制背景 if(MouseFocus.X == i \u0026amp;\u0026amp; MouseFocus.Y == j) { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.LightGray)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.LightGray, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } // 绘制数字 if(pMine[i, j] != 0) { Brush DrawBrush = new SolidBrush(Color.Blue); // 定义钢笔 // 各个地雷数目的颜色 if (pMine[i, j] == 2) { DrawBrush = new SolidBrush(Color.Green); } if (pMine[i, j] == 3) { DrawBrush = new SolidBrush(Color.Red); } if (pMine[i, j] == 4) { DrawBrush = new SolidBrush(Color.DarkBlue); } if (pMine[i, j] == 5) { DrawBrush = new SolidBrush(Color.DarkRed); } if (pMine[i, j] == 6) { DrawBrush = new SolidBrush(Color.DarkSeaGreen); } if (pMine[i, j] == 7) { DrawBrush = new SolidBrush(Color.Black); } if (pMine[i, j] == 8) { DrawBrush = new SolidBrush(Color.DarkGray); } SizeF Size = g.MeasureString(pMine[i, j].ToString(), new Font(\u0026#34;Consolas\u0026#34;, 16)); g.DrawString(pMine[i, j].ToString(), new Font(\u0026#34;Consolas\u0026#34;, 16), DrawBrush, nOffsetX + 34 * (i - 1) + 1 + (32 - Size.Width) / 2, nOffsetY + 34 * (j - 1) + 1 + (32 - Size.Height) / 2); } // 绘制地雷 if(pMine[i, j] == -1) { g.DrawImage(Properties.Resources.Mine, nOffsetX + 34 * (i - 1) + 1 + 4, nOffsetY + 34 * (j - 1) + 1 + 2); // 绘制地雷 } } 此时，我们再次测试的时候，就会看到地雷的图标了：\n阶段性效果\n然而，我们发现有一个问题，当我们单击数字的时候，会把所有的地雷都显示出来，也就是游戏结束。我们修改左击的事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1) { if(pState[MouseFocus.X, MouseFocus.Y] == 0) { dfs(MouseFocus.X, MouseFocus.Y); } } else { // 地雷，游戏结束 GameLost(); } } 这时候，刚才的问题就得到了修复。但是我们却又发现了一个问题——游戏结束的时候，还是可以继续单击雷区，打开区域。为此，我们增加一个变量检测游戏是否结束，如果结束，则任何按键都视为无效。首先定义一个变量：\n1 bool bGame; // 游戏是否结束 我们在游戏开始的时候对它进行初始化，在 New Game 菜单事件处理函数的末尾修改代码如下：\n1 2 3 4 Label_Mine.Text = nMineCnt.ToString(); // 显示地雷数目 Label_Timer.Text = \u0026#34;0\u0026#34;; // 计时器清零 Timer_Main.Enable = true; // 启动计时器计时 bGame = false; // 游戏暂未结束 将 GameLost 函数修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private void GameLost() { for(int i = 1; i\u0026lt;= nWidth; i++) { for(int j = 1; j\u0026lt;= nHeight; j++) { if(pMine[i, j] == -1 \u0026amp;\u0026amp; (pState[i, j] == 0 || pState[i, j] == 3)) // 未点开或者标记为问号的雷 { pState[i, j] = 1; // 点开该地雷 } } } bGame = true; } 同时修改 MouseUp 事件，将开头代码修改如下：\n1 2 3 4 5 6 private void Form_Main_MouseUp(object sender, MouseEventArgs e) { if(MouseFocus.X == 0 \u0026amp;\u0026amp; MouseFocus.Y == 0 || bGame) // 不在地雷区域或游戏结束 { return; // 不做任何处理 } 至此，这个问题已经得到了修复。我们可以运行查看结果。\n但是，我们现在还有一个判断游戏胜利的函数没有写，我们在每次打开地雷区域的时候判断游戏者是否胜利，首先定义一个 GameWin 函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 private void GameWin() { int nCnt = 0; // 用户标记红旗数目、问号数目、以及无标记未点开区域总数 for(int i = 1; i \u0026lt;= nWidth; i++) { for(int j = 1; j \u0026lt;= nHeight; j++) { if(pState[i, j] == 0 || pState[i, j] == 2 || pState[i, j] == 3) // 对应标记未点开区域、红旗区域、问号区域 { nCnt++; } } } if(nCnt == nMineCnt) // 胜利条件 { Timer_Main.Enabled = false; // 关闭计时器 MessageBox.Show(String.Format(\u0026#34;游戏胜利，耗时：{0} 秒\u0026#34;, Label_Timer.Text), \u0026#34;提示\u0026#34;, MessageBoxButtons.OK); // 更新记录 if (nWidth == 10 \u0026amp;\u0026amp; nHeight == 10 \u0026amp;\u0026amp; nMineCnt == 10) // 初级 { if (Properties.Settings.Default.Beginner \u0026gt; Convert.ToInt32(Label_Timer.Text)) // 更新记录 { Properties.Settings.Default.Beginner = Convert.ToInt32(Label_Timer.Text) Properties.Settings.Default.Beginner.Save(); } } else if (nWidth == 16 \u0026amp;\u0026amp; nHeight == 16 \u0026amp;\u0026amp; nMineCnt == 40) // 中级 { if (Properties.Settings.Default.Intermediate \u0026gt; Convert.ToInt32(Label_Timer.Text)) // 更新记录 { Properties.Settings.Default.Intermediate = Convert.ToInt32(Label_Timer.Text) Properties.Settings.Default.Intermediate.Save(); } } else if (nWidth == 30 \u0026amp;\u0026amp; nHeight == 16 \u0026amp;\u0026amp; nMineCnt == 40) // 高级 { if (Properties.Settings.Default.Expert \u0026gt; Convert.ToInt32(Label_Timer.Text)) // 更新记录 { Properties.Settings.Default.Expert = Convert.ToInt32(Label_Timer.Text) Properties.Settings.Default.Expert.Save(); } } bGame = true; } } 然后，在MouseUp最后调用该函数：\n1 2 3 4 GameWin(); this.Refresh(); bMouseLeft = bMouseRight = false; } 此时，我们的游戏基本完成了，但是有时会有这样的问题，左右双击区域的时候，不会显示到数字边界上，我们在 OpenMine 的时候调用一下 dfs 函数即可，将 OpenMine 函数修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private tool OpenMine(int sx, int sy) { bool bFlag = true; // 默认周围无雷 for (int i = 0; i \u0026lt; 8; i++) { // 获取偏移量 int x = MouseFocus.X + dx[i]; int y = MouseFocus.Y + dy[i]; if (pState[x, y] == 0) // 问号 { pState[x, y] = 1; // 打开 if(pMine[x, y] == -1) // 有地雷 { dfs(x, y); } else // 有地雷 { bFlag = false; break; } } } return bFlag; } 至此，我们的扫雷游戏基本完成了，接下来还需要处理的一个功能是音效，首先搜索音效资源：Bomb、Tick。然后按照之前的方法，将它们添加到 Resources.resx 文件中。\n定义两个变量用来播放这两个音效，并且在构造函数中进行初始化，如下：\n1 2 System.Media.SoundPlayer soundTick; // 计时 System.Media.SoundPlayer soundBomb; // 爆炸 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public Form_Main() { InitializeComponent(); this.DoubleBuffered = true; // 开启双缓冲 // 初始化游戏参数 nWidth = Properties.Settings.Default.Width; nHeight = Properties.Settings.Default.Height; nMineCnt = Properties.Settings.Default.MineCnt; // 初始化 bMark = Properties.Settings.Default.Mark; bAudio = Properties.Settings.Default.Audio; markMToolStripMenuItem.Checked = bMark; audioMToolStripMenuItem.Checked = bAudio; // 初始化音频 soundTick = new System.Media.SoundPlayer(Properties.Resources.Tick); soundBomb = new System.Media.SoundPlayer(Properties.Resources.Bomb); UpdateSize(); SelectLevel(); } 接下来分别在计时器的事件以及 GameLost 函数中添加如下代码：\n1 2 3 4 5 6 7 8 private void Timer_Main_Tick(object sender, EventArgs e) { if(bAudio) { soundTick.Play(); // 播放 } Label_Timer.Text = Convert.ToString(Convert.ToInt32(Label_Timer.Text) + 1); // 自增 1 秒 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private void GameLost() { for(int i = 1; i\u0026lt;= nWidth; i++) { for(int j = 1; j\u0026lt;= nHeight; j++) { if(pMine[i, j] == -1 \u0026amp;\u0026amp; (pState[i, j] == 0 || pState[i, j] == 3)) // 未点开或者标记为问号的雷 { pState[i, j] = 1; // 点开该地雷 } } } if(bAudio) { soundBomb.Play(); } bGame = true; } 此外，我们还需要将音效的初始默认值设置为 False，只需要将 Setting 文件中的默认值改为 False 即可。此外，我们还需要在 GameLost 的时候停止计时器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private void GameLost() { for(int i = 1; i\u0026lt;= nWidth; i++) { for(int j = 1; j\u0026lt;= nHeight; j++) { if(pMine[i, j] == -1 \u0026amp;\u0026amp; (pState[i, j] == 0 || pState[i, j] == 3)) // 未点开或者标记为问号的雷 { pState[i, j] = 1; // 点开该地雷 } } } if(bAudio) { soundBomb.Play(); } Timer_Main.Enabled = false; // 停用计时器 bGame = true; } 至此，我们的一个扫雷游戏就制作完成了，效果如下：\n运行效果\n但有时我们会发现雷区还没有被完全打开，就已经弹出了游戏结束的对话框，为此，我们只需要在 MouseUp 事件中将刷新和判断游戏胜利的语句换一下次序即可：\n1 2 3 this.Refresh(); GameWin(); bMouseLeft = bMouseRight = false; 测试的时候，我们发现，单击 Rank 对话框中的 Reset 按钮，虽然数据库恢复了默认值，但是显示的值却没有马上恢复默认值，为此，双击 Rank 窗口中的 Reset 按钮，修改它的事件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 private void Button_Reset_Click(object sender, EventArgs e) { // 将标签设置为默认值 Label_Beginer.Text = String.Format(\u0026#34;Beginner: {0}\u0026#34;, 999); Label_Intermeidate.Text = String.Format(\u0026#34;Intermediate: {0}\u0026#34;, 999); Label_Expert.Text = String.Format(\u0026#34;Expert: {0}\u0026#34;, 999); // 将所有记录设置为 999 即完成初始化 Propoerties.Settings.Default.Beginner = 999; Propoerties.Settings.Default.Intermediate = 999; Propoerties.Settings.Default.Export = 999; Propoerties.Settings.Default.Save(); // 保存设置 } 至此，一个较为完善的扫雷游戏就完成了，我将它托管在了 GitHub 上：Minesweeper。\n","date":"2015-05-02T11:12:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%85%AB%E8%8A%82%E6%95%B4%E4%BD%93%E5%AE%8C%E5%96%84/","title":"扫雷游戏制作过程（CSharp 描述）：第八节、整体完善"},{"content":"这一节我们主要讲解扫雷时鼠标单击的事件。我们首先介绍左键单击的事件，分为两种情况——遇到地雷，游戏结束；不是地雷，自动点开相邻的非地雷区域，并且显示对应地雷区域周围地雷的数目。\n我们首先需要为 Form_Main 添加 MouseDown 以及 MouseUp 事件，分别用来监测鼠标按下以及弹起的事件信息。再定义两个全局变量，用来标识鼠标左键以及右键是否被按下，代码如下：\n1 2 bool bMouseLeft; // 鼠标左键是否被按下 bool bMouseRight; // 鼠标右键是否被按下 在 MouseDown 事件中输入下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 private void Form_Main_MouseDown(object sender, MouseEventArgs e) { if(e.Button == MouseButtons.Left) // 鼠标左键被按下 { bMouseLeft = true; } if(e.Button == MouseButtons.Right) // 鼠标右键被按下 { bMouseRight = true; } } 在 MouseUp 事件中，我们需要获取鼠标弹起前按下的鼠标按键的状态信息，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private void Form_Main_MouseUp(object sender, MouseEventArgs e) { if(bMouseLeft \u0026amp;\u0026amp; BMouseRight) // 左右键同时按下 { } else if(bMouseLeft) // 左键被按下 { } else if(bMouseRight) // 右键被按下 { } } 我们首先处理鼠标左键按下的情况，这里分为两种情况，在前文中已经介绍过。但是在处理之前，我们需要获取游戏者单击的是哪个雷区，因此我们需要加入一些用以判断当前鼠标所属区域的代码。但是回顾一下，我们上一节中在 MouseMove 事件中已经获得了当前鼠标所属的区域，并且保存在了全局变量中，因此，我们直接调用即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void Form_Main_MouseUp(object sender, MouseEventArgs e) { if(MouseFocus.X == 0 \u0026amp;\u0026amp; MouseFocus.Y == 0) // 不在地雷区域 { return; // 不做任何处理 } if(bMouseLeft \u0026amp;\u0026amp; BMouseRight) // 左右键同时按下 { } else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1) { // 非地雷，自动打开周围非地雷区域 } else { // 地雷，游戏结束 } } else if(bMouseRight) // 右键被按下 { } bMouseLeft = bMouseRight = false; } 我们首先来处理非地雷的情况。也就是说我们需要寻找所有相邻的非地雷区域，这里我们才有深度优先搜索（Depth First Search），首先定义一个函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private void dfs(int sx, int sy) { pState[sx, sy] = 1; // 访问该点 for(int i = 0; i \u0026lt; 4; i++) { // 获取相邻点的坐标 int x = sx + px[i]; int y = sy + py[i]; if(x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= nWidth \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026lt;= nHeight \u0026amp;\u0026amp; pMine[x, y] != -1 \u0026amp;\u0026amp; pMine[sx, sy] == 0 \u0026amp;\u0026amp; (pState[x, y] == 0 || pState[x, y] == 3)) // 不是地雷，处于地雷区域，且未点开，或者标记为问号 { dfs(x, y); // 访问该点 } } } 在 MouseUp 函数中调用，并且刷新绘图区域：\n1 2 3 4 5 6 7 8 9 10 11 else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1) { dfs(MouseFocus.X, MouseFocus.Y); } else { // 地雷，游戏结束 } } 此时，我们运行程序，单击雷区，与上一节结束时的程序没有什么区别，因为我们还没有更新绘图函数，用下面的代码更新 PaintGame 函数主循环中的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /// \u0026lt;summary\u0026gt; /// 绘制游戏区 /// \u0026lt;/summary\u0026gt; private void PaintGame(Graphics g) { g.Clear(Color.White); // 清空绘图区 // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u0026lt;= nWidth; i++) // 绘制行 { for (int j = 1; j \u0026lt;= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 if(pState[i, j] == 0) // 未点开 { if(i == MouseFocus.X \u0026amp;\u0026amp; j == MouseFocus.Y) // 是否为高亮点 { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.SandyBrown)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } } else if(pState[i, j] == 1) // 点开 { if(pMine[i, j] != -1) // 非地雷 { // 绘制背景 if(MouseFocus.X == i \u0026amp;\u0026amp; MouseFocus.Y == j) { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.LightGray)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.LightGray, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } // 绘制数字 if(pMine[i, j] != 0) { Brush DrawBrush = new SolidBrush(Color.Blue); // 定义钢笔 // 各个地雷数目的颜色 if (pMine[i, j] == 2) { DrawBrush = new SolidBrush(Color.Green); } if (pMine[i, j] == 3) { DrawBrush = new SolidBrush(Color.Red); } if (pMine[i, j] == 4) { DrawBrush = new SolidBrush(Color.DarkBlue); } if (pMine[i, j] == 5) { DrawBrush = new SolidBrush(Color.DarkRed); } if (pMine[i, j] == 6) { DrawBrush = new SolidBrush(Color.DarkSeaGreen); } if (pMine[i, j] == 7) { DrawBrush = new SolidBrush(Color.Black); } if (pMine[i, j] == 8) { DrawBrush = new SolidBrush(Color.DarkGray); } SizeF Size = g.MeasureString(pMine[i, j].ToString(), new Font(\u0026#34;Consolas\u0026#34;, 16)); g.DrawString(pMine[i, j].ToString(), new Font(\u0026#34;Consolas\u0026#34;, 16), DrawBrush, nOffsetX + 34 * (i - 1) + 1 + (32 - Size.Width) / 2, nOffsetY + 34 * (j - 1) + 1 + (32 - Size.Height) / 2); } } } } } } 此时，我们再次运行程序，单击某个格子，如果不是地雷，那么就可以看到下面的情况：\n阶段性效果\n接下来，我们先不处理游戏失败的情况，先来考虑右击事件，它主要用于更改标记，我们在右击函数中加入下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 else if(bMouseRight) // 右键被按下 { if(bMark) // 可以使用标记 { if(pState[MouseFocus.X, MouseFocus.Y] == 0) // 未点开 { pState[MouseFocus.X, MouseFocus.Y] = 2; // 红旗 } else if(pState[MouseFocus.X, MouseFocus.Y] == 2) // 红旗 { pState[MouseFocus.X, MouseFocus.Y] = 3; // 问号 } else if(pState[MouseFocus.X, MouseFocus.Y] == 3) // 问号 { pState[MouseFocus.X, MouseFocus.Y] = 0; // 未点开 } } } this.Refresh(); bMouseLeft = bMouseRight = false; } 同样，我们现在运行程序还是不会有什么效果。我们需要更新PaintGame函数。再次之前，我们需要将我们的图标信息代入到工程中来，在导入之前我们需要将它们大尺寸分别修改为 24×24 和 20×20，以达到更好的显示效果。\n在右侧解决方案资源管理器中找到 Resources.resx 文件，双击打开资源管理界面，将两张图片选中后拖动过去即可完成图片的导入。同时修改 PaintGame 函数的未点开功能部分如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 /// \u0026lt;summary\u0026gt; /// 绘制游戏区 /// \u0026lt;/summary\u0026gt; private void PaintGame(Graphics g) { g.Clear(Color.White); // 清空绘图区 // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u0026lt;= nWidth; i++) // 绘制行 { for (int j = 1; j \u0026lt;= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 if(pState[i, j] == 0) // 未点开 { // 绘制背景 if(i == MouseFocus.X \u0026amp;\u0026amp; j == MouseFocus.Y) // 是否为高亮点 { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.SandyBrown)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } // 绘制标记 if(pState[i, j] == 2) { g.DrawImage(Properties.Resources.Flag, nOffsetX + 34 * (i - 1) + 1 + 4, nOffsetY + 34 * (j - 1) + 1 + 2); // 绘制红旗 } if(pState[i, j] == 3) { g.DrawImage(Properties.Resources.Doubt, nOffsetX + 34 * (i - 1) + 1 + 4, nOffsetY + 34 * (j - 1) + 1 + 2); // 绘制问号 } } else if(pState[i, j] == 1) // 点开 { if(pMine[i, j] != -1) // 非地雷 { // 绘制背景 if(MouseFocus.X == i \u0026amp;\u0026amp; MouseFocus.Y == j) { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.LightGray)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.LightGray, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } // 绘制数字 if(pMine[i, j] != 0) { Brush DrawBrush = new SolidBrush(Color.Blue); // 定义钢笔 // 各个地雷数目的颜色 if (pMine[i, j] == 2) { DrawBrush = new SolidBrush(Color.Green); } if (pMine[i, j] == 3) { DrawBrush = new SolidBrush(Color.Red); } if (pMine[i, j] == 4) { DrawBrush = new SolidBrush(Color.DarkBlue); } if (pMine[i, j] == 5) { DrawBrush = new SolidBrush(Color.DarkRed); } if (pMine[i, j] == 6) { DrawBrush = new SolidBrush(Color.DarkSeaGreen); } if (pMine[i, j] == 7) { DrawBrush = new SolidBrush(Color.Black); } if (pMine[i, j] == 8) { DrawBrush = new SolidBrush(Color.DarkGray); } SizeF Size = g.MeasureString(pMine[i, j].ToString(), new Font(\u0026#34;Consolas\u0026#34;, 16)); g.DrawString(pMine[i, j].ToString(), new Font(\u0026#34;Consolas\u0026#34;, 16), DrawBrush, nOffsetX + 34 * (i - 1) + 1 + (32 - Size.Width) / 2, nOffsetY + 34 * (j - 1) + 1 + (32 - Size.Height) / 2); } } } } } } 此时，我们发现当我们的区域处于红旗或者问号的时候，左击的时候还是会打开该区域，修改左击代码如下：\n1 2 3 4 5 6 7 8 9 10 11 else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1 \u0026amp;\u0026amp; pState[MouseFocus.X, MouseFocus.Y] == 0) { dfs(MouseFocus.X, MouseFocus.Y); } else { // 地雷，游戏结束 } } 此时，我们以及完成了基本的游戏功能了。接下来我们还需要完成一个鼠标左右键同时按下的事件，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 if(bMouseLeft \u0026amp;\u0026amp; BMouseRight) // 左右键同时按下 { if(pState[MouseFocus.X, MouseFocus.Y] == 1 \u0026amp;\u0026amp; pMine[MouseFocus.X, MouseFocus.Y] \u0026gt; 0) // 为数字区域 { int nFlagCnt = 0, nDoubtCnt = 0, nSysCnt = pMine[MouseFocus.X, MouseFocus.Y]; // 记录红旗数目，问号数目，九宫格地雷数目 for(int i = 0; i \u0026lt; 8; i++) { // 获取偏移量 int x = MouseFocus.X + dx[i]; int y = MouseFocus.Y + dy[i]; if(pState[x, y] == 2) // 红旗 { nFlagCnt++; } if(pState[x, y] == 3) // 问号 { nDoubtCnt++; } if(nFlagCnt == nSysCnt || nFlagCnt + nDoubtCnt == nSysCnt) // 打开九宫格 { bool bFlag = OpenMine(MouseFocus.X, MouseFocus.Y); if(!bFlag) // 周围有地雷 { // 结束游戏 } } } } } 这里，我们缺少一个 OpenMine 函数，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private tool OpenMine(int sx, int sy) { bool bFlag = true; // 默认周围无雷 for (int i = 0; i \u0026lt; 8; i++) { // 获取偏移量 int x = MouseFocus.X + dx[i]; int y = MouseFocus.Y + dy[i]; if (pState[x, y] == 0) // 问号 { pState[x, y] = 1; // 打开 if(pMine[x, y] == -1) // 有地雷 { bFlag = false; break; } } } return bFlag; } 此时，如果我们运行程序，很有可能出现下面的情况，有的地方是一个白色的区域，没有任何内容：\n阶段性效果\n出现这种结果，也就意味着出现了地雷，因为我们的 PaintGame 函数暂时还没有绘制地雷的功能。\n细心的读者可能发现了一个问题，地图上有了一面红旗，底下的状态栏中却仍然显示地雷数目为 10，我们通过修改右击事件来修复这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 private void Form_Main_MouseUp(object sender, MouseEventArgs e) { if(MouseFocus.X == 0 \u0026amp;\u0026amp; MouseFocus.Y == 0) // 不在地雷区域 { return; // 不做任何处理 } if(bMouseLeft \u0026amp;\u0026amp; BMouseRight) // 左右键同时按下 { if(pState[MouseFocus.X, MouseFocus.Y] == 1 \u0026amp;\u0026amp; pMine[MouseFocus.X, MouseFocus.Y] \u0026gt; 0) // 为数字区域 { int nFlagCnt = 0, nDoubtCnt = 0, nSysCnt = pMine[MouseFocus.X, MouseFocus.Y]; // 记录红旗数目，问号数目，九宫格地雷数目 for(int i = 0; i \u0026lt; 8; i++) { // 获取偏移量 int x = MouseFocus.X + dx[i]; int y = MouseFocus.Y + dy[i]; if(pState[x, y] == 2) // 红旗 { nFlagCnt++; } if(pState[x, y] == 3) // 问号 { nDoubtCnt++; } if(nFlagCnt == nSysCnt || nFlagCnt + nDoubtCnt == nSysCnt) // 打开九宫格 { bool bFlag = OpenMine(MouseFocus.X, MouseFocus.Y); if(!bFlag) // 周围有地雷 { // 结束游戏 } } } } } else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1 \u0026amp;\u0026amp; pState[MouseFocus.X, MouseFocus.Y] == 0) { dfs(MouseFocus.X, MouseFocus.Y); } else { // 地雷，游戏结束 } } else if(bMouseRight) // 右键被按下 { if(bMark) // 可以使用标记 { if(pState[MouseFocus.X, MouseFocus.Y] == 0) // 未点开 { pState[MouseFocus.X, MouseFocus.Y] = 2; // 红旗 Label_Mine.Text = Convert.ToString(Convert.ToInt32(Label_Mine.Text) - 1); // 剩余地雷数目减 1 } else if(pState[MouseFocus.X, MouseFocus.Y] == 2) // 红旗 { pState[MouseFocus.X, MouseFocus.Y] = 3; // 问号 Label_Mine.Text = Convert.ToString(Convert.ToInt32(Label_Mine.Text) + 1); // 剩余地雷数目加 1 } else if(pState[MouseFocus.X, MouseFocus.Y] == 3) // 问号 { pState[MouseFocus.X, MouseFocus.Y] = 0; // 未点开 } } } this.Refresh(); bMouseLeft = bMouseRight = false; } 最终，我们会看到这样的效果：\n运行效果\n我们将在下一节中介绍游戏结束的相关内容。\n","date":"2015-05-01T22:23:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%83%E8%8A%82%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%AD/","title":"扫雷游戏制作过程（CSharp 描述）：第七节、内部实现（续）"},{"content":"在进行内部实现之前，我们先来考虑一下扫雷的内部逻辑。首先，我们需要保存每个点上是否有地雷，如果没有地雷，那么要显示与它紧邻的八个格子中一共有多少的地雷。还需保存每个雷区的状态（点开，未点开，红旗，问号）。我们考虑定义两个常量，表示地雷的最大范围：\n1 2 const int MAX_WIDTH = 64; // 最大宽度 const int MAX_HEIGHT = 32; // 最大高度 接下来定义两个数组，用来保存上述两种数据。对于第一类数据，我们使用 -1 表示该区域有地雷，使用数字表示与它紧邻的八个格子中一共有多少地雷；对于第二类数据，我们使用 0 表示未点开，1 表示点开，2 表示红旗，3 表示问号。如下图所示：\n1 2 int[,] pMine = new int[MAX_WIDTH, MAX_HEIGHT]; // 第一类数据 int[,] pState = new int[MAX_WIDTH, MAX_HEIGHT]; // 第二类数据 接下来我们需要初始化游戏数据，双击 New Game 菜单，输入游戏的初始化代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private void newGameNToolStripMenuItem_Click(object sender, EventArgs e) { // 以下两行清空数组 Array.Clear(pMine, 0, pMine.Length); Array.Clear(pState, 0, pState.Length); // 初始化地雷数据 Random Rand = new Random(); for(int i = 1; i \u0026lt;= nMineCnt; ) // 地雷总数 { // 随机地雷坐标 (x, y) int x = Rand.Next(nWidth) + 1; int y = Rand.Next(nHeight) + 1; if (pMine[x, y] != -1) { pMine[x, y] = -1; i++; } } for(int i = 1 ; i \u0026lt;= nWidth; i++) // 枚举宽度 { for(int j = 1; j \u0026lt;= nHeight; j++) // 枚举高度 { if(pMine[i, j] != -1) // 不是地雷，显示周围地雷数 { for(int k = 0; k \u0026lt; 8; k++) // 八个方向拓展 { if(pMine[i + dx[k], j + dy[k]] == -1) // 找到地雷 { pMine[i, j]++; // 地雷数自增 } } } } } } 其中涉及到了 dx 以及 dy 这两个偏移量常量数组的定义，如下图所示：\n1 2 int[] dx = new int[] { -1, 0, 1, -1, 1, -1, 0, 1 }; // x 坐标偏移量 int[] dy = new int[] { 1, 1, 1, 0, 0, -1, -1, -1 }; // y 坐标偏移量 接下来我我们来实现一些特效，例如高亮当前鼠标悬浮位置的雷区，打开设计窗口，添加 MouseMove 事件：\n1 2 3 4 5 6 7 private void Form_Main_MouseMove(object sender, MouseEventArgs e) { int x = (e.X - 6) / 36 + 1; // 获取 x 位置 int y = (e.Y - MenuStrip_Main.Height - 6) / 36 + 1; // 获取 y 位置 MouseFocus.X = x; MouseFocus.Y = y; // 设置当前高亮点 PaintGame(); // 重绘雷区 } 为此，我们还需要定义一个变量 MouseFocus 来记录当前的高亮点，代码分别如下：\n1 Point MouseFocus; // 高亮点记录 同时，我们需要在初始化的时候对它进行清零操作，将下面的清零代码加入到刚才的初始化函数中：\n1 2 // 重置高亮点 MouseFocus.X = 0; MouseFocus.Y = 0; 接下来我们需要修改 PaintGame 函数，添加对高亮点的绘制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /// \u0026lt;summary\u0026gt; /// 绘制游戏区 /// \u0026lt;/summary\u0026gt; private void PaintGame() { Graphics g = this.CreateGraphics(); // 创建绘图句柄 g.FillRectangle(Brushes.White, new Rectangle(0, 0, this.Width, this.Height)); // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u0026lt;= nWidth; i++) // 绘制行 { for (int j = 1; j \u0026lt;= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 if(i == MouseFocus.X \u0026amp;\u0026amp; j == MouseFocus.Y) // 是否为高亮点 { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.SandyBrown)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } } } } 此时，我们可以尝试运行，然而却发现界面会一直在闪，使得游戏体验急剧下降，为了修复这个问题，我们只需要在构造函数中添加一句代码，开启双缓冲即可，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public Form_Main() { InitializeComponent(); this.DoubleBuffered = true; // 开启双缓冲 // 初始化游戏参数 nWidth = Properties.Settings.Default.Width; nHeight = Properties.Settings.Default.Height; nMineCnt = Properties.Settings.Default.MineCnt; // 初始化 bMark = Properties.Settings.Default.Mark; bAudio = Properties.Settings.Default.Audio; markMToolStripMenuItem.Checked = bMark; audioMToolStripMenuItem.Checked = bAudio; UpdateSize(); SelectLevel(); } 然而我们发现效果并没有很大的提升，这是由于我们之前定义的 PaintGame 函数所导致的，它不断的定义新的 Graphics 实例，使得这个过程变得很慢，我们可以直接使用 Paint 事件中的 Graphics 实例。首先修改 PaintGame 函数的定义以及部分实现，如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /// \u0026lt;summary\u0026gt; /// 绘制游戏区 /// \u0026lt;/summary\u0026gt; private void PaintGame(Graphics g) { g.Clear(Color.White); // 清空绘图区 // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u0026lt;= nWidth; i++) // 绘制行 { for (int j = 1; j \u0026lt;= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 if(i == MouseFocus.X \u0026amp;\u0026amp; j == MouseFocus.Y) // 是否为高亮点 { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.SandyBrown)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } } } } 同时修改 Paint 事件中的调用函数：\n1 2 3 4 private void Form_Main_Paint(object sender, PaintEventArgs e) { PaintGame(e.Graphics); } 对于其它非 Paint 函数调用的 PaintGame 函数，一律修改为 this.Refresh(); 即可，如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// \u0026lt;summary\u0026gt; /// 自动更新窗口大小 /// \u0026lt;summary\u0026gt; private void UpdateSize() { int nOffsetX = this.Width - this.ClientSize.Width; // 包含了窗口标题栏以及上下边框的高度 int nOffsetY = this.Height - this.ClientSize.Height; // 包含了左右边框的宽度 int nAdditionY = MenuStrip_Main.Height + TableLayoutPanel_Main.Height; // 包含了菜单栏以及下方显示信息栏的高度 this.Width = 12 + 34 * nWidth + nOffsetX; // 设置窗口高度，34 为每个雷区的高度，12 为上下总空隙（6px + 6px），再加上偏移量 this.Height = 12 + 34 * nHeight + nAdditionY + nOffsetY; // 设置窗口宽度，同理 // PaintGame() this.Refresh(); } 1 2 3 4 5 6 7 private void Form_Main_MouseMove(object sender, MouseEventArgs e) { int x = (e.X - 6) / 36 + 1; // 获取 x 位置 int y = (e.Y - MenuStrip_Main.Height - 6) / 36 + 1; // 获取 y 位置 MouseFocus.X = x; MouseFocus.Y = y; // 设置当前高亮点 this.Refresh(); // 重绘雷区 } 再次运行的时候，我们发现已经没有了之前的闪屏问题了。然而我们却发现了新的问题，对于当前移动到的位置坐标获取不准确，我们进行下面的调整：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private void Form_Main_MouseMove(object sender, MouseEventArgs e) { if (e.X \u0026lt; 6 || e.X \u0026gt; 6 + nWidth * 34 || e.Y \u0026lt; 6 + MenuStrip_Main.Height || e.Y \u0026gt; 6 + MenuStrip_Main.Height + nHeight * 34) // 不在地雷区域 { MouseFocus.X = 0; MouseFocus.Y = 0; } else { int x = (e.X - 6) / 36 + 1; // 获取 x 位置 int y = (e.Y - MenuStrip_Main.Height - 6) / 36 + 1; // 获取 y 位置 MouseFocus.X = x; MouseFocus.Y = y; // 设置当前高亮点 } this.Refresh(); // 重绘雷区 } 此时，我们运行程序的时候，就会发现界面基本已经完成了。\n接下来我们需要为 Setting 菜单添加一个单击确定按钮以后就自动开始游戏的功能，为此我们只需要修改 UpdateSize 函数，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 /// \u0026lt;summary\u0026gt; /// 自动更新窗口大小 /// \u0026lt;summary\u0026gt; private void UpdateSize() { int nOffsetX = this.Width - this.ClientSize.Width; // 包含了窗口标题栏以及上下边框的高度 int nOffsetY = this.Height - this.ClientSize.Height; // 包含了左右边框的宽度 int nAdditionY = MenuStrip_Main.Height + TableLayoutPanel_Main.Height; // 包含了菜单栏以及下方显示信息栏的高度 this.Width = 12 + 34 * nWidth + nOffsetX; // 设置窗口高度，34 为每个雷区的高度，12 为上下总空隙（6px + 6px），再加上偏移量 this.Height = 12 + 34 * nHeight + nAdditionY + nOffsetY; // 设置窗口宽度，同理 newGameNToolStripMenuItem_Click(new object(), new EvenetArgs()); // 调用新建游戏函数 } 接下来我们需要修改一下显示地雷数目以及计时的标签，在新建游戏的函数中修改如下：\n1 2 3 Label_Mine.Text = nMineCnt.ToString(); // 显示地雷数目 Label_Timer.Text = \u0026#34;0\u0026#34;; // 计时器清零 Timer_Main.Enabled = true; // 启动计时器计时 运行后，我们发现计时器并没有显示出来，因为我们还没有为计时器摄制事件。在设计窗口页面中双击计时器，程序自动创建计时器事件，输入下面的代码：\n1 2 3 4 private void Timer_Main_Tick(object sender, EventArgs e) { Label_Timer.Text = Convert.ToString(Convert.ToInt32(Label_Timer.Text) + 1); // 自增 1 秒 } 同时记得在设计页面中将记时器的 Interval 属性设置为 1000，表示每秒执行一次计时器事件代码。\n最后，我们运行程序，效果如下：\n运行效果\n下一讲将会涉及具体的鼠标单击以及右击雷区时的逻辑事件的判定。\n","date":"2015-04-30T21:26:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%85%AD%E8%8A%82%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/","title":"扫雷游戏制作过程（CSharp 描述）：第六节、内部实现"},{"content":"上一节中，我们还剩下 Setting 和 Rank 两个菜单项目没有设置事件，是因为它们都涉及到了弹出一个新的窗口。这一节，我们将主要介绍创建窗口的方法，以及窗口之间的数据通信。\n首先，我们新建一个窗口，在右侧找到解决方案资源管理器，右击 Minesweeper 项目名，选择添加，如图所示：\n菜单示意图\n选择新建项，如图所示：\n菜单示意图\n在弹出的窗口中选择 Windows 窗体，并将名称修改为 Form_Setting.cs，单击确定，如图所示：\n新建窗口示意图\n将新建的窗口 Icon 属性修改为扫雷的图标，将 MaximizeBox 属性修改为 False，将 Name 属性修改为 Form_Setting，将 BackColor 属性修改为 White，将 Text 属性修改为 Minesweeper，将 FormBorderStyle 属性改为 FixedSingle。\n在左边工具箱面板下公共控件中找到 Label 控件，双击添加到窗口中，将它的 Name 属性修改为 Label_Width，Text 属性修改为“Width:”，并移动到合适的位置，再在工具箱面板中找到 NumericUpDown 控件，双击添加到窗口中，将它的 Name 属性修改为 NumericUpDown_Width，Minimum 属性修改为 1，Maximun 属性修改为 30，（其中 Minimum 以及 Maximum 的属性表示为数字的变化范围。）TextAlign 属性修改为 Center。其中 Minimum以 及 Maximum 的属性表示为数字的变化范围。如下图所示：\n窗口示意图\n重复上述操作，添加雷区高度（Height），地雷数目（Mine）的控件，其中高度的变化范围为 1 至 16，数目的变化范围为 1 至 99。如下图所示：\n窗口示意图\n接下来我们需要添加两个按钮，用来确定修改以及取消修改。在左侧工具箱面板的公共控件中找到 Button 控件，双击添加到窗体中，将它的 Name 属性修改为 Button_OK，Text 属性修改为 OK。同时添加一个取消按钮（Cancel），如下图所示：\n窗口示意图\n然后拖动窗口右下方的白点，调整窗口大小到合适的位置，如下图所示：\n窗口示意图\n接下来我们用同样的方法和设置来创建一个排行榜的窗口（Form_Rank）。\n放置三个标签，分别表示初级（Label_Beginner）、中级（Label_Intermediate）、高级（Label_Expert）的最高分，并且加入两个按钮，表示重新计分（Button_Reset）、确定（OK），如图所示：\n窗口示意图\n接下来，我们就可以调用这两个窗口了。打开 Form_Main 窗口，为 Setting 和 Rank 分别添加单击事件（双击菜单项，程序自动添加该时间），并且写下如下代码：\n1 2 3 4 5 6 7 8 9 10 11 private void settingSToolStripMenuItem_Click(object sender, EventArgs e) { Form_Setting Setting = new Form_Setting(); Setting.ShowDialog(); } private void rankRToolStripMenuItem_Click(object sender, EventArgs e) { Form_Rank Rank = new Form_Rank(); Rank.ShowDialog(); } 这样，我们就完成了对窗口的调用。接下去，我们先来实现较为简单的 Rank 窗口。每次读取最高分的数据，这也就要求我们每次记录得分。\n打开 Settings 文件，添加三种等级的最高分，并且将初始值都设置为 999，如下图所示：\nSetting 示意图\n打开排名窗口，双击窗口标题栏，程序会自动添加一个 Load 事件，我们在这里添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 private void Form_Rank_Load(object sender, EventArgs e) { // 读取数据 int nBeginner = Propoerties.Settings.Default.Beginner; int nIntermediate = Propoerties.Settings.Default.Intermediate; int nExport = Propoerties.Settings.Default.Export; // 显示内容 Label_Beginer.Text = String.Format(\u0026#34;Beginner: {0}\u0026#34;, nBeginner); Label_Intermeidate.Text = String.Format(\u0026#34;Intermediate: {0}\u0026#34;, nIntermediate); Label_Expert.Text = String.Format(\u0026#34;Expert: {0}\u0026#34;, nExpert); } 这样，我们调试一下，就可以看到排名的效果了：\nRank 示意图\n接下去我们需要为 Reset 以及 OK 按钮添加事件。首先考虑 OK 按钮，双击按钮，添加单击事件，并且添加如下代码：\n1 2 3 4 private void Button_OK_Click(object sender, EventArgs e) { this.close(); // 关闭窗口，非退出程序 } 对于 Reset 按钮，我们添加如下代码：\n1 2 3 4 5 6 7 8 private void Button_Reset_Click(object sender, EventArgs e) { // 将所有记录设置为 999 即完成初始化 Propoerties.Settings.Default.Beginner = 999; Propoerties.Settings.Default.Intermediate = 999; Propoerties.Settings.Default.Export = 999; Propoerties.Settings.Default.Save(); // 保存设置 } 这样，我们就完成了排行榜的功能。接下来我们来考虑设置窗口的功能。我们首先为 Cancel 按钮添加如下代码：\n1 2 3 4 private void Button_Cancel_Click(object sender, EventArgs e) { this.close(); // 关闭窗口，非退出程序 } 我们考虑 OK 按钮，我们需要和 Form_Main 窗口进行通信，修改 Form_Setting 的构造函数，如图所示：\n1 2 3 4 5 6 7 8 Form_Main Main; public Form_Setting(Form_Main _Main) { InitializeComponent(); Main = _Main; // 传递父窗口实例 } 接着将 Form_Main 中 nWidth、nHeight、nMine 变量设置为公有类型：\n1 2 3 public int nWidth; // 表示雷区的宽度 public int nHeight; // 表示雷区的高度 public int nMineCnt; // 表示地雷的数量 然后修改对 Setting 窗口的调用函数：\n1 2 3 4 5 private void settingSToolStripMenuItem_Click(object sender, EventArgs e) { Form_Setting Setting = new Form_Setting(this); // 将本身作为参数传递过去 Setting.ShowDialog(); } 至此，我们就完成了 Setting 窗口和 Main 窗口的信息连接，双击 Setting 窗口的标题栏，修改它的 Load 事件如下，以实现对 Main 窗口中原有游戏参数的读取：\n1 2 3 4 5 6 private void Form_Setting_Load(object sender, EventArgs e) { NumericUpDown_Width.Value = Convert.ToDecimal(Main.nWidth); NumericUpDown_Height.Value = Convert.ToDecimal(Main.nHeight); NumericUpDown_Mine.Value = Convert.ToDecimal(Main.nMineCnt); } 这样，我们运行的时候就可以看到 Setting 窗口自动获取了 Main 中的游戏参数：\nSetting 窗口示意图\n接下来我们为 OK 按钮添加如下的事件：\n1 2 3 4 5 6 7 private void Button_OK_Click(object sender, EventArgs e) { Main.nWidth = Convert.ToDecimal(NumericUpDown_Width.Value); Main.nHeight = Convert.ToDecimal(NumericUpDown_Height.Value); Main.nMineCnt = Convert.ToDecimal(NumericUpDown_Mine.Value); this.Close(); } 这样，我们就完成了游戏规模的设置，有时候，我们发现弹出来的设置窗口以及排行窗口显示的位置都偏左上角，我们对它进行一些调整，修改它们的 StartPosition 属性为 CenterParent。\n最后，在调用完设置窗口后，还需要 UpdateSize 一下来实现对游戏规模的修改：\n1 2 3 4 5 6 private void settingSToolStripMenuItem_Click(object sender, EventArgs e) { Form_Setting Setting = new Form_Setting(this); // 将本身作为参数传递过去 Setting.ShowDialog(); UpdateSize(); } 最终我们可以实现各种大小的雷区：\n运行效果\n这一节暂且讲到这里，下一节我们将会介绍地雷数目以及时间秒数的显示，以及扫雷内部模型的建立。\n","date":"2015-04-24T16:09:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%94%E8%8A%82%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C%E7%BB%AD/","title":"扫雷游戏制作过程（CSharp 描述）：第五节、菜单操作（续）"},{"content":"我们现在的程序单击菜单的时候不会有任何反应，这一节我们主要介绍菜单的相关代码，使得菜单能够正常使用。\n在第二节中，我们曾经提出希望在对应级别（初级、中级、高级、自定义）的按钮的显示勾，以表示目前的游戏等级。我们有两个时候需要对它进行操作，一个是加载上次游戏设置的时候，一个是在游戏过程中进行设置的时候，我们先介绍第一种情况。按照下图修改代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /// \u0026lt;summary\u0026gt; /// 选择对应的游戏等级 /// \u0026lt;/summary\u0026gt; private void SelectLevel() { if (nWidth == 10 \u0026amp;\u0026amp; nHeight == 10 \u0026amp;\u0026amp; nMineCnt == 10) { beginnerBToolStripMenuItem.Checked = true; intermediateIToolStripMenuItem.Checked = false; expertEToolStripMenuItem.Checked = false; settingSToolStripMenuItem.Checked = false; } else if (nWidth == 16 \u0026amp;\u0026amp; nHeight == 16 \u0026amp;\u0026amp; nMineCnt == 40) { beginnerBToolStripMenuItem.Checked = false; intermediateIToolStripMenuItem.Checked = true; expertEToolStripMenuItem.Checked = false; settingSToolStripMenuItem.Checked = false; } else if (nWidth == 30 \u0026amp;\u0026amp; nHeight == 16 \u0026amp;\u0026amp; nMineCnt == 99) { beginnerBToolStripMenuItem.Checked = false; intermediateIToolStripMenuItem.Checked = false; expertEToolStripMenuItem.Checked = true; settingSToolStripMenuItem.Checked = false; } else { beginnerBToolStripMenuItem.Checked = false; intermediateIToolStripMenuItem.Checked = false; expertEToolStripMenuItem.Checked = false; settingSToolStripMenuItem.Checked = true; } } 注意到 beginnerBToolStripMenuItem、intermediateIToolStripMenuItem、expertEToolStripMenuItem、settingSToolStripMenuItem 分别表示四个等级的菜单的名称，通过修改它们的 Checked 属性来达到修改对应项目前面勾的状态。我们还需要在初始化函数中调用这个函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// \u0026lt;summary\u0026gt; /// 游戏参数设置 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;Width\u0026#34;\u0026gt;雷区宽度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Height\u0026#34;\u0026gt;雷区高度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;MineCnt\u0026#34;\u0026gt;地雷数目\u0026lt;/param\u0026gt; private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; UpdateSize(); SelectLevel(); } 这时候，我们运行就会发现Beginner菜单前面的勾被选中了：\n菜单示意图\n下面我们来处理一下各个菜单按钮的事件，我们只需要双击菜单上的按钮，程序会自动创建对应的单击事件，我们只需要在其中书写代码即可。我们首先来创建 Beginner、Intermediate、Expert、Exit、About 菜单项目对应的事件。我们先介绍 Beginner、Intermediate、Expert 菜单项目对应的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private void beginnerBToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 10; nHeight = 10; nMineCnt = 10; SelectLevel(); } private void intermediateIToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 16; nHeight = 16; nMineCnt = 40; SelectLevel(); } private void expertEToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 30; nHeight = 16; nMineCnt = 99; SelectLevel(); } 接下来，我们处理 Exit 事件，我们希望在退出游戏之前询问游戏者是否确认退出，代码如下：\n1 2 3 4 5 6 7 private void exitXToolStripMenuItem_Click(object sender, EventArgs e) { if(MessageBox.Show(\u0026#34;Are you sure to exit the game?\u0026#34;, \u0026#34;Exit\u0026#34;, MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes) { Application.Exit(); } } 然后，我们来处理 About 事件，我们希望得到类似 Windows 默认关于窗口的界面。为此，首先我们需要引用一个类，在代码的开头部分加上下图高亮部分的代码：\n1 2 3 4 5 6 7 8 9 10 using System; using System.Collections.Generic; using System.ComponentModal; using System.Data; using System.Drawing; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; 为了实现这样的功能，我们需要调用 Windows 系统内部的一个 API，添加这样一个函数：\n1 2 3 4 5 6 7 8 9 10 /// \u0026lt;summary\u0026gt; /// 系统关于对话框（API） /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;hWnd\u0026#34;\u0026gt;窗口句柄\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;szApp\u0026#34;\u0026gt;标题文本\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;szOtherStuff\u0026#34;\u0026gt;内容文本\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;hIcon\u0026#34;\u0026gt;图标句柄\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; [DllImport(\u0026#34;shell32.dll\u0026#34;)] public extern static int ShellAbout(IntPtr hWnd, string szApp, string szOtherStuff, IntPtr hIcon); 在 About 事件中添加如下代码进行调用：\n1 2 3 4 private void aboutAToolStripMenuItem_Click(object sender, EventArgs e) { ShellAbout(this.Handle, \u0026#34;Minesweeper\u0026#34;, \u0026#34;A minesweeper game using CSharp language.\u0026#34;, this.Icon.Handle); } 运行以后查看结果如下图所示：\n关于\n可能细心的读者会发现，虽然我们通过菜单修改了游戏等级，但是我们窗口中的雷区却没有发生变化，因为我们没有在菜单被按下的时候没有调用 UpdateSize 函数。在三个按钮的事件中添加对 UpdateSize 函数的调用即可。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private void beginnerBToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 10; nHeight = 10; nMineCnt = 10; SelectLevel(); UpdateSize(); } private void intermediateIToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 16; nHeight = 16; nMineCnt = 40; SelectLevel(); UpdateSize(); } private void expertEToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 30; nHeight = 16; nMineCnt = 99; SelectLevel(); UpdateSize(); } 在此运行的时候，我们发现修改游戏等级的时候，游戏界面也会发生相应的变化。但是还有一点瑕疵，就是在大规模变成小规模的时候，边上会有多余的雷区。为了修正这个 Bug，我们需要将原来 Paint 事件中代码放在一个新的函数 PaintGame 中，同时添加高亮区域的代码，并且在 Paint 事件中进行调用，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private void Form_Main_Paint(object sender, PaintEventArgs e) { PaintGame(); } /// \u0026lt;summary\u0026gt; /// 绘制游戏区 /// \u0026lt;/summary\u0026gt; private void PaintGame() { Graphics g = this.CreateGraphics(); // 创建绘图句柄 g.FillRectangle(Brushes.White, new Rectangle(0, 0, this.Width, this.Height)); // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u0026lt;= nWidth; i++) // 绘制行 { for (int j = 1; j \u0026lt;= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } } } 除此之外，在UpdateSize最后也需要调用PaintGame函数，如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 /// \u0026lt;summary\u0026gt; /// 自动更新窗口大小 /// \u0026lt;summary\u0026gt; private void UpdateSize() { int nOffsetX = this.Width - this.ClientSize.Width; // 包含了窗口标题栏以及上下边框的高度 int nOffsetY = this.Height - this.ClientSize.Height; // 包含了左右边框的宽度 int nAdditionY = MenuStrip_Main.Height + TableLayoutPanel_Main.Height; // 包含了菜单栏以及下方显示信息栏的高度 this.Width = 12 + 34 * nWidth + nOffsetX; // 设置窗口高度，34 为每个雷区的高度，12 为上下总空隙（6px + 6px），再加上偏移量 this.Height = 12 + 34 * nHeight + nAdditionY + nOffsetY; // 设置窗口宽度，同理 PaintGame() } 再次运行的时候，就会发现边上多余的雷区已经消失了。\n接下来我们处理 Mark 以及 Audio 两个事件，我们需要定义两个变量来记录它们的数据，因为这对于我们以后的开发有很大的关系。如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 bool bMark; // 表示是否使用标记 bool bAudio; // 表示是否使用音效 } } 同样我们需要在游戏开始的时候读取上次的数据，如果没有则都设置为真。我们首先看 Setting 文件：\nSetting 文件配置\n同时加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public Form_Main() { InitializeComponent(); // 初始化游戏参数 nWidth = Properties.Settings.Default.Width; nHeight = Properties.Settings.Default.Height; nMineCnt = Properties.Settings.Default.MineCnt; // 初始化 bMark = Properties.Settings.Default.Mark; bAudio = Properties.Settings.Default.Audio; markMToolStripMenuItem.Checked = bMark; audioMToolStripMenuItem.Checked = bAudio; UpdateSize(); SelectLevel(); } 同时为 Mark 以及 Audio 菜单项目添加如下的事件：\n1 2 3 4 5 6 7 8 9 private void markMToolStripMenuItem_Click(object sender, EventArgs e) { markMToolStripMenuItem.Checked = bMark = !bMark; } private void audioMToolStripMenuItem_Click(object sender, EventArgs e) { audioMToolStripMenuItem.Checked = bAudio = !bAudio; } 至此，我们还剩 New Game、Setting、Rank 三个菜单选项的事件没有涉及，因为它们需用用到更多的内容，我们将会在下一节中进行讲解。\n","date":"2015-04-22T16:33:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%9B%9B%E8%8A%82%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C/","title":"扫雷游戏制作过程（CSharp 描述）：第四节、菜单操作"},{"content":"这一节我们主要涉及界面中雷区的绘制方法。\n首先来考虑几个问题。为了保存整个雷区的信息，我们需要哪些数据。显然，除了要保存雷区的宽度和高度（分别定义为宽和高方向上方块的个数）外，还需要保存地雷的数目。这样我们需要用到三个变量 nWidth, nHeight, nMineCnt 分别保存雷区的宽度、雷区的高度以及地雷的数目。\n右击窗口，选择查看代码，也可以使用快捷键 F7，如下图所示：\n菜单示意图\n可以看到这样的代码界面：\n代码界面\n添加如下所示的代码，用来定义扫雷区域的基本变量，它们的含义在上文或者注释中都有提及：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } } } 为了方便设置这三个参数，我们可以定义一个新的函数 SetGame，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } } } 这样，我们就可以通过调用 SetGame 函数来设置游戏的参数了。为了方便阅读，我们可以为这个函数加上一个注释，在函数名上方输入\u0026quot;///\u0026quot;，程序会自动生成一个注释块，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } /// \u0026lt;summary\u0026gt; /// /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;Width\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Height\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;MineCnt\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } } } 输入相关信息，第二行的内容是用来对函数的作用进行说明，下面的三行分别用来对三个参数的作用进行说明，将它们修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 /// \u0026lt;summary\u0026gt; /// 游戏参数设置 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;Width\u0026#34;\u0026gt;雷区宽度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Height\u0026#34;\u0026gt;雷区高度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;MineCnt\u0026#34;\u0026gt;地雷数目\u0026lt;/param\u0026gt; private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } 这样当我们输入这个函数的时候（当然，我们目前还不需要调用这个函数。），就会显示出来对应的注释，如下图所示：\n注释示意图\n到目前为止，我们的代码应该是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } /// \u0026lt;summary\u0026gt; /// 游戏参数设置 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;Width\u0026#34;\u0026gt;雷区宽度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Height\u0026#34;\u0026gt;雷区高度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;MineCnt\u0026#34;\u0026gt;地雷数目\u0026lt;/param\u0026gt; private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } } } 接下来我们可以定义几个辅助函数，分别表示设置游戏参数为初级、中级、高级，如下图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /// \u0026lt;summary\u0026gt; /// 设置游戏等级为初级 /// \u0026lt;/summary\u0026gt; private void SetGameBeginner() { SetGame(10, 10, 10); } /// \u0026lt;summary\u0026gt; /// 设置游戏等级为中级 /// \u0026lt;/summary\u0026gt; private void SetGameIntermediate() { SetGame(16, 16, 40); } /// \u0026lt;summary\u0026gt; /// 设置游戏等级为高级 /// \u0026lt;/summary\u0026gt; private void SetGameExpert() { SetGame(30, 16, 99); } 在我们开始游戏的时候，我们希望它自动获取上次的游戏设置，如果这是第一次开始游戏，那么将游戏设置为初级。\n我们先来看一下第一个需求，自动获取上次的游戏设置，这就意味着我们需要在上次游戏关闭的时候将上次的游戏设置保存下来。保存到哪里呢，我们在这里采用 Setting 文件来保存这些数据。工程创建的时候，系统会自动生成一个 Setting 文件。因此我们不需要自己创建，只需要使用原有的 Setting 文件即可。在右方解决方案资源管理器面板中展开 Properties，右击 Settings.settings，选择打开即可。\n解决方案资源管理器\n打开后的界面如图所示：\nSettings.settings 示意图\n按照下图对它进行设置，设置完成后按Ctrl + S进行保存。\nSettings.settings 设置示意图\n注意到第四栏值，我们将它初始化为初级的参数，也就完成了我们刚才的第二个需求——无法找到上一次设置的时候，我们将它置为初级模式。\n就行了，我们需要通过代码将这些参数读入到定义的变量中去，加入如下图所示的代码：\n1 2 3 4 5 6 7 8 9 public Form_Main() { InitializeComponent(); // 初始化游戏参数 nWidth = Properties.Settings.Default.Width; nHeight = Properties.Settings.Default.Height; nMineCnt = Properties.Settings.Default.MineCnt; } 有了这些参数我们就可以绘制雷区了，我们假定雷区为 32×32 的小方块，并且四周有一圈宽度为 1 的留白，用于与其它雷区区别，这样，每个雷区的实际大小为 34×34。\n接下去，我们将窗口切换到界面布局，选中主窗口，在左边的属性面板中，单击事件按钮，并找到 Paint 事件，双击该条目，系统会自动创建一个事件，我们将在这里绘制雷区。如下图所示：\n创建事件\n添加 Paint 事件以后，程序会自动跳到代码编辑窗口，并且会看到如下的代码：\n1 2 3 4 private void Form_Main_Paint(object sender, PaintEventArgs e) { } 将Paint函数中的内容修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private void Form_Main_Paint(object sender, PaintEventArgs e) { Graphics g = this.CreateGraphics(); // 创建绘图句柄 // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u0026lt;= nWidth; i++) // 绘制行 { for (int j = 1; j \u0026lt;= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } } } 然后，我们按下 Ctrl + F5 就可以看到下面的效果：\n阶段性效果\n看上去感觉样式很奇怪，后边多出了很多空白的区域，而且下方还有一些部分没有显示出来，因为我们还没有根据游戏的参数调整窗口的大小。新建一个名为 UpdateSize 的函数，输入下图的代码：\n1 2 3 4 5 6 7 8 9 10 11 /// \u0026lt;summary\u0026gt; /// 自动更新窗口大小 /// \u0026lt;summary\u0026gt; private void UpdateSize() { int nOffsetX = this.Width - this.ClientSize.Width; // 包含了窗口标题栏以及上下边框的高度 int nOffsetY = this.Height - this.ClientSize.Height; // 包含了左右边框的宽度 int nAdditionY = MenuStrip_Main.Height + TableLayoutPanel_Main.Height; // 包含了菜单栏以及下方显示信息栏的高度 this.Width = 12 + 34 * nWidth + nOffsetX; // 设置窗口高度，34 为每个雷区的高度，12 为上下总空隙（6px + 6px），再加上偏移量 this.Height = 12 + 34 * nHeight + nAdditionY + nOffsetY; // 设置窗口宽度，同理 } 接下来我们在 SetGame 函数中调用这个函数，使得修改游戏参数的时候自动修改窗口大小，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /// \u0026lt;summary\u0026gt; /// 游戏参数设置 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;Width\u0026#34;\u0026gt;雷区宽度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;Height\u0026#34;\u0026gt;雷区高度\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;MineCnt\u0026#34;\u0026gt;地雷数目\u0026lt;/param\u0026gt; private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; UpdateSize(); } 最后不要忘记了在初始化读入上次游戏参数后也需要修改窗口大小，代码如下：\n1 2 3 4 5 6 7 8 9 10 public Form_Main() { InitializeComponent(); // 初始化游戏参数 nWidth = Properties.Settings.Default.Width; nHeight = Properties.Settings.Default.Height; nMineCnt = Properties.Settings.Default.MineCnt; UpdateSize(); } 最后按 Ctrl + F5 编译运行，得到最终结果：\n运行效果\n到目前为止，扫雷的界面已经基本出来了，下一节我们主要介绍一下菜单的相关代码。\n","date":"2015-04-21T15:42:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E8%8A%82%E9%9B%B7%E5%8C%BA%E7%BB%98%E5%88%B6/","title":"扫雷游戏制作过程（CSharp 描述）：第三节、雷区绘制"},{"content":"这一节我们主要介绍关于扫雷游戏界面的设计，此处我们借鉴经典扫雷界面的设计方法，首先需要创建一个菜单栏。具体方法在左边找到工具箱窗口，展开其中的菜单和工具栏，找到 MenuStrip 选项，如图所示：\n添加 MenuStrip\n只需要双击该条目就可以在窗口中新建一个菜单栏，如图所示：\nMenuStrip 添加效果\n对于这个控件（我们习惯上将窗口中的东西称作为控件），我们还是需要修改它的一些属性，对于个人习惯而言，我习惯于修改它的 Name 属性，这样编程的时候不至于将很多控件混淆。我们将它的 Name 属性修改为“MenuStrip_Main”。单击“请在此键入”，输入“Game(\u0026amp;G)”，其中 \u0026amp;G 整体会显示成 G 这个字母下面加一个下划线，这样在用户使用的时候就可以通过按下字母 G 来访问这个按键了。（当然，顶层菜单还需要按下 Alt 键，例如 Alt + G 键。）输入以后的界面如图所示：\n添加菜单项\n使用同样的方法，创建如下图所示的一个菜单栏：\n菜单示意图\n注意到，图中的分割线，只需要输入一个减号，即“-”，再按下回车键即可得到。\n我们一次介绍一下各个选项的功能，以便读者对它们有一个基本的了解。菜单一共有两组，一个为游戏（Game），一个为帮助（Help）：其中游戏菜单下分别包含了新游戏（New Game）、初级（Beginner）、中级（Intermediate）、高级（Expert）、设置（Setting）、标记（Mark）、音效（Audio）、排行榜（Rank）、退出（Exit）；而帮助菜单下仅包含关于（About）。\n其中新游戏用来开始一场新的游戏；初级、中级、高级，用于选择不同的游戏难度；设置用于自定义扫雷区域的大小以及地雷的数目；标记用于设置是否启用红旗、问号这一类的标记；音效用于设置是否启用音效；排行榜用于对游戏时间进行排名（仅记录初级、中级、高级的结果，对于自定义游戏的结果不进行记录）；退出用于退出游戏。最后，关于用来显示游戏的一些关于信息。\n对于初级、中级、高级、标记、音效这几个菜单，我们需要在它的前面显示它的状态，即是否被选中，如果选中了就会在它的前面出现一个勾，如果没有选中，则没有，这是我们以后需要实现的功能，在此先进行说明。\n至此，我们的菜单栏就制作完成了。接下来我们需要制作一个用来记录地雷数目以及用时的功能。我们选择工具箱中容器的 TableLayoutPanel，双击该项目，会在窗口中创建一个 TableLayoutPanel 控件。同样我们先将它的 Name 属性修改为“TableLayoutPanel_Main”。展开它的 Size 属性，将 Height 属性修改为 48。同时修改它的 Dock 属性，选择 Bottom，如图所示：\nTableLayoutPanel 属性设置\n我们会发现它会自动吸附在底部，如果改成别的参数则会吸附在别的位置，这里我们设置为 Bottom。同时将 RowCount 属性设置为 1，ColumnCount 属性设置为 9。打开 Columns 属性对话框，按照下图进行修改：\nTableLayoutPanel 行列样式\n这里进行一些解释，其中 Column1、Column3、Column5、Column7、Column9 为中心对称的，用来设置边距，不放置任何控件，纯粹为了排版需要。接下来我们需要在 Column2、Column8 中分别放置地雷（Mine_Show.png）以及秒表（Timer.png）的图标，表示剩余的地雷数目以及已用时长。而 Columns4、Columns6 中分别放置用于显示地雷数目以及已用时长的文本。下载地址：地雷、秒表。\n在工具箱中展开公共控件，找到 PictureBox，将它拖动到 TableLayoutPanel 的第二个列中，同时将它的 Name 属性设置为“PictureBox_Mine”，Dock 属性设置为 Fill（表示充满整个页面，此处的页面即 TableLayoutPanel 中 Column2 全部），BackgroundImage 属性定位到Mine_Show.png文件（通过导入按钮），BackgroundImageLayout 属性设置为 Stretch（表示自动缩放图像大小）。使用同样的方法加入一个 PictureBox 控件，将它放到 Column8 中，同时将 Name 属性设置为“PictureBox_Timer”，BackgroundImage 属性定位到 Timer.png 文件，其余与 PictureBox_Mine 设置相同。其中图片导入的方法如下图所示：\nTableLayoutPanel PixtureBox 资源设置\n接下来我们需要添加两个用于显示内容的 Label 控件，展开工具箱中的公共控件，找到 Label 控件，分别拖动到 Column4 和 Column6，并且将 Dock 属性设置为 Fill，TextAlign 属性设置为 MiddleCenter（使文字显示在控件中心），Font 属性设置为“Consolas, 16.2pt”（即 Consolas 字体，字号三号）。其 Name 属性及 Text 属性分别修改为“Label_Mine”和“Label_Timer”。同时将它们的 ForeColor 属性分别设置为“DarkRed”和“HotTrack”（这项属性用于设置文字显示的颜色）。\n至此界面已经基本完成了，但是我们还需要增加一个控件——Timer，用来计时。展开工具箱中的组件，双击 Timer。这个控件不会在界面上显示，但是会在后台进行计时功能。同样，我们将它的 Name 属性修改为“Timer_Main”，Interval 属性修改为“1000”（这里为计时间隔，以毫秒为单位，此处为 1000 毫秒，即 1 秒计时一次）。\n最后按下 Ctrl + F5 进行编译查看结果，相较于第一节中的界面已经有了很大的改观，如图所示：\n运行效果\n到这里或许读者会问，最为重要的扫雷区域怎么制作呢，关于这个区域，我们将会使用程序来生成，而不是使用控件。我们将会在下一节中进行讲解。\n","date":"2015-04-20T19:31:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%8C%E8%8A%82%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/","title":"扫雷游戏制作过程（CSharp 描述）：第二节、界面设计"},{"content":"这一系列的文章主要受许宏旭的启发而来。他目前在连载更新一篇使用 C# 制作五子棋的教程。选择这一项目的主要原因是 Windows 8.1 系统上的扫雷需要前往应用商店下载，显得有些麻烦。因此想自己制作一个。主要采用 C# 语言进行实现。主要功能与原来的扫雷游戏基本相同，进行修改的地方主要是扫雷区的界面。如有不恰当的地方，还望指正。\n该项目现已根据文章进度托管在GitHub上，读者可以自行查看。\n玩过扫雷的读者应该知道，扫雷需要用到三种图片素材——地雷、红旗、问号。当右击一个方块的时候，会插上红旗，表示游戏者认为该方块内有地雷；再次右击该方块，会变成问号，表示不确定该方块内是否有地雷；第三次右击该方块，问号消失，恢复到初始的状态。我们前往Iconfinder寻找合适的图标，并且通过 Photoshop 或者 Illustrator 的处理得到我们所需要的图标。文章中含有下载地址的图标资源可以使用右键—目标另存为进行下载。\n通过一定的搜索以及图片的处理，我们得到了下面一组素材图标。\nMine Sweeper 素材\n除了这些素材以外，我们还需要找一个图标，使得整个程序看上去更加正式一点，这里使用图标如下，注意程序图标的后缀为ico。\nMine Sweeper 图标\n接下来，我们打开Visual Studio 2013开始创建工程，界面如下：\nVisual Studio 2013\n依次展开文件—新建—项目，选择“Visual C#”中的“Windows 窗体应用程序”，项目名称填写为“Minesweeper”，单击确定创建项目。如下图所示：\n创建项目\n创建好的项目如下图所示。\n项目创建完毕\n我们需要对这个窗口的几项属性进行修改，首先通过 Text 属性将它的标题修改为“Minesweeper”；通过FormBorderStyle属性将它的大小设置为“FixedSingle”，即为不可调节窗口大小；通过 MaximizeBox 属性将它的最大化按钮设置为“False”，即最大化按钮失效；通过 Name 属性将它的名称修改为“Form_Main”，修改这个属性主要用于后面书写代码的方便；通过 BackColor 属性将它的背景修改为“White”。如下图所示：\n属性修改\n我们可以顺便修改一下这个窗口的代码文件的名称。在右上方找到解决方案资源管理器，右击Form_1.cs—重命名—Form_Main.cs，程序会自动将下面包含的文件名也都改成一致的名称。如图所示：\n文件名修改\n接下来我们需要修改一下程序的图标，将刚才下载的 favicon 文件放到 Minesweeper/Minesweeper 文件夹下，同时将三个图标资源放到 Minesweeper/Minesweeper/Resources 文件夹下（Resources 文件夹需要自己新建），如下图所示：\n创建 Resources 文件夹\n在属性栏中找到 Icon 属性，并且定位到 favicon.ico 文件，如下图所示：\n设置 Icon\n此时，我们按下快捷键 Ctrl + S 对整个工程进行保存，并且按下快捷键 Ctrl + F5 运行查看我们的程序，效果如下：\n运行结果\n到目前为止，我们的程序只是一个空白的界面，下一节中我们将介绍程序的界面布局的设计。\n","date":"2015-04-20T17:58:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%80%E8%8A%82%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/","title":"扫雷游戏制作过程（CSharp 描述）：第一节、创建项目"},{"content":"HDU 2955 这是一道概率 DP，我第一次的想法是把概率 $P$ 乘以 100，变成一个背包然后做 0/1 背包，后来发现这样做是错误的。\n原因：概率应该是相乘，而不是相加。\n后来看了题解想到了另外一种方法，使用逃脱概率来计算，用 $f[j]$ 表示偷走 $j$ 价值后逃脱的概率。易知，多次逃脱概率为每次逃脱概率相乘。这里不使用被逮捕的概率是因为被逮捕的情况比较复杂（例如偷第一件物品不被逮捕，偷第二件物品被逮捕，被逮捕的概率应该为头第一件物品不被逮捕的概率乘以偷第二件物品不被逮捕的概率。），而当我们转而考虑它的对立事件——逃脱时，问题就会变得容易了，因为逃脱的概率永远是相乘的。\n更为严格的说法是这样的：设被第 $i$ 个银行逮捕的事件为 $P_i$，那么 $1-\\sum{P_i}$ 就是至少被一个银行逮捕的概率，也就是我们所需要求的被逮捕的概率。通过这样的数学上的说理，我们可以证明这一算法是正确的。\n由于要计算逃脱概率，我们可以在读入的时候就把可能被逮捕的概率 $P$ 变成可能逃脱的概率 $1 - P$。这样，状态转移方程为：$$ f[j] = \\max{\\left\\{f[j - \\mathrm{pValue}[i]] \\times \\mathrm{pCost}[i], f[j]\\right\\}}$$ 其中 $\\mathrm{pValue}[i]$ 表示第 $i$ 个银行的价值，$\\mathrm{pCost}[i]$ 表示偷第 $i$ 个银行逃脱的概率。\n这时候，我们还需要考虑一个转移条件，如果 $f[j - \\mathrm{pValue}[i]]$ 没有被更新过，那么是不能转移过来的。因为暂时没有一个状态可以偷到 $j - \\mathrm{pValue}[i]$ 价值的物品。\n接下来，我们要考虑一下初始条件，很显然 $f[0] = 1$，因为不偷任何东西，就不会被逮捕，逃脱的概率就为 1。其余 $f[j] = -1$，其中 $j \\neq 0$，表示暂时没有一个状态可以偷到 $j$ 价值的物品。\n最后扫一遍 $f[j]$，满足 $1 - f[j] \\leq P$ 的最大下标 $j$ 为满足题设条件的答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int pValue[MAX]; double pCost[MAX], f[MAX]; int main() { int T, M, V; double P; cin \u0026gt;\u0026gt; T; for(int k = 1; k \u0026lt;= T; k++) { f[0] = 1; V = 0; for(int i = 1; i \u0026lt; MAX; i++) { f[i] = -1; } cin \u0026gt;\u0026gt; P \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= M; i++) { cin \u0026gt;\u0026gt; pValue[i] \u0026gt;\u0026gt; pCost[i]; pCost[i] = 1 - pCost[i]; V += pValue[i]; } for(int i = 1; i \u0026lt;= M; i++) { for(int j = V; j \u0026gt;= pValue[i]; j--) { if(f[j - pValue[i]] != -1) { f[j] = max(f[j - pValue[i]] * pCost[i], f[j]); } } } int ans = 0; for(int i = 0; i \u0026lt;= V; i++) { if(1 - f[i] \u0026lt;= P) { ans = i; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 接触的第一道概率DP，发现DP非常的灵活，自己还有很多东西要学。 @ 2015年3月14日\nHDU 1864 这是一道较为典型的 0/1 背包，但是物品的价值和费用都需要自己处理出来。需要注意一下只能报销 A、B、C 类的发票。只要有一个条件不成立，就不报销该发票。\n输入两位小数的时候，把它乘以 100，做 0/1 背包就可以了，状态转移方程为：$$f[j] = \\max{\\left\\{f[j - \\mathrm{pValue}[i]] + \\mathrm{pCost}[i], f[j]\\right\\}}$$ 数据方面可能输入的时候没有给出小数部分，比如直接输入 100，而不是 100.00。但是题目中没有给出报销限额的数据范围，开到 3000000 就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; const int MAX = 3840000; int pHash[32]; int f[MAX], pValue[MAX], pCost[MAX]; int main() { int N, M, V, nCnt; string strTmp; double Q; while(cin \u0026gt;\u0026gt; Q \u0026gt;\u0026gt; N \u0026amp;\u0026amp; N) { V = Q * 100; nCnt = 0; memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= N; i++) { int nSum = 0; bool bFlag = true; cin \u0026gt;\u0026gt; M; memset(pHash, 0, sizeof(pHash)); for(int j = 1; j \u0026lt;= M; j++) { cin \u0026gt;\u0026gt; strTmp; pHash[strTmp[0] - \u0026#39;A\u0026#39;] += atof(strTmp.substr(2, strTmp.length() - 2).c_str()) * 100; } for(int j = 0; j \u0026lt; 32; j++) { if(j \u0026gt;= 3 \u0026amp;\u0026amp; pHash[j]) { bFlag = false; } nSum += pHash[j]; if(pHash[j] \u0026gt; 60000) { bFlag = false;} } if(nSum \u0026gt; 100000) { bFlag = false; } if(bFlag) { nCnt++; pValue[nCnt] = pCost[nCnt] = nSum; } } for(int i = 1; i \u0026lt;= nCnt; i++) { for(int j = V; j \u0026gt;= pCost[i]; j--) { f[j] = max(f[j - pCost[i]] + pValue[i], f[j]); } } int ans = 0; for(int i = 0; i \u0026lt;= V; i++) { ans = max(ans, f[i]); } cout \u0026lt;\u0026lt; ans / 100 \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; if(ans % 100 \u0026lt; 10 ) { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; } cout \u0026lt;\u0026lt; ans % 100 \u0026lt;\u0026lt; endl; } return 0; } 这道题目第一次 Hash 表的范围为 32，访问到了 MAX，所以导致了 Runtime Error。 @ 2015年3月14日\nHDU 1231 这道题目有一种贪心的做法，扫一遍 $\\mathrm{pData[i]}$ 求和（Sum += pData[i]），如果遇到当前和 $\\mathrm{Sum}$ 小于 0 的时候，就更新答案，并且把当前累加的和置为当前遍历到的数字 $\\mathrm{pData}[i]$。\n还会有一种动态规划的方法：$$f[i] = \\max{\\left\\{f[i - 1] + \\mathrm{pData}[i], \\mathrm{pData}[i]\\right\\}}$$ 每次更新以后都要更新答案。需要注意，如果最后最大的和还是负数的话，则输出 0 以及数据的首尾两个元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int l, r, ans, al, ar; int pData[MAX], f[MAX]; int main() { ios::sync_with_stdio(false); int K; while(cin \u0026gt;\u0026gt; K) { if(K == 0) { break; } for(int i = 1; i \u0026lt;= K; i++) { cin \u0026gt;\u0026gt; pData[i]; } l = r = al = ar = 1; ans = pData[1]; memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= K; i++) { if(f[i - 1] + pData[i] \u0026gt; pData[i]) { f[i] = f[i - 1] + pData[i]; r = i; } else { f[i] = pData[i]; l = r = i; } if(f[i] \u0026gt; ans) { ans = f[i]; al = l; ar = r; } } if(ans \u0026gt;= 0) { cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pData[al] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pData[ar] \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pData[1] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pData[K] \u0026lt;\u0026lt; endl; } } return 0; } 以前处理这类题目的时候都是使用贪心的方法，今天看到动态规划的方法，使得对于以前贪心的方法有了更深刻的理解。这两种方法的本质思想是相同的。 @ 2015年3月14日\nHDU 1003 这道题目上面一道题目是差不多的。状态转移方程为：$$f[i] = \\max{\\left\\{f[i - 1] + \\mathrm{pData}[i], \\mathrm{pData}[i]\\right\\}}$$ 唯一的一个区别是状态转移的时候并不能严格大于，因为它要找到第一个，因此左端点一定是越小越好。\n如果使用严格大于的话，假设前面有 $X$ 个数加起来等于 0，它并不影响最终和的答案，但是却使得求出的答案不是第一个了。\n其余的代码和上面一道题目没有太大的区别，注意一下输出格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 102400; int l, r, ans, al, ar; int pData[MAX], f[MAX]; int main() { ios::sync_with_stdio(false); int K, N; while(cin \u0026gt;\u0026gt; K) { for(int i = 1; i \u0026lt;= K; i++) { cin \u0026gt;\u0026gt; N; for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; pData[j]; } l = r = al = ar = 1; ans = pData[1]; memset(f, 0, sizeof(f)); for(int j = 1; j \u0026lt;= N; j++) { if(f[j - 1] + pData[j] \u0026gt;= pData[j]) // 此处为非严格大于 { f[j] = f[j - 1] + pData[j]; r = j; } else { f[j] = pData[j]; l = r = j; } if(f[j] \u0026gt; ans) { ans = f[j]; al = l; ar = r; } } cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; al \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ar \u0026lt;\u0026lt; endl; if(i != K) { cout \u0026lt;\u0026lt; endl; } } } return 0; } 这到题目一开始是用贪心做的，今天重新用动态规划做了一下。 @ 2015年3月14日\nHDU 1506 这道题目以前用单调栈做过，单调栈的思路如下：不断的将矩形入栈，当当前要加入的矩形的高度大于栈顶的矩形高度时，将栈顶的矩形出栈，与当前的矩形合成一个大的矩形，高度为较短的矩形的高度。然后把和合成的新的矩形加入栈顶，并且更新答案。这样扫一遍就好了。\n下面介绍DP的思想：我们首先考虑这样一件事情，一段矩形的面积取决于矩形的个数以及最矮的矩形的高度。我们可以枚举每一个矩形，然后往左右两边枚举连续比它高的矩形的总个数 $N$，那么就更新答案。\n下面就要考虑如何快速的求出左右两边连续比它高的矩形的总个数。\n我们不妨考虑左边的情况，用 $\\mathrm{pLeft}[i]$ 表示第 $i$ 个矩形左边连续比它高的矩形最左边的矩形的编号。那么如果我们有另外一个矩形 $j$，存在 $\\mathrm{pData}[j] \u0026lt; \\mathrm{pData}[i]$，我们就可以将 $\\mathrm{pLeft}[j]$ 置为 $\\mathrm{pLeft}[i]$，然后再往左迭代。需要注意的是，左右两边需要分开进行。因为从左往右只能保证 $\\mathrm{pLeft}$ 数组被更新了，可以进行迭代，而 $\\mathrm{pRight}$ 则还是类似之前的暴搜一样，复杂度很高，因此我们需要将左右两边分开迭代。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;stdio.h\u0026gt; const int MAX = 102400; long long pData[MAX], pLeft[MAX], pRight[MAX]; long long max(long long x, long long y); int main() { int N; long long ans; while(scanf(\u0026#34;%I64d\u0026#34;, \u0026amp;N) != EOF \u0026amp;\u0026amp; N) { ans = 0; for(int i = 1; i \u0026lt;= N; i++) { scanf(\u0026#34;%I64d\u0026#34;, \u0026amp;pData[i]); pLeft[i] = pRight[i] = i; } for(int i = 1; i \u0026lt;= N; i++) { int nCur = i - 1; while(nCur \u0026gt;= 1 \u0026amp;\u0026amp; pData[i] \u0026lt;= pData[nCur]) { pLeft[i] = pLeft[nCur]; nCur = pLeft[nCur] - 1; } } for(int i = N; i \u0026gt;= 1; i--) { int nCur = i + 1; while(nCur \u0026lt;= N \u0026amp;\u0026amp; pData[i] \u0026lt;= pData[nCur]) { pRight[i] = pRight[nCur]; nCur = pRight[nCur] + 1; } } for(int i = 1; i \u0026lt;= N; i++) { ans = max(ans, pData[i] * (pRight[i] - pLeft[i] + 1)); } printf(\u0026#34;%I64d\\n\u0026#34;, ans); } return 0; } long long max(long long x, long long y) { return x \u0026gt; y ? x : y; } 这道题目没有严格的状态转移方程，只有一个状态转移的思想。 @ 2015年3月15日\nHDU 1505 这道题目是上面一道题目的加强版，变成了一个二维的问题。我们可以这样转化。\n枚举每一行，每一行中的每个点向上搜有 $X$ 个连续的 \u0026lsquo;F\u0026rsquo;，就表示这个点所表示的的矩形的高度为 $X$，然后每一行使用一次上一道题目的动态规划思想即可，复杂度$O\\left(N^2 * \\log{N}\\right)$。\n关键问题在于如何在最短的时间内构造出这样的一个数组 $\\mathrm{pData}$，使得 $\\mathrm{pData}[i][j]$ 表示从第 $i$ 行第 $j$ 个向上搜索有几个连续的 \u0026lsquo;F\u0026rsquo;。\n我们可以考虑一个类似前缀和的思想，如果当前读入的地形为 \u0026lsquo;F\u0026rsquo;，那么 $\\mathrm{pData}[i][j] = \\mathrm{pData}[i - 1][j] + 1$，表示和上面组成一个更大的矩形；否则，$\\mathrm{pData}[i][j] = 0$，表示不能和上面的组成更大的矩形。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024; int pLeft[MAX], pRight[MAX]; int pMap[MAX][MAX], pData[MAX][MAX]; int main() { char dwTmp; int T, M, N; cin \u0026gt;\u0026gt; T; while(T) { T--; int ans = 0; memset(pData, 0, sizeof(pData)); cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= M; i++) { for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; dwTmp; pMap[i][j] = (dwTmp == \u0026#39;R\u0026#39; ? 1 : 0); if(!pMap[i][j]) { pData[i][j] = pData[i - 1][j] + 1; } else { pData[i][j] = 0; } } } for(int i = 1; i \u0026lt;= M; i++) { memset(pLeft, 0, sizeof(pLeft)); memset(pRight, 0, sizeof(pRight)); for(int j = 1; j \u0026lt;= N; j++) { pLeft[j] = pRight[j] = j; } for(int j = 1; j \u0026lt;= N; j++) { int nCur = j - 1; while(nCur \u0026gt;= 1 \u0026amp;\u0026amp; pData[i][j] \u0026lt;= pData[i][nCur]) { pLeft[j] = pLeft[nCur]; nCur = pLeft[nCur] - 1; } } for(int j = N; j \u0026gt;= 1; j--) { int nCur = j + 1; while(nCur \u0026lt;= N \u0026amp;\u0026amp; pData[i][j] \u0026lt;= pData[i][nCur]) { pRight[j] = pRight[nCur]; nCur = pRight[nCur] + 1; } } int nTmp = 0; for(int j = 1; j \u0026lt;= N; j++) { nTmp = max(nTmp, pData[i][j] * (pRight[j] - pLeft[j] + 1)); } ans = max(ans, nTmp); } cout \u0026lt;\u0026lt; ans * 3 \u0026lt;\u0026lt; endl; } return 0; } 这道题目需要一个转化的思想，把二维的地图转化为一维的情况，然后调用N遍处理一维问题的算法，就可以解决问题了。 @ 2015年3月15日\nHDU 2602 简单的 0/1 背包问题，状态转移方程：$$f[j] = \\max{\\left\\{f[j - \\mathrm{pCost}[i]] + \\mathrm{pValue}[i], f[j]\\right\\}}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024; int pCost[MAX], pValue[MAX], f[MAX]; int main() { int T, N, V; cin \u0026gt;\u0026gt; T; while(T) { T--; memset(f, 0, sizeof(f)); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pValue[i]; } for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pCost[i]; } for(int i = 1; i \u0026lt;= N; i++) { for(int j = V; j \u0026gt;= pCost[i]; j--) { f[j] = max(f[j - pCost[i]] + pValue[i], f[j]); } } int ans = 0; for(int i = 1; i \u0026lt;= V; i++) { ans = max(ans, f[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 这道题目比较简单。 @ 2015年3月15日\nHDU 1087 这道题目是求上升序列的最大和。用 $f[i]$ 表示以第 $i$ 个节点结尾可以达到的最大和，那讲最长上升序列改造一下即可，状态转移方程基本不变：$$f[i] = \\max{\\left\\{f[j]\\right\\}} + \\mathrm{pData}[i]$$ 其中 $1\\leq j \u0026lt; i$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024; int pData[MAX], f[MAX], pSum[MAX]; int main() { int N; while(cin \u0026gt;\u0026gt; N \u0026amp;\u0026amp; N) { for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pData[i]; } memset(f, 0, sizeof(f)); f[1] = pData[1]; for(int i = 2; i \u0026lt;= N; i++) { int nTmp = 0; for(int j = 1; j \u0026lt; i; j++) { if(pData[j] \u0026lt; pData[i]) { nTmp = max(nTmp, f[j]); } } f[i] = nTmp + pData[i]; } int ans = 0; for(int i = 1; i \u0026lt;= N; i++) { ans = max(ans, f[i]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 这道题目也不难。 @ 2015年3月15日\nHDU 2571 这是一道动态规划的题目，只不过转移的时候需要考虑的情况变多了。不但要考虑从点 $(i - 1, j)$，$(i, j - 1)$ 以及 $(i, j / k)$ 转移过来，其中 $k$ 为 $j$ 的约数。\n需要注意的是，数据可能为负数，因此需要将初值置为 -2147483647，更新的时候需要注意初值是否改变，如果没有改变，说明没有状态能够转移过来，因此不需要操作（也就是加 0），否则就把该数值加上去，并且在加上原来地图上的数值。\n还需要注意的时，转移的时候应该使用动态规划使用的数组，而不是地图上的数据。\n最后，状态转移方程为：$$ f[i][j] = \\max{\\left\\{f[i - 1][j], f[i][j - 1], f[i][\\frac{j}{k}]\\right\\}} + \\mathrm{pData}[i][j]$$ 其中 $f[i][j]$ 表示走到点 $(i, j)$ 能够获得的最大幸运值，同时 $k$ 是 $j$ 的约数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024; int pMap[MAX][MAX], f[MAX][MAX]; int main() { int C, N, M; cin \u0026gt;\u0026gt; C; while(C) { C--; memset(f, 0, sizeof(f)); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= M; j++) { cin \u0026gt;\u0026gt; pMap[i][j]; } } for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= M; j++) { int nTmp = -2147483647; if(i != 1) { nTmp = max(nTmp, f[i - 1][j]); } if(j != 1) { nTmp = max(nTmp, f[i][j - 1]); } for(int k = 2; k \u0026lt;= j; k++) { if(j % k == 0) { nTmp = max(nTmp, f[i][j / k]); } } f[i][j] = (nTmp == -2147483647 ? 0 : nTmp) + pMap[i][j]; } } cout \u0026lt;\u0026lt; f[N][M] \u0026lt;\u0026lt; endl; } return 0; } 这道题目和典型的走迷宫差不多，只是状态转移的时候需要考虑更多的情况。还需要注意的是输入的数据有负数的情况。 @ 2015年3月15日\nHDU 1069 这道题目也可以运用动态规划来求解，在此之前，我们需要处理几个小问题。\n首先是对于题目中所讲的每个矩形有无穷个的处理方法。根据题目条件，每类方块可以转化成3类方块考虑以哪条边为高度），再考虑底面的边长可以互换，因此无数个一类方块可以转化为有限的 6 个方块来求解。\n为了保证动态规划的正确性，我们需要对数据进行排序，可选的两种排序方法如下：\n按照 $x$ 递增，然后按照 $y$ 递增，最后按照 $z$ 递增； 按照 $xy$ 递增。 我们用 $f[i]$ 表示以第 $i$ 个方块为最后一个方块所能到达的最大高度。那么状态转移方程为：$$f[i] = \\max{\\left\\{f[j]\\right\\}} + \\mathrm{pData}[i].z$$ 其中 $pData[i].z$ 表示第 $i$ 个方块的高度，且满足 $1\\leq j \u0026lt; i$。\n此外转移的条件为可以将第 $i$ 个方块放到第 $j$ 个方块上面，或者第 $i$ 个方块可以放到第 $j$ 个方块的下面，即 $$\\begin{cases} \\mathrm{pData}[i].x \u0026lt; \\mathrm{pData}[j].x \\\\ \\mathrm{pData}[i].y \u0026lt; \\mathrm{pData}[j].y\\end{cases}\\quad\\mathrm{or}\\quad\\begin{cases}\\mathrm{pData}[i].x \u0026gt; \\mathrm{pData}[i].x\\\\ \\mathrm{pData}[i].y \u0026gt; \\mathrm{pData}[i].y\\end{cases}$$\n最后的答案就是 $\\max{\\left\\{\\mathrm{pData}[i].z\\right\\}}$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 512; struct Block { Block(int _x = 0, int _y = 0, int _z = 0) { x = _x; y = _y; z = _z; } int x, y, z; }; int cmp(Block a, Block b) { if(a.x != b.x) { return a.x \u0026lt; b.x; } else if(a.y != b.y) { return a.y \u0026lt; b.y; } else { return a.z \u0026lt; b.z; } } bool operator \u0026lt; (Block a, Block b) { return a.x \u0026lt; b.x \u0026amp;\u0026amp; a.y \u0026lt; b.y; } bool operator \u0026gt; (Block a, Block b) { return a.x \u0026gt; b.x \u0026amp;\u0026amp; a.y \u0026gt; b.y; } int f[MAX], ans; vector\u0026lt;Block\u0026gt; pVec; int main() { int N, nCase = 0, x, y, z; while(cin \u0026gt;\u0026gt; N \u0026amp;\u0026amp; N) { cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; \u0026#34;: maximum height = \u0026#34;; ans = 0; pVec.clear(); memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; pVec.push_back(Block(x, y, z)); pVec.push_back(Block(x, z, y)); pVec.push_back(Block(y, x, z)); pVec.push_back(Block(y, z, x)); pVec.push_back(Block(z, x, y)); pVec.push_back(Block(z, y, x)); } sort(pVec.begin(), pVec.end(), cmp); for(int i = 0; i \u0026lt; pVec.size(); i++) { int nTmp = 0; for(int j = 0; j \u0026lt; i; j++) { if(pVec[i] \u0026lt; pVec[j] || pVec[i] \u0026gt; pVec[j]) { nTmp = max(nTmp, pVec[j].z); } } pVec[i].z += nTmp; } for(int i = 0; i \u0026lt; pVec.size(); i++) { ans = max(ans, pVec[i].z); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 这道题目也是用了一个动态规划的思想，把数据排序以后就可以是用动态规划了。只是要注意可以放在上面也可以放在下面。还有就是把无穷个方块转化为 6 个方块，使得问题得到简化。 @ 2015年3月15日\nHDU 1171 将每种物品都变成 $M$ 个体积为 $V$ 的物品，然后进行一遍 0/1 背包。\n我们用 $f[j]$ 表示装体积为 $V$ 的物品是否可行（可行为 1，不可行为 0）。初始化时，对于每种物品均有 $f[V] = 0$;\n状态转移方程为：$$f[j] = 1 \\quad\\mathrm{iff.}~~ f[j - \\mathrm{pCost}[i]] = 1$$\n最后我们只要计算小于等于 $V / 2$ 的情况下最多能够装多少体积的物品，记作 $\\mathrm{ans}$。那么答案就是 $V - \\mathrm{ans}$ 以及 $\\mathrm{ans}$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024000; int V, C; int pCost[MAX], f[MAX]; int main() { int N, x, y; while(cin \u0026gt;\u0026gt; N) { if(N \u0026lt; 0) { break; } V = 0; C = 0; memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; for(int j = 1; j \u0026lt;= y; j++) { pCost[++C] = x; V += x; f[x] = 1; } } for(int i = 1; i \u0026lt;= C; i++) { for(int j = V; j \u0026gt;= pCost[i]; j--) { if(f[j - pCost[i]] == 1) { f[j] = 1; } } } int ans = 0; for(int i = 1; i \u0026lt;= V / 2; i++) { if(f[i]) { ans = i; } } cout \u0026lt;\u0026lt; V - ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 这道题目主要考察一个动态规划的思想，通过状态的转移来求解一共能够装多少体积的物品。 @ 2015年3月23日\nHDU 2084 数字三角形。状态转移方程为：$$f[i][j] += \\max{\\left\\{f[i + 1][j], f[i + 1][j + 1]\\right\\}}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024000; int V, C; int pCost[MAX], f[MAX]; int main() { int N, x, y; while(cin \u0026gt;\u0026gt; N) { if(N \u0026lt; 0) { break; } V = 0; C = 0; memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; for(int j = 1; j \u0026lt;= y; j++) { pCost[++C] = x; V += x; f[x] = 1; } } for(int i = 1; i \u0026lt;= C; i++) { for(int j = V; j \u0026gt;= pCost[i]; j--) { if(f[j - pCost[i]] == 1) { f[j] = 1; } } } int ans = 0; for(int i = 1; i \u0026lt;= V / 2; i++) { if(f[i]) { ans = i; } } cout \u0026lt;\u0026lt; V - ans \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 最为经典的动态规划题目。 @ 2015年3月23日\nHDU 1176 我们用 $f[i][j]$ 来表示第 $i$ 时间在第 $j$ 个位置上能够接到的馅饼总数。\n那么状态转移方程为：$$f[i][j] += \\max{\\left\\{f[i + 1][j - 1], f[i + 1][j], f[i + 1][j + 1]\\right\\}}$$\n这里采用倒推法，因为最后我们一开始的起始位置在 5。因此只需要输出 $f[0][5]$ 即可。\n当然，这里还需要处理一下边界 0 和 10 的情况，具体表现为：$$\\begin{cases} f[i][0] = f[i][0] + \\max{\\left\\{f[i + 1][0], f[i + 1][1]\\right\\}}\\\\ f[i][10] = f[i][10] + \\max{\\left\\{f[i + 1][9], f[i + 1][10]\\right\\}}\\end{cases}$$\n读入数据的时候，我们可以直接置 f[T][X]++，其中 $T$ 为时间点，$X$ 为坐标。\n最后，最大的时间点 $T$，我们从 $T-1$ 遍历到0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 102400; int f[MAX][16]; int max(int x, int y); int max(int x, int y, int z); int main() { ios::sync_with_stdio(false); int N, X, T, nCnt = 0; while(cin \u0026gt;\u0026gt; N \u0026amp;\u0026amp; N) { memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; X \u0026gt;\u0026gt; T; f[T][X]++; nCnt = max(nCnt, T); } for(int i = nCnt - 1; i \u0026gt;= 0; i--) { f[i][0] += max(f[i + 1][0], f[i + 1][1]); for(int j = 1; j \u0026lt; 10; j++) { f[i][j] += max(f[i + 1][j - 1], f[i + 1][j], f[i + 1][j + 1]); } f[i][10] += max(f[i + 1][9], f[i + 1][10]); } cout \u0026lt;\u0026lt; f[0][5] \u0026lt;\u0026lt; endl; } return 0; } int max(int x, int y) { return x \u0026gt; y ? x : y; } int max(int x, int y, int z) { return max(x, max(y, z)); } 这道题目也是考虑状态的转移。 @ 2015年3月23日\nHDU 1203 这道题目和一开始做到的 HDU 2955 是差不多的题目，也是一道概率 DP。同样我们考虑它的反面，用 $f[j]$ 表示花费 $j$ 万元被所有 offer 拒绝的最小概率，也就对应着至少被一个 offer 接受的最大概率。\n与之不同的是，我们在这里不需要考虑转移的条件，直接置所有的 $f[j] = 1$。而状态转移方程则为：$$f[j] = \\min{\\left\\{f[j - \\mathrm{pCost}[i]] \\times \\mathrm{pValue}[i], f[j]\\right\\}}$$ 最后输出的时候注意一下格式即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; const int MAX = 10240; int pCost[MAX]; double pValue[MAX], f[MAX]; int main() { int N, M; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M) { if(N == 0 \u0026amp;\u0026amp; M == 0) { break; } for(int i = 1; i \u0026lt;= M; i++) { cin \u0026gt;\u0026gt; pCost[i] \u0026gt;\u0026gt; pValue[i]; pValue[i] = 1 - pValue[i]; } for(int i = 0; i \u0026lt;= N; i++) { f[i] = 1; } for(int i = 1; i \u0026lt;= M; i++) { for(int j = N; j \u0026gt;= pCost[i]; j--) { f[j] = min(f[j - pCost[i]] * pValue[i], f[j]); } } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(1) \u0026lt;\u0026lt; (1 - f[N]) * 100 \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 又是一道概率 DP。 @ 2015年3月23日\nHDU 2159 这是一个二维完全背包，一个装杀怪数目，一个装忍耐值。\n我们使用 $f[j][k]$ 表示杀了 $j$ 个怪兽，使用了 $k$ 个忍耐值，能够获得的最大经验。\n那么状态转移方程为：$$f[j][k] = \\max{\\left\\{f[j - 1][k - \\mathrm{pBare}[i]] + \\mathrm{pExp}[i], f[j][k]\\right\\}}$$\n最后，若 $f[S][M] \u0026lt; N$，则无解。否则我们需要求解能够升级的情况下所使用的最少的忍耐值 nTmp，输出 M - nTmp 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 128; int pExp[MAX], pBare[MAX]; int f[MAX][MAX]; int main() { int N, M, K, S; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K \u0026gt;\u0026gt; S) { memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= K; i++) { cin \u0026gt;\u0026gt; pExp[i] \u0026gt;\u0026gt; pBare[i]; } for(int i = 1; i \u0026lt;= K; i++) { for(int j = 1; j \u0026lt;= S; j++) { for(int k = pBare[i]; k \u0026lt;= M; k++) { f[j][k] = max(f[j - 1][k - pBare[i]] + pExp[i], f[j][k]); } } } if(f[S][M] \u0026lt; N) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { int nTmp = M; for(int i = 0; i \u0026lt;= S; i++) { for(int j = M; j \u0026gt;= 0; j--) { if(f[i][j] \u0026gt;= N) { nTmp = min(nTmp, j); } } } cout \u0026lt;\u0026lt; M - nTmp \u0026lt;\u0026lt; endl; } } return 0; } 第一次做二维背包的问题，感觉理解透了，也不怎么难。 @ 2015年3月23日\nHDU 2577 我们令 $f[i]$、$g[i]$ 分别表示输入完 $i$ 个字符后，Caps Lock 灯关与开的状态下所需要的按键次数，易得状态转移方程：\n第 $i$ 个字母小写：$$f[i] = \\min{\\left\\{f[i - 1] + 1, g[i - 1] + 2\\right\\}},\\quad g[i] = \\min{\\left\\{f[i - 1] + 2, g[i - 1] + 2\\right\\}}$$ 第 $i$ 个字母大写：$$f[i] = \\min{\\left\\{f[i - 1] + 2, g[i - 1] + 2\\right\\}},\\quad g[i] = \\min{\\left\\{f[i - 1] + 2, g[i - 1] + 2\\right\\}}$$ 下面我们来分析一下上面的状态转移方程：第 $i$ 个字母小写，要保持最后 Caps Lock 灯关，那么在灯关的状态下直接输入字母，因此为 f[i - 1] + 1；在灯开的状态下关灯，输入字母，因此为 g[i - 1] + 2。如果要保持最后 Caps Lock 灯开，在灯关的状态下输入字母，开灯，因此为 f[i - 1] + 2；在灯开的状态下 Shift + 字母，因此为 g[i - 1] + 2。当第 $i$ 个字母大写的情况类似。\n初始条件如下：\n第 1 个字母小写：$f[0] = 1,\\quad g[0] = 2$ 第 1 个字母大写：$f[0] = 2,\\quad g[0] = 2$ 最后答案为 min(f[x.length() - 1], g[x.length() - 1] + 1)，因为最后 Caps Lock 灯要保持关闭状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 128; int f[MAX], g[MAX]; bool IsUpper(char x); bool IsLower(char x); int main() { int N; string x; while(cin \u0026gt;\u0026gt; N) { for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x; memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); if(IsLower(x[0])) { f[0] = 1; g[0] = 2; } else { f[0] = 2; g[0] = 2; } for(int j = 1; j \u0026lt; x.length(); j++) { if(IsLower(x[j])) { f[j] = min(f[j - 1] + 1, g[j - 1] + 2); g[j] = min(f[j - 1] + 2, g[j - 1] + 2); } else { f[j] = min(f[j - 1] + 2, g[j - 1] + 2); g[j] = min(f[j - 1] + 2, g[j - 1] + 1); } } cout \u0026lt;\u0026lt; min(f[x.length() - 1], g[x.length() - 1] + 1) \u0026lt;\u0026lt; endl; } } return 0; } bool IsUpper(char x) { return x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;Z\u0026#39;; } bool IsLower(char x) { return x \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;; } 这道题目需要用两个数组来维护不同的两种状态，使得问题得到简化。 @ 2015年4月5日\nHDU 2844 一个很明显的思路是构造 $C_i$ 个物品 $A_i$，然后做一遍 0/1 背包即可。但是会 TLE，因此需要寻求优化的方法。\n在这里我们采用二进制拆分的方法。对于 $C_i$ 个物品 $A_i$，将它拆分成 $A_i \\times (1 + 2 + 4 + 8 + 16 + \u0026hellip; + \\mathrm{left})$，根据二进制的知识，我们知道通过这样的方法可以获得 $1 \\times A_i, 2 \\times Ai, \\cdots C_i \\times Ai$ 的各个数值。证明如下：\n这就等效于证明可以从 $1, 2, 4, 8, 16, \\cdots , \\mathrm{left}$ 中选取任意个数字组成 $1, 2, 3,\\cdots , C_i$。我们将这些数字写成二进制的形式，会发现这与前面的拆分是一一对应的。因此这样拆分物品不影响结果的正确性，接下来做一遍 0/1 背包即可出解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 102400; int f[MAX]; int pValue[MAX], pData[MAX]; int main() { int N, M, nTmp; ios::sync_with_stdio(false); while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M) { int nCnt = 0; if(N == 0 \u0026amp;\u0026amp; M == 0) { break; } memset(f, 0, sizeof(f)); f[0] = 1; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pValue[i]; } for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; nTmp; for(int j = 1; j \u0026lt;= nTmp; j \u0026lt;\u0026lt;= 1) { pData[++nCnt] = pValue[i] * j; nTmp -= j; } if(nTmp) { pData[++nCnt] = pValue[i] * nTmp; } } for(int i = 1; i \u0026lt;= nCnt; i++) { for(int v = M; v \u0026gt;= pData[i]; v--) { if(f[v - pData[i]]) { f[v] = 1; } } } int ans = 0; for(int i = 1; i \u0026lt;= M; i++) { ans += f[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } 第一次接触到二进制拆分的思路，感觉很巧妙，值得学习。 @ 2015年4月5日\n未完待续\u0026hellip;\n","date":"2015-03-14T13:22:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-hdu/","title":"动态规划 - HDU"},{"content":"Description Every city in Berland is situated on $Ox$ axis. The government of the country decided to build new telecasting station. After many experiments Berland scientists came to a conclusion that in any city citizens displeasure is equal to product of citizens amount in it by distance between city and TV-station. Find such point on $Ox$ axis for station so that sum of displeasures of all cities is minimal.\nInput Input begins from line with integer positive number $N$ ($0\u0026lt;N\u0026lt;15000$) – amount of cities in Berland. Following $N$ pairs $(X, P)$ describes cities ($0\u0026lt;X, P\u0026lt;50000$), where $X$ is a coordinate of city and $P$ is an amount of citizens. All numbers separated by whitespace(s).\nOutput Write the best position for TV-station with accuracy $10^{-5}$.\nSample Input 1 2 3 4 5 4 1 3 2 1 5 2 6 2 Sample Output 1 3.00000 Analysis 这道题目有几个地方需要注意：\n最后精确到 $10^{-5}$ 的要求基本是多余的，只要在结果后面再输出“.00000”； 本题使用了 Special Judge，因此答案可能不唯一。 有了上面两点的认识，我们来考虑一般的解决方案。我们不妨考虑电视台建在城市中，很容易证明，这也是这个问题的一个解。\n我们不妨把所有的城市列出来，比如样例输入中，一共有 8 个城市，我们把它们认为是不同的，并且列成一排：\n$$(1, 1)\\quad (1, 2)\\quad (1, 3)\\quad (2, 4)\\quad (5, 5)\\quad (5, 6)\\quad (6, 7)\\quad (6, 8)$$\n其中第一个数字表示城市的位置，第二个数字表示第几个城市。很容易发现，我们需要求的是最中间的那个城市。\n如果城市数目为奇数，那么我们所需要求的就是第 S / 2 + 1 个城市，其中 $S$ 表示城市总数； 如果城市数目为偶数，那么我们可以输出第 S / 2 个城市或第 S / 2 + 1 个城市。 为了方便起见，我们都取第 S / 2 + 1 个城市，这并不会对答案的这正确性产生影响。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct City { City(int _P = 0, int _M = 0) { P = _P; M = _M; } int P, M; }; int cmp(City x, City y) { return x.P \u0026lt; y.P; } vector\u0026lt;City\u0026gt; pCity; int main() { int N, P, M; while(cin \u0026gt;\u0026gt; N) { int nCnt = 0; pCity.clear(); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; P \u0026gt;\u0026gt; M; pCity.push_back(City(P, M)); nCnt += M; } sort(pCity.begin(), pCity.end(), cmp); int nTmp = nCnt / 2 + 1; int nPos = 0; for(; nTmp \u0026gt; 0; nPos++) { if(nTmp - pCity[nPos].M \u0026gt; 0) { nTmp -= pCity[nPos].M; } else { break; } } cout \u0026lt;\u0026lt; pCity[nPos].P \u0026lt;\u0026lt; \u0026#34;.00000\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 这道题目主要是一开始说明的两点要注意一下，否则会 WA 很多次。\n","date":"2015-03-07T19:37:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-114-telecasting-station/","title":"SGU 114 - Telecasting station"},{"content":"Description Inspired by a \u0026ldquo;Little Bishops\u0026rdquo; problem, Petya now wants to solve problem for rooks.\nA rook is a piece used in the game of chess which is played on a board of square grids. A rook can only move horizontally and vertically from its current position and two rooks attack each other if one is on the path of the other.\nGiven two numbers $n$ and $k$, your job is to determine the number of ways one can put $k$ rooks on an $n\\times n$ chessboard so that no two of them are in attacking positions.\nInput The input file contains two integers $n$ ($1\\leq n\\leq 10$) and $k$ ($0\\leq k\\leq n^2$).\nOutput Write index $I$ for given number as the first number in line. Write $I$ super-primes numbers that are items in optimal presentation for given number. Write these $I$ numbers in order of non-increasing.\nSample Input 1 6 Sample Output 1 2 2 3 3 Analysis 由于 $K$ 个车每行只能放一个，所以一共有 $K!$ 种情况，一共有 $N\\times N$ 的棋盘，行列选择共 $\\binom{N}{k}\\cdot \\binom{N}{k}$ 种情况。因此，通过排列组合，我们有 $$\\mathrm{ans} = \\binom{N}{k}\\cdot \\binom{N}{k}\\cdot K!$$ 化简可得 $$\\mathrm{ans} = \\frac{N!}{K!\\cdot (N - K)!}\\cdot\\frac{N!}{(N - K)!}$$\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MAX = 16; unsigned long long f[MAX]; int main() { f[0] = 1; for(int i = 1; i \u0026lt; MAX; i++) { f[i] = f[i - 1] * i; } int N, K; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K) { if(K \u0026gt; N) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; f[N] / f[K] / f[N - K] * f[N] / f[N - K] \u0026lt;\u0026lt; endl; } } return 0; } 还以为类似八皇后，准备写 Check 函数，后来发现只是简单的排列组合而已。\n","date":"2015-03-07T14:26:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-222-little-rooks/","title":"SGU 222 - Little Rooks"},{"content":"Description You task is to find minimal natural number $N$, so that $N!$ contains exactly $Q$ zeroes on the trail in decimal notation. As you know $N! = 1\\cdot2\\cdots N$. For example, $5! = 120$, 120 contains one zero on the trail.\nInput One number $Q$ written in the input ($0\\leq Q\\leq 10^8$).\nOutput Write \u0026ldquo;No solution\u0026rdquo;, if there is no such number $N$, and $N$ otherwise.\nSample Input 1 2 Sample Output 1 10 Analysis 统计 $N!$ 末尾 0 的个数，其实只要看因数 2 和 5 个数的最小值，因为只有 $2\\times 5$ 会产生 0。然而实际上因数 2 的个数远大于因数 5 的个数，所以只要看因数 5 的个数。\n由于题目给出的空间限制只有 4096KB，所以不能打表，会 MLE。百度题解以后发现可以用二分。\n二分的时候统计 1 到 $N$ 这 $N$ 个数中因数 5 的个数，我们采用这样的方法：$$\\mathrm{ans} = \\left\\lfloor\\frac{N}{5}\\right\\rfloor + \\left\\lfloor\\frac{N}{5^2}\\right\\rfloor + \\left\\lfloor\\frac{N}{5^3}\\right\\rfloor + \\cdots $$\n处理这个过程有两种方法，一个是打表，把 5 的幂次打表出来，还有一种利用类似秦九邵算法的思想，每次 ans += N / 5，同时 N /= 5。\n需要注意的是，当输入 0 的时候，要输出 1，因为 0 不是自然数。还有二分的上下界应为 $[1, 2147483647]$。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 2147483647; int main() { int N; while(cin \u0026gt;\u0026gt; N) { if(N == 0) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; continue; } int l = 1, r = MAX, ans = -1; while(l \u0026lt;= r) { int nMid = (l + r) \u0026gt;\u0026gt; 1; int nTmp = nMid, nCnt = 0; while(nTmp) { nCnt += nTmp / 5; nTmp /= 5; } if(nCnt == N) { ans = nMid; r = nMid - 1; } else if(nCnt \u0026lt; N) { l = nMid + 1; } else { r = nMid - 1; } } if(ans == -1) { cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } return 0; } 这道题目一开始 WA 了好几次，后来发现是二分的上界设置的太小了。\n","date":"2015-03-07T13:18:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-154-factorial/","title":"SGU 154 - Factorial"},{"content":"Description On a circle border there are $2k$ different points $A_1, A_2, \\cdots , A_{2k}$, located contiguously. These points connect $k$ chords so that each of points $A_1, A_2, \\cdots, A_{2k}$ is the end point of one chord. Chords divide the circle into parts. You have to find $N$ - the number of different ways to connect the points so that the circle is broken into minimal possible amount of parts $P$.\nInput The first line contains the integer $k$ ($1\\leq k\\leq 30$).\nOutput The first line should contain two numbers $N$ and $P$ delimited by space.\nSample Input 1 2 Sample Output 1 23 Analysis 我们可以采用分治的方法，固定某个点，从其上引一条弦，将圆分成左右两部分。我们可以将这两部分看成新的圆，那么方案数就是这两个圆的方案数相乘。即：$$f[N] = \\sum{\\left(f[i - 1] \\cdot f[N - i]\\right)}$$ 其中 $1\\leq i\\leq N$。$f[i-1]$ 表示左边的圆，为 $k = i - 1$ 时的情况，$f[N - i]$ 为右边的圆，表示 $k = N - i$ 时的情况。这样，我们只要递推一下就可以了。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 32; long long f[MAX]; int main() { int N; f[0] = 1; f[1] = 1; f[2] = 2; for(int i = 3; i \u0026lt; MAX; i++) { for(int j = 1; j \u0026lt;= i; j++) { f[i] += f[j - 1] * f[i - j]; } } while(cin \u0026gt;\u0026gt; N) { cout \u0026lt;\u0026lt; f[N] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; N + 1 \u0026lt;\u0026lt; endl; } return 0; } 这也算是一道数学题，然而想到分治这一点还是有些难度的。\n","date":"2015-03-07T11:04:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-130-circle/","title":"SGU 130 - Circle"},{"content":"Description Famous Berland ACM-ICPC team Anisovka consists of three programmers: Andrew, Michael and Ilya. A long time ago, during the first few months the team was founded, Andrew was very often late to the trainings and contests. To stimulate Andrew to be more punctual, Ilya and Andrew decided to introduce a new rule for team participants. If somebody is late (i.e. comes at least one second after appointed time) he owes a cup of tea to other team members. If he is late for 5 minutes, he owes two cups of tea. If he is late for 15 minutes, he owes three cups of tea. And if he is late for 30 minutes or more, he owes 4 cups of tea.\nThe training starts at the time $S$ (counted in seconds, from some predefined moment of time) and Andrew comes at the time $P$ (also in seconds, counted from the same moment of time).\nYour task is to find how many cups of tea Andrew owes.\nInput The input file contains single line with integer numbers $S$ and $P$ ($0\\leq S, P\\leq 10^4$).\nOutput Write to the output file the number of cups Andrew owes.\nSample Input #1 1 10 10 Sample Output #1 1 0 Sample Input #2 1 10 11 Sample Output #2 1 1 Sample Input #3 1 0 300 Sample Output #3 Analysis 水题。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int S, P; while(cin \u0026gt;\u0026gt; S \u0026gt;\u0026gt; P) { int nDiff = P - S; if(nDiff \u0026lt;= 0) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else if(nDiff \u0026gt;= 1 \u0026amp;\u0026amp; nDiff \u0026lt; 300) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; } else if(nDiff \u0026gt;= 300 \u0026amp;\u0026amp; nDiff \u0026lt; 900) { cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; } else if(nDiff \u0026gt;= 900 \u0026amp;\u0026amp; nDiff \u0026lt; 1800) { cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; 4 \u0026lt;\u0026lt; endl; } } return 0; } 练练手。\n","date":"2015-03-07T09:48:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-276-andrews-troubles/","title":"SGU 276 - Andrew's Troubles"},{"content":"Description There are two boxes. There are $A$ balls in the first box, and $B$ balls in the second box ($0 \u0026lt; A + B \u0026lt; 2147483648$). It is possible to move balls from one box to another. From one box into another one should move as many balls as the other box already contains. You have to determine, whether it is possible to move all balls into one box.\nInput The first line contains two integers $A$ and $B$, delimited by space.\nOutput First line should contain the number $N$ - the number of moves which are required to move all balls into one box, or -1 if it is impossible.\nSample Input 1 2 6 Sample Output 1 2 Analysis 模拟法 设定一个规定步数（经过反复测试，在给定的数据范围内32步即可满足要求），如果在规定步数内完成任务，则输出步数，否则输出-1。\n数学法 首先我们有一个结论 $(x, y)$ 与 $\\left(\\frac{x}{\\mathrm{gcd}(x, y)}, \\frac{y}{\\mathrm{gcd}(x, y)}\\right)$ 具有相同的答案。\n证明：我们可以运用整体的思想，将 $\\mathrm{gcd}(x, y)$ 个球看成一个球。例如 5 5，我们可以看成 1 1，其中后面的 1 代表了 5 个小球。\n有了上面的结论，我们只需要处理 $(X, Y)$ 即可，其中 $$ X = \\frac{x}{\\mathrm{gcd}(x, y)},\\quad Y = \\frac{y}{\\mathrm{gcd}(x, y)}$$ 很明显，当 $X + Y$ 为奇数时无解，因为要完成任务，必定有状态 $(A, A)$ 出现，其中 $A = \\frac{X + Y}{2}$。\n接下来，我们来推到一般解的情况，令 $N = X + Y$，并设 $K$步完成任务：\n步骤数目 解空间状态 $K$ $(N, 0)$ $K - 1$ $(N / 2, N / 2)$ $K - 2$ $(N / 4, 3N / 4)$ $K - 3$ $(N / 8, 7N / 8), (5N / 8, 3N / 8)$ $K - 4$ $(N / 16, 15N / 16), (9N / 16, 7N / 16), (5N / 16, 11N / 16), (13N / 16, 3N / 16)$ $\\cdots$ $\\cdots$ 我们可以看到，当 $N$ 为 2 的幂次时有解，其中 2 的指数则为所需要的步骤数（这也就验证了模拟时只需要 32 步即可），这样我们就可以很轻松的解决这个问题了。\nSolution 模拟法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 32; int main() { int x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { int nCnt = 0; while(x != 0 \u0026amp;\u0026amp; y != 0 \u0026amp;\u0026amp; nCnt \u0026lt;= MAX) { if(x \u0026lt;= y) { y -= x; x += x; } else { x -= y; y += y; } nCnt++; } if(x != 0 \u0026amp;\u0026amp; y != 0) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; } } return 0; } 数学法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; int gcd(int x, int y); int main() { int x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { int nCnt = 0; int nTmp = gcd(x, y); x /= nTmp; y /= nTmp; int nSum = x + y; while(nSum \u0026gt; 1) { if(nSum \u0026amp; 1) { nCnt = -1; break; } else { nCnt++; nSum \u0026gt;\u0026gt;= 1; } } if(x == 0 || y == 0) { nCnt = 0; } cout \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; } } int gcd(int x, int y) { if(y == 0) { return x; } else { return gcd(y, x % y); } } 这道数学题想了好久，终于AC了，主要在于一个逆推的过程以及看出 $(x, y)$ 与 $\\left(\\frac{x}{\\mathrm{gcd}(x, y)}, \\frac{y}{\\mathrm{gcd}(x, y)}\\right)$ 同解。\n","date":"2015-03-07T09:28:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-126-boxes/","title":"SGU 126 - Boxes"},{"content":"Description Let $f(n)$ be a sum of digits for positive integer $n$. If $f(n)$ is one-digit number then it is a digital root for $n$ and otherwise digital root of $n$ is equal to digital root of $f(n)$. For example, digital root of 987 is 6. Your task is to find digital root for expression $$ A_1\\cdot A_2\\cdots A_N + A_1\\cdot A_2\\cdots A_{N-1} + \\cdots + A_1\\cdot A_2 + A_1$$\nInput Input file consists of few test cases. There is $K$ ($1\\leq K\\leq 5$) in the first line of input.\nEach test case is a line. Positive integer number $N$ is written on the first place of test case ($N\\leq 1000$). After it there are $N$ positive integer numbers (sequence $A$). Each of this numbers is non-negative and not more than $10^9$.\nOutput Write one line for every test case. On each line write digital root for given expression.\nSample Input 1 2 1 3 2 3 4 Sample Output 1 5 Analysis 结论题：$f(n) \\equiv n \\mod 9$。\n证明如下：\n令 $$n = a_0 \\cdot 10^{p_0} + a_1 \\cdot 10_{p_1} + \\cdots + a_{m-1} \\cdot 10^1 + a_m \\cdot 10^0$$ 其中 $n$ 为 $m$ 位数。则 $$n \\mod 9 = a_0 + a_1 + \\cdots + a_{m-1} + a_m = f(n)$$ 即 $$f(n) \\equiv n \\mod 9$$ 证毕。\n需要注意的是，当 $n \\mod 9 = 0$ 的时候，$f(n) = 9$。\n读入的时候要先把数据 mod 9，否则中间计算过程会超 int。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 1024; int pData[MAX]; int main() { int T, N; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { int ans = 0; cin \u0026gt;\u0026gt; N; for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; pData[j]; pData[j] %= 9; } for(int j = 1; j \u0026lt;= N; j++) { int nTmp = 1; for(int k = 1; k \u0026lt;= j; k++) { nTmp *= pData[k]; if(nTmp \u0026gt;= 9) { nTmp %= 9; } } ans += nTmp; if(ans \u0026gt;= 9) { ans %= 9; } } cout \u0026lt;\u0026lt; (ans == 0 ? 9 : ans) \u0026lt;\u0026lt; endl; } } 又是一个数论结论，结论题有时候还是挺难想到的。\n","date":"2015-02-24T15:18:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-118-digital-root/","title":"SGU 118 - Digital Root"},{"content":"Description Find amount of numbers for given sequence of integer numbers such that after raising them to the $M$-th power they will be divided by $K$.\nInput Input consists of two lines. There are three integer numbers $N, M, K$ ($0\u0026lt;N, M, K\u0026lt;10001$) on the first line. There are N positive integer numbers − given sequence (each number is not more than 10001) − on the second line.\nOutput Write answer for given task.\nSample Input 1 2 4 2 50 9 10 11 12 Sample Output 1 1 Analysis 快速幂，时间复杂度为 $O(n\\log{n})$，应该是可以过的。\n要注意用 int 的话会溢出，所以我直接用了 unsigned long long。\n这道题目还有一个方法是质因数分解，求出 $M$ 次方以后的各个因数个数（就是把个因子个数乘以 $M$），然后和 $M$ 的个因子的个数比较即可。\nSolution 快速幂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; using namespace std; typedef unsigned long long ull; ull Pow(ull x, ull y, ull z); int main() { ull nTmp; int N, M, K; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K) { int nCnt = 0; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; nTmp; if(Pow(nTmp, M, K) == 0) { nCnt++; } } cout \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; } return 0; } ull Pow(ull x, ull y, ull z) { if(y == 1) { return x % z; } ull nTmp = Pow(x, y / 2, z); if(y \u0026amp; 1) { return (ull)nTmp * nTmp * x % z; } else { return (ull)nTmp * nTmp % z; } } 质因数分解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int X[MAX], Y[MAX]; void Fact(int x, int *p); int main() { int nTmp; int N, M, K; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K) { int nCnt = 0; memset(Y, 0, sizeof(Y)); Fact(K, Y); for(int i = 1; i \u0026lt;= N; i++) { memset(X, 0, sizeof(X)); cin \u0026gt;\u0026gt; nTmp; Fact(nTmp, X); for(int i = 0; i \u0026lt; MAX; i++) { X[i] *= M; } bool bFlag = true; for(int j = 0; j \u0026lt; MAX; j++) { if(X[j] \u0026lt; Y[j]) { bFlag = false; break; } } if(bFlag) { nCnt++; } } cout \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; } return 0; } void Fact(int x, int *p) { for(int i = 2; i \u0026lt;= x; i++) { if(x % i == 0) { while(x % i == 0) { (*(p + i))++; x /= i; } } } } 这道题目使用快速幂需要将整除转换成 mod 以后余 0。\n","date":"2015-02-24T14:14:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-117-counting/","title":"SGU 117 - Counting"},{"content":"Description You want to arrange the window of your flower shop in a most pleasant way. You have $F$ bunches of flowers, each being of a different kind, and at least as many vases ordered in a row. The vases are glued onto the shelf and are numbered consecutively 1 through $V$, where $V$ is the number of vases, from left to right so that the vase 1 is the leftmost, and the vase $V$ is the rightmost vase. The bunches are moveable and are uniquely identified by integers between 1 and $F$. These id-numbers have a significance: They determine the required order of appearance of the flower bunches in the row of vases so that the bunch i must be in a vase to the left of the vase containing bunch $j$ whenever $i \u0026lt; j$.\nSuppose, for example, you have bunch of azaleas (id-number=1), a bunch of begonias (id-number=2) and a bunch of carnations (id-number=3). Now, all the bunches must be put into the vases keeping their id-numbers in order. The bunch of azaleas must be in a vase to the left of begonias, and the bunch of begonias must be in a vase to the left of carnations. If there are more vases than bunches of flowers then the excess will be left empty. A vase can hold only one bunch of flowers.\nEach vase has a distinct characteristic (just like flowers do). Hence, putting a bunch of flowers in a vase results in a certain aesthetic value, expressed by an integer. The aesthetic values are presented in a table as shown below. Leaving a vase empty has an aesthetic value of 0.\nVASES 1 2 3 4 5 Bunches 1 (azaleas) 7 23 -5 -24 16 2 (begonias) 5 21 -4 10 23 3 (carnations) -21 5 -4 -20 20 According to the table, azaleas, for example, would look great in vase 2, but they would look awful in vase 4.\nTo achieve the most pleasant effect you have to maximize the sum of aesthetic values for the arrangement while keeping the required ordering of the flowers. If more than one arrangement has the maximal sum value, any one of them will be acceptable. You have to produce exactly one arrangement.\n$1\\leq F\\leq 100$ where $F$ is the number of the bunches of flowers. The bunches are numbered 1 through $F$.\n$F\\leq V\\leq 100$ where $V$ is the number of vases.\n$-50\\leq A_{i,j}\\leq 50$ where $A_{i,j}$ is the aesthetic value obtained by putting the flower bunch $i$ into the vase $j$.\nInput The first line contains two numbers: $F$, $V$.\nThe following $F$ lines: Each of these lines contains $V$ integers, so that $A_{i,j}$ is given as the $j$\u0026lsquo;th number on the $(i+1)$\u0026lsquo;st line of the input file.\nOutput The first line will contain the sum of aesthetic values for your arrangement.\nThe second line must present the arrangement as a list of $F$ numbers, so that the $k$\u0026lsquo;th number on this line identifies the vase in which the bunch $k$ is put.\nSample Input 1 2 3 4 3 5 7 23 -5 -24 16 5 21 -4 10 23 -21 5 -4 -20 20 Sample Output 1 2 53 2 4 5 Analysis 经典的动态规划题。我们令 $f[i][j]$ 表示前 $i$ 束花放到前 $j$ 个花瓶中获得的最大的魅力值。\n由于花束必须按编号递增安排，所以我们可以得到状态转移方程：$$ f[i][j] = \\max{\\left(f[i][j - 1], f[i - 1][j - 1] + \\mathrm{pData}[i][j]\\right)}$$ 即 $f[i][j]$ 这个状态可以由 $f[i][j - 1]$（第 $i$ 束花不放在第 $j$ 个花瓶里）以及 $f[i - 1][j - 1]$（第 $i$ 束花放在第 $j$ 个花瓶里）转移过来。\n这道题目还需要输出方案，我们需要记录转移过程。我的方法是令一个结构体，保存它是由那个状态转移过来的，并且是否放置了花束。输出方案的时候递归输出即可。\n还有一个注意点，题目中的魅力值可能为负数。这为我们初始化 $f$ 数组的时候带来了问题。\n我选择的解决方案是把魅力值加上一个偏移量 100，保证了魅力值为正数，然后把 $f$ 数组全部置为 0，输出的时候把魅力值减去 $100\\times F$ 即可。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 128; struct State { State(int _x = 0, int _y = 0, int _k = 0) { x = _x; y = _y; k = _k; } int x, y, k; }; int f[MAX][MAX], pData[MAX][MAX]; State pAns[MAX][MAX]; void Print(int x, int y); int main() { ios::sync_with_stdio(false); int F, V; while(cin \u0026gt;\u0026gt; F \u0026gt;\u0026gt; V) { memset(f, 0, sizeof(f)); for(int i = 1; i \u0026lt;= F; i++) { for(int j = 1; j \u0026lt;= V; j++) { cin \u0026gt;\u0026gt; pData[i][j]; pData[i][j] += 100; } } for(int i = 1; i \u0026lt;= F; i++) { for(int j = 1; j \u0026lt;= V; j++) { if(f[i][j - 1] \u0026lt; f[i - 1][j - 1] + pData[i][j]) { f[i][j] = f[i - 1][j - 1] + pData[i][j]; pAns[i][j] = State(i - 1, j - 1, 1); } else { f[i][j] = f[i][j - 1]; pAns[i][j] = State(i, j - 1, 0); } } } cout \u0026lt;\u0026lt; f[F][V] - 100 * F \u0026lt;\u0026lt; endl; Print(F, V); cout \u0026lt;\u0026lt; endl; } return 0; } void Print(int x, int y) { if(x == 0 \u0026amp;\u0026amp; y == 0) { return; } State tmp = pAns[x][y]; Print(tmp.x, tmp.y); if(tmp.k == 1) { cout \u0026lt;\u0026lt; tmp.y + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } 这道题目一开始 WA 了好几次，后来发现是没有发现魅力值为负数的时候，把 $f$ 数组初始化为 0 会导致错误答案。\n","date":"2015-02-24T13:13:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-104-little-shop-of-flowers/","title":"SGU 104 - Little shop of flowers"},{"content":"Description Dominoes – game played with small, rectangular blocks of wood or other material, each identified by a number of dots, or pips, on its face. The blocks usually are called bones, dominoes, or pieces and sometimes men, stones, or even cards.\nThe face of each piece is divided, by a line or ridge, into two squares, each of which is marked as would be a pair of dice\u0026hellip;\nThe principle in nearly all modern dominoes games is to match one end of a piece to another that is identically or reciprocally numbered.\nENCYCLOPÆDIA BRITANNICA\nGiven a set of domino pieces where each side is marked with two digits from 0 to 6. Your task is to arrange pieces in a line such way, that they touch through equal marked sides. It is possible to rotate pieces changing left and right side.\nInput The first line of the input contains a single integer $N$ ($1\\leq N\\leq 100$) representing the total number of pieces in the domino set. The following $N$ lines describe pieces. Each piece is represented on a separate line in a form of two digits from 0 to 6 separated by a space.\nOutput Write \u0026ldquo;No solution\u0026rdquo;”\u0026quot; if it is impossible to arrange them described way. If it is possible, write any of way. Pieces must be written in left-to-right order. Every of $N$ lines must contains number of current domino piece and sign \u0026ldquo;+\u0026rdquo; or \u0026ldquo;-\u0026rdquo; (first means that you not rotate that piece, and second if you rotate it).\nSample Input 1 2 3 4 5 6 5 1 2 2 4 2 4 6 4 2 1 Sample Output 1 2 3 4 5 2 - 5 + 1 + 3 + 4 - Analysis 这道题目做了好久好久，终于 AC 了。\n我第一次看到这道题目完全不知道怎么做，第二次觉得可以 dfs。后来看了题解，发现是欧拉通路。\n我们将 0~6 这 7 个数字看成点，每个多米诺骨牌看成一条无向边，构建一张图。\n这边用到一个 trick，我们设置 pVisited 数组的时候，不一定要判断点是否访问过，我们也可以用来判断边是否访问过，这样我们就可以使用边集数组来保存这张图。\n欧拉通路也就是一笔画问题，它区别于欧拉回路（欧拉回路要求回到起始点）。\n思路很简单，首先确定起点：\n度为奇数的点的总数为 0，任选一个点为起点； 度为奇数的点的总数为 2，任选两个点中的某个点为起点； 其他情况下无解。 接下来就是写欧拉通路了，之前在一个 NOIP 的参考资料上看到一个 dfs 的版本，按着它写了一遍，一直 WA，后来发现，他的方法好像有问题。\n除此之外，还需要判断自环，也就是如果这张图不连通，那么显然是无解的。\n还有，选择起点的时候，任意返回一个点，需要注意这个点必须是出现过的点，否则就会 WA。\n经过这么多的思考，重新写了不知道多少遍代码，终于 AC 了。\n最后还在“No solution”中“s”的大小写问题上 PE 了一次。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 128; const int SIZE = 8; struct Node { int s, e; }; struct Path { int x; char y; }; int N; bool bFlag; bool pVisited[MAX]; int pDegree[SIZE], pMap[SIZE][SIZE]; Node pNode[MAX]; Path pPath[MAX]; int Check(); void dfs(int nStart, int nFlag, int nStep); int main() { int x, y; while(cin \u0026gt;\u0026gt; N) { bFlag = false; memset(pMap, 0, sizeof(pMap)); memset(pVisited, false, sizeof(pVisited)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; pMap[x][y]++; pMap[y][x]++; pNode[i].s = x; pNode[i].e = y; } int nStart = Check(); if(nStart == -1) { cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; } else { for(int i = 1; i \u0026lt;= N; i++) { if(pNode[i].s == nStart) { dfs(i, 1, 1); break; } else if(pNode[i].e == nStart) { dfs(i, 2, 1); break; } } } if(!bFlag) { cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34; \u0026lt;\u0026lt; endl; } } } int Check() { memset(pDegree, 0, sizeof(pDegree)); int nCnt = 0, nPos = pNode[1].s; for(int i = 0; i \u0026lt; SIZE; i++) { for(int j = 0; j \u0026lt; SIZE; j++) { pDegree[i] += pMap[i][j]; } } for(int i = 0; i \u0026lt; SIZE; i++) { if(pDegree[i] % 2) { nCnt++; nPos = i; } } if(nCnt == 0 || nCnt == 2) { return nPos; } else { return -1; } } void dfs(int nStart, int nFlag, int nStep) { if(bFlag) { return; } pVisited[nStart] = true; pPath[nStep].x = nStart; pPath[nStep].y = (nFlag == 1) ? \u0026#39;+\u0026#39; : \u0026#39;-\u0026#39;; if(nStep == N) { for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; pPath[i].x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pPath[i].y \u0026lt;\u0026lt; endl; } bFlag = true; } int nNext = (nFlag == 1) ? pNode[nStart].e : pNode[nStart].s; for(int i = 1; i \u0026lt;= N; i++) { if(!pVisited[i]) { if(pNode[i].s == nNext) { dfs(i, 1, nStep + 1); } else if(pNode[i].e == nNext) { dfs(i, 2, nStep + 1); } pVisited[i] = false; } } } 终于 AC 了这道题目，写了好久好久了。\n","date":"2015-02-22T13:10:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-101-domino/","title":"SGU 101 - Domino"},{"content":"Description His Royal Highness King of Berland Berl XV was a very wise man and had a very accomplished wife, who was aware of the fact, that prominent and outstanding personalities once having written down their names on the pages of glorious History, remain there forever. His Royal Highness King Berl XV experienced an intrinsic, lost nowadays, deep and sincere sense of respect and trust for his beloved spouse. So he decided to acquire a chronicler of his own. Due to the ambiguous nature of misunderstanding and the crying injustice of history to ambiguity, he decided to leave all his royal responsibilities aside and made up his royal mind to find the chronicler, who will make him famous, depicting all his heroic deeds truthfully and gloriously enough.\nThe King assembled the greatest minds of his kingdom at the Academic Chroniclers Meeting (ACM), as he named it, and decided to test their might. The task was to build the Smallest Lexicographical Concatenation (SLC) out of the given $N$ strings. SLC of $N$ strings $s_1,\\cdots, s_N$ is the lexicographically smallest their concatenation $s_{i_1} + \\cdots + s_{i_N}$, where $ i_1,\\cdots, i_N $ is a permutation of integers from 1 through $N$. It\u0026rsquo;s a great privilege to be a chronicler, so don\u0026rsquo;t miss your chance and don\u0026rsquo;t screw it up! Make the king choose you!\nInput The first line of the input file contains a single integer $N$ ($1\\leq N\\leq 100$) indicating the number of strings. The following $N$ lines contain $N$ strings, one string per line. The length of each string is no more than 100 characters. Each string consists only of lowercase Latin letters. There are no any leading or trailing spaces.\nOutput Print the SLC of the given $N$ strings to the output file as a single line.\nSample Input 1 2 3 4 5 6 7 6 it looks lilke an easy problem Sample Output 1 aneasyitlikelooksproblem Analysis 一开始没看题意，只看了输入输出，以为是按字典序连接后输出，后来才发现是使得连接后的字典序最小。\n既然要使得连接后的字典序列最小，那么对于任意两个相邻的字符串 $x, y$ 当且仅当 $x + y$ 的字典序比 $y + x$ 的字典序大的时候交换，因此直接排序即可。\n对于直接按字典序最小排序输出的一个很好的反例是：对于两个字符串 ac 和 aca，应该输出 acaac，而不是 acaca。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MAX = 128; string pData[MAX]; int cmp(string x, string y) { return x + y \u0026lt; y + x; } int main() { int N; while(cin \u0026gt;\u0026gt; N) { for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pData[i]; } sort(pData + 1, pData + N + 1, cmp); for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; pData[i]; } cout \u0026lt;\u0026lt; endl; } return 0; } 这道题目总的来说不难，但是要把总的字典序最小转换到排序的问题上，本身还是具有一定难度的。\n而且以后一定要认真看题，不能直接看输入输出。\n不过觉得这道题目好像还在考英语。\n","date":"2015-02-22T13:10:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-347-join-the-strings/","title":"SGU 347 - Join the Strings"},{"content":"Description Find coordinates of any $\\triangle ABC$ if it is know that $|AB|=c$, $|AC|=b$, $|AM|=m$, $AM$ is a median of triangle.\nInput There are three real numbers in input: $c$, $b$, $m$ ($0\u0026lt;c, b, m\\leq 10^3$) separated by a space. Length of the fractional part of each number is not greater than 2 digits.\nOutput If solution exists, write three lines. Write coordinates of point $A$ to first line, coordinates of $B$ to second line and coordinates of $C$ to third line. Separate numbers by a space; absolute value of each coordinate must not exceed $10^4$. Write numbers with 5 digits after decimal point. If there is no solution, write \u0026ldquo;Mission impossible\u0026rdquo;.\nSample Input 1 5 5 3 Sample Output 1 2 3 0.00000 3.00000 -4.00000 0.00000 4.00000 0.00000 Analysis 解析几何的题目，因为是任意输出一个 $\\triangle ABC$，为了简化计算，我们不妨令点 $A$ 为坐标原点，即 $A(0, 0)$。同时，我们可以令点 $B$ 在 $x$ 轴上，即 $B(c, 0)$。这样，问题就转化成了求解点 $C$ 的坐标了。根据中学有关解析几何的知识，我们可以得出下面的求解过程：\n设 $C(x, y)$，则 $M\\left(\\frac{x + c}{2}, \\frac{y}{2}\\right)$。得方程组：$$\\begin{align}x^2 + y^2 \u0026amp;= b^2 \\\\ (\\frac{x + c}{2})^2 + (\\frac{y}{2})^2 \u0026amp;= m^2 \\end{align}$$ 将上面两个式子联立，化简即可得到：$$\\begin{cases}x = \\frac{4 m^2 - b^2 - c^2}{2c} \\\\ y = \\sqrt{b^2 - x^2}\\end{cases}$$ 接下来要判断是否有解，一种方法是根据上面两个方程推导有解的条件，另一种方法是直接判断 $y^2$ 是否大于等于 0。这里我们采用第二种方法，因为不需要额外推导公式，利用已有的结果就可以得出我们需要的答案。\n要特别注意的是，在这里，很可能出现 \u0026ldquo;-0.00000\u0026rdquo; 的情况，对于这种情况，我们需要进行特殊处理。使得它等于 0。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int Check(double x); int main() { double c, b, m; while(cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; b \u0026gt;\u0026gt; m) { double x = (4 * m * m - b * b - c * c) / (2 * c), y = b * b - x * x; if(Check(y) \u0026gt;= 0) { if(Check(x) == 0) { x = 0; } if(Check(y) == 0) { y = 0; } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; 0.0 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 0.0 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 0.0 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sqrt(y) \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Mission impossible\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } int Check(double x) { if(fabs(x) \u0026lt; 1E-9) { return 0; } else { return x \u0026gt; 0 ? 1 : -1; } } 本来在刷小白书的课后习题，但是记到简单的链表和堆栈让我 WA 了很久，所以就去 SGU 上找了几道题目刷刷。\n做题目的时候一直遇不到 AC 很容易打击积极性。\n这道题目主要在于推到公式，以及注意对于浮点数 \u0026ldquo;-0.00000\u0026rdquo; 这种情况的处理。\n","date":"2015-02-22T12:33:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-151-construct-a-triangle/","title":"SGU 151 - Construct a triangle"},{"content":"Description There are $N$ integers ($1\\leq N\\leq 65537$) $A_1, A_2,\\cdots, A_N$ ($0\\leq A_i\\leq 10^9$). You need to find amount of such pairs $(i, j)$ that $1\\leq i \u0026lt; j\\leq N$ and $A[i]\u0026gt;A[j]$.\nInput The first line of the input contains the number $N$. The second line contains $N$ numbers $A_1,\\cdots,A_N$.\nOutput Write amount of such pairs.\nSample Input 1 2 5 2 3 1 5 4 Sample Output 1 3 Analysis 逆序数。树状数组即可。每次更新 $A[i]$ 为 1，然后所有的逆序数就是 $$A[i] - \\sum{\\left(A[i] - 1\\right)} + 1$$ 更新的同时获取答案。\n注意答案可能会超 int，所以使用 long long。\n数据中 $A[i]$ 的值过大，但是 $N$ 最大只有 65537，所以使用离散化即可，离散化只要 sort 一下，然后用 lower_bound 即可。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 102400; int N; int T[MAX], A[MAX], B[MAX]; int LowBit(int x); void Update(int x, int y); long long Sum(int x); int main() { while(cin \u0026gt;\u0026gt; N) { long long ans = 0; memset(T, 0, sizeof(T)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; A[i]; B[i] = A[i]; } sort(B + 1, B + N + 1); for(int i = 1; i \u0026lt;= N; i++) { A[i] = lower_bound(B + 1, B + N + 1, A[i]) - B; } for(int i = 1; i \u0026lt;= N; i++) { Update(A[i], 1); ans += A[i] - Sum(A[i] - 1) - 1; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } int LowBit(int x) { return x \u0026amp; (-x); } void Update(int x, int y) { while(x \u0026lt;= N) { T[x] += y; x += LowBit(x); } } long long Sum(int x) { long long ans = 0; while(x) { ans += T[x]; x -= LowBit(x); } return ans; } 最近整理了一下树状数组，准备刷一下树状数组专题，这道题目是非常基础的应用。\n","date":"2015-02-17T11:58:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-180-inversions/","title":"SGU 180 - Inversions"},{"content":"断断续续终于刷完了计算几何专题，感觉太麻烦，小错误不断，尤其是精度问题。还有输出问题，有时候 printf 比 cout 要方便。\nUVaOJ 10250 给出正方形的一组对角坐标，求另外两个坐标，用三角函数推到公式。\n不妨设两点为 $A(x_1, y_1)$ 和 $C(x_2, y_2)$，则中点为 $G\\left(\\frac{x_1 + x_2}{2}, \\frac{y_1 + y_2}{2}\\right)$，对角线长度为 $L = \\sqrt{(x_1 - x_2)^2 - (y_1 - y_2)^2}$。\n设直线 $AC$ 与 $x$ 轴的夹角为 $\\alpha$，则 $$\\sin\\alpha = \\frac{y_2 - y_1}{L},\\quad \\cos\\alpha = \\frac{x_2 - x_1}{L}$$\n则另外两个坐标分别为 $$B\\left(G_x - \\frac{1}{2}\\cdot L \\cdot \\sin, G_y + \\frac{1}{2}\\cdot L \\cdot \\cos\\alpha\\right),\\quad D\\left(G_x + \\frac{1}{2}\\cdot L \\cdot \\sin\\alpha, G_y - \\frac{1}{2}\\cdot L \\cdot \\cos\\alpha\\right)$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; struct Point { double x, y; }; int main() { Point a, b; while(cin \u0026gt;\u0026gt; a.x \u0026gt;\u0026gt; a.y \u0026gt;\u0026gt; b.x \u0026gt;\u0026gt; b.y) { Point c, d; double l = hypot(a.x - b.x, a.y - b.y); double sin = (a.y - b.y) / l; double cos = (a.x - b.x) / l; double x = (a.x + b.x) / 2.0; double y = (a.y + b.y) / 2.0; c.x = x - l * sin * 0.5; c.y = y + l * cos * 0.5; d.x = x + l * sin * 0.5; d.y = y - l * cos * 0.5; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(10) \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d.x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d.y \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 579 时钟每小时走 $30^\\circ$，分钟每分钟走 $6^\\circ$，模拟即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { int h, m; while(scanf(\u0026#34;%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m) != EOF) { if(h == 0 \u0026amp;\u0026amp; m == 0) { break; } if(h == 12) { h = 0; } double dAngle = (h * 30.0 + m / 2.0) - m * 6.0; if(dAngle \u0026lt; 0) { dAngle = -dAngle; } if(dAngle \u0026gt; 180) { dAngle = 360 - dAngle; } printf(\u0026#34;%.3f\\n\u0026#34;, dAngle); } return 0; } UVaOJ 375 等腰三角形内接圆直到半径小于 $10^{-6}$，根据几何关系推得半径 $$r = \\tan{\\frac{1}{2}\\cdot\\left[\\arctan{\\frac{2\\cdot \\mathrm{Height}}{\\mathrm{Width}}}\\right]}\\cdot \\frac{\\mathrm{Width}}{2} $$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; const double PI = 4.0 * atan(1.0); int main() { int T; double x, y; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); for(int i = 1; i \u0026lt;= T; i++) { scanf(\u0026#34;%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y); double dSum = 0; double r = tan(atan(y / x * 2) / 2) * x / 2; while(r \u0026gt;= 1E-6) { dSum += r; x = x / y * (y - 2 * r); y -= 2 * r; r = tan(atan(y / x * 2) / 2) * x / 2; } printf(\u0026#34;%13.6lf\\n\u0026#34;, 2 * PI * dSum); if(i != T) { printf(\u0026#34;\\n\u0026#34;); } } return 0; } UVaOJ 10387 根据几何关系，速度 $v = L / t$，角度为 $$\\arctan{\\frac{y}{x}} \\times \\frac{180}{\\pi}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { double PI = acos(-1.0); double a, b, s, m, n; while(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; s \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n) { if(a == 0 \u0026amp;\u0026amp; b == 0 \u0026amp;\u0026amp; s == 0 \u0026amp;\u0026amp; m == 0 \u0026amp;\u0026amp; n == 0) { break; } double x = a * m, y = b * n; double l = hypot(x, y); cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; atan(y / x) * 180.0 / PI \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; l / s \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10112 枚举各个点，判断是否满足条件，求三角形面积可以使用三阶行列式，判断点是否在三角形内可以使用 $S_{\\triangle ABC} = S_{\\triangle ABD} + S_{\\triangle ACD} + S_{\\triangle BCD}$ 来判断。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; const int MAX = 128; struct Tri { char dwLabel; int x, y; }; Tri pTri[MAX]; double fabs(double x); double Area(int i, int j, int k); bool Check(int i, int j, int k, int nPos); string Solve(int N); int main() { int N; while(1) { cin \u0026gt;\u0026gt; N; if(N == 0) { break; } cin.ignore(); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pTri[i].dwLabel \u0026gt;\u0026gt; pTri[i].x \u0026gt;\u0026gt; pTri[i].y; cin.ignore(); } cout \u0026lt;\u0026lt; Solve(N) \u0026lt;\u0026lt; endl; } return 0; } string Solve(int N) { double dMax = 0; string strAns = \u0026#34;000\u0026#34;; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { if(i == j) { continue; } for(int k = 1; k \u0026lt;= N; k++) { if(k == i || k == j) { continue; } int nPos; for(nPos = 1; nPos \u0026lt;= N; nPos++) { if(nPos == i || nPos == j || nPos == k) { continue; } if(Check(i, j, k, nPos)) { break; } } if(nPos == N + 1 \u0026amp;\u0026amp; Area(i, j, k) \u0026gt; dMax) { dMax = Area(i, j, k); strAns[0] = pTri[i].dwLabel; strAns[1] = pTri[j].dwLabel; strAns[2] = pTri[k].dwLabel; } } } } return strAns; } double Area(int i, int j, int k) { return fabs(0.5 * ((pTri[k].y - pTri[i].y) * (pTri[j].x - pTri[i].x) - (pTri[j].y - pTri[i].y) * (pTri[k].x - pTri[i].x))); } bool Check(int i, int j, int k, int nPos) { double dSum = Area(i, j, nPos) + Area(i, k, nPos) + Area(j, k, nPos); double dGap = dSum - Area(i, j, k); return (fabs(dGap) \u0026lt; 1E-8); } 终于把小白书第一部分的推荐题目刷完了，总计 65 道。\n","date":"2015-02-17T11:37:00+08:00","permalink":"https://ivy-end.github.io/p/acm-icpc-%E5%AF%92%E5%81%87%E7%BB%83%E4%B9%A0-07/","title":"ACM-ICPC 寒假练习 07"},{"content":"这一次主要是数论专题，感到思维量比上一次的数学题要多多了。同样的问题也是英文题看起来有些吃力。\nUVaOJ 575 这应该算不上是一个数论题，它重新定义了一种进制转换的公式，然后根据公式计算即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; int Pow(int x, int y); int main() { string x; while(cin \u0026gt;\u0026gt; x) { if(x == \u0026#34;0\u0026#34;) { break; } int ans = 0; for(int i = 0; i \u0026lt; x.length(); i++) { ans += (x[i] - \u0026#39;0\u0026#39;) * (Pow(2, x.length() - i) - 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } int Pow(int x, int y) { int ret = 1; for(int i = 1; i \u0026lt;= y; i++) { ret *= x; } return ret; } UVaOJ 10110 这是一道典型的数论题，最后亮着的灯，它的开关一定被拨动了奇数次。所以，我们只要看它的因数个数的奇偶性。\n记得高中数学竞赛的时候遇到过类似的题目，有一个结论——完全平方数的因数有奇数个，非完全平方数的因数有偶数个。\n这个命题的证明有些繁琐，读者自己思考一下就会发现，这个结论是正确的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { long long N; while(cin \u0026gt;\u0026gt; N) { if(N == 0) { break; } long long x = (long long)floor(sqrt(N * 1.0) + 0.5); if(x * x == N) { cout \u0026lt;\u0026lt; \u0026#34;yes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } UVaOJ 550 类似倒推的思想。\n首先，我们有$B$、$D$、$M$ ——分别代表进制、最后一位数字、乘数。我们不妨记满足条件的数字为 $N$，且 $N \\cdot M = S$。\n有了上述假设，我们就可以进行如下操作：\n$N$ 的最后一位数字为 $D$，那么 $S$ 的最后一位数字记为 $T = D \\cdot M \\mod B$（这里为 $B$ 进制）。\n这时候需要注意的是，$S$ 的最后一位数字，恰好是 $N$ 的倒数第二位数字，那么也就是说 $N$ 的倒数第二位数字为 $T$。\n有了 $N$ 的倒数第二位数字，我们就可以求出 $S$ 的倒数第二位数字为 $T\\cdot M \\mod B + T / B$（其中 $T / B$ 为进位），以此类推。\n直到我们计算出来的数字与一开始给定的数字 $D$ 相当，这时候的 $N$ 的位数即为答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int B, D, M; while(cin \u0026gt;\u0026gt; B \u0026gt;\u0026gt; D \u0026gt;\u0026gt; M) { int nCnt = 1; int nD = D; while((nD = M * (nD % B) + (nD / B)) \u0026amp;\u0026amp; nD != D) { nCnt++; } cout \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 568 由于数据范围比较小，我们可以直接算出来，记得在每次计算的时候把末尾的 0 去掉，同时为了防止溢出，我们可以对 10 的一个幂次取模。\n这里选择了 10000，因为最大的 $N$ 为 10000。但是这个选取并不是任意的，比如我们取 10，计算出来的结果就会出错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; const int MAX = 100000; int main() { int N; while(cin \u0026gt;\u0026gt; N) { int ans = 1; for(int i = 1; i \u0026lt;= N; i++) { ans *= i; while(ans % 10 == 0) { ans /= 10; } ans %= MAX; } cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34; \u0026lt;\u0026lt; ans % 10 \u0026lt;\u0026lt; endl; } } UVaOJ 408 这道题目就是求满足 $$\\mathrm{seed}(x + 1) = [\\mathrm{seed}(x) + \\mathrm{STEP}] \\mod \\mathrm{MOD}$$ 的 $\\mathrm{seed}(x)$ 能否组成模 $\\mathrm{MOD}$ 的剩余系。\n有一个结论，若 $\\mathrm{gcd}(\\mathrm{STEP}, \\mathrm{MOD}) = 1$，则可以组成一个模 $\\mathrm{MOD}$ 的剩余系。\n我们可以这样来证明：\n$$\\begin{align*}\\mathrm{seed}(x + 1) \u0026amp;= [\\mathrm{seed}(x) + \\mathrm{STEP}] \\mod \\mathrm{MOD} \\\\ \u0026amp;= [\\mathrm{seed}(x - 1) + 2 \\cdot \\mathrm{STEP}] \\mod \\mathrm{MOD} \\\\ \u0026amp;= [\\mathrm{seed}(x - 2) + 3 \\cdot \\mathrm{STEP}] \\mod \\mathrm{MOD} \\\\ \u0026amp;= \\cdots \\\\ \u0026amp;= [\\mathrm{seed}(0) + (x + 1) \\cdot \\mathrm{STEP}] \\mod \\mathrm{MOD}\\end{align*}$$\n若不能满足条件，则必定存在 $0 \\leq i \\neq j \u0026lt; \\mathrm{MOD}$ 的整数 $i$ 和 $j$ 满足：$\\mathrm{seed}(i) = \\mathrm{seed}(j)$，即 $$[\\mathrm{seed}(0) + i \\cdot \\mathrm{STEP}] \\mod \\mathrm{MOD} = [\\mathrm{seed}(0) +j \\cdot \\mathrm{STEP}] \\mod \\mathrm{MOD}$$ 即 $$((j - i) \\cdot \\mathrm{STEP}) \\mod \\mathrm{MOD} = 0$$ 又 $j - i \u0026lt; \\mathrm{MOD}$，所以 $\\mathrm{gcd}(\\mathrm{STEP}, \\mathrm{MOD}) \\neq 1$，即 $ \\mathrm{STEP} $ 中含有 $\\mathrm{MOD}$ 的因子——若 $\\mathrm{MOD}$ 整除 $j - i$，那么 $\\mathrm{STEP}$ 中含有 $\\mathrm{MOD}$ 的因子 $\\mathrm{MOD} / (j - i)$，反之，$\\mathrm{STEP}$ 含有因子 $\\mathrm{MOD}$。\n故需满足题设条件，必有 $$\\mathrm{gcd}(\\mathrm{STEP}, \\mathrm{MOD}) = 1$$\n证毕。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int gcd(int x, int y); int main() { int x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { if(gcd(x, y) == 1) { cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34; Good Choice\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34; Bad Choice\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } return 0; } int gcd(int x, int y) { if(y == 0) { return x; } else { return gcd(y, x % y); } } UVaOJ 350 简单模拟，没有想到数论的做法。不断的计算 $L$，直到发现重复。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int f[MAX]; int main() { int nCase = 0; int Z, I, M, L; while(cin \u0026gt;\u0026gt; Z \u0026gt;\u0026gt; I \u0026gt;\u0026gt; M \u0026gt;\u0026gt; L) { if(Z == 0 \u0026amp;\u0026amp; I == 0 \u0026amp;\u0026amp; M == 0 \u0026amp;\u0026amp; L == 0) { break; } int nCnt = -1; memset(f, 0, sizeof(f)); do { L = ((Z % M) * (L % M) + (I % M)) % M; f[L]++; nCnt++; } while(f[L] == 1); cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10061 要求 $N!$ 转化为 $B$ 进制后的位数以及末尾 0 的个数。\n为了简化问题，我们首先来看 10 进制的情况。\n我们知道，在 10 进制情况下，我们有 $$f(N) = f(N / 5) + N / 5$$\n证明：令 $k = N / 5$，则 $$N! = 5k \\cdot 5(k - 1) \\cdot \\cdots \\cdot 10 \\cdot 5 \\cdot a = 5^k \\cdot k! \\cdot a$$ 其中 $a$ 为不能被 5 整除的部分。因此， $$f(N) = f(k) + k = f(N / 5) + N / 5$$ 证毕。\n有了上面的结论，我们可以大胆猜测，对于 $B$ 进制数，我们有 $$f(N, B) = f(N / X, B) + N / X$$ 其中 $X$ 为 $B$ 的最大因数，证略。\n这样，我们就解决了第一个问题，对于第二个问题，我们可以直接取对数，计算 $\\log{\\left(N!\\right)}$，即 $$\\log{1} + \\log{2} + \\log{3} + \\cdots + \\log{N}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; const int MAX = 1 \u0026lt;\u0026lt; 20; double pLog[MAX]; int main() { for(int i = 1; i \u0026lt; MAX; i++) { pLog[i] = pLog[i - 1] + log(i); } int N, B; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; B) { int nLen = (int)floor(pLog[N] / log(B) + 1E-9) + 1; int nMaxFactor, nFactorCnt = 0, nCnt = 0; for(int i = 2; i \u0026lt;= B; i++) { nFactorCnt = 0; while(B % i == 0) { nMaxFactor = i; nFactorCnt++; B /= i; } } while(N) { N /= nMaxFactor; nCnt += N; } cout \u0026lt;\u0026lt; nCnt / nFactorCnt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; nLen \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10392 质因数分解即可，要注意题目中说只有一个大于 1,000,000 的因子，但是还是需要处理本身就是素数以及除到最后不等于 1 的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 1000020; vector\u0026lt;int\u0026gt; pVec; bool pVisited[MAX]; int main() { memset(pVisited, false, sizeof(pVisited)); for(int i = 2; i \u0026lt; MAX; i++) { if(!pVisited[i]) { pVec.push_back(i); } for(int j = i + i; j \u0026lt; MAX; j += i) { pVisited[j] = true; } } long long N; while(cin \u0026gt;\u0026gt; N) { if(N \u0026lt; 0) { break; } int nCnt = 0; for(int i = 0; i \u0026lt; pVec.size(); i++) { if(N \u0026lt; pVec[i]) { break; } while(N % pVec[i] == 0) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pVec[i] \u0026lt;\u0026lt; endl; N /= pVec[i]; nCnt++; } } if(nCnt == 0 || N != 1) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10879 这道题目的样例好像有点吓唬人，其实里面应该有 spj 的。\n数据量不大，直接分解因式即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T, N; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { cin \u0026gt;\u0026gt; N; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; N; int nCnt = 0; for(int j = 2; j * j \u0026lt;= N; j++) { if(N % j == 0) { cout \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; N / j; nCnt++; } if(nCnt == 2) { break; } } cout \u0026lt;\u0026lt; endl; } return 0; } 数论专题很多都是看着题解做的，因为很多都不知道，学到了很多新的东西。\n","date":"2015-02-13T12:50:00+08:00","permalink":"https://ivy-end.github.io/p/acm-icpc-%E5%AF%92%E5%81%87%E7%BB%83%E4%B9%A0-06/","title":"ACM-ICPC 寒假练习 06"},{"content":"刷完了数学专题，感觉思维量有些大，同时也对浮点数的运算有些接触。最重要的还是感觉有时候题目读起来有些吃力，需要借助中文翻译。\nUVaOJ 113 这道题目是集训的时候第一天晚上的题目，据说可以 double 解决，当时没有 AC。\n现在重新做了一遍，需要注意的是最后输出的结果一定要转换成int，否则会 WA。\n同时，double 转换为 int 的时候可以采取这样的方式：(int)floor(x + 0.5)。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { double x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { cout \u0026lt;\u0026lt; (int)floor(pow(y, 1 / x) + 0.5) \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10161 这道题目是通常的找规律题目，和一道《Cantor 的数表》是差不多的，需要注意奇偶不同的处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { int N; while(cin \u0026gt;\u0026gt; N) { if(N == 0) { break; } int k = ceil(sqrt(N)); int s = (k - 1) * (k - 1); int d = N - s; int x, y; if(d \u0026lt;= k) { x = d; y = k; } else { x = k; y = 2 * k - d; } if(k \u0026amp; 1) { swap(x, y); } cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 253 这道题目如果直接考虑会非常的麻烦，我们可以考虑“颜色对”这样一个概念。\n即，将互为对面的两种颜色看为一个颜色对，那么一个立方体一共有 3 个颜色对，只要匹配这三个颜色对就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 4; bool pVisited[MAX]; int main() { string x; while(cin \u0026gt;\u0026gt; x) { int nCnt = 0; memset(pVisited, false, sizeof(pVisited)); for(int i = 1; i \u0026lt;= 3; i++) { for(int j = 1; j \u0026lt;= 3; j++) { if((x[i - 1] == x[5 + j] \u0026amp;\u0026amp; x[6 - i] == x[12 - j] || x[i - 1] == x[12 - j] \u0026amp;\u0026amp; x[6 - i] == x[5 + j]) \u0026amp;\u0026amp; !pVisited[j]) { nCnt++; pVisited[j] = true; break; } } } cout \u0026lt;\u0026lt; (nCnt == 3 ? \u0026#34;TRUE\u0026#34; : \u0026#34;FALSE\u0026#34;) \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 621 这道题目感觉不是数学题，应该算字符串处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; string x; while(cin \u0026gt;\u0026gt; N) { cin.ignore(); for(int i = 1; i \u0026lt;= N; i++) { getline(cin, x); if(x == \u0026#34;1\u0026#34; || x == \u0026#34;4\u0026#34; || x == \u0026#34;78\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; endl; } else if(x.substr(x.length() - 2, 2) == \u0026#34;35\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; endl; } else if(x[0] == \u0026#39;9\u0026#39; \u0026amp;\u0026amp; x[x.length() - 1] == \u0026#39;4\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; endl; } else if(x.substr(0, 3) == \u0026#34;190\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;?\u0026#34; \u0026lt;\u0026lt; endl; } } } return 0; } UVaOJ 10025 这道题目当时没有想出来怎么做，后来看了题解恍然大悟。\n首先，根据对称性，我们可以只考虑 $k \u0026gt; 0$ 的情况。\n然后，我们令 $S = \\bigoplus 1\\bigoplus 2\\bigoplus 3\\bigoplus\\cdots\\bigoplus N$，其中 $\\bigoplus$ 为正负号。\n如果将 $S$ 中任意一个 $\\bigoplus$ 变换符号，那么 $S$ 的减少量或者增加量必定为偶数。\n我们考虑 $\\bigoplus$ 都为 $+$ 的情况，因为当 $S \u0026gt; k$ 的时候，我们可以改变其中的 $\\bigoplus$ 来达到要求的 $k$。\n因此，只要求最小的 $N$，使得 $S \u0026gt; k$，并且满足 $S - k$ 为偶数，因为每次变换 $\\bigoplus$ 的符号对 $S$ 的改变量为偶数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T, K; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { cin \u0026gt;\u0026gt; K; if(K \u0026lt; 0) { K = -K; } int nSum = 0; for(int j = 1; ; j++) { nSum += j; if(nSum \u0026gt;= K \u0026amp;\u0026amp; (nSum - K) % 2 == 0) { cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; break; } } if(i != T) { cout \u0026lt;\u0026lt; endl; } } return 0; } UVaOJ 591 贪心，计算变换后每列的末高度。将高于末高度的搬到低于末高度的地方即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 64; int pData[MAX]; int main() { int N, nCase = 0; while(cin \u0026gt;\u0026gt; N) { if(N == 0) { break; } int nSum = 0, ans = 0; cout \u0026lt;\u0026lt; \u0026#34;Set #\u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pData[i]; nSum += pData[i]; } nSum /= N; for(int i = 1; i \u0026lt;= N; i++) { if(pData[i] \u0026gt; nSum) { ans += pData[i] - nSum; } } cout \u0026lt;\u0026lt; \u0026#34;The minimum number of moves is \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } } UVaOJ 107 这道题目需要推导公式，我们令要输出的答案分别为 $x$ 和 $y$。\n假设 $k$ 代小猫（包括第一代），每个小猫帽子里有 $N$ 个小猫。\n那么我们可以得到公式 $$(N + 1)^k = H,\\quad N^k = C$$\n两边去对数即可得到 $$k \\cdot \\log{\\left(N + 1\\right)} = \\log{H},\\quad k \\cdot \\log{N} = \\log{C}$$\n将 $k$ 约去，得到 $$\\log{H}\\cdot\\log{N} = \\log{\\left(N + 1\\right)}\\cdot\\log{C}$$\n根据上式，我们额可以求出 $N$，即每个小猫帽子里有几个小猫。之所以约去 $k$，是为了多次运算导致浮点数误差。\n求得 $N$ 以后，我们就可以进一步的求出一共有多少只小猫不在工作。这是一个等比数列 $$x = 1 + N + N^2 + N^3 + \u0026hellip; + N^k$$\n当 $N = 1$ 时 $$x = k = \\log{H} / \\log{2}$$ 由 $(N + 1)^K = H$，代入 $N = 1$ 得 $2^k = H$\n当 $N \\neq 1$ 时 $$x = \\frac{1 - N^k}{1 - N} = \\frac{1 - C}{1 - N} = \\frac{C - 1}{N - 1}$$\n为了计算所有小猫的身高，我们可以得到另一个等比数列 $$y = H + N \\cdot\\left(\\frac{N}{N + 1}\\right)\\cdot H + N^2 \\cdot\\left(\\frac{N}{N + 1}\\right)^2\\cdot H + \\cdots + N^k \\cdot\\left(\\frac{N}{N + 1}\\right)^k\\cdot H$$\n当 $N = 1$ 时 $$ y = H \\cdot \\left(1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} + \\cdots + \\frac{1}{2^k}\\right) = H \\cdot \\left(2 - \\frac{1}{2^k}\\right) = 2\\cdot H - H \\cdot\\frac{1}{2^k} = 2 \\cdot H - 1$$ 由 $(N + 1)^K = H$，代入 $N = 1$ 得 $2^k = H$\n当 $N \\neq 1$ 时 $$ y = H \\cdot \\frac{1 - \\left(\\frac{N^2}{N + 1}\\right)^k}{1 - \\frac{N^2}{N + 1}} = (N + 1) \\cdot H - C \\cdot N$$\n又，当 $N = 1$ 时，必有 $C = 1$，因此我们对输入数据进行分类讨论即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { double H, C; while(cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; C) { if(H == 0 \u0026amp;\u0026amp; C == 0) { break; } int x, y; if(C == 1) { x = ceil(log(H) / log(2)); y = 2 * H - 1; } else { int N; for(N = 1; N \u0026lt; H; N++) { if(fabs(log(H) * log(N) - log(C) * log(N + 1)) \u0026lt; 1E-8) { break; } } x = (C - 1) / (N - 1); y = (N + 1) * H - C * N; } cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 573 蜗牛爬墙，很经典的题目，要注意两点：\n上爬的衰减因子只与第一次上爬的距离有关； 当上爬的距离小于0时，蜗牛不再上爬。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { double H, U, D, F; while(cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; U \u0026gt;\u0026gt; D \u0026gt;\u0026gt; F) { if(H == 0) { break; } F /= 100.0; int nDay = 0; double dNow = 0, dUp = U; while(1) { nDay++; dNow += dUp; dUp -= F * U; if(dNow \u0026gt; H) { cout \u0026lt;\u0026lt; \u0026#34;success on day \u0026#34; \u0026lt;\u0026lt; nDay \u0026lt;\u0026lt; endl; break; } if(dUp \u0026lt; 0) { dUp = F = 0; } dNow -= D; if(dNow \u0026lt; 0) { cout \u0026lt;\u0026lt; \u0026#34;failure on day \u0026#34; \u0026lt;\u0026lt; nDay \u0026lt;\u0026lt; endl; break; } } } return 0; } UVaOJ 846 这道题目一开始完全不知道怎么做，后来百度以后才发现有规律：\n距离 步长 距离 步长 1 1 9 5 2 2 10 6 3 3 11 6 4 3 12 6 5 4 13 7 6 4 14 7 7 5 15 7 8 5 16 7 我们令 $d = y - x$（其中 $x$ 和 $y$ 为输入数据），s = floor(sqrt(d))，规律如下：$$s = \\begin{cases} 2s - 1, \u0026amp; s^2 = d \\\\ 2s + 1, \u0026amp; s(s+1) \u0026lt; d \\\\ 2s, \u0026amp; \\mathrm{otherwise}\\end{cases}$$ 当然，要注意特判相距为 0 的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { int T, x, y; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int d = y - x; if(d == 0) { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34; \u0026lt;\u0026lt; endl; } else { int s = (int)(sqrt(d * 1.0)); if(s * s == d) { s = 2 * s - 1; } else if(s * (s + 1) \u0026lt; d) { s = 2 * s + 1; } else { s *= 2; } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } } return 0; } UVaOJ 10499 一开始没看懂题意。感觉在考英语。\n我们假设一开始小球的半径 $R = 1$，那么表面积 $S = 4\\pi$。分割成 $N$ 部分，表面积增加 $N\\cdot \\pi$。那么答案即为 $N / 4 \\times 100 = 25N$。\n注意，需要特判 1 的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long N; while(cin \u0026gt;\u0026gt; N) { if(N \u0026lt; 0) { break; } long long nPercent = N * 25; if(N == 1) { nPercent = 0; } cout \u0026lt;\u0026lt; nPercent \u0026lt;\u0026lt; \u0026#34;%\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10790 映射法：每个四边形对应一条对角线——每条对角线对应一个交点。\n题目转化为求四边形的个数，即为 $$\\binom{N}{2} \\cdot \\binom{M}{2}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int nCase = 0; long long x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { if(x == 0 \u0026amp;\u0026amp; y == 0) { break; } long long ans = x * (x - 1) * y * (y - 1) / 4; cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 11044 由于边缘不需要计算，那么答案就是 $$\\left\\lceil\\frac{W-2}{3}\\right\\rceil \\cdot \\left\\lceil\\frac{H-2}{3}\\right\\rceil$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { int T, W, H; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { cin \u0026gt;\u0026gt; W \u0026gt;\u0026gt; H; int x = (W - 2) / 3 + ((W - 2) % 3 != 0); int y = (H - 2) / 3 + ((H - 2) % 3 != 0); cout \u0026lt;\u0026lt; x * y \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10719 模拟多项式除法，只要会多项式除法，写起来就非常的轻松。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;sstream\u0026gt; using namespace std; const int MAX = 10240; int pData[MAX], pAns[MAX]; int main() { int k; string x; while(cin \u0026gt;\u0026gt; k) { memset(pData, 0, sizeof(pData)); memset(pAns, 0, sizeof(pAns)); int nCnt = 0, nPos = 1, r = 0; cin.ignore(); getline(cin, x); istringstream iss(x); while(iss \u0026gt;\u0026gt; pData[++nCnt]); nCnt--; while(nPos \u0026lt; nCnt) { if(pData[nPos] != 0) { pAns[nPos] = pData[nPos]; pData[nPos] = 0; pData[nPos + 1] += k * pAns[nPos]; } nPos++; } if(pData[nPos]) { r = pData[nPos]; } cout \u0026lt;\u0026lt; \u0026#34;q(x):\u0026#34;; for(int i = 1; i \u0026lt; nPos; i++) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pAns[i]; } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34;r = \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10177 结论题。对于 $w$ 维正方体，边长为 $N$，其中包含的正方体（$S$）、长方体（$R$）的个数为：$$ S(w) = 1^w + 2^w + 3^w + \u0026hellip; + N^w$$ $$R(w) = \\left(\\frac{N \\cdot (N + 1)}{2}\\right)^w - S(w)$$\n这里补充一下幂级数求和公式：$$S(4) = \\frac{N \\cdot (N + 1) \\cdot \\left(3 N^2 + 3 N - 1\\right)}{30}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long N; while(cin \u0026gt;\u0026gt; N) { long long s2 = (N * (N + 1) * (2 * N + 1)) / 6; long long s3 = (N * (N + 1) / 2) * (N * (N + 1) / 2); long long s4 = (N * (N + 1) * (2 * N + 1) * (3 * N * N + 3 * N - 1)) / 30; long long r2 = (N * (N + 1) / 2) * (N * (N + 1) / 2) - s2; long long r3 = (N * (N + 1) / 2) * (N * (N + 1) / 2) * (N * (N + 1) / 2) - s3; long long r4 = (N * (N + 1) / 2) * (N * (N + 1) / 2) * (N * (N + 1) / 2) * (N * (N + 1) / 2) - s4; cout \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r3 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r4 \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10916 我们知道 $2^N \u0026lt; N! \u0026lt; 2^{(N + 1)}$，以 2 为底取对数得 $$N \u0026lt; \\log{1} + \\log{2} + \\log{3} + \\cdots + \\log{N} \u0026lt; N + 1$$\n这样，模拟一下就可以得到答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { int N; while(cin \u0026gt;\u0026gt; N) { if(N == 0) { break; } int k = (N - 1960) / 10 + 2; double dSum = 0.0; for(int i = 1; ; i++) { dSum += log(i) / log(2); if(dSum \u0026gt; (1 \u0026lt;\u0026lt; k)) { cout \u0026lt;\u0026lt; i - 1 \u0026lt;\u0026lt; endl; break; } } } return 0; } UVaOJ 10970 记得在 Codeforces 上做过，当时被 hack 了。这里数据范围比较小，所以可以直接用 int。\n$$ \\mathrm{ans} = xy - 1$$\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { cout \u0026lt;\u0026lt; x * y - 1 \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 10014 这道题目也需要推导公式。根据题目条件，我们有：$$\\begin{cases}2 \\cdot a_1 = a_0 + a_2 - 2 \\cdot c_1\\\\ 2 \\cdot a_2 = a_1 + a_3 - 2 \\cdot c_2\\\\ 2 \\cdot a_3 = a_2 + a_4 - 2 \\cdot c_3\\\\ \\cdots \\\\ 2 \\cdot a_N = a_{N-1} + a_{N+1} - 2 \\cdot c_N \\end{cases}$$ 将第一个式子分别加到下面 $N - 1$ 个式子上，得到：$$\\begin{cases}2 \\cdot a_1 = a_0 + a_2 - 2 \\cdot c_1\\\\ a_1 + a_2 = a_0 + a_3 - 2 \\cdot \\left(c_1 + c_2\\right)\\\\ a_1 + a_3 = a_0 + a_4 - 2 \\cdot \\left(c_1 + c_2 + c_3\\right)\\\\ \\cdots \\\\ a_1 + a_N = a_0 + a_{N+1} - 2 \\cdot \\left(c_1 + c_2 + c_3 + \\cdots + c_N\\right) \\end{cases}$$ 将上面 $N$ 个式子累加，得到：$$ (N + 1) \\cdot a_1 = N \\cdot a_0 + a_N + 1 - 2 \\cdot \\left(N \\cdot c_1 + (N - 1) \\cdot c_2 + (N - 2) \\cdot c_3 + \\cdots + c_N\\right)$$ 由此，便可得到 $a_1$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { int T, N; double s, e; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { double ans = 0, dTmp; cin \u0026gt;\u0026gt; N; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; ans = N * s + e; for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; dTmp; ans -= 2.0 * (N - j + 1) * dTmp; } cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; ans / (N + 1) \u0026lt;\u0026lt; endl; if(i != T) { cout \u0026lt;\u0026lt; endl; } } return 0; } 刷完数学专题，感觉数学题目的思维量还是很大的，同时也要注意浮点数对结果造成的误差。\n","date":"2015-02-12T14:24:00+08:00","permalink":"https://ivy-end.github.io/p/acm-icpc-%E5%AF%92%E5%81%87%E7%BB%83%E4%B9%A0-05/","title":"ACM-ICPC 寒假练习 05"},{"content":"断断续续的把排序和检索专题刷完了，感觉英语还是不够，题目太长以后看起来就会很吃力。\n还有一点感触就是 STL 的广泛应用。学到了很多新东西。\n当然，不能忍受的就是答案最后多输出一行空行，UVaOJ 会判 WA。\nUVaOJ 340 简单模拟题，一开始没有看懂题目。百度以后才明白的题意。朴素模拟以后即可得到答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024; int pCode[MAX], pGuess[MAX], pVisited[MAX]; int main() { int N, nCase = 0; while(cin \u0026gt;\u0026gt; N) { if(N == 0) { break; } memset(pCode, 0, sizeof(pCode)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pCode[i]; } cout \u0026lt;\u0026lt; \u0026#34;Game \u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; while(1) { int x = 0, y = 0, nCnt = 0; memset(pGuess, 0, sizeof(pGuess)); memset(pVisited, 0, sizeof(pVisited)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pGuess[i]; if(pGuess[i] == 0) { nCnt++; } } if(nCnt == N) { break; } for(int i = 1; i \u0026lt;= N; i++) { if(pCode[i] == pGuess[i]) { x++; pVisited[i] = 2; } } for(int i = 1; i \u0026lt;= N; i++) { if(pVisited[i] == 2) { continue; } for(int j = 1; j \u0026lt;= N; j++) { if(pVisited[j] != 0) { continue; } if(pCode[i] == pGuess[j]) { y++; pVisited[j] = 1; break; } } } cout \u0026lt;\u0026lt; \u0026#34; (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } UVaOJ 10420 STL 中的 set 水过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; map\u0026lt;string, int\u0026gt; pMap; int main() { int N; while(cin \u0026gt;\u0026gt; N) { pMap.clear(); string x, y; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x; getline(cin, y); pMap[x]++; } map\u0026lt;string, int\u0026gt;::iterator it; for(it = pMap.begin(); it != pMap.end(); it++) { cout \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl; } } return 0; } UVaOJ 10474 水题，一开始没看见“CASE”是大写的，WA 了好几次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MAX = 10240; int pData[MAX]; int main() { int nCase = 0; int N, Q, x; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q) { if(N == 0 \u0026amp;\u0026amp; Q == 0) { break; } for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pData[i]; } cout \u0026lt;\u0026lt; \u0026#34;CASE# \u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; sort(pData + 1, pData + N + 1); for(int i = 1; i \u0026lt;= Q; i++) { cin \u0026gt;\u0026gt; x; bool bFlag = false; for(int j = 1; j \u0026lt;= N; j++) { if(pData[j] == x) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; found at \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; bFlag = true; break; } } if(!bFlag) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; not found\u0026#34; \u0026lt;\u0026lt; endl; } } } return 0; } UVaOJ 152 这道题目一开始也没有看懂题意，百度以后才明白的题意。\n为了避免 sqrt 的误差，可以直接判断平方的大小关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; const int pTable[] = { 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 }; struct Point { int x, y, z; }; int pOut[MAX]; Point pData[MAX]; int Calc(int i, int j); int main() { int x, y, z, nCnt = 0; memset(pOut, 0, sizeof(pOut)); while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z) { if(x == 0 \u0026amp;\u0026amp; y == 0 \u0026amp;\u0026amp; z == 0) { break; } pData[++nCnt] = {x, y, z}; } for(int i = 1; i \u0026lt;= nCnt; i++) { int nMin = 2147483647; for(int j = 1; j \u0026lt;= nCnt; j++) { if(i == j) { continue; } int nTmp = Calc(i, j); if(nMin \u0026gt; nTmp) { nMin = nTmp; } } pOut[nMin]++; } for(int i = 1; i \u0026lt;= 10; i++) { cout \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; pOut[i]; } cout \u0026lt;\u0026lt; endl; return 0; } int Calc(int i, int j) { int x = pData[i].x - pData[j].x; int y = pData[i].y - pData[j].y; int z = pData[i].z - pData[j].z; int nTmp = x * x + y * y + z * z; for(int k = 1; k \u0026lt;= 10; k++) { if(nTmp \u0026lt; pTable[k]) { return k; } } } UVaOJ 299 学过线性代数以后直接想到了逆序数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int pData[MAX]; int main() { int T, N; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { cin \u0026gt;\u0026gt; N; int nCnt = 0; memset(pData, 0, sizeof(pData)); for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; pData[j]; } for(int j = 1; j \u0026lt;= N; j++) { for(int k = j + 1; k \u0026lt;= N; k++) { if(pData[j] \u0026gt; pData[k]) { nCnt++; } } } cout \u0026lt;\u0026lt; \u0026#34;Optimal train swapping takes \u0026#34; \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; \u0026#34; swaps.\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 120 简单模拟题，也是百度以后才知道的题意。\n如果当前区间最大的不是第一个，那么先将它翻转到第一个，然后在翻转到当前区间的最后一个。\n如果它恰好是第一个，直接翻转到最后一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; deque\u0026lt;int\u0026gt; Q; int main() { int nTmp; string x; while(getline(cin, x)) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; istringstream iss(x); Q.clear(); while(iss \u0026gt;\u0026gt; nTmp) { Q.push_front(nTmp); } for(deque\u0026lt;int\u0026gt;::iterator it = Q.begin(); it != Q.end(); it++) { deque\u0026lt;int\u0026gt;::iterator iMax = max_element(it, Q.end()); if(iMax != it) { if(iMax != Q.end() - 1) { reverse(iMax, Q.end()); cout \u0026lt;\u0026lt; iMax - Q.begin() + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } reverse(it, Q.end()); cout \u0026lt;\u0026lt; it - Q.begin() + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 156 STL 中的 map 水过。但是对于 map 内部的自动排序还不是非常的理解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 10240; map\u0026lt;string, int\u0026gt; pMap; vector\u0026lt;string\u0026gt; pVec; string pData[MAX], pSorted[MAX]; string ToLower(string x); int main() { int nCnt = 0; string x; while(cin \u0026gt;\u0026gt; x) { if(x == \u0026#34;#\u0026#34;) { break; } nCnt++; pData[nCnt] = x; pSorted[nCnt] = ToLower(x); sort(pSorted[nCnt].begin(), pSorted[nCnt].end()); pMap[pSorted[nCnt]]++; } for(map\u0026lt;string, int\u0026gt;::iterator it = pMap.begin(); it != pMap.end(); it++) { if((*it).second != 1) { continue; } int nPos; for(nPos = 1; nPos \u0026lt;= nCnt; nPos++) { if(pSorted[nPos] == (*it).first) { break; } } pVec.push_back(pData[nPos]); } sort(pVec.begin(), pVec.end()); for(int i = 0; i \u0026lt; pVec.size(); i++) { cout \u0026lt;\u0026lt; pVec[i] \u0026lt;\u0026lt; endl; } } string ToLower(string x) { for(int i = 0; i \u0026lt; x.length(); i++) { if(x[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x[i] \u0026lt;= \u0026#39;Z\u0026#39;) { x[i] += 32; } } return x; } UVaOJ 400 一开始没有注意到除数为 0 的情况，导致 RE 了好多次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MAX = 60; vector\u0026lt;string\u0026gt; pVec; int main() { int N; string x; while(cin \u0026gt;\u0026gt; N) { int nMax = 0; pVec.clear(); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x; pVec.push_back(x); nMax = max(nMax, (int)x.length()); } int nCnt = MAX / (nMax + 2); if(nCnt == 0) { nCnt = 1; } int nRow = N / nCnt + (N % nCnt != 0); sort(pVec.begin(), pVec.end()); cout \u0026lt;\u0026lt; \u0026#34;------------------------------------------------------------\u0026#34; \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= nRow; i++) { for(int j = 1; j \u0026lt;= nCnt; j++) { int nPos = (j - 1) * nRow + i - 1; if(nPos \u0026gt;= N) { continue; } cout.setf(ios::left); if(nPos \u0026gt;= (nCnt - 1) * nRow) { cout \u0026lt;\u0026lt; setw(nMax) \u0026lt;\u0026lt; pVec[nPos]; } else { cout \u0026lt;\u0026lt; setw(nMax + 2) \u0026lt;\u0026lt; pVec[nPos]; } } cout \u0026lt;\u0026lt; endl; } } return 0; } UVaOJ 123 这道题目要求按照原来的顺序，而 sort 是非稳定排序，在这上面 WA 了好几次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;sstream\u0026gt; using namespace std; const int MAX = 10240; int cmp(pair\u0026lt;string, pair\u0026lt;string, int\u0026gt; \u0026gt; x, pair\u0026lt;string, pair\u0026lt;string, int\u0026gt; \u0026gt; y) { if(x.first != y.first) { return x.first \u0026lt; y.first; } else { return x.second.second \u0026lt; y.second.second; } } string pData[MAX]; set\u0026lt;string\u0026gt; pSet; vector\u0026lt;pair\u0026lt;string, pair\u0026lt;string, int\u0026gt; \u0026gt; \u0026gt; pVec; string ToLower(string x); string ToUpper(string x); int main() { int nPos = 0; string x; while(cin \u0026gt;\u0026gt; x) { if(x == \u0026#34;::\u0026#34;) { break; } pSet.insert(x); } cin.ignore(); while(getline(cin, x)) { string strLow = ToLower(x); istringstream iss(strLow); int nCnt = 0; while(iss \u0026gt;\u0026gt; x) { if(x != \u0026#34;\u0026#34;) { pData[++nCnt] = x; } } for(int i = 1; i \u0026lt;= nCnt; i++) { if(!pSet.count(pData[i])) { string strTmp = \u0026#34;\u0026#34;; for(int j = 1; j \u0026lt;= nCnt; j++) { if(j != i) { strTmp += pData[j] + \u0026#34; \u0026#34;; } else { strTmp += ToUpper(pData[j]) + \u0026#34; \u0026#34;; } } strTmp = strTmp.substr(0, strTmp.length() - 1); pVec.push_back(make_pair(ToUpper(pData[i]), make_pair(strTmp, ++nPos))); } } } sort(pVec.begin(), pVec.end(), cmp); for(int i = 0; i \u0026lt; pVec.size(); i++) { cout \u0026lt;\u0026lt; pVec[i].second.first \u0026lt;\u0026lt; endl; } return 0; } string ToLower(string x) { for(int i = 0; i \u0026lt; x.length(); i++) { if(x[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x[i] \u0026lt;= \u0026#39;Z\u0026#39;) { x[i] += 32; } } return x; } string ToUpper(string x) { for(int i = 0; i \u0026lt; x.length(); i++) { if(x[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; x[i] \u0026lt;= \u0026#39;z\u0026#39;) { x[i] -= 32; } } return x; } UVaOJ 10194 水题，直接模拟即可。注意写好排序的 cmp 函数即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MAX = 1024; struct Player { Player() { Clear(); } void Clear() { strName = \u0026#34;\u0026#34;; nPoint = nGame = 0; nWin = nTie = nLose = 0; nDiff = nScored = nAgainst = 0; } string strName; string strTmp; int nPoint, nGame; int nWin, nTie, nLose; int nDiff, nScored, nAgainst; }; Player pData[MAX]; int GetPos(string x); int Trans(string x); string ToLower(string x); int cmp(Player x, Player y) { if(x.nPoint != y.nPoint) { return x.nPoint \u0026gt; y.nPoint; } if(x.nWin != y.nWin) { return x.nWin \u0026gt; y.nWin; } if(x.nDiff != y.nDiff) { return x.nDiff \u0026gt; y.nDiff; } if(x.nScored != y.nScored) { return x.nScored \u0026gt; y.nScored; } if(x.nGame != y.nGame) { return x.nGame \u0026lt; y.nGame; } return ToLower(x.strName) \u0026lt; ToLower(y.strName); } int main() { int N, nPlayer, nGame; string x; cin \u0026gt;\u0026gt; N; cin.ignore(); for(int i = 1; i \u0026lt;= N; i++) { getline(cin, x); cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; int nCnt = 0; cin \u0026gt;\u0026gt; nPlayer; cin.ignore(); for(int j = 1; j \u0026lt;= nPlayer; j++) { getline(cin, x); pData[++nCnt].Clear(); pData[nCnt].strName = x; pData[nCnt].strTmp = ToLower(x); } cin \u0026gt;\u0026gt; nGame; cin.ignore(); for(int j = 1; j \u0026lt;= nGame; j++) { getline(cin, x); int nLeft = x.find_first_of(\u0026#39;#\u0026#39;), nRight = x.find_last_of(\u0026#39;#\u0026#39;), nMid = x.find(\u0026#39;@\u0026#39;); string strLeft = x.substr(0, nLeft); string strRight = x.substr(nRight + 1, x.length() - nRight - 1); string strLeftPoint = x.substr(nLeft + 1, nMid - nLeft - 1); string strRightPoint = x.substr(nMid + 1, nRight - nMid - 1); int nLeftPos = GetPos(strLeft), nRightPos = GetPos(strRight); int nLeftPoint = Trans(strLeftPoint), nRightPoint = Trans(strRightPoint); pData[nLeftPos].nGame++; pData[nRightPos].nGame++; pData[nLeftPos].nScored += nLeftPoint; pData[nRightPos].nScored += nRightPoint; pData[nLeftPos].nAgainst += nRightPoint; pData[nRightPos].nAgainst += nLeftPoint; if(nLeftPoint \u0026gt; nRightPoint) { pData[nLeftPos].nWin++; pData[nRightPos].nLose++; } else if(nLeftPoint \u0026lt; nRightPoint) { pData[nLeftPos].nLose++; pData[nRightPos].nWin++; } else { pData[nLeftPos].nTie++; pData[nRightPos].nTie++; } } for(int i = 1; i \u0026lt;= nPlayer; i++) { pData[i].nPoint = pData[i].nWin * 3 + pData[i].nTie; pData[i].nDiff = pData[i].nScored - pData[i].nAgainst; } sort(pData + 1, pData + nPlayer + 1, cmp); for(int i = 1; i \u0026lt;= nPlayer; i++) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;) \u0026#34; \u0026lt;\u0026lt; pData[i].strName \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pData[i].nPoint \u0026lt;\u0026lt; \u0026#34;p, \u0026#34; \u0026lt;\u0026lt; pData[i].nGame \u0026lt;\u0026lt; \u0026#34;g (\u0026#34; \u0026lt;\u0026lt; pData[i].nWin \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; pData[i].nTie \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; pData[i].nLose \u0026lt;\u0026lt; \u0026#34;), \u0026#34; \u0026lt;\u0026lt; pData[i].nDiff \u0026lt;\u0026lt; \u0026#34;gd (\u0026#34; \u0026lt;\u0026lt; pData[i].nScored \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; pData[i].nAgainst \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } if(i != N) { cout \u0026lt;\u0026lt; endl; } } return 0; } int GetPos(string x) { for(int nPos = 1; nPos \u0026lt; MAX; nPos++) { if(pData[nPos].strTmp == ToLower(x)) { return nPos; } } } int Trans(string x) { int nRet = 0; for(int i = 0; i \u0026lt; x.length(); i++) { nRet *= 10; nRet += x[i] - \u0026#39;0\u0026#39;; } return nRet; } string ToLower(string x) { for(int i = 0; i \u0026lt;x.length(); i++) { if(x[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x[i] \u0026lt;= \u0026#39;Z\u0026#39;) { x[i] += 32; } } return x; } UVaOJ 755 直接 map 水过。多输出了一行空行，导致 WA 了一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const char pTable[] = { \u0026#39;2\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;*\u0026#39; }; int cmp(pair\u0026lt;string, int\u0026gt; x, pair\u0026lt;string, int\u0026gt; y) { return x.first \u0026lt; y.first; } vector\u0026lt;pair\u0026lt;string, int\u0026gt; \u0026gt; pVec; map\u0026lt;string, int\u0026gt; pMap; int main() { int T, N; string x; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { pVec.clear(); pMap.clear(); cin \u0026gt;\u0026gt; N; cin.ignore(); for(int j = 1; j \u0026lt;= N; j++) { getline(cin, x); string strTmp = \u0026#34;\u0026#34;; for(int k = 0; k \u0026lt; x.length(); k++) { if(x[k] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; x[k] \u0026lt;= \u0026#39;9\u0026#39;) { strTmp += x[k]; } if(x[k] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x[k] \u0026lt;= \u0026#39;Z\u0026#39;) { strTmp += pTable[x[k] - \u0026#39;A\u0026#39;]; } } while(strTmp.length() != 7) { strTmp = \u0026#39;0\u0026#39; + strTmp; } pMap[strTmp]++; } for(map\u0026lt;string, int\u0026gt;::iterator it = pMap.begin(); it != pMap.end(); it++) { if((*it).second \u0026gt; 1) { pVec.push_back(*it); } } if(pVec.size() == 0) { cout \u0026lt;\u0026lt; \u0026#34;No duplicates.\u0026#34; \u0026lt;\u0026lt; endl; } else { sort(pVec.begin(), pVec.end(), cmp); for(int j = 0; j \u0026lt; pVec.size(); j++) { cout \u0026lt;\u0026lt; pVec[j].first.substr(0, 3) \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; pVec[j].first.substr(3, 4) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pVec[j].second \u0026lt;\u0026lt; endl; } } if(i != T) { cout \u0026lt;\u0026lt; endl; } } return 0; } UVaOJ 10785 类似归并的思想。一开始打错表了，WA 了一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const char pOdd[] = { \u0026#39;A\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;I\u0026#39; }; const char pEven[] = { \u0026#39;J\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;R\u0026#39; }; string Solve(int x); int main() { int T, N; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { cin \u0026gt;\u0026gt; N; cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; Solve(N) \u0026lt;\u0026lt; endl; } return 0; } string Solve(int x) { string strRet = \u0026#34;\u0026#34;; string strOdd = \u0026#34;\u0026#34;; string strEven = \u0026#34;\u0026#34;; int nOdd = (x + 1) / 2; int nEven = x / 2; int nOddCnt = nOdd / 21 + (nOdd % 21 != 0); int nEvenCnt = nEven / 5 + (nEven % 5 != 0); for(int i = 1; i \u0026lt;= nOddCnt; i++) { for(int j = 1; j \u0026lt;= 21; j++) { strOdd += pOdd[i - 1]; } } for(int i = 1; i \u0026lt;= nEvenCnt; i++) { for(int j = 1; j \u0026lt;= 5; j++) { strEven += pEven[i - 1]; } } strOdd = strOdd.substr(0, nOdd); strEven = strEven.substr(0, nEven); sort(strOdd.begin(), strOdd.end()); sort(strEven.begin(), strEven.end()); int nOddPos = 0, nEvenPos = 0; for(int i = 1; i \u0026lt;= x; i++) { if(i \u0026amp; 1) { strRet += strOdd[nOddPos++]; } else { strRet += strEven[nEvenPos++]; } } return strRet; } 这一组题目做下来，感觉英语还是要提升，有时候题目一长，干扰信息一多，读起来就感觉很有难度了。\n","date":"2015-02-11T17:18:00+08:00","permalink":"https://ivy-end.github.io/p/acm-icpc-%E5%AF%92%E5%81%87%E7%BB%83%E4%B9%A0-04/","title":"ACM-ICPC 寒假练习 04"},{"content":"今天刷了高精度专题，本来准备写一个高精度类，然后直接套模版，后来发现根据每题的要求分开写高精度反而效率高。\n主要涉及了高精度加法、乘法、除法、取余（其中后两项为高精度和低精度进行运算）。\n终于打过一遍高精度除以低精度了，高精度专题也算圆满了。\nUVaOJ 424 高精度加法，水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int nLen; int pData[MAX]; int main() { nLen = 1; memset(pData, 0, sizeof(pData)); string x; while(cin \u0026gt;\u0026gt; x) { if(x != \u0026#34;0\u0026#34;) { while(x[0] == \u0026#39;0\u0026#39;) { x = x.substr(1, x.length() - 1); } nLen = max(nLen, (int)x.length()); for(int i = 1; i \u0026lt;= x.length(); i++) { pData[i] += x[x.length() - i] - \u0026#39;0\u0026#39;; pData[i + 1] += pData[i] / 10; pData[i] %= 10; } while(pData[nLen + 1]) { nLen++; } } else { for(int i = nLen; i \u0026gt;= 1; i--) { cout \u0026lt;\u0026lt; pData[i]; } cout \u0026lt;\u0026lt; endl; nLen = 1; memset(pData, 0, sizeof(pData)); } } return 0; } UVaOJ 10106 高精度乘法，要注意的是某一个乘数为 0 的情况，要特判一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int nLen; int pData[MAX]; int main() { string x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { if(x.length() \u0026lt; y.length()) { swap(x, y); } nLen = x.length() + y.length(); memset(pData, 0, sizeof(pData)); for(int i = 1; i \u0026lt;= y.length(); i++) { for(int j = 1; j \u0026lt;= x.length(); j++) { pData[i + j - 1] += (x[x.length() - j] - \u0026#39;0\u0026#39;) * (y[y.length() - i] - \u0026#39;0\u0026#39;); pData[i + j] += pData[i + j - 1] / 10; pData[i + j - 1] %= 10; } } while(nLen \u0026amp;\u0026amp; !pData[nLen]) { nLen--; } if(nLen == 0) { nLen = 1; } for(int i = nLen; i \u0026gt;= 1; i--) { cout \u0026lt;\u0026lt; pData[i]; } cout \u0026lt;\u0026lt; endl; } return 0; } UVaOJ 465 判断加数、乘数以及结果是否在 int 范围内，一开始把结果都算出来再比较。后来查了资料发现可以直接用 double 过，其中使用到了 atof 这个命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; const int MAX_INT = 2147483647; int main() { char dwOpt; string x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; dwOpt \u0026gt;\u0026gt; y) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dwOpt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; double a, b; a = atof(x.c_str()); b = atof(y.c_str()); if(a \u0026gt; MAX_INT) { cout \u0026lt;\u0026lt; \u0026#34;first number too big\u0026#34; \u0026lt;\u0026lt; endl; } if(b \u0026gt; MAX_INT) { cout \u0026lt;\u0026lt; \u0026#34;second number too big\u0026#34; \u0026lt;\u0026lt; endl; } if(dwOpt == \u0026#39;+\u0026#39; \u0026amp;\u0026amp; a + b \u0026gt; MAX_INT) { cout \u0026lt;\u0026lt; \u0026#34;result too big\u0026#34; \u0026lt;\u0026lt; endl; } if(dwOpt == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; a * b \u0026gt; MAX_INT) { cout \u0026lt;\u0026lt; \u0026#34;result too big\u0026#34; \u0026lt;\u0026lt; endl; } } } UVaOJ 748 带有小数的乘方问题。\n先确定小数点的位数，然后去掉小数点，进行高精度乘方运算，最后加上小数点即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int nLen, nDot; int pData[MAX]; string Solve(string x, string y); int main() { string x; int y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { while(x[x.length() - 1] == \u0026#39;0\u0026#39;) { x = x.substr(0, x.length() - 1); } nDot = x.length() - x.find(\u0026#39;.\u0026#39;) - 1; nDot *= y; x = x.substr(0, x.find(\u0026#39;.\u0026#39;)) + x.substr(x.find(\u0026#39;.\u0026#39;) + 1, x.length() - x.find(\u0026#39;.\u0026#39;) - 1); string z = \u0026#34;1\u0026#34;; for(int i = 1; i \u0026lt;= y; i++) { z = Solve(z, x); } if(z.length() \u0026lt;= nDot) { cout \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; for(int i = z.length(); i \u0026lt; nDot; i++) { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; } cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; endl; } else { for(int i = 0; i \u0026lt; z.length() - nDot; i++) { cout \u0026lt;\u0026lt; z[i]; } cout \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; for(int i = z.length() - nDot; i \u0026lt; z.length(); i++) { cout \u0026lt;\u0026lt; z[i]; } cout \u0026lt;\u0026lt; endl; } } return 0; } string Solve(string x, string y) { if(x.length() \u0026lt; y.length()) { swap(x, y); } nLen = x.length() + y.length(); memset(pData, 0, sizeof(pData)); for(int i = 1; i \u0026lt;= y.length(); i++) { for(int j = 1; j \u0026lt;= x.length(); j++) { pData[i + j - 1] += (x[x.length() - j] - \u0026#39;0\u0026#39;) * (y[y.length() - i] - \u0026#39;0\u0026#39;); pData[i + j] += pData[i + j - 1] / 10; pData[i + j - 1] %= 10; } } while(nLen \u0026amp;\u0026amp; !pData[nLen]) { nLen--; } if(nLen == 0) { nLen = 1; } string z = \u0026#34;\u0026#34;; for(int i = 1; i \u0026lt;= nLen; i++) { z = (char)(pData[i] + \u0026#39;0\u0026#39;) + z; } return z; } UVaOJ 10494 高精度除以低精度以及取模运算。在网上搜了资料，终于学会了。但是要注意 0 % X 的情况。\n另外想说的是非常喜欢这道题目的标题“If We Were A Child Again”，勾起了多少回忆。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 10240; int nLen; int pData[MAX], pAns[MAX]; string Solve(string x, long long y, char dwOpt); int main() { char dwOpt; string x; long long y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; dwOpt \u0026gt;\u0026gt; y) { cout \u0026lt;\u0026lt; Solve(x, y, dwOpt) \u0026lt;\u0026lt; endl; } return 0; } string Solve(string x, long long y, char dwOpt) { memset(pData, 0, sizeof(pData)); memset(pAns, 0, sizeof(pAns)); nLen = x.length(); for(int i = 1; i \u0026lt;= x.length(); i++) { pData[i] = x[x.length() - i] - \u0026#39;0\u0026#39;; } long long d = 0; for(int i = nLen; i \u0026gt;= 1; i--) { d = d * 10 + pData[i]; pAns[i] = d / y; d %= y; } while(nLen \u0026amp;\u0026amp; pAns[nLen] == 0) { nLen--; } if(nLen == 0) { nLen = 1; } string z = \u0026#34;\u0026#34;; if(dwOpt == \u0026#39;/\u0026#39;) { for(int i = 1; i \u0026lt;= nLen; i++) { z = (char)(pAns[i] + \u0026#39;0\u0026#39;) + z; } } else { while(d) { z = (char)(d % 10 + \u0026#39;0\u0026#39;) + z; d /= 10; } if(z == \u0026#34;\u0026#34;) { z = \u0026#34;0\u0026#34;; } } return z; } 今天由于题目相对比较少，所以做的比较快。接下来一个专题应该是排序和检索。\n","date":"2015-02-08T14:02:00+08:00","permalink":"https://ivy-end.github.io/p/acm-icpc-%E5%AF%92%E5%81%87%E7%BB%83%E4%B9%A0-03/","title":"ACM-ICPC 寒假练习 03"},{"content":"今天刷了小白书的字符串专题，各种 WA 以及 PE。UVaOJ 中有时候会把 PE 判成 WA，这样会导致很难查错。\nUVa 401 这道题目有个坑，只有表格中列出的才是镜像字母，没有列出了的表示没有镜像字母，在这上 WA 了一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; const char pAlphabet[] = { \u0026#39;A\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;*\u0026#39; }; bool Palindrome(string x); bool Mirrored(string x); int main() { string x; while(cin \u0026gt;\u0026gt; x) { if(!Palindrome(x)) { if(Mirrored(x)) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; -- is a mirrored string.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; -- is not a palindrome.\u0026#34; \u0026lt;\u0026lt; endl; } } else { if(Mirrored(x)) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; -- is a mirrored palindrome.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; -- is a regular palindrome.\u0026#34; \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; endl; } return 0; } bool Palindrome(string x) { for(int i = 0; i \u0026lt; x.length() / 2; i++) { if(x[i] != x[x.length() - i - 1]) { return false; } } return true; } bool Mirrored(string x) { if(x.length() == 1) { if(x[0] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x[0] \u0026lt;= \u0026#39;Z\u0026#39;) { if(pAlphabet[x[0] - \u0026#39;A\u0026#39;] != x[0]) { return false; } } else { if(pAlphabet[x[0] - \u0026#39;0\u0026#39; + 25] != x[0]) { return false; } } } for(int i = 0; i \u0026lt; x.length() / 2; i++) { if(x[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x[i] \u0026lt;= \u0026#39;Z\u0026#39;) { if(pAlphabet[x[i] - \u0026#39;A\u0026#39;] != x[x.length() - i - 1]) { return false; } } else { if(pAlphabet[x[i] - \u0026#39;0\u0026#39; + 25] != x[x.length() - i - 1]) { return false; } } } return true; } UVa 10010 这道题目要求八个方向都要搜一遍，一开始准备写八个函数，后来发现用 dx[] 和 dy[] 数组就搞定了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 128; const int dx[] = { 0, 0, 1, -1, -1, 1, -1, 1 }; const int dy[] = { 1, -1, 0, 0, 1, 1, -1, -1 }; int T, N, M, Q; char pMap[MAX][MAX]; char ToLower(char x); void Find(string x); bool Search(string s, int x, int y); int main() { string x; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { memset(pMap, 0, sizeof(pMap)); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int j = 1; j \u0026lt;= N; j++) { for(int k = 1; k \u0026lt;= M; k++) { cin \u0026gt;\u0026gt; pMap[j][k]; pMap[j][k] = ToLower(pMap[j][k]); } } cin \u0026gt;\u0026gt; Q; for(int j = 1; j \u0026lt;= Q; j++) { cin \u0026gt;\u0026gt; x; Find(x); } if(i != T) { cout \u0026lt;\u0026lt; endl; } } return 0; } char ToLower(char x) { if(x \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;) { return x; } else { return x + 32; } } void Find(string x) { bool bFlag = false; for(int i = 0; i \u0026lt; x.length(); i++) { x[i] = ToLower(x[i]); } for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= M; j++) { if(Search(x, i, j)) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; bFlag = true; break; } } if(bFlag) { break; } } } bool Search(string s, int x, int y) { for(int i = 0; i \u0026lt; 8; i++) { bool bFlag = true; for(int j = 0; j \u0026lt; s.length(); j++) { int nx = x + dx[i] * j; int ny = y + dy[i] * j; if(pMap[nx][ny] != s[j]) { bFlag = false; break; } } if(bFlag) { return true; } } return false; } UVa 10361 这道题目卡了好久，一直不知道为什么我的代码会各种 WA 以及 PE。最后还是采用了网上一种 C 语言的写法才 AC 了。但还是不知道为什么我的错了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; const int MAX = 128; char s1[MAX], s2[MAX], s3[MAX], s4[MAX], s5[MAX], line[MAX]; void getss(char s[]); int main() { int N; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); getchar(); for(int i = 1; i \u0026lt;= N; i++) { getss(s1); getss(s2); getss(s3); getss(s4); getss(s5); gets(line); line[strlen(line) - 3] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s%s%s%s%s\\n\u0026#34;, s1, s2, s3, s4, s5); printf(\u0026#34;%s%s%s%s%s\\n\u0026#34;, line, s4, s3, s2, s5); } return 0; } void getss(char s[]) { for(int i = 0; i \u0026lt; MAX; i++) { if((s[i] = getchar()) ==\u0026#39;\u0026lt;\u0026#39; || s[i] == \u0026#39;\u0026gt;\u0026#39; || s[i] == \u0026#39;\\n\u0026#39;) { s[i] = \u0026#39;\\0\u0026#39;; break; } } } UVa 537 这道题目一下就 AC 了，处理的时候注意一下坑数据。\n这里还有一个知识点，除了 atoi 可以实现 string 到 int 的转换，还有 atof，可以实现 string 到 double 的转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdlib.h\u0026gt; using namespace std; int main() { int T; cin \u0026gt;\u0026gt; T; cin.ignore(); for(int j = 1; j \u0026lt;= T; j++) { cout \u0026lt;\u0026lt; \u0026#34;Problem #\u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; double u = 0, i = 0, p = 0; string x, U = \u0026#34;\u0026#34;, I = \u0026#34;\u0026#34;, P = \u0026#34;\u0026#34;; getline(cin, x); if(x.find(\u0026#34;U=\u0026#34;) != string::npos) { U = x.substr(x.find(\u0026#34;U=\u0026#34;) + 2, x.find(\u0026#39;V\u0026#39;, x.find(\u0026#34;U=\u0026#34;)) - x.find(\u0026#34;U=\u0026#34;) - 2); } if(x.find(\u0026#34;I=\u0026#34;) != string::npos) { I = x.substr(x.find(\u0026#34;I=\u0026#34;) + 2, x.find(\u0026#39;A\u0026#39;, x.find(\u0026#34;I=\u0026#34;)) - x.find(\u0026#34;I=\u0026#34;) - 2); } if(x.find(\u0026#34;P=\u0026#34;) != string::npos) { P = x.substr(x.find(\u0026#34;P=\u0026#34;) + 2, x.find(\u0026#39;W\u0026#39;, x.find(\u0026#34;P=\u0026#34;)) - x.find(\u0026#34;P=\u0026#34;) - 2); } if(U != \u0026#34;\u0026#34;) { if(U[U.length() - 1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; U[U.length() - 1] \u0026lt;= \u0026#39;9\u0026#39;) { u = atof(U.c_str()); } else { u = atof(U.substr(0, U.length() - 1).c_str()); if(U[U.length() - 1] == \u0026#39;m\u0026#39;) { u /= 1000.0; } if(U[U.length() - 1] == \u0026#39;k\u0026#39;) { u *= 1000.0; } if(U[U.length() - 1] == \u0026#39;M\u0026#39;) { u *= 1000000.0; } } } if(I != \u0026#34;\u0026#34;) { if(I[I.length() - 1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; I[I.length() - 1] \u0026lt;= \u0026#39;9\u0026#39;) { i = atof(I.c_str()); } else { i = atof(I.substr(0, I.length() - 1).c_str()); if(I[I.length() - 1] == \u0026#39;m\u0026#39;) { i /= 1000.0; } if(I[I.length() - 1] == \u0026#39;k\u0026#39;) { i *= 1000.0; } if(I[I.length() - 1] == \u0026#39;M\u0026#39;) { i *= 1000000.0; } } } if(P != \u0026#34;\u0026#34;) { if(P[P.length() - 1] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; P[P.length() - 1] \u0026lt;= \u0026#39;9\u0026#39;) { p = atof(P.c_str()); } else { p = atof(P.substr(0, P.length() - 1).c_str()); if(P[P.length() - 1] == \u0026#39;m\u0026#39;) { p /= 1000.0; } if(P[P.length() - 1] == \u0026#39;k\u0026#39;) { p *= 1000.0; } if(P[P.length() - 1] == \u0026#39;M\u0026#39;) { p *= 1000000.0; } } } if(U != \u0026#34;\u0026#34; \u0026amp;\u0026amp; I != \u0026#34;\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;P=\u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; u * i \u0026lt;\u0026lt; \u0026#34;W\u0026#34; \u0026lt;\u0026lt; endl; } if(U != \u0026#34;\u0026#34; \u0026amp;\u0026amp; P != \u0026#34;\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;I=\u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; p / u \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } if(I != \u0026#34;\u0026#34; \u0026amp;\u0026amp; P != \u0026#34;\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;U=\u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; p / i \u0026lt;\u0026lt; \u0026#34;V\u0026#34; \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } return 0; } UVa 409 只用运用 string 的 find 函数就可以解决了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 32; int pCnt[MAX]; string pKeyword[MAX], pExcuse[MAX], pTmp[MAX]; int main() { int N, K, nCase = 0; while(cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K) { cout \u0026lt;\u0026lt; \u0026#34;Excuse Set #\u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; endl; memset(pCnt, 0, sizeof(pCnt)); for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; pKeyword[i]; pKeyword[i] += \u0026#39; \u0026#39;; } cin.ignore(); for(int i = 1; i \u0026lt;= K; i++) { getline(cin, pTmp[i]); pExcuse[i] = pTmp[i]; for(int j = 0; j \u0026lt; pExcuse[i].length(); j++) { if(pExcuse[i][j] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; pExcuse[i][j] \u0026lt;= \u0026#39;Z\u0026#39;) { pExcuse[i][j] += 32; } if(!(pExcuse[i][j] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; pExcuse[i][j] \u0026lt;= \u0026#39;z\u0026#39;)) { pExcuse[i][j] = \u0026#39; \u0026#39;; } } pExcuse[i] += \u0026#39; \u0026#39;; } for(int i = 1; i \u0026lt;= K; i++) { for(int j = 1; j \u0026lt;= N; j++) { int nPos = 0; while((nPos = pExcuse[i].find(pKeyword[j], nPos)) \u0026amp;\u0026amp; nPos != string::npos) { pCnt[i]++; nPos += pKeyword[j].length() + 1; } } } int nMax = 0; for(int i = 1; i \u0026lt;= K; i++) { nMax = max(nMax, pCnt[i]); } for(int i = 1; i \u0026lt;= K;i ++) { if(pCnt[i] == nMax) { cout \u0026lt;\u0026lt; pTmp[i] \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; endl; } return 0; } UVa 10878 一看就知道和二进制有关系，翻译过来果然如此（忽略字符 .）。解法中用了秦九韶算法来进制转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int nCnt = 0; string x; while(getline(cin, x)) { int nTmp = 0; if(x == \u0026#34;___________\u0026#34;) { nCnt++; } if(nCnt == 2) { break; } if(x != \u0026#34;___________\u0026#34;) { x = x.substr(1, x.length() - 2); for(int i = 0; i \u0026lt; x.length(); i++) { if(x[i] != \u0026#39;.\u0026#39;) { nTmp *= 2; } if(x[i] == \u0026#39;o\u0026#39;) { nTmp += 1; } } cout \u0026lt;\u0026lt; (char)(nTmp); } } return 0; } UVa 10815 C++ 的 STL 中的 set 可以水过。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int MAX = 5120; set\u0026lt;string\u0026gt; pSet; bool IsAlpha(char x); char ToLower(char x); int main() { string x; while(getline(cin, x)) { for(int i = 0; i \u0026lt; x.length(); i++) { if(!IsAlpha(x[i])) { continue; } string strTmp; while(i \u0026lt; x.length() \u0026amp;\u0026amp; IsAlpha(x[i])) { strTmp += ToLower(x[i++]); } pSet.insert(strTmp); } } for(set\u0026lt;string\u0026gt;::iterator it = pSet.begin(); it != pSet.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } bool IsAlpha(char x) { return x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;Z\u0026#39; || x \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;z\u0026#39;; } char ToLower(char x) { if(x \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x \u0026lt;= \u0026#39;Z\u0026#39;) { x += 32; } return x; } UVa 644 一开始 TLE，还以为算法不行，后来发现是读入出了问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 10240; string x[MAX]; int main() { int nCase = 0, nPos = 0; while(cin \u0026gt;\u0026gt; x[++nPos]) { if(x[nPos] != \u0026#34;9\u0026#34;) { continue; } else { nPos--; bool bFlag = true; for(int i = 1; i \u0026lt;= nPos; i++) { for(int j = 1; j \u0026lt;= nPos; j++) { if(x[i].length() \u0026lt; x[j].length()) { if(x[i] == x[j].substr(0, x[i].length())) { bFlag = false; break; } } } if(!bFlag) { break; } } if(bFlag) { cout \u0026lt;\u0026lt; \u0026#34;Set \u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; \u0026#34; is immediately decodable\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Set \u0026#34; \u0026lt;\u0026lt; ++nCase \u0026lt;\u0026lt; \u0026#34; is not immediately decodable\u0026#34; \u0026lt;\u0026lt; endl; } nPos = 0; } } } UVa 10115 自己写一个 replace 函数就可以 AC 了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 16; string strRules[MAX], strReplace[MAX]; string\u0026amp; ReplaceAll(string\u0026amp; str, const string\u0026amp; strOld, const string\u0026amp; strNew); int main() { int N; while(cin \u0026gt;\u0026gt; N) { string x; if(N == 0) { break; } cin.ignore(); for(int i = 1; i \u0026lt;= N; i++) { getline(cin, strRules[i]); getline(cin, strReplace[i]); } getline(cin, x); for(int i = 1; i \u0026lt;= N; i++) { x = ReplaceAll(x, strRules[i], strReplace[i]); } cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } return 0; } string\u0026amp; ReplaceAll(string\u0026amp; str, const string\u0026amp; strOld, const string\u0026amp; strNew) { while(true) { string::size_type pos(0); if((pos = str.find(strOld)) != string::npos) { str.replace(pos, strOld.length(), strNew); } else { break; } } return str; } 最后总结一个知识点，如何在 C++ 中自己写基于 string 的 relpace 函数。\n在这里，replace 分为两种，一种是 repalce_all，一种是 replace_all_distinct。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* replace 12 with 21 12212 -\u0026gt; 22211 */ string\u0026amp; replace_all(string\u0026amp; str,const string\u0026amp; old_value,const string\u0026amp; new_value) { while(true) { string::size_type pos(0); if( (pos=str.find(old_value))!=string::npos ) str.replace(pos,old_value.length(),new_value); else break; } return str; } /* replace 12 with 21 12212 -\u0026gt; 21221 */ string\u0026amp; replace_all_distinct(string\u0026amp; str,const string\u0026amp; old_value,const string\u0026amp; new_value) { for(string::size_type pos(0); pos!=string::npos; pos+=new_value.length()) { if( (pos=str.find(old_value,pos))!=string::npos ) str.replace(pos,old_value.length(),new_value); else break; } return str; } 还有很深的感触就是 UVaOJ 上面关于 WA 和 PE 分的不是很清楚。多了空行算 WA，行内少了或多了空格算 PE。\n一套字符串题目刷下来，感到非常吃力，被各种 WA 以及 PE。\n","date":"2015-02-07T19:29:00+08:00","permalink":"https://ivy-end.github.io/p/acm-icpc-%E5%AF%92%E5%81%87%E7%BB%83%E4%B9%A0-02/","title":"ACM-ICPC 寒假练习 02"},{"content":"刚刚结束了 ACM 的集训，仔细反思了第一学期的大学学习生活。\n首先要说的是上课，在一开始的时候，我每次都会提前很久去占座。但是这样的情况并没有持续很久，有一段时间由于感觉老师讲得太慢，经常上课开小差。但是事后自习想了想，还是决定回到开学时的状态。但是这时候我却惊讶的发现，并不需要占座了，就算是踩着上课铃去上课，也依旧可以坐到第一排（线性代数除外）。解决了态度问题，接下来还是有一个不可回避的问题，有时候觉得讲得太慢，不想听。所以就带了自己的书，讲到不懂的，就认真听课，其余时间就好好看自己的书，学习别的东西。\n接下来是平时的自习，作业了。说来惭愧，一个学期都没有去过图书馆自习，一般都是晚自习做完作业，如果做不完就回宿舍做。因为是上床下桌，有一个隔板，所以我可以不受干扰的自己看书。在大一上学期，我自学了《数学文化》这门课程，并且进一步的了解了微分方程，以及线性代数。当然，还有很多没有做完的事情，比如《中国古代哲学史》没有如期看完，做志愿者时问学者要的《唐代文学研究》看了一篇《唐宋科举制度对诗词体裁的影响》就没有坚持看下去。\n我感觉大学是一个非常适合学习的时间段。首先，没有太大的压力，其次， 可以利用的教育资源很多。这时候，只要我们想学的，都可以通过查阅资料，自己慢慢沉进去，总会有收获。大抵就这就是学习吧。孔子曰，有教无类，我想，学习也大抵如此。曾经听过这样一句话：未知是已知的边缘。已知的越多就会发现未知的越多。仔细想想，的确非常有道理。至于学习的方面，我想可以是多样化的，因为你无法预知你现在所学的或许在未来的某个时刻会派上用场。\n我依稀记得张贤明说过的一个词「慎独」，当时只是觉得自己又知道了一个新的名词，现在想想，这中间寄托了他的多少期望。\n现在回想起来，在中学时期，每到放假都会玩，但是现在，书桌前堆满了书和论文，只是想着什么时候把它们看完。或许这是我一个非常大的转变吧。\n不得不提的是 ACM，经过了三次校内选拔，七天的留校集训，要开始准备四月份的邀请赛。希望今年的比赛能够夺得亚洲区金牌吧。\n再来说说今天刚刚收到的成绩单，总评绩点 3.84 / 4.0，但是这似乎并不能使我感到满意。英语一如既往的成为短板。\n或许我们可以比高三更加认真，付出的更多，谁又知道命运会在将来给你什么呢。\n","date":"2015-02-06T20:57:00+08:00","permalink":"https://ivy-end.github.io/p/reflections/","title":"REFLECTIONS"},{"content":"这一系列的练习主要在 Virtual Judge 上进行，题目为小白书上的题目推荐。\nUVa 10055 求两方军队人数的差值，直接相减即可。\n不过要注意两个数的大小关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { long long x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { if(x \u0026gt; y) { swap(x, y); } cout \u0026lt;\u0026lt; y - x \u0026lt;\u0026lt; endl; } return 0; } UVa 10071 简单物理题，求两倍时间内匀速运动的路程。即 $s = 2vt$。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x, y; while(cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y) { cout \u0026lt;\u0026lt; x * y * 2 \u0026lt;\u0026lt; endl; } return 0; } UVa 10300 根据题目描述推导公式，$$ \\mathrm{ans} = \\sum{\\left(\\frac{x}{y}\\cdot y\\cdot z\\right)} = \\sum{xz}$$\n题中讲到了首先计算每只动物的占地面积，乘以环境友好常数，再乘以动物数目。这里可以直接将动物数目约去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int T, N, x, y, z; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { int ans = 0; cin \u0026gt;\u0026gt; N; for(int j = 1; j \u0026lt;= N; j++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; ans += x * z; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } UVa 458 凯撒密码，加密的时候将 ASCII 右移了 7 位，解密的时候只要反过来左移 7 位即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string x; while(getline(cin, x)) { for(int i = 0; i \u0026lt; x.length(); i++) { cout \u0026lt;\u0026lt; (char)(x[i] - 7); } cout \u0026lt;\u0026lt; endl; } return 0; } UVa 494 一开始想通过计算空格数来计算单词个数，后来发现不行，只好使用原始的模拟方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string x, y; while(getline(cin, x)) { y = \u0026#34;\u0026#34;; int ans = 0; for(int i = 0; i \u0026lt; x.length(); i++) { if(x[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; x[i] \u0026lt;= \u0026#39;Z\u0026#39; || x[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; x[i] \u0026lt;= \u0026#39;z\u0026#39;) { y += x[i]; } else { if(y != \u0026#34;\u0026#34;) { ans++; y = \u0026#34;\u0026#34;; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } UVa 414 英语不好，题目看了半天，找了翻译，才看懂题目。\n实际上，只有包裹在 $X$ 内部的空格才要统计在内，即得 $\\mathrm{ans} = \\mathrm{Total} - \\mathrm{Minimum} \\times \\mathrm{Row}$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int N; string x; while(cin \u0026gt;\u0026gt; N) { cin.get(); if(!N) { break; } int nTotal = 0, nMin = 2147483647; for(int i = 1; i \u0026lt;= N; i++) { int nTmp = 0; getline(cin, x); for(int j = 0; j \u0026lt; x.length(); j++) { if(x[j] == \u0026#39; \u0026#39;) { nTmp++; } } nTotal += nTmp; nMin = min(nMin, nTmp); } cout \u0026lt;\u0026lt; nTotal - nMin * N \u0026lt;\u0026lt; endl; } return 0; } UVa 490 这个处理要注意没有字符的时候输出空格，否则会 PE。类似矩阵转置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; const int MAX = 128; string strTmp[MAX]; int main() { int nPos = 0, nLen = 0; while(getline(cin, strTmp[++nPos])) { nLen = max(nLen, (int)strTmp[nPos].length()); } for(int j = 0; j \u0026lt; nLen; j++) { for(int i = nPos - 1; i \u0026gt;= 1; i--) { if(j \u0026lt; strTmp[i].length()) { cout \u0026lt;\u0026lt; strTmp[i][j]; } else { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; } return 0; } int max(int x, int y) { return x \u0026gt; y ? x : y; } UVa 445 朴素的字符串处理题，注意换行的处理。水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; string x; int main() { while(getline(cin, x)) { int nPos = 0; while(nPos \u0026lt; x.length()) { int nCnt = 0; if(x[nPos] == \u0026#39;!\u0026#39;) { cout \u0026lt;\u0026lt; endl; } while(x[nPos] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; x[nPos] \u0026lt;= \u0026#39;9\u0026#39;) { nCnt += x[nPos] - \u0026#39;0\u0026#39;; nPos++; } for(int i = 1; i \u0026lt;= nCnt; i++) { if(x[nPos] == \u0026#39;b\u0026#39;) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { cout \u0026lt;\u0026lt; x[nPos]; } } nPos++; } cout \u0026lt;\u0026lt; endl; } return 0; } UVa 488 水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; void Tri(int x); int main() { int T, N, M; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int j = 1; j \u0026lt;= M; j++) { Tri(N); if(j != M) { cout \u0026lt;\u0026lt; endl; } } if(i != T) { cout \u0026lt;\u0026lt; endl; } } } void Tri(int x) { for(int i = 1; i \u0026lt;= x - 1; i++) { for(int j = 1; j \u0026lt;= i; j++) { cout \u0026lt;\u0026lt; i; } cout \u0026lt;\u0026lt; endl; } for(int i = 1; i \u0026lt;= x; i++) { cout \u0026lt;\u0026lt; x; } cout \u0026lt;\u0026lt; endl; for(int i = x - 1; i \u0026gt;= 1; i--) { for(int j = i; j \u0026gt;= 1; j--) { cout \u0026lt;\u0026lt; i; } cout \u0026lt;\u0026lt; endl; } } UVa 489 还是英语不好，百度了游戏规则才看懂了题目。看懂以后就是水题了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 32; bool pVisited[MAX]; int main() { int N; string x, y; while(cin \u0026gt;\u0026gt; N) { if(N == -1) { break; } bool bFlag = true; int nCnt = 0, nTmp = 0, nWrong = 0; memset(pVisited, false, sizeof(pVisited)); cout \u0026lt;\u0026lt; \u0026#34;Round \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; for(int i = 0; i \u0026lt; x.length(); i++) { if(!pVisited[x[i] - \u0026#39;a\u0026#39;]) { pVisited[x[i] - \u0026#39;a\u0026#39;] = true; nCnt++; } } for(int i = 0; i \u0026lt; y.length(); i++) { if(pVisited[y[i] - \u0026#39;a\u0026#39;]) { pVisited[y[i] - \u0026#39;a\u0026#39;] = false; nTmp++; } else { nWrong++; } if(nTmp == nCnt \u0026amp;\u0026amp; nWrong \u0026lt; 7) { bFlag = true; break; } if(nTmp != nCnt \u0026amp;\u0026amp; nWrong \u0026gt;= 7) { bFlag = false; break; } } if(bFlag) { if(nTmp == nCnt) { cout \u0026lt;\u0026lt; \u0026#34;You win.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;You chickened out.\u0026#34; \u0026lt;\u0026lt; endl; } } else { cout \u0026lt;\u0026lt; \u0026#34;You lose.\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } UVa 694 又是 $3n + 1$ 问题，一开始总是 TLE，位运算以后还是 TLE，后来发现用了 int，中间值会溢出，所以表面上是 TLE，实际上已经 WA 了。或许这就是 TLE 有可能是 WA 的一个很好的例子吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; int main() { long long A, L, nCase = 0; while(scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;A, \u0026amp;L) != EOF) { if(A == -1 \u0026amp;\u0026amp; L == -1) { break; } printf(\u0026#34;Case %lld: A = %lld, limit = %lld, number of terms = \u0026#34;, ++nCase, A, L); long long nCnt = 0; while(A \u0026lt;= L) { nCnt++; if(A == 1) { break; } if(A \u0026amp; 1) { A = 3 * A + 1; } else { A \u0026gt;\u0026gt;= 1; } } printf(\u0026#34;%lld\\n\u0026#34;, nCnt); } return 0; } UVa 457 感觉像模拟细胞生命的游戏，模拟即可，水题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 64; int pData[MAX], pDish[MAX][2]; int main() { int T; cin \u0026gt;\u0026gt; T; for(int i = 1; i \u0026lt;= T; i++) { memset(pDish, 0, sizeof(pDish)); pDish[20][0] = 1; for(int j = 0; j \u0026lt; 10; j++) { cin \u0026gt;\u0026gt; pData[j]; } for(int j = 1; j \u0026lt;= 50; j++) { for(int k = 1; k \u0026lt;= 40; k++) { if(pDish[k][0] == 0) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } if(pDish[k][0] == 1) { cout \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; } if(pDish[k][0] == 2) { cout \u0026lt;\u0026lt; \u0026#34;x\u0026#34;; } if(pDish[k][0] == 3) { cout \u0026lt;\u0026lt; \u0026#34;W\u0026#34;; } } for(int k = 1; k \u0026lt;= 40; k++) { int nCnt = pDish[k - 1][0] + pDish[k][0] + pDish[k + 1][0]; pDish[k][1] = pData[nCnt]; } for(int k = 1; k \u0026lt;= 40; k++) { pDish[k][0] = pDish[k][1]; } cout \u0026lt;\u0026lt; endl; } if(i != T) { cout \u0026lt;\u0026lt; endl; } } return 0; } 总结一下，刷了 12 道水题，发现比 SGU 简单多了，就这样穿插着刷一刷小白书吧。\n","date":"2015-02-06T17:33:00+08:00","permalink":"https://ivy-end.github.io/p/acm-icpc-%E5%AF%92%E5%81%87%E7%BB%83%E4%B9%A0-01/","title":"ACM-ICPC 寒假练习 01"},{"content":"Description CIA has decided to create a special telephone directory for its agents. The first 2 pages of the directory contain the name of the directory and instructions for agents, telephone number records begin on the third page. Each record takes exactly one line and consists of 2 parts: the phone number and the location of the phone. The phone number is 4 digits long. Phone numbers cannot start with digits 0 and 8. Each page of the telephone directory can contain not more then $K$ lines. Phone numbers should be sorted in increasing order. For the first phone number with a new first digit, the corresponding record should be on a new page of the phone directory. You are to write a program, that calculates the minimal number P pages in the directory. For this purpose, CIA gives you the list of numbers containing $N$ records, but since the information is confidential, without the phones locations.\nInput The first line contains a natural number $K$ ($0 \u0026lt; K \u0026lt; 255$) - the maximum number of lines that one page can contain. The second line contains a natural $N$ ($0 \u0026lt; N \u0026lt; 8000$) - number of phone numbers supplied. Each of following $N$ lines contains a number consisting of 4 digits - phone numbers in any order, and it is known, that numbers in this list cannot repeat.\nOutput First line should contain a natural number $P$ - the number of pages in the telephone directory.\nSample Input 1 2 3 4 5 6 7 8 9 10 11 12 5 10 1234 5678 1345 1456 1678 1111 5555 6789 6666 5000 Sample Output 1 5 Analysis 这是一道水题。事实上，我们只需要电话号码的第一位，因此，读入数据以后直接除以 1000 即可，然后记录一下以各个数字开头的电话号码有几个。\n如果不能被 $K$ 整除，那么就需要 Num / (K + 1) 页，否则只需要 Num / K 页，这样处理的同时也满足了题目中每个新的首位电话号码另起一页的要求。\n需要注意的是，最后要把题目中提到的电话簿开头 2 页加上去。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 16; const int HEX = 1000; int K, N; int pData[MAX]; int main() { while(cin \u0026gt;\u0026gt; K \u0026gt;\u0026gt; N) { int nTmp, ans = 0; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; nTmp; pData[nTmp / HEX]++; } for(int i = 1; i \u0026lt;= 9; i++) { ans += pData[i] / K + (pData[i] % K != 0); } cout \u0026lt;\u0026lt; ans + 2 \u0026lt;\u0026lt; endl; } return 0; } 被 101 卡了好久，一直做不出来，往后看看，这道水题居然排在了它的后面。\n","date":"2015-02-05T21:30:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-127-telephone-directory/","title":"SGU 127 - Telephone directory"},{"content":"Description You are given natural numbers $a$ and $b$. Find $a^b - b^a$.\nInput Input contains numbers $a$ and $b$ ($1\\leq a,b\\leq 100$).\nOutput Write answer to output.\nSample Input 1 2 3 Sample Output 1 -1 Analysis 非常明显的高精度，再观察一下样例，要处理减法，而且有负数，注意一下好了。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 1024; const int HEX = 10000; const int BIT = 4; class Huge { public: Huge(); Huge(int x); ~Huge(); public: Huge\u0026amp; operator *= (int x); Huge\u0026amp; operator - (Huge \u0026amp;x); bool operator \u0026gt; (Huge x); public: friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;out, Huge \u0026amp;x); public: int m_pData[MAX]; int m_nLen; }; Huge::Huge() { memset(m_pData, 0, sizeof(m_pData)); m_nLen = 1; } Huge::Huge(int x) { memset(m_pData, 0, sizeof(m_pData)); m_pData[1] = x; m_nLen = 1; } Huge::~Huge() { } bool Huge::operator \u0026gt; (Huge x) { if(this-\u0026gt;m_nLen != x.m_nLen) { return this-\u0026gt;m_nLen \u0026gt; x.m_nLen; } else { for(int i = this-\u0026gt;m_nLen; i \u0026gt;= 1; i--) { if(this-\u0026gt;m_pData[i] != x.m_pData[i]) { return this-\u0026gt;m_pData[i] \u0026gt; x.m_pData[i]; } } } return true; } Huge\u0026amp; Huge::operator *= (int x) { for(int i = 1; i \u0026lt;= this-\u0026gt;m_nLen; i++) { this-\u0026gt;m_pData[i] *= x; } for(int i = 1; i \u0026lt;= this-\u0026gt;m_nLen; i++) { this-\u0026gt;m_pData[i + 1] += this-\u0026gt;m_pData[i] / HEX; this-\u0026gt;m_pData[i] %= HEX; } while(this-\u0026gt;m_pData[this-\u0026gt;m_nLen + 1]) { this-\u0026gt;m_nLen++; } return *this; } Huge\u0026amp; Huge::operator - (Huge \u0026amp;x) { bool bFlag = (*this \u0026gt; x); if(!bFlag) { swap(*this, x); } Huge *ans = new Huge(); ans = this; for(int i = 1; i \u0026lt;= ans-\u0026gt;m_nLen; i++) { ans-\u0026gt;m_pData[i] -= x.m_pData[i]; if(ans-\u0026gt;m_pData[i] \u0026lt; 0) { ans-\u0026gt;m_pData[i + 1]--; ans-\u0026gt;m_pData[i] += HEX; } } while(!ans-\u0026gt;m_pData[ans-\u0026gt;m_nLen] \u0026amp;\u0026amp; ans-\u0026gt;m_nLen) { ans-\u0026gt;m_nLen--; } if(!bFlag) { ans-\u0026gt;m_pData[ans-\u0026gt;m_nLen] = -ans-\u0026gt;m_pData[ans-\u0026gt;m_nLen]; } return *ans; } ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;out, Huge \u0026amp;x) { out \u0026lt;\u0026lt; x.m_pData[x.m_nLen]; for(int i = x.m_nLen - 1; i \u0026gt;= 1; i--) { if(x.m_pData[i] \u0026lt; 1000) { out \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; } if(x.m_pData[i] \u0026lt; 100) { out \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; } if(x.m_pData[i] \u0026lt; 10) { out \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; } out \u0026lt;\u0026lt; x.m_pData[i]; } return out; } int main() { int a, b; while(cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { Huge x(a), y(b); for(int i = 1; i \u0026lt; b; i++) { x *= a; } for(int i = 1; i \u0026lt; a; i++) { y *= b; } cout \u0026lt;\u0026lt; x - y \u0026lt;\u0026lt; endl; } return 0; } 高精度是我最惧写的，因为太麻烦，每次都要写上百行，还要重载运算符，弄不好还需要进行调试。\n","date":"2015-02-05T14:52:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-112-ab-ba/","title":"SGU 112 - a^b - b^a"},{"content":"Description Nearly prime number is an integer positive number for which it is possible to find such primes $P_1$ and $P_2$ that given number is equal to $P_1\\cdot P_2$. There is given a sequence on $N$ integer positive numbers, you are to write a program that prints \u0026ldquo;Yes\u0026rdquo; if given number is nearly prime and \u0026ldquo;No\u0026rdquo; otherwise.\nInput Input file consists of $N + 1$ numbers. First is positive integer $N$ ($1\\leq N\\leq 10$). Next $N$ numbers followed by $N$. Each number is not greater than $10^9$. All numbers separated by whitespace(s).\nOutput Write a line in output file for each number of given sequence. Write \u0026ldquo;Yes\u0026rdquo; in it if given number is nearly prime and \u0026ldquo;No\u0026rdquo; in other case.\nSample Input 1 2 1 6 Sample Output 1 Yes Analysis 考虑到数据范围不是很大，$10^9$ 以内仅有五千多万个质数，可以通过打表来解决。打表自然是筛法求素数。\n每次读入数据以后，只要比较到 $\\sqrt{X}$ 就可以了，这样我们就可以在 $O\\left(\\sqrt{n}\\right)$ 的时间内求出结果。\n这里有个小小的注意点，我们在循环的时候，最好使用 i * i \u0026lt;= X 来代替 i \u0026lt;= sqrt(X) + 1，因为后者容易产生浮点数误差。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; const int MAX = 32000; bool pPrimes[MAX]; vector\u0026lt;int\u0026gt; pVec; int main() { unsigned long long N, x, y; memset(pPrimes, true, sizeof(pPrimes)); for(int i = 2; i \u0026lt; MAX; i++) { if(pPrimes[i]) { pVec.push_back(i); for(int j = i + i; j \u0026lt; MAX; j += i) { pPrimes[j] = false; } } } cin \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; x; bool bFlag = false; for(int j = 0; j \u0026lt; pVec.size(); j++) { if(x % pVec[j] == 0) { y = x / pVec[j]; bool bTmp = true; for(int k = 2; k * k \u0026lt;= y; k++) { if(y % k == 0) { bTmp = false; break; } } if(y \u0026lt;= 1) { bTmp = false; } if(y == 2) { bTmp = true; } if(bTmp) { bFlag = true; break; } } } if(bFlag) { cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 这道题目可以用来练习使用筛法求素数，题目本身并不具有很强的思考性。\n","date":"2015-02-05T14:46:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-113-nearly-prime-numbers/","title":"SGU 113 - Nearly prime numbers"},{"content":"Description For given number $N$ you must output amount of $N$-digit numbers, such, that last digits of their square is equal to 987654321.\nInput Input contains integer number $N$ ($1\\leq N\\leq 10^6$).\nOutput Write answer in output file.\nSample Input 1 8 Sample Output 1 0 Analysis 在一定意义上，这也是一道数学题。\n由于一个数平方的后X位，只与这个数字的后X位有关系，所以我们不妨使用下面的程序打一个表来看一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // sqrt(987654321) \u0026gt; 30000 for(long long i = 30000; i \u0026lt;= 999999999; i++) { long long x = i * i; if(x % 1000000000 == 987654321) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return 0; } 打完表以后，我们发现只有 8 个数字满足条件，而且分布在 100,000,000 到 999,999,999 之间。\n下面我们来推导满足题目条件的答案与输入的位数 $N$ 的关系：$$\\mathrm{ans} = \\begin{cases}0, \u0026amp; N \\leq 8\\\\ 8, \u0026amp; N = 9\\\\ 72\\times 10^{N - 10}, \u0026amp; N \\geq 10\\end{cases}$$ 最后一种情况我们要稍微考虑一下，由于平方后的后 9 位只与原数的后 9 位有关，因此就变成了给定后 9 位（第二种情况下的 8 个答案作为后九位数字），前面 $N-9$ 位数字的方案数，由排列组合以及 $N$ 位数的要求，不难的出结论：$72 \\times 10^{N - 10}$。\n有了这个结论，我们就可以在 $O(1)$ 时间内得到答案。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int N; cin \u0026gt;\u0026gt; N; if(N \u0026lt;= 8) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else if(N == 9) { cout \u0026lt;\u0026lt; 8 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; 72 \u0026lt;\u0026lt; endl; while(N - 10) { cout \u0026lt;\u0026lt; 0; N--; } } return 0; } 这道题目最主要的是通过打表找出规律，然后通过数学方法，巧妙地将题目所要求的答案转换为前面 $N-9$ 位上数字的排列方式，这样问题就得到了简化，也就很容易解决了。\n","date":"2015-02-05T14:33:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-107-987654321-problem/","title":"SGU 107 - 987654321 problem"},{"content":"Description Petya is well-known with his famous cabbage patties. Petya\u0026rsquo;s birthday will come very soon, and he wants to invite as many guests as possible. But the boy wants everybody to try his specialty of the house. That\u0026rsquo;s why he needs to know the number of the patties he can cook using the stocked ingredients. Petya has $P$ grams of flour, $M$ milliliters of milk and $C$ grams of cabbage. He has plenty of other ingredients. Petya knows that he needs $K$ grams of flour, $R$ milliliters of milk and $V$ grams of cabbage to cook one patty. Please, help Petya calculate the maximum number of patties he can cook.\nInput The input file contains integer numbers $P$, $M$, $C$, $K$, $R$ and $V$, separated by spaces and/or line breaks ($1 \\leq P, M, C, K, R, V \\leq 10000$).\nOutput Output the maximum number of patties Petya can cook.\nSample Input 1 2 3000 1000 500 30 15 60 Sample Output 1 8 Analysis 简单的数学分析就知道，所求答案为 $\\left\\lfloor\\frac{P}{K}\\right\\rfloor$，$\\left\\lfloor\\frac{M}{R}\\right\\rfloor$，$\\left\\lfloor\\frac{C}{V}\\right\\rfloor$ 的最小值。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; int min(int x, int y, int z); int main() { int P, M, C, K, R, V; cin \u0026gt;\u0026gt; P \u0026gt;\u0026gt; M \u0026gt;\u0026gt; C; cin \u0026gt;\u0026gt; K \u0026gt;\u0026gt; R \u0026gt;\u0026gt; V; cout \u0026lt;\u0026lt; min(P / K, M / R, C / V) \u0026lt;\u0026lt; endl; return 0; } int min(int x, int y, int z) { return min(x, min(y, z)); } 这道题目涉及到的一个数学思想是——短板理论。\n也就是决定能够制作多少个馅饼的数目是由各个原料能够制作的馅饼数的最小值来决定的。\n短板理论在我们的日常生活中也很常见。我们也要经常发现自己的短板所在，并对其进行提升，进一步的完善自我，提升自我。\n","date":"2015-01-30T17:57:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-184-patties/","title":"SGU 184 - Patties"},{"content":"Description Little Johnny likes to draw a lot. A few days ago he painted lots of straight lines on his sheet of paper. Then he counted in how many zones the sheet of paper was split by these lines. He noticed that this number is not always the same. For instance, if he draws 2 lines, the sheet of paper could be split into 4, 3 or even 2 (if the lines are identical) zones. Since he is a very curious kid, he would like to know which is the maximum number of zones into which he can split the sheet of paper, if he draws $N$ lines. The sheet of paper is to be considered a very large (=infinite) rectangle.\nInput The input file will contain an integer number: $N$ ($0\\leq N\\leq 65535$).\nOutput You should output one integer: the maximum number of zones into which the sheet of paper can be split if Johnny draws $N$ lines.\nSample Input #1 1 0 Sample Output #1 1 1 Sample Input #2 1 1 Sample Output #2 1 2 Analysis 数学题。直线分平面数，我们也可以通过找规律的方法来求出它的公式：\n线段数 $N$ 平面数 $M$ 0 1 1 1 + 1 = 2 2 2 + 2 = 4 3 4 + 3 = 7 4 7 + 4 = 11 5 11 + 5 = 16 6 16 + 6 = 22 根据上表，我们可以很容易的求得递推公式：$$M_N = M_{N-1} + N$$\n由此得到通项公式：$$M = \\frac{N \\cdot (N + 1)}{2} + 1$$\n当然我们也可以使用数学归纳法证明这个结论。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; typedef unsigned long long ull; int main() { int N; cin \u0026gt;\u0026gt; N; cout \u0026lt;\u0026lt; (ull)N * (N + 1) / 2 + 1; return 0; } 本题需要注意的是给出的数据范围如果不使用 unsigned long long 会溢出，因此必须使用 unsigned long long。\n","date":"2015-01-29T21:33:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-135-drawing-lines/","title":"SGU 135 - Drawing Lines"},{"content":"Description First year of new millenium is gone away. In commemoration of it write a program that finds the name of the day of the week for any date in 2001.\nInput Input is a line with two positive integer numbers $N$ and $M$, where $N$ is a day number in month $M$. $N$ and $M$ is not more than 100.\nOutput Write current number of the day of the week for given date (Monday – number 1, … , Sunday – number 7) or phrase \u0026ldquo;Impossible\u0026rdquo; if such date does not exist.\nSample Input 1 21 10 Sample Output 1 7 Analysis 翻看日历，我们可以知道 2001 年 1 月 1 日为星期一。\n这样，我们只需要计算输入的日期为该年中的第几天就行了。\n当然，要记得判断输入的日期是否合法。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; const int pDay[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; int main() { int N, M, ans = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; if((M \u0026gt; 12 || N \u0026gt; 31) || (M == 4 || M == 6 || M == 9 || M == 11) \u0026amp;\u0026amp; N \u0026gt; 30 || M == 2 \u0026amp;\u0026amp; N \u0026gt; 28) { cout \u0026lt;\u0026lt; \u0026#34;Impossible\u0026#34; \u0026lt;\u0026lt; endl; } else { for(int i = 1; i \u0026lt; M; i++) { ans += pDay[i]; } ans += N; cout \u0026lt;\u0026lt; (ans % 7 == 0 ? 7 : ans % 7) \u0026lt;\u0026lt; endl; } return 0; } ","date":"2015-01-29T21:18:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-115-calendar/","title":"SGU 115 - Calendar"},{"content":"Description The Fibonacci sequence of numbers is known: $F_1 = 1$; $F_2 = 1$; $F_{n+1} = F_n + F_{n-1}$, for $n\u0026gt;1$. You have to find $S$ - the sum of the first $K$ Fibonacci numbers.\nInput First line contains natural number $K$ ($0\u0026lt;K\u0026lt;41$).\nOutput First line should contain number $S$.\nSample Input 1 5 Sample Output 1 12 Analysis 考虑到数据范围，这道题目只要模拟一下就行了。但是我还是比较喜欢使用数学方法来求解。\n令 $S_n$ 表示斐波那契数列的前 $N$ 项和，那么我们很容易求得 $S_n = F_{n+2} - 1$。\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 64; int f[MAX]; int main() { int N; cin \u0026gt;\u0026gt; N; f[1] = f[2] = 1; for(int i = 3; i \u0026lt;= N + 2; i++) { f[i] = f[i - 1] + f[i - 2]; } cout \u0026lt;\u0026lt; f[N + 2] - 1 \u0026lt;\u0026lt; endl; return 0; } 这道题目应该是非常简单的。当然，如果你不知道斐波那契数列可以在$O(n)$时间内求得，那么这道题目对于你来说还是有一定难度的。\n","date":"2015-01-29T21:03:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-123-the-sum/","title":"SGU 123 - The Sum"},{"content":"Description There is sequence 1, 12, 123, 1234, \u0026hellip;, 12345678910, \u0026hellip; . Given first $N$ elements of that sequence. You must determine amount of numbers in it that are divisible by 3.\nInput Input contains $N$ ($1\\leq N\\leq 2^{31} - 1$).\nOutput Write answer in output file.\nSample Input 1 4 Sample Output 1 2 Analysis 由于一个数对 $3$ 取模恒等于这个数各个位上数字之和对 $3$ 取模。因此，非常容易想到的方法是找规律：\n项数 $N$ 数列 除以 $3$ 的余数 答案 $ans$ 1 1 1 0 2 12 0 1 3 123 0 2 4 1234 1 2 5 12345 0 3 6 123456 0 4 7 1234567 1 4 8 12345678 0 5 9 123456789 0 6 由上述表格，我们可以大致的看出规律，即：$$\\mathrm{ans} = \\begin{cases} \\mathrm{ans}, \u0026amp; N \\mod 3 = 1\\\\ \\mathrm{ans} + 1, \u0026amp; N \\mod 3 = 0, 2\\end{cases}$$\n有了上述的讨论，我们可以很容易的写出一个暴力算法，但是考虑到 $N$ 的数据范围比较大，这并不是一个非常好的选择。\n我们可以推导出数学公式来求解这个问题。观察上表（下面的除法为 C++ 意义中的整除）：$$ \\mathrm{ans}=\\begin{cases}2N / 3, \u0026amp; N \\mod 3 = 0\\\\ 2N / 3, \u0026amp; N \\mod 3 = 1 \\\\ 2N / 3 + 1, \u0026amp; N \\mod 3 = 2\\end{cases}$$\n把上述公式归纳成一个公式，即为 ans = 2 * N / 3 + (N % 3 == 2)，此处 N % 3 == 2 的返回值为真、假，分别对应着 1 和 0。\nSolution 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int N; cin \u0026gt;\u0026gt; N; cout \u0026lt;\u0026lt; N / 3 * 2 + (N % 3 == 2) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; return 0; } ","date":"2015-01-29T20:48:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-105-div-3/","title":"SGU 105 - Div 3"},{"content":"Description For given integer $N$ ($1\\leq N\\leq 10^4$) find amount of positive numbers not greater than $N$ that coprime with $N$. Let us call two positive integers (say, $A$ and $B$, for example) coprime if (and only if) their greatest common divisor is 1. (i.e. $A$ and $B$ are coprime iff $\\mathrm{gcd}\\left(A,B\\right) = 1$).\nInput Input file contains integer $N$.\nOutput Write answer in output file.\nSample Input 1 9 Sample Output 1 6 Analysis 我首先想到的是欧拉函数 $\\varphi\\left(N\\right)$，后来发现数据量并不是特别的大，所以又用暴力做了一遍，也 AC 了。\n这道题目的重点在于欧拉函数 $\\varphi\\left(N\\right)$ 的求法，现总结如下：\n欧拉函数 $\\varphi\\left(N\\right)$：小于等于 $N$ 且与 $N$ 互素的正整数的个数。\n欧拉函数据有如下性质：\n$\\varphi\\left(1\\right) = 1$ $\\varphi\\left(N\\right) = N\\cdot\\sum_{p|N}{\\left(\\frac{p-1}{p}\\right)}$，其中 $p$ 为素数 $\\varphi\\left(p^k\\right) = p^k - p^{k - 1} = \\left(p-1\\right)p^{k - 1}$，其中p为素数 $\\varphi\\left(mn\\right)=\\varphi\\left(m\\right)\\cdot \\varphi\\left(n\\right)$，其中 $\\mathrm{gcd}\\left(m,n\\right)=1$ 根据第 2 个式子我们就可以求出欧拉函数。\n基本思路：首先置 $\\varphi\\left(N\\right) = N$，然后枚举 $N$ 的素因子 $p$，将 $p$ 的整数倍的欧拉函数 $\\varphi\\left(k\\cdot p\\right)$ 置 $\\varphi\\left(k\\cdot p\\right) = \\varphi\\left(k\\cdot p\\right) \\cdot \\frac{p - 1}{p}$ 即可。\n基本代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 1024; int N; int p[MAX], phi[MAX]; int main() { cin \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= N; i++) // 初始化 { p[i] = 1; phi[i] = i; } p[1] = 0; // 1不是素数 for(int i = 2; i \u0026lt;= N; i++) // 筛素数 { if(p[i]) { for(int j = i * i; j \u0026lt;= N; j += i) { p[j] = 0; } } } for(int i = 2; i \u0026lt;= N; i++) // 求欧拉函数 { if(p[i]) { for(int j = i; j \u0026lt;= N; j += i) // 处理素因子p[i] { phi[j] = phi[j] / i * (i - 1); // 先除后乘，防止中间过程超出范围 } } } cout \u0026lt;\u0026lt; \u0026#34;Primes: \u0026#34; \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= N; i++) { if(p[i]) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Euler Phi Function: \u0026#34; \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; phi[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } Solution 欧拉函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; using namespace std; int phi(int x); int main() { int N; cin \u0026gt;\u0026gt; N; cout \u0026lt;\u0026lt; phi(N) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; return 0; } int phi(int x) { int nRet = x; int nTmp = (int)sqrt(x); for(int i = 2; i \u0026lt;= nTmp; i++) { if(x % i == 0) { nRet = nRet / i * (i - 1); while(x % i == 0) { x /= i; } } } if(x \u0026gt; 1) { nRet = nRet / x * (x - 1); } return nRet; } 暴力 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; using namespace std; int gcd(int x, int y); int main() { int N, nRet = 0; cin \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= N; i++) { if(gcd(N, i) == 1) { nRet++; } } cout \u0026lt;\u0026lt; nRet \u0026lt;\u0026lt; endl; return 0; } int gcd(int x, int y) { if(y == 0) { return x; } return gcd(y, x % y); } SGU 不愧是经典题目的合集，每做一道题都会学到一些新的东西。\n","date":"2015-01-29T20:17:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-102-coprimes/","title":"SGU 102 - Coprimes"},{"content":"[100. A+B]\nDescription Read integers $A$ and $B$ from input file and write their sum in output file.\nInput Input file contains $A$ and $B$ ($0\u0026lt;A,B\u0026lt;10001$).\nOutput Write answer in output file.\nSample Input 1 5 3 Sample Output 1 8 Analysis 水题。\nSolution 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; return 0; } 到了大学，开始接触 ACM。高中里参加了 3 年 NOIP，拿了两年的二等奖，现在终于接触到了 ACM，找到了 SGU 这个 OJ 开始刷题。\n一方面，这上面的题目都有些难度，另一方面，由于是英文的，可以在一定程度上提高我的英语水平。\n我是按照 SGU 上题目的 AC 数来刷的，并不是完全按照编号往下刷的。\n","date":"2015-01-29T20:08:00+08:00","permalink":"https://ivy-end.github.io/p/sgu-100-a--b/","title":"SGU 100 - A + B"},{"content":" 2015\n时光匆匆流去，转眼又已迎来新的一年。按照惯例，应该写篇文章总结一下，突然发现要说的事情太多了。各位看官且莫着急，听我慢慢道来。\n总的来说，整个 2014 感觉过的很漫长，这似乎和某个研究结果相符：每天遇到的事件越多，觉得一天的时间越长。我想这大概是因为这一年发生过太多事情的缘故吧。面对着早已习惯的分别，也已变得不太在意。要说总结，我也不知道该怎么总结。对我来说，这一年只有两个阶段：为了高考奋斗、进入大学学习。当然，除此之外也干了很多有意义的事。且从头说起罢。\n还记得刚过年的时候，想想上学这么多年也没怎么认真过，既然高考很重要，那就认真一次。自招、保送种种早已过去，以前还懊悔没有去数学决赛，到那时候也就完全没了这些想法。虽然多少分数并不是特别理想，但是想想也没什么，大不了重头再来。只是后来不知为什么没了那股冲劲，也自然就松懈了。要说那时候的状态，《他》无疑是最恰当的。就这样迎接了高考的洗礼。就这样结束了高中生涯。但是等到分数出来，却还是倍感意外，写下了《没有如果》。\n其实就我个人而言，对于高中的印象不是特别的深刻，没有太多印象深刻的事情。也就感觉三年就这样过去了。如果非要说些什么，我想大概是NOIP、MOI了吧。\n参加竞赛，是我个人觉得高中里非常正确的一个决定。如果再来一次，我还是会义无反顾的参加竞赛，即使没有取得非常好的成绩。它教给我的，远不止那几本高中教科书的内容，它使得我更有胆识去挑战更高更强的目标，同时也使得我对自己的能力有了更恰当的界定。\n还有一件事情，对数学的热爱，也是在高中里正式发展出来的。在初中里，只是觉得自己数学比较好，比较喜欢钻研难题，但是对数学并没有特别的情感。直到听了老严讲了两年数学，对数学的热爱与日俱增。很多人对于老严教数学不置可否，甚至有人觉得老严不会教学。在这么多的评价中，我觉得只有一个评价比较符合老严：\n老严教的是心，而不是学。\n的确，老严从不注重一个个题目的教学，而是整体数学思维的建立。有了这些铺垫，也就很容易解释到了大学里的我，依旧非常的喜欢数学，虽然学的是高数，却刷着吉米多维奇。四级考试的时候，作文题目记最喜欢的一门课，我随手写下了高数。很多人并不是特别喜欢数学，特别是高数。其实仔细品品，就会发现数学难言的美。最近我有一个新的认识：数学是科学中的哲学，它的发展促进了其它科学的发展，其它科学的发展同时也促进了数学的发展。说了这么多，不如举两个例子，来体会一下数学的哲学之美。\n首先要提到的，自然是欧拉公式，一个联系着 π、e、i 的等式。这已经被说烂了，并没有太多的心意。我们不妨来看一下我们所熟悉的方面——导数。大家应该都知道两个函数乘积的求导公式。但是这个小小的公式里，却蕴含着美妙的哲理：上帝是公平的，对每个函数都进行了一次求导。\n学了将近一学期高数的我们，应该也清楚正无穷、负无穷、无穷这三个符号。所谓无穷，包含着正无穷、负无穷。我们可以将数轴的首尾粘连起来，那么正负无穷就得以相遇，那么我们只需要一步就可以从正无穷走向负无穷，亦或从负无穷走向正无穷，这不恰好预示着道家所说的物极必反吗？\n不知不觉就扯偏了，但不可否认，数学的确具有别致的美。\n高考结束以后，的确轻松了很多。加入了钱老板的产业，成为了一名高三数学老师。幸苦了将近三个月，起早贪黑，没有旅游，没有太多的聚会。但是觉得很充实，学会了很多，收获了很多。当然，这中间也发生了很多故事，详见《P2P.edu - 个人总结》。一直的忙碌，以至于突然停下来以后感觉没什么事情可做，于是在某个夏夜翻来覆去的思索，记下了《夏夜寄思》。\n第一次在家里看《开学第一课》，但是自己早已不是主角，只是看着屏幕里的孩子们笑，想想他们多年后也会像我一样，看着屏幕里另一群孩子笑吧。也就在这个时候，迎来了中秋，难得望月，记下一篇《中秋望月感怀》。而此时，小伙伴们大多都已经开学。\n就这样，日子一天天的步入了大学，军训过后，开始了正式的大学生活，第一节慕课，校长讲了为什么要读大学，深有感触，思索了几天，写下了《我为什么要读大学》。等到一切慢慢步入正轨，才发现自己所选专业的课程非常多，而且作业也不少，每周都忙不过来。除此之外，并没有太多的不适应，六年的住宿生活，使得自己早已习惯了宿舍里的生活，也并不存在适应不适应的问题了。\n进入大学以来，虽然也加了学生会，但是从不揽事，只是尽可能把本职工作做好，因为实在无心无力，忙不过来。但是最近作为团队项目负责人的我申报了一个 3I 工程的项目——基于 Android、iOS 的书院掌上 APP 客户端系统以及服务器开发。希望能够顺利结项吧。还有值得一提的事情是参加了 ACM 校选赛，认识了很多志同道合的同学、学长，但愿能够在今后的赛场上摘金夺银吧。\n不知不觉写了那么多，但是感觉什么都没写，就这样吧。\n2015 会更好。\n","date":"2014-12-31T20:38:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%94%B2%E5%8D%88%E5%BF%972014-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"甲午志（2014 年度总结）"},{"content":"其实期中考试上上周就考完了，只是这几天才出分数。客观的来说，不算低了，却觉得不够。就好像今天刚刚结束的第二场ACM校选赛，第三名，却觉得为什么不是第一名。\n很久之前就有人回复我说，为什么还不更新博客。自从开学以来，忙东忙西，一直没有时间，因为我自己也不知道大学究竟是什么，回想起之前写过的一篇《我为什么要上大学》，总觉得讲不到点子上，有很多想法没有表达出来，看来很有可能会诞生一篇续集吧。\n几天前，Godaddy 给我发了一封电子邮件，说我的域名要到期了，突然意识到这个小小的博客已经存在了将近两年了。在这两年间，我也如当初创立博客的设想一样，记录着自己的生活，学习，也算是一笔宝贵的精神财富吧。\n以上两个原因，促成了写这篇文章的外因，而主要的内因是这段时间事情没那么忙了，同时一些问题也思考的差不多了，所以记录下来。\n开学这么久了，已经并不觉得大学有多么新鲜了，社团、学生会有多么好玩了。更加明白了我们导师说的，大学里最重要的还是成绩。很多东西都是形同虚设，作坊式的小打小闹，难成气候。与其在这上浪费时间，不如花时间多读几本好书。曾经在高中刷了很多的课外书，连图书馆的老师（阿姨）都认识我了，看见我还跟我打招呼。到了大学里，看见图书馆这么多的书，也不知道从何下手，不可能一个一个书架的刷，而我通常会找一些名著慢慢来啃，虽然很慢，却很有味道。\n另一个很深的感触是空闲的时间变多了，我可以花时间捣鼓以前没时间折腾的东西。虽然有人觉得东一榔头西一棒槌成不了什么事，但是我总觉得这一榔头，一棒槌在未来会联系在一起，创造出一些改变我们的东西来。接触的东西越多，越觉得自己水平不够。就如同做数学题一样，第一个境界是觉得自己什么都不会，第二个境界是觉得自己什么都会，第三个境界是觉得自己太弱了。接触的多了，视野开阔了，心也自然的平静了。现在想想张兴老师的“静”字或许还有这层含义吧。\n且再说些别的，上周回港一次，和同学出去玩，坐公交的时候，正好碰到我们那边的高中放学，一群高一的学生涌了上来，我坐在位置上，看着他们青涩的面庞，稚嫩的眼神，突然想起了多年前的我，是不是也如那般懵懂无知。只是希望他们不要再重蹈我的覆辙。基于这种心理，也慢慢理解了小时候父母的管教。那些年少时光，我们再也回不去了，但是我们拥有现在，也就拥有无限可能，未来 掌握在我们的手上。中学就如同围城一样，外面的人想进去，里面的人想出来；外面的人因为习惯了曾经被告知的目标，也就慢慢失去了自己找寻目标和方向的能力；里面的人整天被目标所烦恼，希望出去放松一下。但这终究只是念想，不可能成为事实，也就要求我们及时的找到自己的目标与方向，不要在一开始就放任自流，走上了令自己后悔的道路。\n其实一开始我也不知道自己想写什么，写着写着就写到了这些。\n最后还是讲讲刚刚结束的第二场ACM校选赛吧，很多题目做的感觉呼之欲出了，但是就是离正确答案差那么一点点。虽然这只是一点点，但是我想需要改进的就不止那么一点点了吧。\n","date":"2014-12-10T23:28:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9C%9F%E4%B8%AD%E9%9A%8F%E8%AE%B0/","title":"期中随记"},{"content":"高数教了一段时间了，对于等价无穷小量代换法求极限为什么只能在乘除中使用，而不能在加减的情况下使用的条件感到有些疑惑，于是找了一些资料，仔细的研究了这个问题，整理如下：\n等价无穷小的定义及常用的等价无穷小 无穷小量是指某变化过程中极限为 $ 0 $ 的变量。而等价无穷小量是指在某变化过程中比值极限为 $ 1 $ 的两个无穷小量。\n常用的等价无穷小有： $$ \\sin{x}\\sim \\tan{x}\\sim\\arctan{x}\\sim\\arcsin{x}\\sim \\ln{\\left(1+x \\right )}\\sim x\\left(x\\rightarrow 0\\right ) $$ $$ 1-\\cos{x}\\sim \\frac{x^{2}}{2},\\sqrt[n]{1+x}-1\\sim \\frac{x}{n} \\left(x\\rightarrow 0\\right ) $$ 等价无穷小量在求极限问题中非常重要。恰当的使用等价无穷小量代换常常使极限问题大大简化。但是有时却不能使用等价无穷小量代换。\n等价无穷小替换原理 定理1：设 $ \\displaystyle\\alpha,\\alpha_{1},\\beta,\\beta_{1} $ 是某一变化过程中的无穷小量，且 $ \\alpha \\sim \\alpha_{1},\\beta \\sim \\beta_{1} $ ，若 $ \\lim{\\frac{\\alpha}{\\beta}} $ 存在，则 $$ \\lim{\\frac{\\alpha}{\\beta}}=\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}} $$\n例1：$$ \\lim_{x\\rightarrow 0}{\\frac{\\ln{\\left(1+3x\\right)}}{\\sin{2x}}} $$\n解：$$ \\lim_{x\\rightarrow 0}{\\frac{\\ln{\\left(1+3x\\right)}}{\\sin{2x}}}=\\lim_{x\\rightarrow 0}{\\frac{3x}{2x}}=\\frac{3}{2} $$\n例2：$$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}} $$\n错误解法： $$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}}=\\lim_{x\\rightarrow 0}{\\frac{x-x}{x^3}}=0 $$\n正确解法：$$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}}=\\lim_{x\\rightarrow 0}{\\frac{\\sin{x}\\left(1-\\cos{x}\\right)}{x^{3}\\cdot\\cos{x}}}=\\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}}{x^{2}\\cdot\\cos{x}}}=\\lim_{x\\rightarrow 0}{\\frac{1}{2\\cos{x}}}=\\frac{1}{2} $$\n从上面的解法可以看出，该题分子不能直接用等价无穷小量替代来做，下面我们分析产生错误的原因：等价无穷小之间本身一般并不相等，它们之间一般相差一个较它们高阶的无穷小，由函数 $ f\\left(x\\right) $ 在点 $ x=0 $ 处的泰勒公式，即麦克劳林公式：$$ f\\left ( x \\right )=f\\left ( 0 \\right )+f\u0026rsquo;\\left ( 0 \\right )x+\\frac{f\u0026rsquo;\u0026rsquo;\\left ( 0 \\right )}{2!}x^{2}+\\cdots+\\frac{f^{\\left ( n \\right )}\\left ( 0 \\right )}{n!}x^{n}+o\\left ( x^{n} \\right ) $$ 很容易有：$$ \\tan{x}=x+\\frac{x^{3}}{3}+\\frac{2x^5}{15}+o\\left ( x^{5} \\right ) \\quad \\left ( x\\rightarrow 0 \\right ) $$ $$ \\sin{x}=x+\\frac{x^{3}}{3!}+\\frac{x^{5}}{5!}+\\frac{x^{7}}{7!}+\\cdots+\\frac{\\left ( -1 \\right )^{m-1}x^{2m-1}}{\\left ( 2m-1 \\right )!}+o\\left ( x^{2m-1} \\right ) \\quad \\left ( x\\rightarrow 0 \\right ) $$\n由此可知， $ \\sin{x} $ 与 $ \\tan{x} $ 相差一个较 $ x $ 的三阶无穷小，此三阶无穷小与分母 $ x^{3} $ 相比不可忽略，因为把上述结论代入原式得 $$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}}=\\lim{x\\rightarrow 0}{\\frac{\\frac{x^{3}}{3}+\\frac{x^{3}}{3!}+o\\left ( x^{3} \\right )}{x^{3}}}=\\frac{1}{2} $$ 由此，我们可以得出：加减情况下不能随便使用等价无穷小。\n下面我们给出一个在加减情况下使用等价无穷小的定理并加以证明。在这里我们只讨论减的情况，因为我们知道加上一个数可以看成减去这个数的负数。为方便，首先说明下面的定理及推论中的无穷小量其自变量都是 $ x $ ，其趋近过程都相同： $ x\\rightarrow 0 $ ，在有关的极限中都省去了极限的趋近过程。\n定理2：设 $ \\alpha,\\alpha_{1},\\beta,\\beta_{1} $ 是某一变化过程中的无穷小量，且 $ \\alpha \\sim \\alpha_{1},\\beta \\sim \\beta_{1} $ ，则 $ \\alpha-\\beta \\sim \\alpha_{1}-\\beta_{1} $ 的充分必要条件是 $ \\lim{\\frac{\\alpha}{\\beta}}=k\\neq 1 $ 。\n证明：\n$ 1^{\\circ} $ 充分性：$$\\alpha\\sim\\alpha_{1},\\beta\\sim\\beta_{1}\\Rightarrow \\lim{\\frac{\\alpha}{\\alpha_{1}}}=\\lim{\\frac{\\beta}{\\beta_{1}}}=1 $$ 又 $$ \\lim{\\frac{\\alpha}{\\beta}}=k\\neq 1,\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}}=k\\neq 1 $$ 则 $$ \\lim{\\frac{\\alpha-\\beta}{\\alpha_{1}-\\beta_{1}}}=\\lim{\\frac{\\frac{\\alpha}{\\beta_{1}}-\\frac{\\beta}{\\beta_{1}}}{\\frac{\\alpha_{1}}{\\beta_{1}}-1}}=\\frac{k-1}{k-1}=1 $$ 即 $$ \\alpha -\\beta\\sim \\alpha_{1} - \\beta_{1} $$\n$ 2^{\\circ} $ 必要性：$$ \\alpha\\sim\\beta,\\alpha_{1}\\sim\\beta_{1}\\Rightarrow \\lim{\\frac{\\alpha-\\beta}{\\alpha_{1}-\\beta_{1}}}=1 $$ 即 $$ \\lim{\\left(\\frac{\\alpha-\\beta}{\\alpha_{1}-\\beta_{1}}-1 \\right )}=0 $$ 通分得 $$ \\lim{\\frac{\\alpha-\\alpha_{1}}{\\alpha_{1}-\\beta_{1}}}-\\lim{\\frac{\\beta-\\beta_{1}}{\\alpha_{1}-\\beta_{1}}}=0 $$ 所以 $$ \\lim{\\frac{\\frac{\\alpha}{\\alpha_{1}}-1}{1-\\frac{\\beta}{\\alpha_{1}}}}-\\lim{\\frac{1-\\frac{\\beta}{\\beta_{1}}}{\\frac{\\alpha_{1}}{\\beta_{1}}-1}}=0 $$ 又 $$ \\lim{\\frac{\\alpha}{\\alpha_{1}}}=1,\\lim{\\frac{\\beta}{\\beta_{1}}}=1 $$ 所以 $$ \\lim{\\frac{0}{1-\\frac{\\beta}{\\alpha_{1}}}}-\\lim{\\frac{0}{\\frac{\\alpha_{1}}{\\beta_{1}}-1}}=0 $$ 所以 $$ \\lim{\\frac{\\beta_{1}}{\\alpha_{1}}}=k\\neq 1\\Rightarrow \\lim{\\frac{\\alpha_{1}}{\\beta_{1}}}=k\\neq 1 $$ 又 $$ \\lim{\\frac{\\alpha}{\\beta}}=\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}} $$ 所以 $$ \\lim{\\frac{\\alpha}{\\beta}}=k\\neq 1,\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}}=k\\neq 1 $$ 由 $ 1^{\\circ},2^{\\circ} $ 得，原命题成立。证毕。\n这样一来，就得到了差形式无穷小量等价代换的充要条件。\n例3：$$ \\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}+2\\sin{x}}{\\arcsin{2x}-\\sin{x}}} $$\n解：$$ 1-\\cos{x}\\sim\\frac{x^{2}}{2},-2\\sin{x}\\sim -2x, 2\\arcsin{x}\\sim 2x,\\sin{x}\\sim x\\left ( x\\rightarrow 0 \\right ) $$ 所以 $$ \\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}}{-2\\sin{x}}}=0\\neq 1,\\lim_{x\\rightarrow 0}{\\frac{2\\arcsin{x}}{\\sin{x}}}=2\\neq 1 $$ 由定理 2 得 $$ \\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}+2\\sin{x}}{\\arcsin{2x}-\\sin{x}}}=\\lim_{x\\rightarrow}{\\frac{\\frac{x^{2}}{2}+2x}{x}}=2 $$\n例4：$$ \\lim_{x\\rightarrow 0}{\\frac{\\arctan{2x}+\\arcsin{5x}}{\\sin{3x}}} $$\n解：$$ \\arctan{2x}\\sim 2x,\\arcsin{5x}\\sim 5x,\\sin{3x}\\sim 3x\\left ( x\\rightarrow 0 \\right ) $$ 又 $$ \\lim{\\frac{\\arctan{2x}}{-\\arcsin{5x}}}=-\\frac{2}{5}\\neq 1 $$ 由定理 2 得 $$ \\lim_{x\\rightarrow 0}{\\frac{\\arctan{2x}+\\arcsin{5x}}{\\sin{3x}}}=\\frac{2x+5x}{3x}=\\frac{7}{3} $$\n总结 本文指出，在有加减的情况下不能随便运用等价无穷小代换求极限，并且指出了在有加减的情况下能够使用等价无穷小代换的充分必要条件。对于不满足条件的情况，根据给出的泰勒展开公式，可以求出。\n","date":"2014-11-01T00:33:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/","title":"浅谈等价无穷小量代换原理"},{"content":"自从上了大学以后，时常想起浅栖的一篇文章《为什么要读大学》。我也一直在思考，我为什么要读大学，前几天看了朱秀林校长的演讲，他也问了同样的问题，为什么要读大学，这是一个基本的问题，想明白了这个问题，可以解决很多问题。利用一节高数课，我仔细的思考了这个问题，并给出了自己的答案——为了成为更完整的人。\n还记得高中里，常常听别人说起，现在辛苦一点，到了大学里就会轻松很多。到了大学里才发现，其实大学比高三辛苦多了，说轻松只是相对于那些高中不认真的人来说，想要达到同一高度，是轻松一些。但是如果对自己有更高的要求，那也不见得会和「轻松」这两个字有什么关系。\n「想清楚自己想要什么」是一个先决问题，它会影响我们后续的一连串选择，人生就是由不同的选择构成的。要时刻记得自己想要什么，这样才能在大学这个充满诱惑的地方守住自己的方寸之地。\n当然，这也就是自己的「目标」，浅栖的班主任给了很好的诠释：\n如果要追求绩点，想清楚成绩意味着什么；如果要参加学生会，想清楚学生会职务意味着什么；如果要保研，想清楚保研的实质要求是让导师认为你是一个好学生，并且所有的条件都是由此而出；如果要出国，提前考虑好，或许能多几次 GRE 和托福的机会，可以关注各种交换机会、暑期，甚至大一就可以去招聘会，比较早的时候把规划做好，压力来的时候就可以从容不迫。\n有了目标，就要为之奋斗，否则就不能称之为目标，甚至连梦想都谈不上，只能是空想。这时候，就需要我们的「执行力」，在前进的过程中，给自己设下底线：每周早读3次、坚持完成作业、每次考试90分以上，诸如此类。并且朝着目标不断奋斗。\n大学是一个较为浮躁的地方，因此，要静下心来，还需要的一件事情便是「专注」。专注的做自己的事情，而不被旁人影响。对于这一点，我觉得深受初中班主任的一次教导——仔细的时候不论发生了什么都不抬头。这也是我初中三年学习习惯上最大的收获。至于有人喜欢边听音边写作业，则会使得自己的心变得散乱。需要不断的自我调整，使得自己的内心变得宁静。这是张兴老师告诉我的，随着时间的推移，我慢慢加深了对于他所讲的「静」的含义。\n当然，更需要的是学会懂美，这包括了很多，人性美、文学美等等都包含在里面，从我们的专业中悟出「道」，否则，如果我们只是掌握了一些专业知识，那么和技校生又有什么区别呢。\n下面就我自身的情况，谈谈我对于大学生活中的一些基本的问题的看法吧。\n我们有早读课，名义上叫做「诚信早读」，有人去签到后也去早读了；有人去签到后继续宿舍睡觉；有人干脆不去签到。从这一点小小的地方就拉出了莫大的差距。早读给我的感觉倒不是真正的目的，而是为了让我们早起，从而能更好地利用早上这段时间。\n而对于上课，那就更随性了，玩手机、睡觉应有尽有。我的想法是，要弄清楚，自己哪里需要听，哪里不需要听。可以睡觉，可以做自己的事，但是玩的话就有点说不过去了。睡觉，可能是昨天晚上作业太多，赶夜工，凑巧下面还有自己需要听的课，那么睡觉是无可厚非的；至于做自己的事，可以是看书、做作业或者任何不影响他人的事情。这大概就是我的上课状态吧。\n讲到上课，不得不提一提旷课这件事情，我觉得只要理由正当，并且自己恰当的权衡，我觉得是可以的。当然，如果和辅导员关系好，开张假条应付一下就更好了。我上次旷课是为了参加国际唐代文学年会的开幕式，旷了体育课，并且在辅导员那里开了假条。我觉得非常值得，开幕式持续了一个上午，是一场名副其实的文学盛宴。当然，也不是鼓励大家旷课，主要是自己要权衡，也就是之前的一个问题，想清楚自己想要什么。\n在说说效率这件事情吧，记得有这么一个公式：投入时间×效率＝实际投入。所以，提高效率远比加大时间投入有效，这也是浅栖的文章给我的一个很大的启发。顺便再讲讲占座的事情，我个人觉得，自己会的课程，不需要占座，做在后面可以自己看看书，在做作业，还不会被老师点名之类的；自己不会的课程，一定要占在前面，实在不行一定要追着老师问，有句话叫做「弄斧必到班门」，我是很赞同的。\n至于阅读，大学里有很多的空闲时间，这就给了我们极大的自由度，再辅以一卡通可以借阅十几本书，而图书馆又很大，那么，用这些时间好好阅读一下文史哲方面的书籍是一个非常的选择。至于为什么是这方面的书籍，我想，它们更能启发我们思考，塑造我们的思想，使我们变得更加理性。而对于专业的书籍，在实践中的学习远比书籍重要得多，因此没有太大的必要。当然，读书也不能像读小说一样看过就完。要精读、深度，尤其是流传至今的著作，它们经历是时间的考验与洗礼，是名副其实的人们智慧的结晶。\n有了阅读，必有思考，古人云：「一日三省吾身」，我想实在做不到，「一日一省吾身」还是可以的，并且思考一下，今天做了什么，明天该做什么。还有重要的一点就是读书的时候要做勤于做读书笔记，写读后感。然而，这里强调的思考是深度思考，刨根问底式的思考。可以先刨根问底，然后再一步一步演绎出我们的问题，并由此向外延伸，对于问题有新的认识，在这点上，我们高数老师的哲学思想对我有很大的启发。\n作为学生，不能没有作业，但是做不做就是问题了。我感觉这完全是个自觉的问题，有人可以完全不要平时分，也不会挂科。但是如果你的目标是刷绩点的话，就要认真了，最好自加压力，找点习题做做。\n对于不可避免的问题——游戏，我决定还是说几句，我们这一届也有人玩游戏玩的很厉害，我对于游戏的看法可以引用浅栖的班主任的一段话来阐释：\n东方文化强调纪律、律己，即适当的自我约束。8 小时的被迫上课、讲座、做作业之后，人会想要补偿，于是玩游戏，你说玩游戏的害处不只是耽误时间，其最大的害处在于让自己成为欲望的奴隶，变得散懒，无法控制自己。\n而对于如何解决这样的问题，我想最好的办法就是在自己很累的时候，做一些自己感兴趣的事情，比如听歌、练书法之类的，慢慢使自己的内心静下来。\n社团与社交，我觉得主要看这个岗位是否有利于自身的进一步发展，没有必要为了结识更多的人而去可以的加入某些社团，讨好某些人，一个很现实的问题，他们可能并不把你当朋友。因此，这个问题随性就好，朋友都是在自然之中结交的。\n总而言之，上大学就是为了使自己成为更完整的人。\n当然，还要牢记一句话：「不要忘记了当初为什么出发。」\n","date":"2014-10-18T23:13:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AF%BB%E5%A4%A7%E5%AD%A6/","title":"我为什么要读大学"},{"content":" 月\n水调歌头\n丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。\n明月几时有？把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？\n转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。\n\u0026lt; music netease song 225636 \u0026gt;\n今年，可以说是一个转折点。高考结束了，以前经常以前玩的小伙伴不得不面临分别，各奔东西。有的还没有开学，有的却早已开学，独自在异乡漂泊，在这个理当团聚的日子，承受着难言的乡愁。\n「今夜月明人尽望，不知秋思落谁家。」，但无奈正如太白所云「月是故乡明」，因此找了一张故乡的月光图，给远方的小伙伴聊慰乡愁。\n且回到苏轼的词上，这首词我记得是小学里就学过的，当时老师要求我们背诵，也就这样背了。到了初中，又学了一遍，又背了一遍。当时觉得苏轼太痴，他对月亮说他思念弟弟，月亮怎么会去理他，这也就更不存在所谓的「千里共婵娟」了。到了现在，方才明白苏轼之心，思之切，故而痴，那么下面的一切也都可以理解了。现在的我也不禁吟出「但愿人长久，千里共婵娟。」的企盼。\n这当然不是无用的心灵寄托，我愿意相信，月亮正帮着我们传递着彼此的思念，只是速度没有网络那么快罢了。但我却更倾向于古人的传信方式，「行人临发又开封」多美；「驿寄梅花，鱼传尺素。」多美；「一夜乡心五处同」多美。\n匆匆的告别，以为再见一面又有何难。只有真的离别了，才明了再见一面何等之难。告别，似乎是这个暑假的主旋律。告别了高中，告别了小伙伴，过几天又要告别张家港，到别处奔波流浪。还记得零模、一模、二模、三模、高考，查分数、填志愿、录取，短短一年，经历了这么多事情，现在回想起来，却感觉像是很久以前的事情，而它们却实实在在的发生在几个月前。\n不管现在如何，未来总是充满希望。\n","date":"2014-09-08T22:10:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%802014/","title":"中秋望月感怀（2014）"},{"content":" 夏虫也为我沉默，\n沉默是今晚的康桥。\n窗外的夏虫唧唧喳喳的叫着，在 iPad 上打字，以前感觉很慢，去突然间感觉快了起来。\n细细想来，自从毕业以后，一直在忙，不是写程序，就是补课，我也不知道自己整天在忙些什么，或许只有让自己忙起来，每天有一大堆的事情等着处理，才不会感觉到无所事事带来的焦躁与不安吧。\n现在，补课结束了，程序在分工协作，任务不是很重，所以忙里偷闲，来欣赏夏虫演奏的大自然的交响曲。\n一切景语皆情语。回想六年中学生涯，不禁感慨万千。补课时看到那些学生，不论小学、初中、高中，都由衷的羡慕。正如围城一样，我们再也去不到围墙里面，只能在外面看着他们重复着我们的故事，时而为他们感到高兴，时而为他们感到担忧，但到后来才明了，这是他们的生活，需要他们去体验，我们的旁观起不了任何作用，只是徒增自己的感伤罢了。\n例如高昕宇，小升初，考上了常青藤，我似乎在他身上看到一点自己的影子，因此总是希望他往后六年的中学生涯好好努力，好好把握，自己当初没有完成的心愿，希望他们能够完成。\n有这样的想法，大抵是因为自己六年中学生涯有太多的遗憾吧。六年认识了很多人，从刚开始的点头之交，慢慢接触，大部分人最终回归到点头之交，有些人变的形同陌路，当然，也有极少数人变成了倾心相交。在这个过程中，有人放冷箭，有人争锋相对，到最后才发现，他们竟然是你信任的人。人情冷暖，大抵如斯。\n六年，真正认真的是初三、高一、高三。前两次基本如愿，哪料到高考出乎意料。这且不说，这六年来，事事受阻，极少有守得云开见日，且都遭受非议。或许，这该是上天最好的安排吧，且看这出戏该如何演吧，剧本在上帝手里，也在自己手里，却没有最终解释权。世事难料，大抵如斯。\n当分别已成习惯，我们已不会记起比尔博姆的告别，剩下的只是互道珍重，或许这便是最后一别，再无相见。回想起来，这六年来，经历了小学毕业，当时大家还小，完全不理解分别的含义，在分别时，还笑嘻嘻的互相打闹；初中毕业，走出教室的那一刻，并没有想到分别，事后才意识到，这一别就是永恒。现下的各奔东西，却变的稀疏平常。大家都相信，还可以继续联系。只是，不知道以后联系上的，是不是今日的你，以后一起玩耍的，是不是今日的你。时间总是那么无情，呼唤着距离一起，将彼此分隔、分割。无能为力，大抵如斯。\n岁月褪去了我们的稚气，留下一副看似坚硬的外壳，却不料它一触即破，剩下我们独自哀伤。在这跌爬滚打中，逐渐加厚了外壳，却变的冷漠，失去了本来的纯朴与自然。由此产生的便是深深的距离感。变的复杂无比，却极力追求简单，到头来连自己都没有弄懂自己是谁。所谓宿命，大抵如斯。\n不知不觉，已过夜半，窗外仍有小作坊在工作，夏虫依旧唧唧喳喳的叫着。\n","date":"2014-08-22T00:15:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%A4%8F%E5%A4%9C%E5%AF%84%E6%80%9D/","title":"夏夜寄思"},{"content":"P2P.edu 是我们学生自发组织、创办，自主管理的一个补课机构，地点租在南门路与南环路的交界处的「圆梦教育」。总的来说，没有满六位数的营业额，或许不能算作是一次非常成功的创业，但是却是一次非常成功的尝试。\n从 6 月底持续到现在，很多课程都已经进入尾声，我的课程已正式结束了，写下此个人总结，算是打点计时器，记录一下这个事件吧。\n给我的感觉，在创办前期，策划、广告宣传、洽谈生意等，在此期间学到了很多。从设计报价单、学员登记表、签到表，到传单的制作、发放，再到与家长及学生的交流。整个过程，使得我对于自主创业有了一个非常基本的概念和模型，但是这些经历还远远不够。\n我个人认为，P2P.edu 在前期最大的败笔是广告宣传的不到位，主要来自于校方的压力，当然，我们也有一种「怕」的不足。怕校方的责怪，但是到了后来，意识到我们并不隶属校方管辖的时候，再去发传单，或许已经有些晚了。现在想想，我们当时确定的传单的受众群体太狭窄，因此 500 张的传单并没有完全发出去。但是却不得不承认，我们经过学生和家长的舆论宣传，还是达到了一定的效果，以至于前几天还有人报名，当然，我们已经没有时间再去办第二期了。\n对于需要改进的部分，我想大抵是没有设计一款软件代替签到，财务结算，以至于到后来制作财务报表的时候忙的焦头烂额。在一开始，我的确想到设计一款软件，但是毕竟第一次从事补课行业，对于一些需求并不是特别了解，所以设计的也非常简陋，到后来就直接废弃了。这或许是下次创业需要注意的地方。在与家长的交流中，也学会了很多说话的艺术。\n在这段时间内，也接触了很多学生，也有很多让我留下了很深的印象。下面简单的记叙一下。\n杨逸涵，小升初，报考常青藤失利。我记得第一次辅导他是他报考常青藤的前一天。给我的总体感觉，聪明是挺聪明的，却不全部用在正道上。以前几乎每天都要被训一顿。可能他的年龄制约了他的性格，有些自负，做出不题目就会哭鼻子，让教他的老师啼笑皆非，总体来说，还是挺有趣的一个小朋友； 高昕宇，小升初，常青藤。我个人认为，这是我们这么多学生中最聪明的一个。但是好玩，不高兴做作业，为此我们想了很多方法来对付他，譬如，下棋，输了两倍的作业量，赢了不做。虽然他每次都输，输了以后还赖皮，到最好还是输了，但是这样一来就心服口服的做了两倍的作业； 这两个学生是小升初的代表，当然，还有一些小升初的学生，但是都非常一般。看着他们，我想起了小升初时期的我，也不知道他们接下来的几年会经历什么，希望他们有个好的未来。\n赵张滨，新高三，沙中。这是我的学生，一共补了两期，总共 20 节课，虽然不属于聪明的类型，却还算认真，也值得鼓励，只是他这样的水平去参加高考，真不知道会是个什么样的结果； 朱奔，新高三，梁丰。只是唯一一个补自招的，是我们这边最认真的学生，就算前一天玩的再晚，第二天仍然坚持来上课。 这是新高三的代表，愿他们高考顺利。关于赵张滨，还有个「机智哥」的故事，也是我们在办公室内揣测出来的。当时我们便想到我们上学的时候，办公室里的老师是不是也像我们一样。\n还有很多学生，但是给我印象深刻的也就这几个。总的来说，这些学生给我的感觉——眼高手低。所有的人都不愿承认自己弱，但是他们的水平却够不到强。我似乎看到了很久以前的自己，当时也是好高骛远，眼高手低。\n当然，这只是一个方面的现象，还有上课不听，作业不做的情况。我处理过一例作业不做的情况，他最终乖乖的把没做的作业补了起来。似乎体会到了老师对待我们不做作业时的焦急与无奈。\n有了这段经历，对于老师也肃然起敬。\n备课，刚开始每天备课到十点半，第二天一会儿就讲完了，后来白天也开始备课，还是一会儿就讲完了。最麻烦的是出试卷，虽然我看看题目和答案还是可以判断题目的难易程度的，但相当的麻烦，要一个一个字的打下来，排版，打印。至于批作业，我教的是一对一，所以也就轻松一点。帮同学批作业的时候，也感到很无力，可能是他们错的太多，也可能我批作业的速度太慢。\n上课，学生做题目的速度太慢了，我只能干等着，这非常的浪费时间，到了后来，便是先把第二天要讲的全部做完了，第二天直接讲题目。\n下面讲讲我个人的上课感受吧，说实话，一开始，我也是非常兴奋，每节课都认真备课，虽然每天弄到将近十一点，但是心里还是很高兴的。\n第一个学生是赵张滨，上面已经介绍过了，沙中的一位学生。给我的感觉，太内向。但是后来发现，他居然喜欢画漫画，还给我看了一幅他画的漫画，画的还不错，剧情是抄来的。不算聪明，也不算勤奋，有时候偷偷懒，我记得每次让他背的公式——三角函数、求导法则、向量点乘诸如此类，总是偷工减料，到最后我不得不让他默写公式。\n我记得有一次他在做一道求函数值域的题目，他绕了个远路，我说道：你这么做是没有必要的，太麻烦了。没想到他一脸委屈的表情，快要哭出来，弄的我非常尴尬，赶紧转移了话题。总是觉得怪怪的，都升高三了，一个男生，还哭鼻子。\n我记得前面 10 节课上完了，我给他妈妈打电话，问她要不要续报，跟她分析利弊，她答应续报 10 节。就这样，赵张滨一共报了 20 节课。\n最后一节课，我给他考了一份我们的高考数学试卷，两卷加起来 150 多分，比之刚来补课的期末考试 130 分是一个很大的提升，也是对我教学能力的一个肯定。\n在此期间，我又接了一个学生——张博涵，第一节课试听。后塍高中，自诩中考英语 90 分背背新概念就行了。第一节课上集合，给我的感觉，虽然概念都不清楚，做起题目来倒也不赖。但是，他试听完以后，就再也没来。和他家长联系，也没有结果。就当是做了一次义工吧。而后来事实证明，他根本不想补课，被抓了过来。\n接下来的一个学生——顾誉，梁丰高中的学生，新高二。是我和潘子昊一起教的，而且他教的课时比较多，我的印象不太深刻，只是反映我课上出的题目太难。（其实很简单。）\n我训过的学生——杨逸涵、施意涵。前者大声吵闹，扰乱办公室正常工作秩序；后者不做作业。\n总的来说，虽然收入不是特别多，总计 2600（现在年终奖金还没有发下来，发下的话，应该会捐给云南鲁甸）。但是却比去年写程序赚钱学到的东西多了很多。\n有了这些铺垫，到了大学里，经济独立，这个想法应该比较成熟了。\n最后，感谢大家。\n","date":"2014-08-18T21:53:00+08:00","permalink":"https://ivy-end.github.io/p/p2p.edu-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/","title":"P2P.edu - 个人总结"},{"content":"上回说到张兴给了我一本初赛的辅导书，让我备战全国初赛。\n我记得第一天运动会，我下午去机房，听到高二的说，他们准备明天一天都在机房自习，当时我也很想这样，但是当时的班主任却绝不会同意，所以也就罢了这个念头。当天就准备简单的做做题目。也是那时候第一次接触「Tyvj」——一个在线评测网站（其他竞赛做题目可以刷书，我们做题目必须在电脑上。）。\n第一道题目是高二的人给我的一道题目，现在看来只是一道简单的前序和（其实当时的题目数据也用不到这个算法），但是我却不会做。他们认为我什么都不会，于是说，做「A+B Problem」吧，当时我不知道是什么意思，看了题目才知道。（感觉是一股嘲笑味。）当下自觉不解——什么我平时写了那么多程序，却连这种题目都不会做。后来才明白，我平日所涉猎的和当时所做的题目完全是两回事。（但当时的我却未能领会到这一点。）两天的集训（自习）很快就结束了，感觉自己也学到了一点东西，比如问了高三某大神关于图论的一些问题，他非常耐心的给我讲解了图论的基本概念。虽然这样下来，我还是不会做题目，但是理解起来便简单多了。\n且说那个十一长假，我在家里只要一有空便会翻开那本书，有时候要去亲戚家吃饭，也带着那本书。一个长假下来，却也看了将近大半。只是对于很多概念，例如「树」、「图」不是很理解。所以在后面很多题目上也是一知半解。\n到了初赛的那天，我们中午 12 点在机房集合，再次进行考前辅导。高三的在三楼自己做题目，高二的则和我在二楼做题目。令我感到奇怪的是，辅导员竟然学生。（虽然后来我也成了所谓的「辅导员」。）其间，张春华老师还给我们讲了一下「树」的三种遍历——「前序遍历」、「中序遍历」、「后序遍历」。还好当时即使听懂了，因为果然考到了。出发前半个小时，在三楼做题目的缪叔下来讲了一个「Floyed Alogrithm」，我也听懂了它的原理。（虽然当时还不会写代码。）\n讲完便可以出发了，高二、高三的结伴做公交车（因为人比较多），而我和另外一个高一的学生则坐着张兴老师的汽车，前往比赛场地——暨阳高中（三年都是那里。）我记得在出发前大家还在讨论要不要带可编程计算器去。最后有几个高三的带了过去，但是好像没什么用。\n来到暨阳高中，高二、高三的人已经到了，我们都穿着校服，感觉不是很自在。这时候张兴老师说，我们凭着校服就可以吓住他们。大家哈哈大笑。\n在此期间，看到很多去暨阳高中看运动会的学生，都被拦在了校门外。而我们却在张兴老师的带领下，昂首阔步的踏进了暨阳高中。我记得当时有人冒充进我们的队伍，被门卫揪了出来。进了暨阳高中，我们先找到考场，坐下来以后。便在暨阳高中四处转转。（我们去得比较早。）首先去了田径场，出奇的小，于是便折返去教学楼，出乎意料，看见一座亭子，一座假山，还算有些意趣。\n这样四下闲逛，一会儿便到了开考时间。拿到试卷，我做上去感觉有点难度，有几道关于「树」、「图」的题目完全不会，只能硬着头皮乱猜。（但此时却和初一那年大不相同，毕竟也写了一定的程序，猜也有些门道了。）两个小时很快就过去了，考完出来。我有道题目不太确定，马上去问张春华老师，他遮遮掩掩，我便猜到做错了。看到高三的容光焕发，不屑于对答案，也猜到他们考得不错。\n回到家中，等到八点半，CCF 公布了标准答案，对完发现，考了 70 分。当下打电话给张兴老师，他听了也非常高兴。后来他又打电话过来，说我这个分数过不了初赛，但是已经不错了，考过了好几个高二的学生。他还说有些后悔，当初没认真辅导我，否则说不定就进复赛了。（后来才知道，我当年是三等奖的第一名）\n不管怎么说，这也是我的一次经历，使得我在 OI 的道路上走得更加坚定。\n初赛结束，无缘复赛。可以说时间空了很多。\n（欲知后事如何，且听下回分解。）\n","date":"2014-07-28T20:34:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E5%9B%9B%E5%9B%9E-%E5%B0%8F%E8%AF%95%E8%BA%AB%E6%89%8B/","title":"忆昨日·NOIP - 第四回 小试身手"},{"content":"上回说到，张兴让我以后每个星期六下午都到他那边去上课。\n刚开始，并不要求我周日下午提前到校再去学习，一来为了不让他人察觉（张兴为人比较低调），二来他也有些忙，抽不出太多时间。\n我记得第一节课只有我一个人，当时张老师拿了一本破旧的算法书（应该是他以前用过的），让我一个人根据书上的解说，将「快速排序」（竞赛的入门算法）写出来并成功运行。当天下午我就一直在研究这个，差不过用了一个多小时，才把基本框架写了出来。但是运行后的结果却错误百出。静态查错一直没什么效果。\n这时候张老师说道「试试调试。」我当时以为自己听错了（这是递归程序，调试下去不得了。），得到确认以后，硬着头皮调试下去。过了十多分钟，但仍是无果。这是不免内心烦躁，当时觉得怎么自己第一节课就连这么一个算法都写不出来。更何况之前看《算法导论》的时候还写出来过。当下不服气，觉得张老师给我的书上的伪代码有些麻烦，于是翻开了自己的《算法导论》，找到那一章节，对着伪代码思索片刻，突然找到了问题所在——递归的参数（下标）传错了。\n算法终于写了出来，我非常高兴。抬头一看，只见张老师的妻小都到了，我才明白自己耽误了张老师回家的时间。当下觉得十分抱歉。不料张老师过来检测了一下我的程序，确认完成以后。说道，「嗯，写出来了，时间不早了，回去吧。」又转过去对妻子和女儿说，「我们也回去吧。」我正准备走，不料张老师问道，「你家住哪里？怎么回去？要不要送送你？」我推脱了几句，说家住乐余，自己坐车回去，便走了。\n以后每个星期六，我都会去张老师的办公室，他给我上课，有时那位之前跟着张老师学的人也会过来一起听课。但是张老师给他讲的是 C 语言基础，我自然不用听，于是自己在边上的一台电脑上研究算法。\n有时候，张老师有事不能来，他便然我去和那些高三的人一起自习，但是他们在那个小机房里每人都有自己的电脑，我却没有，只能站在边上看他们写程序，偶尔和他们聊聊。才知道他们都是实验班和强化班的。\n张老师也会来找我谈话，让我多和他们接触接触，学习一些东西，还有一些为人处事的道理，但是也要分辨是非。\n当时我只是初来乍到，对这一切都不熟悉，对于那几位高三的学长也充满了尊敬，看着他们写代码的速度飞快，暗自揣测，他们的水平应该胜过我一筹。（毕竟我之前主攻的是应用开发，而不是算法设计。）便经常向他们请教问题，有时候听到我一些比较可笑的理解（比如将有向图的边理解成向量）他们倒也不生气，耐心的给我讲解。\n我记得有一次问缪叔（缪晓伟，大家都尊称缪叔）有没有做过应用开发，他说他们合作过一个抢答器。当下我便有了一点底——我的算法设计比不上他们，但是他们的应用开发也不一定比我厉害。当然，现在的缪叔一定比我厉害了。（缪叔现就读于南大软院。）\n回到家中，我也只是写一些算法，因为当时还不知道信息学奥林匹克竞赛要考些什么题目，所以做题目根本无从谈起。我以为知道要学一年，到了高二才能参加比赛。\n谁知道，就在运动会前夕，张老师将我将了过去，告诉我十一过来就要初赛了，但是报名早在他认识我之前就完成了。他问我想不想参加一次，去试一试。我虽然没有什么底，但还是点了头。但是想到报名早已结束，就算想参加也没办法了。没想到张老师却说，这件事情他来处理。（后来果然报上了名。）\n当下给了我一本初赛辅导的书，让我抓紧时间看一遍。他的安排是运动会不要去看比赛，去机房和高二、高三的一起做题目。当时我也很激动，便答应了下来。我拿到了书，随手翻了一翻，便知道内容非同寻常，异常的难。很多没见过的名词、算法、题目。但既然答应了，虽然时间紧迫，但硬着头皮也要看完的。\n张老师还是没有改变他低调的风格，让我将书的封面用空白的封皮包住，不要让人家看到。当下我踌躇满志，拿着书回到了教室。\n（欲知后事如何，且听下回分解。）\n","date":"2014-07-22T21:47:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%B8%89%E5%9B%9E-%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0/","title":"忆昨日·NOIP - 第三回 初来乍到"},{"content":"上回说到，我在初中的时候参加过一次普及组的初赛，后来由于种种原因退出了，开始了自己的自学之路。\n到了高中，此时的我已接触了多门编程语言、脚本语言。无意间听说高中还有信息学奥林匹克竞赛，非常欣喜，盼望着能够参加，也想和众位高手一较高下，看看自己多年的自学是否有成效。于是一直深信不疑学校中有许多深藏不露的高手，因此一直非常的低调。直到有一天，得他人引荐，认识了信息组的负责人，也就是后来我的辅导老师，也算是一个朋友——张兴老师。\n第一次交谈是在电话中，他粗略的问了一下我的情况，便说，「今天下午一点半到我办公室来一下，信息组三楼，网管室。」我听了一怔，「网管室」，听上去非常的厉害，想必那位张兴老师也不是泛泛之辈。当下欣喜，难以言表。于是匆匆准备，提前十分钟到了「网管室」。\n现在想来，当初的欣喜，多半源于自己在编程方面的一点小能耐终于能够有人赏识，大抵如此吧。\n在等待的过程中，看见一个人走来，我猜想那人应该是学校的老师，便叫了一声「老师好。」，谁知那人回道，「我不是老师。」。这段插曲算是过去了。又过了几分钟，只见一个男子向我走来，皮肤黝黑，身材枯瘦，再加上之前的插曲，我不敢断定他是老师，便踌躇了一会儿。就在此间，他说道「你就是王凯吧，来的这么早啊。快进来。」边说边从兜里掏出钥匙，熟练的打开门，进去后，他找了一张凳子，放在他的办公桌边上，说道「坐。」从一开始他对我的态度，早已使我受宠若惊，再加上此间，我百般推辞，但奈何不过，只得战战兢兢的坐下。大气都不敢出。（当然，到了后来，我进他办公室，大多都是径直搬了张凳子就坐了下了。所以上文说道，他不仅仅是一位师长。）\n他为了缓解气氛，指着一张断了一个角的凳子，说道「你猜这是怎么坏的？」，我不知道他的意图是什么，只是摇头，他笑道「被一个同学坐坏的，他过会儿也会来。」当下我想，那人应该是一位高手。\n我们谈论的内容非常的广泛，我记得他听到我说初中学过一些 Pascal，以为我想继续学 Pascal，便准备劝我不要去学那么破旧的东西。但得知我想选报 C++ 并且有一定的基础时，倒是舒坦了不少。于是我们便谈了很多关于桌面应用程序开发的事情，又聊到了网页开发，包括 Javascript、JQuery 等等，最后谈到了算法，对于这方面，我只是略懂，因此聊起来有些吃力，还被当场指出了一个错误——我当时给「归并排序」自创了一个名字「递归排序」，闹了一个笑话。\n在这中间，又来了一位同学。他已跟随张兴老师学了几节课，再加上我之前的自我揣测，刚开始对他还是有几分摸不透，毕竟不知道他到底水平如何，所以对于一些自己并没有太大把握的内容，并没有说。但听他的言谈，倒也不似高手，当下才放下了心。\n第一次的聊天，大多都是关于计算机方面的内容，随着接触时间的增加，我们也聊很多关于学习、生活方面的事情，在此按下不表，后文会详细记述。\n在交谈中，一转眼便将近下午三点，我便去自习了。在临行前，他只是告诉我，以后每周六中午放学后，便到他的办公室来。听了这话，我便知道，他愿意将我当作信息组的一员了。由于这是内部决定的名单，因此比正式竞赛分科早了整整半个学期。\n这次谈话对我来说，可谓受益匪浅，自学了三年，终于有一个人可以与我畅谈这些技术。此后，我分别接触了两届信竞大神，虽然他们在年龄上长我一岁，不过倒也相处的来，尤其以缪晓伟、项业成、王意天、胡宇涛四位，交谈最多，他们在学习和生活方面也都给了我很多的经验和指导。这些在后文中会详细记述。\n整件事情回想起来也是一场意外，若非那位小伙伴的举荐，恐怕我不一定会是张兴老师辅导，那么我也就不一定会进信息组。\n（欲知后事如何，且听下回分解。）\n","date":"2014-07-21T22:15:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%BA%8C%E5%9B%9E-%E5%86%8D%E5%85%A5%E4%BF%A1%E7%AB%9E/","title":"忆昨日·NOIP - 第二回 再入信竞"},{"content":"时过期年，再次回首起 NOIP 之路，良多感慨。现下忙里偷闲，不妨记录下来。\n说起信竞（信息学奥林匹克竞赛），第一次接触是在初一的时候。依稀记得，那是初一的一个中午，王学良拿着一张纸（还是一本本子）走进教室，问道：「你们班谁参加过计算机方面的比赛？」当年的我少不更事，非常得意的举起了手。然后问了姓名，让我某天中午去机房开会。\n说来惭愧，当时真是自不量力。小学曾经参加过两次电脑打字比赛，居然恬不知耻的举手了。因此才有了这些事情。\n且说那两次虽然都是一等奖，但是都胜之不武。当时比赛用的那一款软件，我发现了一个漏洞：比赛共进行两次（至于如何计算分数我就不太清楚了—），测试内容是一样的。我在第二次测试的时候，将测试的文本全部改成了空格键，这样，只需要按住空格键不放就行了。通过这一非常不正当的手段，忝列一等奖名单，现在想来，实在是羞愧至极。\n回到正题，那天开会，去了几个人已无法记清，只依稀记得不满十个人。辅导老师名叫鲁智建，三十岁往上的年纪，皮肤偏黑，戴着一副眼镜，看上去谈不上斯文，却也别有一番气度。再加上他说话的语气，当时对他倒也有几分崇敬。我能回忆起来的会议内容大概就是我们需要学习 Pascal 这门语言。\n记得第一次上课，内容是在屏幕上输出“Hello World”字样。当时也只是依葫芦画瓢，什么都不懂。看见屏幕上有几行字，非常欣喜罢了。但是，不知怎么的，我对 Pascal 就是提不上兴趣，现在才明白，因为它的语言太死板，拘泥不通，一点都不优美。下课时，鲁老师让我们自学下一章内容。\n看到一章名叫「函数」（此「函数」非彼「函数」），当时吓得不轻，完全看不懂。\n第三节课上，鲁老师放出了一段代码，让我们一人解释一句。轮到我的时候，我当时非常忐忑，第一次回答问题，生怕回答错了。现在也已忘记了是什么问题，只记得当时答得一本正经。鲁老师不置可否，继续问下一个人下面一条语句。我也是心中一惊「难道我答得不好？」，但还是看了下一条语句，其中有一个我不懂的单词，谁知道我边上的同学答得十分流利，鲁老师夸赞他很厉害，当时我心中说不出的滋味。\n回到家中，问起了何林峻（重庆人氏，因学习易语言相识，此人现从事软件开发。），他只是告诉我「他只是比你多懂几个函数罢了，没什么了不起的。」当时虽然满头雾水，但还是得到了莫大的慰藉。重拾了信心，但还是对坐在我边上的人有几分忌惮，觉得高手真多。\n后来的课上，边上的人突然找到一段代码，可以在屏幕上连续的打出变化的字，看上去就像自己定制的屏幕保护一样。当时感觉他非常厉害。鲁老师只是告诉我们，这个东西以后才会学到，现在不要去弄。（后来我才知道，只是极其简单的循环。）\n我记得当时只学了一个月，其实也就是十节课不到的样子，便迎来了初赛。拿到参赛证，赫然写着「普及组」字样，当时信誓旦旦，日后我一定要去「提高组」摘金夺银。\n匆匆的准备了一番，告知参赛地点在梁丰高中，从常青藤校门出来，走到对面电视大学的站台，坐着公交车，鲁老师带队，连同初二、初三，一行十几人便出发了。\n来到梁丰，被那美丽的校园镇住了，我们坐在中央大道的石凳上休息，虽然是十月的时节，却还是异常的闷热。边上的人听着轻松的音乐放松心情，我就带了一个手机，也没有什么放松的办法，好在也不怎么紧张。（因为不知道，所以不害怕，也就不紧张。）考试地点在图书馆（当时并不知道是图书馆）四楼。记得当时做的是电梯，顿时感觉待遇非同一般。等到了考试地点，看见了那么多考生，才发现自己多么的微不足道。\n拿到试卷，全是不认识的名词，我已记不太清，顿时气势已输了大半。但还是硬着头皮做了下去。半个小时过去了，有几个人提前交卷出去了，顿时感觉他们太厉害了。（现在才知道他们不会做才提前交卷的。）不禁又捏了一把汗，自然方寸大乱。\n所谓「福无双至，祸不单行」，正在此时，突然感到难受难忍（考试那天一直在发烧，来的时候还不要紧，突然难以忍耐。），但还是继续硬磨了十几二十分钟，最终坚持不下，大概是下午 4：20 的样子，提前交卷，回家了。（如果所料不错，考试还有 40 分钟结束。）\n在此之前，从未想过提前交卷的念头，现在想想，倒也可以理解。\n回到家中，自知不中，却还是盼望着能过初赛，但是消息一直没有等到。后来，由于种种原因，退出了初中的信息组。因此也就无缘了后两次初赛。也不知道他们有没有继续弄下去。\n但是这次历练却成为了我系统的自学编程的一个里程碑，也为高中进入信息组打下了坚实的基础。\n（欲知后事如何，且听下回分解。）\n","date":"2014-07-20T22:39:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%B8%80%E5%9B%9E-%E5%88%9D%E5%85%A5%E4%BF%A1%E7%AB%9E/","title":"忆昨日·NOIP - 第一回 初入信竞"},{"content":"1B Spreadsheet\nAnalysis The essence of this problem lays in the conversion between decimal (\u0026lsquo;0\u0026rsquo;-\u0026lsquo;9\u0026rsquo;) and base 26 (\u0026lsquo;A\u0026rsquo;-\u0026lsquo;Z\u0026rsquo;).\nNotice: There is no number in the base 26 system that function as the number \u0026lsquo;0\u0026rsquo; in the decimal system, so when the decimal number is a multiple of 26, a special handle is needed.\nif(C % 26 == 0) { strTmp = 'Z' + strTmp; C /= 26; C--; continue; }\nIn the code above, C means the column, while strTmp stands for the base 26 string after conversion.\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;iostream\u0026gt; #include \u0026lt;ctype.h\u0026gt; using namespace std; string Convert(string x); int N; string strInput; int main() { cin \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; strInput; cout \u0026lt;\u0026lt; Convert(strInput) \u0026lt;\u0026lt; endl; } return 0; } string Convert(string x) { string strRet = \u0026#34;\u0026#34;; int nTmp = 0; bool bTmp = false; for(int i = 0; i \u0026lt; x.size(); i++) { if(isdigit(x[i]) \u0026amp;\u0026amp; !bTmp) { bTmp = true; nTmp++; } if(!isdigit(x[i])) { bTmp = false; } } if(nTmp == 1) { string R, C; int nC = 0, nHex = 1; for(int i = 0; i \u0026lt; x.size(); i++) { if(isalpha(x[i])) { C += x[i]; } else { R += x[i]; } } for(int i = 0; i \u0026lt; C.size(); i++) { nC += (C[C.size() - i - 1] - \u0026#39;A\u0026#39; + 1) * nHex; nHex *= 26; } strRet += \u0026#34;R\u0026#34; + R + \u0026#34;C\u0026#34;; string strTmp = \u0026#34;\u0026#34;; while(nC) { strTmp = (char)(nC % 10 + 48) + strTmp; nC /= 10; } strRet += strTmp; } else { int C = 0; int nPos = x.find(\u0026#39;C\u0026#39;); for(int i = nPos + 1; i \u0026lt; x.size(); i++) { C *= 10; C += (x[i] - \u0026#39;0\u0026#39;); } string strTmp = \u0026#34;\u0026#34;; while(C) { if(C % 26 == 0) { strTmp = \u0026#39;Z\u0026#39; + strTmp; C /= 26; C--; continue; } strTmp = (char)((C % 26) + \u0026#39;A\u0026#39; - 1) + strTmp; C /= 26; } strRet = strTmp + x.substr(1, nPos - 1); } return strRet; } ","date":"2014-07-20T10:08:00+08:00","permalink":"https://ivy-end.github.io/p/codeforces-1b-spreadsheet/","title":"Codeforces 1B - Spreadsheet"},{"content":"1A Theatre Square\nAnalysis Calculate the number of flagstones used to cover the length and width, then multiply them to get the correct answer.\nNotice: Pay attention to the data range. Use unsigned long long.\nSolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { unsigned long long n, m, a, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; a; if(n % a == 0) { n /= a; } else { n = n / a + 1; } if(m % a == 0) { m /= a; } else { m = m / a + 1; } cout \u0026lt;\u0026lt; n * m \u0026lt;\u0026lt; endl; return 0; } ","date":"2014-07-20T09:58:00+08:00","permalink":"https://ivy-end.github.io/p/codeforces-1a-theatre-square/","title":"Codeforces 1A - Theatre Square"},{"content":"没想到高考就这么结束了，分数就这样出来了。\n还没有缓过来，无法接受，横来的失败，令我不知所措。有句话可以比较准确的形容，失去了信仰。\n成绩刚出来，也只是觉得命中注定。中考如斯，高考如斯。但过了一阵子，静下来回忆一下之前的来路，不禁唏嘘。就这样结束了，就以这样的结果结束了？\n当初为了一个目标，开始前行，中途遇到过种种险阻，彷徨、失望、担心，却不曾如现在一般迷惘，不知所措。曾经一度以为自己可以做到，没想到会是这样的结局。值得庆幸的是在这过程中不曾迷失了道路，一直记得当初前行的理由，并一直走了下去，但到今天这样的结果，确是万万没有料到的。这些遗憾与不甘，并不来源于分数本身，而是其后隐藏的，一路前行的过程。\n曾经笃定的眼神，充满希望的方向，瞬间全部化作泡影。\n仔细回想，如果当初毅然决然去参加数学决赛，或许结果不会这样；如果当初毅然决然的停课复习，备战NOIP，或许结果不会这样；如果当初准备上交自招材料的时候没有那么多负面情绪，以至于到最后胡乱应付，或许结果不会这样；如果……\n但是，这一切都已经发生，一切都是我的选择，没有后悔，只是遗憾。要说对不起，我想是那个曾经的自己，以及三年前信誓旦旦的话语。没想到，到头来，一切成空。是不是人们常说的「命里有时终须有，命里无时莫强求。」\n还是谈谈信仰吧，我也不知道，或许付出并不会有什么回报吧。我们都是上帝手中的棋子，演着一部已经定稿的戏剧。所谓「死生有命，富贵在天。」慢慢开始相信「宿命论」。\n每当我非常认真的想要做好一件事情，付出了几乎所有的心血，这件事情往往会搞砸。\n或许，这就是生活——没有如果。\n","date":"2014-06-25T21:50:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%B2%A1%E6%9C%89%E5%A6%82%E6%9E%9C/","title":"没有如果"},{"content":"注：此为一模作文的再创作，之所以取这个题目，是因为当时考试时取的题目实在不堪看。至于将其归于「痴言」分类，大抵可以用曹雪芹的「都云作者痴，谁解其中味。」来解释吧。既然谓之「痴言」，自然是「假语村言」，看官们大可一笑罢之。正文如下：\n他躺在宿舍的床上，皎洁的月光安静的洒在地上。他的舍友早已入睡，只是楼上宿舍还时不时传来些许笑声，他知道他们定是在开卧谈会。\n这倒也无妨，反正他也睡不着，最近一系列的事情搅得他心绪不宁。刚刚从竞赛的前线败下阵来，回到教室，面对着成堆的作业。本来微弱的保送机会也早已化作了泡影。其实对于参加这次竞赛，他内心是极其矛盾的，本可以去参加数学决赛，说不定还可以弄个省一。不过转念一想，就算有了省一，这又都是他所想要的吗？答案自然是否定的。\n对于未来，他有着非常清晰的目标。以至于在高三刚开始填目标时，他毫不犹豫，写下了「上海交大」。当时的他成绩并不理想，他也不知道自己是怎么有勇气在班主任的电脑上打出这几个字来。以至于填完以后根本不敢看班主任一眼，便径直回到自己的座位上。\n回到宿舍，他从舍友口中听到其他同学的一些反应，「有人说你考上上海交大他就从楼上跳下去。」他笑笑，淡淡的答了句「那他得先买好保险。」他一直是这么的自信，哪怕是在最黑最暗的时刻。\n当然，他知道，那些所谓的闲言碎语都没有丝毫用处，行动才是最切合实际的。他也不会相信，自己会在高一上学期短短一百多天刷完一本《英语5·3》；自己的数学会从这儿算错了，那儿没看清题目到一个比较可观的成绩；虽然语文还是在原地踏步，但是他并不着急，他知道，他能够把它做好，用他的老师的一句话说，叫做「尽善尽美」。\n说实话，在一开始，他自己也很迷茫。高二的时候，由于竞赛落下了很多，考试一般都是惨不忍睹。但他找到了支撑他不停奋斗下去的信念。每天背单词，整理错题，刷《英语5·3》，当时的他也不确定，想着，坚持一个月看看结果怎么样吧。第一次月考，他意外的进入了前十的行列，此后基本稳定。但这似乎离他的目标还是相差太远。他总是希望做的更好。\n但是，似乎在几次成绩稳定后，他奋斗的热情似乎有所衰退，好在即时反省，并没有太大的影响。\n又经历了几次大型考试，他的舍友突然又告诉他，「又有一个人说你考上上海交大他就从楼上跳下去。」甚至不惜调侃一句「我也是。」他依旧是那句玩笑的回答。\n这种冷嘲热讽对于他来说已是习以为常，这些年里，他经常和它们打交道，他知道不用去太在意，只要坚定自己的脚步，一直走下去，当阑珊褪去，一切都会柳暗花明。\n记得一模第一天考完，他在走廊上看夜景，他的同学在一旁吹着伤感的曲调，他似乎想起了一些什么，却也只是长嘘一声，此时，他的同学说道「听说你数学考得很好啊。」他苦笑，「还行吧。」他的同学继续说道「还行就是很好。」他无奈的摇了摇头，的确，是不错。但却没有考好的感觉，那种所谓的愉悦与轻松。取而代之的是沉重。\n不是他不善言谈，只是他实在不知道该如何回答才好。或许，这就是所谓的「快乐都在别人的眼里。」有人说他「装深沉」，他也不知道该怎么去回应。其实他知道自己一点都不「深沉」。譬如大家在晚自习下课后通常会讨论数学题，这题怎么做，那题答案是多少，他觉得这些题目还够不着要讨论的难度，所以很少加入。偶尔插一句话，也会被同学「你这方法谁想得到。」给堵回去。他的数学水平也不是很高，他也经常做错题目，看着满目疮痍的试卷，不知所措。\n他也学着别的同学，尝试着阅读英文的小说，却听到「人家英语什么水平，就你，看得懂吗？」当然，他不会就此停下了步伐。\n他也有自己的朋友，有自己信任的人。也愿意在某个午后，和几个朋友出去走走逛逛，抑或坐下来喝杯咖啡，聊聊天。\n看着高考倒计时牌，他不知道六十多天以后会是什么，但是他感到一天天过的越来越快，他知道自己想要的是什么，也知道自己该怎么去做，更明白两个多月后的结果意味着什么。所以，不论如何，他知道自己不能停下脚步。\n「在这人世间有些路是非要单独一个人去面对，单独一个人去跋涉，路再长、再远，夜再黑、再暗也得独自默默地走下去。」他突然想起了席慕容的这句话，在昏昏沉沉中睡去。\n「叮···铃···铃······」拿起手表看了一眼，已是早晨六点，他知道，这又是新的一天。\n梦想，在远方等着他。\n","date":"2014-04-05T21:08:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%BB%96/","title":"他"},{"content":"最近将自己博客里的 HTML 富文本编辑器换成了 Markdown 编辑器，这样可以更加专注于写文章，而不用去关注排版。它比 Word 轻巧，又不如 Latex 般繁复，用来写博客是再适合不过了。\n还记得在放假的时候写的文章中提到希望可以在寒假里再赚一些钱，前几天我们团队（据说已经注册了公司）的队长找到我，让我参与开发一个项目。这个项目据他说是国际项目，分别发布在 Windows、Linux 以及 Mac 三个平台上。他希望我协助开发 Linux 平台，并称会将日后 Linux 平台盈利额的 30% 作为报酬，这是一笔非常可观的收入，要求五月份完工，虽然我非常的欣喜，毕竟这不仅是赚钱的机会，更是对自我能力的提升，但是最后考虑到高考还是没有接。他说我可以只开发 UI，这样可以获得盈利额 12% 作为报酬。思前想后，最终我还是没有接下这个活。\n不知不觉已经正月初十，马上就要开学了，下个学期注定是个不同寻常的学期。当然，我相信我们的 OIer 精神一定可以得到更加淋漓尽致的诠释。就在过年的时候，看到我们团队中一个高三学生写的一篇日志，内容是写给自己的一封信，本想摘录一部分，但是无奈他文笔实在是好，所以索性一并摘录过来（有删改，版权所有：Tjz）\n亲爱的自己，你好。\n当你读到这些文字的时候你已经高三了。我不知道未来的这一百多天的日子里你要经历些什么，不过既然已经跋涉了十一年，最后这一百天里希望你要拼尽全力。\n亲爱的自己，只有你自己最清楚，过去的分分秒秒你付出了多少，浪费了多少。最后的一百多天里希望你平静自己的心。即便自己不是绝顶聪明，也要相信勤能补拙。\n亲爱的自己，未来的日子里请不要轻言放弃。你难免会有失败的时候，因为不只你一个人在努力。但请你相信付出一定会有回报，你要记得跌跌撞撞才是生活，你要把每一次的失败当成下一次成功的路基，你要坚持。当然你也会取得一些进步，那样的时候请你不要放松，因为你放慢了脚步的时候别人并没有。你进步的原因是你之前落下了很多，所以别人在走的时候你需要跑，别人跑起来的时候你就要加速。你没有资本去骄傲。\u0026gt; 亲爱的自己，你需要一个目标。你已经小小的了解了为目标去奋斗的路上并不觉得疲累，所以请你继续追赶。可以是一个城市，一所学校，一个人，或者是一个梦想。总之你需要它来鞭策你变成更好的人。在逐渐缩小距离的同时，再辛苦也觉得值得不是吗？\n亲爱的自己，未来的日子里请你管住自己。不上网并不会折寿几年，你喜欢的书也不是只卖一年就会绝版，还有你的手机也并不是长在身上的器官，离开这些你一样活的好好的。\n还有你那时常泛滥的情绪，请你控制自己的心情。不管你是否经历过，或者还在计较些什么，请你不要继续挣扎，你知道自己曾经输在哪里，所以不可以再摔倒一次。\n请你知道不是你现在所承受的伤痛就叫生死劫。以后你还要走很长很长的路，很多事情还不是时候。\n你可以有喜欢的人，但请你把Ta放在心里。熬不下去的时候花一分钟去想念，然后记得Ta还在努力，你不坚持、不努力就会离Ta越来越远。所以，你要加油。\n亲爱的自己，再动人的情歌、再凄美的故事也不适合高三的你。听英文歌可以练听力，摇滚可以提神，轻音乐能缓解压力。躲在被子里看小说绝对比看报纸看新闻累眼睛。所以当个文青不是不好，是你现在还不够资格。\n亲爱的自己，虽然以后的日日夜夜你要早起晚睡，你要改变自己很多的习惯，你要忍受寂寞。但是还是请你记得要对自己好一点。记得每天喝一杯牛奶，喝茶好过喝咖啡。记得经常锻炼身体会慢慢变好。记得不可以暴饮暴食。记得阴天的时候奖励自己一个大大的微笑，并且带上伞不要淋湿。记得濒临崩溃的时候抱紧自己，告诉自己就快结束了，不能放弃。\n亲爱的自己，你知道自己没有显赫的背景，没人能为你铺出一条康庄大道，你也没有其他的选择。对你而言通往未来的路只有一座叫高考的独木桥，而这一路只能靠你自己披荆斩棘。你要知道你身上背负的不只是你一个人的命运，还有为了你日夜操劳的家人，都是你必须偿还的债。你没有理由也没有时间不努力了。最后一搏，只许成功，不许失败。\n亲爱的自己，请你加油。\n不得不佩服 Tjz 神犇的文笔，我所想说的，他都提到了；我没想到的，他也想到了。\n不得不说，高考对于我们来说意义重大，每次想到都会有些害怕，我也不知道自己在怕什么，也许就像当初面对中考一样的感觉吧。\n说到这，想起上学期只是稍稍在英语方面投入了一些精力，却有了如此结果，倒也出乎意料。或许，这个结果也在我的预料之中。\n既然有了这样一个良好的开端，那么就应该坚持下去，一切都会柳暗花明。虽然目标远大到大家都在嘲笑，但奇迹毕竟是由人来创造的，古语有云\n海到尽头天是岸，山至高处人为峰。\n事在人为！\n","date":"2014-02-09T21:37:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9D%82%E8%AE%B020140209/","title":"杂记（20140209）"},{"content":"本来很早以前就想要写这篇文章了，期间一直在反复思索，于是便一直拖到现在。本文主要是对于生活事件以及个人经历的一些反思，观点可能略有偏激，内容略有冗长，请有选择的阅读。\n这篇文章前几天就起笔了，竟一直拖到今天，不论如何，决不能拖到明年。\n第一个问题是关于为什么要写博客以及博客该写些什么的问题。\n我想还是因为这里比较自由吧。主要还是写一些关于生活的文章，包括一些杂感、竞赛，抑或其他。\n这是我创建博客时候写的第一篇文章《Hello World》中的内容，现在想想竞赛，我早已退役，已经不再属于我所需要记录的范畴，取而代之的可能是对于一些数学内容的思考。至于杂感和其他，这是一个非常庞大的概念，虽然我也经常写，但是总感觉言不由衷。在当初创建这个博客的时候，我就希望可以摆脱其他社交平台，但是到后来却发现还是无法摆脱。虽然我不再在各大社交平台上发表文章，但是我会通过博客的一个插件向空间、人人、微博推送这些文章，其实我也不知道为什么要这么做。虽然我不再关心它们在其他地方的排版，但是这样一来似乎还是回到了之前的情形。\n再者，写文章也是为了记录生活，但是有时候有些话就是不敢或不愿意写出来，这似乎违背了我搭建博客的初衷。对于这一「囚徒困境」我是极其无奈的，这或许会一直持续影响着我。今天去其他博友的博客上逛逛，看到他们写的文章，似乎也有很多关于日常琐碎的生活，或许这样并没有什么不好，只是需要控制好一个度吧。\n第二个问题是关于自己的想法。这个问题还是要面对一下。还记得那次关于萧伯纳和周国平的材料作文，我的观点帮助法被杨英戏称为「怪才」，我当然知道她只是玩笑之言，我也一笑而过。不过时候还是有人说我的想法太「奇怪」，不知那些人是否看过下面这段话：\n他们我行我素，桀骜不驯，惹是生非，就像方孔中的圆桩，他们用不同的角度来看待事物，他们既不墨守成规，也不安与现状，你尽可以赞美他们，否定他们，引用他们，质疑他们，颂扬抑或时诋毁他们。不过唯独不能漠视他们。因为他们改变了事物，他们让人类向前跨越了一大步。他们是别人眼里的疯子，却是我们眼中的天才。因为只有疯狂到认为自己能够改变世界的人，才能真正的改变世界。——斯蒂夫·乔布斯\n乔帮主的这段话还是非常正确的。至于怎么理解，这就是见仁见智的问题了。\n第三个问题是关于人际。这样讲似乎书生气太重了，说白了就是与人相处的事情。有些理论我一直不敢相信它是真的，例如「有的朋友是真的，有的朋友是假的。」不过想想似乎也在理。有的朋友，虽然常年不见，但只要一见面就有说不完的话，就像昨天刚见过一样。而有的朋友，得时刻考虑着为人处事的礼貌。这和心理学上讲人的层进式的防范意识是有一定关系的。或许这才是真正的生活和社会。这也就印证着，所谓的「象牙塔」是并不能真正存在的，我们只能无限接近。\n对于友情，我觉得时间是一个非常重要的因素，所谓「试玉要烧三日满」，对于快餐式的友情，我是不敢苟同的，刚认识几天，便称兄道弟，似乎有些过头了。的确，有的时候，我们似乎只要几天，甚至几个小时，便能知道对方曾经的经历，以及意识形态。但是这并不代表着什么，孔夫子早在两千年前便说过「听其言，观其行。」，这才是最恰当的做法。\n人是非常复杂的动物，虚虚实实，便如同那难以揣测的兵法，所以兵家有句话「兵不厌诈」，那么简单的类比一下，我想各位读者应该可以得到答案。\n第四个问题是关于自身的一些反思。首先摘录一段在别人博客上看到的话：\n我是一个学生， ——我的成绩没有多么耀眼。\n我是一个子女， ——我的孝行没有多么感人。\n我是一个程序员， ——我的程序没有多么成功。\n我是一个朋友， ——我的友谊没有多么真挚。\n我是一个读者， ——我的见解没有多么深刻。\n这段话给我很特别的感觉，似乎非常的切合我。仔细想想，一直以来，我都是非常失败的。\n有些久远的中考，挂了；后来的电子技师，挂了；信心满满的 NOIP，挂了；数学夏令营，还是没拿到免试资格；自荐上海交大，直接被刷了下来；想要翻译的英文资料，却迟迟没有完工；写的程序，漏洞百出；做的网页，惨不忍睹；看过的书，一无是处……\n这些已足够说明上面的事实。我和「优秀」完全搭不上边，我离这两个字还差的很多很多。很多很多。\n","date":"2014-01-30T20:36:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%AF%B9%E4%BA%8E%E7%94%9F%E6%B4%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/","title":"对于生活的一些反思"},{"content":"很早以前就想写篇日志了。一开始是用来抒发竞赛生涯结束的感慨，后来变成了对复赛成绩的凭吊，现在成了一篇随笔。所以题目叫做「杂」。\n期末考试终于结束了，成绩还没出来，至于总结也很难说。且按下不表。\n考前网购了一本书《图解：梅花易数》，想起自己之前靠自己看的那点易学知识，实在是太浅了。一直以为占卜算卦是非常难的事情，一定要有什么特殊的条件。昨天稍稍看了几章《梅花易数》，顿时感到易学的博大精深，对于人世间的种种世相都可以用来占卜，或许这样就可以到达真正的「掐指一算」的程度吧。\n再且说说自招吧。自荐交大，本以为自己实力足够，材料够硬，结果就好比面试的时候直接被关在了门外。说实话，失落，到没太多，当时看到结果，郭华本想安慰一下我，我却直接说「这没什么。」。不过这倒给了看客们一些话题，省的他们没舌根子嚼，也罢，也罢。\n说起这个，似乎还应该感谢两次竞赛的失利，对于打击最大的该是高二的那次，原本斗志昂扬，想着进省队。结果却等来一个二等奖，连省选的资格都没有。再想来，我自认为水平虽然不算特别高，但拿个一等，问题应该不是特别大吧。或许，这就是人生。也多亏有了前几届失败的经历，有了心理准备，也慢慢的有了如今的心理素质，但更大的可能或许是自招并不是我真正看中的吧。既然高考是人生中难得的相对公平的竞争，那么就让它来证明这一切吧。\n不过郭华帮我写的材料，说我「正大光明」，这个评价我还是第一次听到。想想也挺对的。再来说说找张兴写材料吧，虽然我已经不再是梁丰 NOIP 的队员了，但他还是一样的热情，或许 NOIP 只是一个桥梁，沟通的是我们师生二人吧。\n昨天回到家，发现有个「七牛公司」的市场营销人员找到我，绕圈子绕了半天，结果是让我在博客上发他们公司的广告，在听了我一番说辞之后，他说我的拒绝太成熟了。我实在不知道该如何去回复他。不过不管怎么说，这也意味着我的博客在慢慢的发展吧。\n比起空间、人人之类的社交网站，我似乎更倾向于博客，一来博客不会推送信息，不会记录访客，完全是靠读者自己意外搜寻得到，二来比较清静。\n临近年关，有些事情也不想提了，不过还是坚信一句「人在做，天在看。」，所谓业因业果。\n本想回归原来的题目，谈谈竞赛结束的感想，无奈在我的记忆里，只有没日没夜的刷题，以及无数的 Wrong Answer。不过，我倒是学会了如何为了自己的梦想而奋斗。\n至于寒假的规划，首要任务当然是学习，次要人物就是研习《梅花易数》，最好还可以看一点《纳甲筮法》。当然了，如果能够像去年暑假一样，赚点外快就最好了，当然，只是想想罢了。\n暂且到这吧，明天就要去学校了，也不知道会面对一个怎样的分数。\n","date":"2014-01-21T20:31:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9D%82%E8%AE%B020140121/","title":"杂记（20140121）"},{"content":" 2014\n恍惚间，一年的光阴又匆匆流过。不知从什么时候开始，每年写一篇文章似乎成了惯例。今年本来并不打算动笔，但是思来想去还是写写罢，也算是对过往的怀念与铭记，对未来的向往与期待。\n要不是昨天小伙伴们的跨年短信，我还真不觉得昨天的日子有什么特殊的地方。\n不得不说去年发生了很多事情，不得不提的是小高考，考完以后我便写了一篇日志为小高考打个点，也算是对小高考的纪念吧。刚才翻看了一下那篇日志，感觉有很多地方没有记录到，在此补叙几句吧。对于小高考，当时觉得非常神圣，就好像初三时候对中考的感觉一样，但是现在已经考过了，却感觉也没什么，不过如此，或许现在我们既害怕又期待的高考，也会在未来成为茶余饭后的过去吧。\n2013年，印象最深刻的是暑假在数学组的经历。包括了在学校上课，讲题；在扬州培训，考试。虽然那段时间我们每天中午都会把时间放在娱乐上。但是却不可否认这段时间给我们数学能力方面带来的突飞猛进。这也为现在高三应付数学难题打下了扎实的基础，或者根本不算难题。\n当听到别人在讨论着附加题最后一题，说这题有多难多难，真想说，就这种题目也好意思叫难题。但我知道不能说，别人可不这么认为，他们或许觉得你在吹牛，或许觉得你根本不懂。而当你信笔涂鸦解出这道题时，他们又看不懂了，纷纷说你在炫耀。很多事情就是这么回事。\n再说那本英文版的《Steve Jobs》，我自觉看上去没有什么压力，却被人说成炫耀。一如那天文化夜市淘了两本时代周刊时的情况。对此，或许沉默时最恰当的回应，时间是最有力的证明。\n不知大家是否记得某个星期五，上午大课间我被周汉东老师叫去应付省里专家的检查。当时还觉得有多大的场面，而实际上不过如此。倒是等他们来的时间太久了。附上一张图片，或许大家都很好奇发生了些什么。\n为专家组介绍科技小组\n事情大抵就是这样，周围围着一圈专家，我在介绍一个单片机作品。旋转时可以显示出字幕，演示的时候大家都非常好奇，纷纷问我这是如何工作的。那天展示的作品虽然不是我自己做的，但是我之前确实自己动手做过一个类似的作品。所以讲起来也头头是道，以至于第二天有反馈说我那天的讲解非常精准到位。\n还有值得一提的事情大概就是 NOIP 了，但是却一直不想提，我也猜到了这样的结局，又是一个二等奖。也罢。还在暑假里为派出所开发了一套软件，这样一来也至于觉得自己学的编程毫无用武之地。至少可以用自己赚到的钱做自己想做的事情了。\n暑假里加入了 SmartOJ 开发团队，交到了很多朋友，也学到了很多。收获颇丰。\n今天是 2014 的第一天，我想可以开始着手之前策划了许久的项目了。\n高三刚开始的一个月，还比较静的下心，后来慢慢浮躁起来。其间我曾尝试着参悟佛法，无奈实在没有如此高的悟性，最终无功而返。或许还得靠自己吧。\n这些都已经过去了，而过去的这一切证明着我并不差。\n对于已经过去的 2013，确实有很多遗憾，也有很多抱歉，更有很多悔恨。\n对于已经到来的 2014，说实话，有期待，有惶恐。前方的道路是否坎坷，我也不知道下一步会怎么样，但是我知道只有努力才有可能。\n或许现在能做的，只是奋斗。\n我相信！\n","date":"2014-01-01T20:13:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%99%B8%E5%B7%B3%E5%BF%972013-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"癸巳志（2013 年度总结）"},{"content":"很早就想整理这部分的知识了，迫于时间原因，一直拖到现在。下面就圆、椭圆、双曲线、抛物线的切点弦进行一些研究。主要涉及两个方面，一个是关于曲线上某点的切线方程，另一个是关于曲线的切点弦方程。\n一、关于曲线上某点的切线方程 1、圆 我们都知道，过圆$x^{2}+y^{2}=r^{2}\\left ( r \u0026gt; 0 \\right )$上一点$P\\left(x_{0},y_{0}\\right)$的切线方程是$x_{0}x+y_{0}y=r^{2}$。下面我们就更为一般的情形进行探究：\n定理1.1：给定圆$C:\\left ( x-a \\right )^{2}+\\left ( y- b\\right )^{2}=r^{2}\\left ( r \u0026gt; 0 \\right )$，以及圆上一点$P\\left(x_{0},y_{0}\\right)$，则过该点的切线方程为 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$\n证明：对于圆$C:\\left ( x-a \\right )^{2}+\\left ( y- b\\right )^{2}=r^{2}$，两边同时对$x$求导，得 $$ 2\\left ( x-a \\right )+2\\left ( y-b \\right )\\cdot\\frac{dy}{dx}=0 $$ 其中$\\frac{dy}{dx})即为(y\u0026rsquo;$，只是导数两种不同的记号，化简整理得 $$ \\frac{dy}{dx}=-\\frac{x-a}{y-b} $$ 那么我们可以写出切线方程为 $$ y-y_{0}=-\\frac{x_{0}-a}{y_{0}-b}\\left ( x-x_{0} \\right ) $$ 进一步化简得 $$ \\left ( x_{0}-a \\right )x+\\left ( y_{0}-b \\right )y-\\left ( x_{0}^{2}+y_{0}^{2} \\right )+ax_{0}+by_{0}=0 $$ 又$P\\left(x_{0},y_{0}\\right)$在圆$C$上，则$\\left ( x_{0}-a \\right )^{2}+\\left ( y_{0}-b \\right )^{2}=r^{2}$，代入上式化简得 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$ 证毕。\n2、椭圆 有了上面的基础，我们可以猜测到椭圆上某点的切线方程。\n定理1.2：给定椭圆$C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}+\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u0026gt; b \u0026gt; 0 \\right )$，以及椭圆上一点$P\\left(x_{0},y_{0}\\right)$，则过该点的切线方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}+\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1. $$ 证明略。\n3、双曲线 定理1.3：给定双曲线$C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}-\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u0026gt; 0, b \u0026gt; 0 \\right )$，以及双曲线上一点$P\\left(x_{0},y_{0}\\right)$，则过该点的切线方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}-\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1 $$ 证明略。对于焦点在$y$轴上的情形，读者可以自行推导。\n4、抛物线 定理1.4：给定抛物线$C:y^{2}=2p\\left ( x-a \\right )\\left ( p \u0026gt; 0 \\right )$，以及抛物线上一点$P\\left(x_{0},y_{0}\\right)$，则过该点的切线方程为 $$ y_{0}y=p(x+x_{0}-2a) $$ 证明略。对于其他三种情形，读者可以自行推导。\n二、关于曲线外某点的切点弦方程 1、圆 类似的，圆$x^{2}+y^{2}=r^{2}\\left ( r \u0026gt; 0 \\right )$外一点$P\\left(x_{0},y_{0}\\right)$的切点弦方程是$x_{0}x+y_{0}y=r^{2}$。下面我们就更为一般的情形进行探究：\n定理2.1：给定圆$C:\\left ( x-a \\right )^{2}+\\left ( y- b\\right )^{2}=r^{2}\\left ( r \u0026gt; 0 \\right )$，以及圆外一点$P\\left(x_{0},y_{0}\\right)$，则该点的切点弦方程为 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$\n证明：设过$P$的切线与圆$C$相交于点$A\\left ( x_{1},y_{1} \\right ))以及(B\\left ( x_{2},y_{2} \\right )$，首先过点$A$的切线同时经过点$P$，切线方程为 $$ \\left ( x_{1}-a \\right )\\left ( x-a \\right )+\\left ( y_{1}-b \\right )\\left ( y-b \\right )=r^{2} $$ 又过点$B$的切线同时也经过点$P$，切线方程为 $$ \\left ( x_{2}-a \\right )\\left ( x-a \\right )+\\left ( y_{2}-b \\right )\\left ( y-b \\right )=r^{2} $$ 综合上述两个方程，便可以得到过点$A,B$的方程，即点(P)的切点弦方程 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$\n2、椭圆 定理2.2：给定椭圆$C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}+\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u0026gt; b \u0026gt; 0 \\right )$，以及椭圆上一点$P\\left(x_{0},y_{0}\\right)$，则该点的切点弦方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}+\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1 $$ 证明略。\n3、双曲线 定理2.3：给定双曲线$C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}-\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u0026gt; 0, b \u0026gt; 0 \\right )$，以及双曲线上一点$P\\left(x_{0},y_{0}\\right)$，则该点的切点弦方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}-\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1 $$ 证明略。对于焦点在$y$轴上的情形，读者可以自行推导。\n4、抛物线 定理2.4：给定抛物线$C:y^{2}=2p\\left ( x-a \\right )\\left ( p \u0026gt; 0 \\right )$，以及抛物线上一点$P\\left(x_{0},y_{0}\\right)$，则该点的切点弦方程为 $$ y_{0}y=p(x+x_{0}-2a) $$ 证明略。对于其他三种情形，读者可以自行推导。 至此，关于二次曲线的两种切线问题已经阐述完毕。从上述过程我们可以看出，过曲线上某点的切线方程和过曲线外某点的切点弦方程的形式是完全一致的，这正是数学的魅力所在！\n","date":"2013-12-31T20:46:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/","title":"关于二次曲线切线问题的研究"},{"content":"NOIP 终于还是结束了，本来想写一篇文章好好记录一下这两年奋斗的历程，但自从周一知道成绩以后，便什么想法都没有了。凭心而论，今年题目比去年简单，可是我却考得没有去年高，实在惭愧。 现在想来，当初高二知道成绩以后的踌躇满志，就注定了高三竞赛的没落。\n本来写了一篇文章，现在也不想打出来了，一切都过去了。或许，竞赛的成绩并不是最重要的。它所教给我的，是一种精神，正如今年国际金牌得主代表清华大学在ACM开幕式上发言时所说「自己选的路，跪着也要走完。」这种永不言弃的精神将一直伴随着我走下去。\n当然，在竞赛的同时还收获了许多意料之外的惊喜。在刷 USACO、Codeforces 的时候，提高了英语的阅读水平。当然，还结交了几个志同道合的网友，虽然大家分布五湖四海，但是却有着相似的经历，同样的目标，虽然现在我们都注定要踏上高考这条路，但却还可以在文化课这一层面进行许多交流。\n自主招生正在如火如荼的展开着，但是我却对这一政策兴趣不大。且听我慢慢道来，那些可以拿到一流大学大幅度加分优惠的，有几个正常发挥高考考不上这些学校的。对于备战自主招生，又要耽搁许多文化课的时间，到头来两边都顾不着。想起舍友季文逸跟我说的话「我当初没有报竞赛是明智的，有多少人真正受益了呢。」\n当然，这也不代表我不参加自主招生。中国人的一贯想法，大家都报名了，我不报名，岂不落后了。估计自荐上交的可能性大一点。\n谨以此文，作为高中 NOIP 生涯的最后一页。\n到现在，一切与文化课无关的事情也都已结束，可以真正的捣鼓文化课了。\n前方有一个清晰的未来——\n是的，我看见了：\n我来了！\n","date":"2013-11-24T09:45:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%91%93%E8%AF%AD%E5%9B%9B%E6%B8%85%E6%99%B0/","title":"呓语（四）：清晰"},{"content":"昨天终于把欧拉函数想通了，现在总结一下。\n欧拉函数 $ \\varphi \\left ( N \\right ) $ 表示小于或等于 $ N $ 的正整数中与 $ N $ 互质的数的个数。又称 $ \\varphi $ 函数、欧拉商数。\n下面介绍欧拉函数的几个性质：\n$ \\displaystyle\\varphi\\left ( 1 \\right )=1 $； $ \\displaystyle\\varphi \\left( N\\right )=N\\cdot\\prod_{p\\mid N}\\left ( \\frac{p-1}{p} \\right ) $； $ \\displaystyle\\varphi \\left ( p^{k} \\right ) = p^{k}-p^{k-1}=\\left(p-1 \\right )\\cdot p^{k-1} $ ，其中 $ p $ 为质数； $ \\displaystyle\\varphi \\left(mn \\right )=\\varphi \\left(m \\right )\\cdot \\varphi \\left(n \\right ) $ ，其中 $ \\gcd \\left ( m,n \\right )=1 $ 。 我们根据这几个性质就可以求出欧拉函数。\n基本思路是首先置 $ \\varphi \\left ( N \\right )=N $ ，然后再枚举素数 $ p $ ，将 $ p $ 的整数倍的欧拉函数 $ \\varphi \\left ( kp \\right ) $ 进行操作 $ \\varphi \\left ( kp \\right )=\\varphi \\left ( kp \\right )\\cdot \\frac{p-1}{p} $ 即可。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 1024; int N; int p[MAX], phi[MAX]; int main() { cin \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= N; i++) // 初始化 { p[i] = 1; phi[i] = i; } p[1] = 0; // 1不是素数 for(int i = 2; i \u0026lt;= N; i++) // 筛素数 { if(p[i]) { for(int j = i * i; j \u0026lt;= N; j += i) { p[j] = 0; } } } for(int i = 2; i \u0026lt;= N; i++) // 求欧拉函数 { if(p[i]) { for(int j = i; j \u0026lt;= N; j += i) // 处理素因子p[i] { phi[j] = phi[j] / i * (i - 1); // 先除后乘，防止中间过程超出范围 } } } cout \u0026lt;\u0026lt; \u0026#34;Primes: \u0026#34; \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= N; i++) { if(p[i]) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Euler Phi Function: \u0026#34; \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; phi[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 以上是关于欧拉函数的求法，对于它的应用，这里暂且介绍一个——求解原根的个数。\n对于原根的定义，我们可以这样来叙述：\n若存在一个实数 $ a $ ，使得 $ a^{i}\\mod{N},a\\in\\left \\{ 1,2,3,\\cdots ,N \\right \\} $ 的结果各不相同，我们就成实数 $ a $ 为 $ N $ 的一个原根。\n原根的个数等于 $ \\varphi \\left ( \\varphi \\left ( N \\right ) \\right ) $ 。这样我们就可以很方便的求出原根的个数。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; typedef unsigned long long ull; ull N; ull phi(ull x); int main() { cin \u0026gt;\u0026gt; N; cout \u0026lt;\u0026lt; phi(phi(N)) \u0026lt;\u0026lt; endl; return 0; } ull phi(ull x) { ull ans = x; ull m = (ull)sqrt(x); for(ull i = 2; i \u0026lt;\u0026lt;= m; i++) { if(x % i == 0) // 求素因子 { ans = ans / i * (i - 1); // 运用通项求解欧拉函数 while(x % i == 0) // 每个素因子只计算一次 { x /= i; } } } if(x \u0026gt; 1) // 防质数 { ans = ans / x * (x - 1); } return ans; } 关于欧拉函数的知识就介绍这么多吧，应付NOIP应该足够了。\n","date":"2013-11-06T07:44:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","title":"算法专题：欧拉函数"},{"content":"求解线性方程组的有效方法是高斯消元。这个算法我看了半个下午才真正理解并且写了出来。\n这个算法的核心思想就是将一个方程组的增广矩阵通过初等行变换转变成上三角矩阵，然后求解各个未知数的解。\n我写的高斯消元是将所有系数看成一个矩阵来求解的。\n下面来简要讲一下高斯消元的过程：\n首先，我们根据方程组写出增广矩阵。每次都找 $ x_{i} $ 系数的绝对值最大的那个方程，将它移到上方，而将下面的方程组的 $ x_{i} $ 的系数全部化成 0。以此类推，到最后再逆序求解每个未知数的解。\n我们来看一个例子，求解方程组 $ \\begin{cases}2x+y-z=8\\\\ -3x-y+2z=-11\\\\ -2x+y+2z=-3\\end{cases} $\n首先我们写出它的增广矩阵 $$ \\begin{bmatrix}\\left.\\begin{matrix}2 \u0026amp; 1 \u0026amp; -1\\\\ -3 \u0026amp; -1 \u0026amp; 2\\\\ -2 \u0026amp; 1 \u0026amp; 2\\end{matrix}\\right|\\begin{matrix}8\\\\ -11\\\\ -3\\end{matrix}\\end{bmatrix} $$ 接下来我们按照算法步骤来求解这个方程组 $$ \\begin{bmatrix} \\left.\\begin{matrix} 2 \u0026amp; 1 \u0026amp; -1\\\\ -3 \u0026amp; -1 \u0026amp; 2\\\\ -2 \u0026amp; 1 \u0026amp; 2 \\end{matrix}\\right| \\begin{matrix} 8\\\\ -11\\\\ -3 \\end{matrix} \\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026amp; -1 \u0026amp; 2\\\\ 2 \u0026amp; 1 \u0026amp; -1\\\\ -2 \u0026amp; 1 \u0026amp; 2 \\end{matrix}\\right| \\begin{matrix} -11\\\\ 8\\\\ -3 \\end{matrix}\\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026amp; -1 \u0026amp; 2\\\\ 0 \u0026amp; \\frac{1}{3} \u0026amp; \\frac{1}{3}\\\\ 0 \u0026amp; \\frac{5}{3} \u0026amp; \\frac{2}{3} \\end{matrix}\\right| \\begin{matrix}-11\\\\ \\frac{2}{3}\\\\ \\frac{13}{3} \\end{matrix} \\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026amp; -1 \u0026amp; 2\\\\ 0 \u0026amp; \\frac{1}{3} \u0026amp; \\frac{1}{3}\\\\ 0 \u0026amp; 0 \u0026amp; -1 \\end{matrix}\\right| \\begin{matrix} -11\\\\ \\frac{2}{3}\\\\ 1 \\end{matrix} \\end{bmatrix}\\\\ \\Rightarrow z=-1,y=3\\times\\left ( \\frac{2}{3}-\\frac{1}{3}\\times\\left ( -1 \\right )\\right )=3,x=-\\frac{1}{3}\\times\\left ( -11+3-2*\\left ( -1 \\right ) \\right )=2 $$\n表达能力有限，我也只能解释成这样了。\n当时我在网上找资料的时候还抱怨作者为什么不解释清楚点，现在发现，不是作者不愿意解释清楚，这个算法实在难以解释清楚。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 1024; int N; double f[MAX][MAX], ans[MAX]; // f[][]为系数（包括常数），ans[]为结果 double fabs(double x); // double的绝对值 void Gauss(); int main() { cin \u0026gt;\u0026gt; N; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N + 1; j++) // 读取所有系数（包括常数）方程已化为ax+by+…+c=0的形式 { cin \u0026gt;\u0026gt; f[i][j]; } } Gauss(); return 0; } void Gauss() { int nRow = 0; // 保存当前系数绝对值最大的行 double dMax = 0.0f; // 保存当前最大绝对值的系数 for(int i = 1; i \u0026lt;= N; i++) // 对于每一列都处理 { dMax = f[i][i]; nRow = i; // 初始化 for(int j = i + 1; j \u0026lt;= N; j++) // 比较下面所有行的第i列的系数 { if(fabs(f[j][i]) \u0026gt; fabs(dMax)) // 取绝对值最大的系数 { dMax = f[j][i]; nRow = j; } } if(dMax != f[i][i]) // 如果不是当前行最大 { for(int j = i; j \u0026lt;= N + 1; j++) { swap(f[nRow][j], f[i][j]); } // 交换这两个方程组的位置 } for(int j = i + 1; j \u0026lt;= N; j++) // 对于下面的所有方程 { double dTmp = f[j][i] / f[i][i]; // 计算要将第i列的系数消去所需要的倍率 for(int k = i; k \u0026lt;= N + 1; k++) // 对于第j行的方程的每一项的系数都要进行处理 { // 用第nRow行的方程乘以dTmp后去减第j行的方程，这样就可以把第j行的方程的第i列的系数消去 double dMinus = dTmp * f[i][k]; f[j][k] -= dMinus; } } } ans[N + 1] = 1.0f; // 预处理，为了下面的循环方便 for(int i = N; i \u0026gt;= 1; i--) // 逆序求解 { for(int j = i; j \u0026lt;= N + 1; j++) { ans[i] -= f[i][j] * ans[j]; // 减去已求解的未知数乘以其在当前求解的方程中的系数 } ans[i] /= f[i][i]; // 将该未知数的系数化为1，得到结果 } for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } double fabs(double x) { if(x \u0026lt; 0) { x = -x; } return x; } 关于高斯消元，这只是一个列主元的算法，还有全主元的，不过个人觉得列主元的就足够用了。\n","date":"2013-11-05T20:34:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/","title":"算法专题：求解线性方程组"},{"content":"关于这个算法，主要是参考 NOIP2012 Day2 T1。即这里所讲的是求解这样一个线性模方程： $$ ax\\equiv 1\\mod{p} $$ 的最小正整数解。\n去年我是暴搜做的，当时什么都不会。今天在这里介绍两种算法，一种是我国古代数学家秦九韶发明的「大衍求一术」，还一种是著名的「扩展欧几里德算法」。\n首先来看一下大衍求一术。这里只介绍它的计算方法，至于证明可以参考扩展欧几里德算法。\n例1：求解方程 $ 23x\\equiv 1\\mod{97} $ 。\n解：我们只需要列出下面这张表就可以得到求解 $$ \\begin{matrix}23^{1} \u0026amp; 23^{1} \u0026amp; 3^{17} \u0026amp; 3^{17} \u0026amp; 1^{38}\\\\ 97^{0} \u0026amp; 5^{4} \u0026amp; 5^{4} \u0026amp; 2^{21} \u0026amp; 2^{21}\\end{matrix} $$ 结果就是 38。\n接下来我们来理论化的表述一下这个算法的过程：\n假设输入 $ a,b $ 满足 $ a\u0026gt;b $ 。那么我们用 $ a_{n},A_{n} $ 分别表示第一行的底数和奇数， $ b_{n},B_{n} $ 分别表示第二行的底数和奇数，如果 $ a_{i}\u0026gt;b_{i} $ ，那么 $ a_{i+1}=a_{i}\\mod{b_{i}},A_{i+1}=A_{i}+B_{i}\\cdot \\left [ \\frac{a_{i}}{b_{i}} \\right ],b_{i+1}=b_{i},B_{i+1}=B_{i} $ ；如果 $ a_{i}\u0026lt;b_{i} $ 则上面的结论倒过来即可。\n算法结束当且仅当 $ a_{i}=1 $ ，此时 $ A_{i} $ 即为所求的最小正整数解。\n例2：求解方程 $ 97x\\equiv 1\\mod{23} $ 。\n解：我们只需要列出下面这张表就可以得到求解 $$ \\begin{matrix}97^{1} \u0026amp; 5^{1} \u0026amp; 5^{1} \u0026amp; 2^{5} \u0026amp; 2^{5} \u0026amp; \\\\ 23^{0} \u0026amp; 23^{0} \u0026amp; 3^{4} \u0026amp; 3^{4} \u0026amp; 1^{9} \u0026amp; 1^{14}\\end{matrix} $$ 结果就是 14。\n对于这个结果，如果1最先出现在下面一行，则需要再计算一次，而且这次计算必须使得余数是1。\n假设输入 $ a,b $ 满足 $ a\u0026lt;b $ 。中间的步骤和之前一行，在计算过程中必然存在一个 $ i $ 使得 $ b_{i}=1 $ ，此时我们只需计算 $ B_{i+1} $ 即可得到结果。其中 $ B_{i+1}=A_{i}+B_{i}\\cdot \\left(a_{i} - 1\\right) $ 。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; using namespace std; struct Num { int nBase, nIndex; // 分别表示底数和奇数 }; Num x, y; int main() { cin \u0026gt;\u0026gt; x.nBase \u0026gt;\u0026gt; y.nBase; x.nIndex = 1; y.nIndex = 0; // 初始化 if(x.nBase \u0026lt; y.nBase) { while(1) { if(x.nBase == 1 || x.nBase == 0) // 循环出口 { cout \u0026lt;\u0026lt; x.nIndex \u0026lt;\u0026lt; endl; break; } if(x.nBase \u0026lt; y.nBase) // 模拟计算过程 { int nDiv = y.nBase / x.nBase; if(y.nBase % x.nBase == 0) { nDiv--; } y.nBase %= x.nBase; y.nIndex += nDiv * x.nIndex; } else { int nDiv = x.nBase / y.nBase; if(x.nBase % y.nBase == 0) { nDiv--; } x.nBase %= y.nBase; x.nIndex += nDiv * y.nIndex; } } } else { while(1) { if(y.nBase == 1) // 出口 { int nDiv = x.nBase - 1; cout \u0026lt;\u0026lt; nDiv * y.nIndex + x.nIndex \u0026lt;\u0026lt; endl; // 求出结果 break; } if(x.nBase \u0026lt; y.nBase) // 模拟计算过程 { int nDiv = y.nBase / x.nBase; if(y.nBase % x.nBase == 0) { nDiv--; } y.nBase %= x.nBase; y.nIndex += nDiv * x.nIndex; } else { int nDiv = x.nBase / y.nBase; if(x.nBase % y.nBase == 0) { nDiv--; } x.nBase %= y.nBase; x.nIndex += nDiv * y.nIndex; } } } return 0; } 可能上面的算法对于某些人来说比较晦涩，我们下面来介绍一下扩展欧几里德算法。首先介绍一个定理：\n方程 $ ax+by=\\gcd\\left ( a,b \\right ) $ 一定有解。\n这样我们的问题就可以转化为求方程 $ ax+b\\cdot \\left ( -y \\right )=1 $ ，在这里，我们先求出方程 $ ax+b\\cdot \\left ( -y \\right )=\\gcd\\left(a,b\\right) $ 的解，然后只要将结果除以 $ \\gcd\\left(a,b\\right) $ 就行了。\n下面来推导一下扩展欧几里德算法。\n我们已知 $$ ax+by=\\gcd\\left ( a,b \\right ) $$ 且 $$ \\gcd\\left ( a,b \\right )=\\gcd\\left(b,a\\mod b \\right ) $$ 不妨设 $$ bx{}\u0026rsquo;+\\left ( a\\mod b \\right )y{}\u0026rsquo;=\\gcd\\left ( b,a\\mod b \\right ) $$ 此时就有 $$ bx{}\u0026rsquo;+\\left ( a\\mod b \\right )y{}\u0026rsquo;=ax+by $$ 展开得到 $$ bx{}\u0026rsquo;+\\left ( a-\\left [ \\frac{a}{b} \\right ]\\cdot b \\right )y{}\u0026rsquo;=ax+by $$ 化简得 $$ ay{}\u0026rsquo;+b\\left (x{}\u0026rsquo;-\\left [ \\frac{a}{b} \\right ]\\cdot y{}\u0026rsquo; \\right )=ax+by $$ 因此可以得到 $$ x=y{}\u0026rsquo;,y=x{}\u0026rsquo;-\\left [ \\frac{a}{b} \\right ]\\cdot y{}\u0026rsquo; $$ 这样我们就可以用递归来实现扩展欧几里德算法了。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; LL A, B, C, X = 0, Y = 0; LL gcd(LL a, LL b); void exgcd(LL a, LL b, LL \u0026amp;x, LL \u0026amp;y); int main() { cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; C = gcd(A, B); exgcd(A, -B, X, Y); while(X \u0026lt; 0) { X += B; } // 找最小正整数 cout \u0026lt;\u0026lt; X \u0026lt;\u0026lt; endl; return 0; } void exgcd(LL a, LL b, LL \u0026amp;x, LL \u0026amp;y) { if(a == 0) { x = 0; y = C / b; // 边界 } else { exgcd(b % a, a, x, y); y = x; // 递推公式 x = (C - b * y) / a; } } LL gcd(LL a, LL b) // 求解最大公倍数 { if(b == 0) { return a; } else { return gcd(b, a % b); } } 相比之下扩展欧几里德更容易理解一点，并且没有大衍求一术那么多特殊情况要处理，比较方便。\n","date":"2013-11-04T19:41:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/","title":"算法专题：不定方程"},{"content":"强连通分量（Strongly Connected Components），简称 SCC。是指在给定的一张图 $ G=\\left(V,E\\right) $ 的一个子图 $ G{}\u0026rsquo;=\\left(V,E\\right) $ 这个子图满足对于其中的任意一对点 $ \\left \\langle V_{i},V_{j} \\right \\rangle $ 均存在这样两条路径 $ \\left \\langle V_{i},\\cdots,V_{j} \\right \\rangle,\\left \\langle V_{j},\\cdots,V_{i} \\right \\rangle $ 。\n如果我们把强连通分量缩成一个点，这时候，原图 $ G $ 则会变成有向无环图。\n图 $ G=\\left(V,E\\right) $ 是有向无环图当且仅当该图中没有点集合元素个数大于1的强连通分量。且任意一个强连通分量都至少包含一个有向环。下面我们通过一张图片来理解一下强连通分量以及缩点：\n强连通分量\n对于统计给定的图 $ G=\\left(V,E\\right) $ 中强连通分量的个数，我们可以应用并查集在 $ O\\left ( \\alpha \\left ( V \\right )\\cdot V \\right ) $ 时间内得到求解。\n如果不仅需要统计强连通分量的个数，还要将强连通分量缩点，则需要用到今天介绍的Kosaraju Algorithm。它的具体步骤如下：\n对原图 $ G $ 进行DFS并将出栈顺序进行逆序，得到的顺序就是拓扑序列。 将原图的每一条边反向，得到反图 $ G{}\u0026rsquo; $ 。 按照第一步生成的拓扑序列的顺序再对反图 $ G{}\u0026rsquo; $ 进行DFS染色，染成同色的就是一个强连通分量。 这个算法比较容易理解，也是最通用的算法。它主要是同时运用了原图 $ G $ 和反图 $ G{}\u0026rsquo; $ 。\n该算法具有一个性质：如果我们把求出来的每个强连通分量缩成一个点，并且用求出每个强连通分量的顺序来标记收缩后的结点，那么这个顺序就是强连通分量缩点后所形成的有向无环图的拓扑序列。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; const int MAX = 10240; int N, M, nCnt = 0; int pMap[MAX][MAX], pColor[MAX]; stack\u0026lt;int\u0026gt; S; // 储存拓扑序列 void dfs1(int x); // 原图DFS void dfs2(int x); // 反图DFS void Kosaraju(); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; memset(pMap, 0, sizeof(pMap)); for(int i = 1; i \u0026lt;= M; i++) { int s, e; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; pMap[s][e] = 1; // 有向图 } Kosaraju(); return 0; } void Kosaraju() { memset(pColor, 0, sizeof(pColor)); for(int i = 1; i \u0026lt;= N; i++) // DFS原图求出拓扑序列 { if(!pColor[i]) { dfs1(i); } } memset(pColor, 0, sizeof(pColor)); while(!S.empty()) // 按照拓扑序列DFS反图 { int x = S.top(); S.pop(); if(!pColor[x]) { nCnt++; // 找到一个强连通分量 dfs2(x); } } cout \u0026lt;\u0026lt; \u0026#34;The number of SCC is \u0026#34; \u0026lt;\u0026lt; nCnt \u0026lt;\u0026lt; endl; } void dfs1(int x) { pColor[x] = 1; // 染色 for(int i = 1; i \u0026lt;= N; i++) { if(pMap[x][i] == 1 \u0026amp;\u0026amp; !pColor[i]) { dfs1(i); } } S.push(x); // 加入拓扑序列 } void dfs2(int x) { pColor[x] = nCnt; // 属于第几个强连通分量 for(int i = 1; i \u0026lt;= N; i++) { if(pMap[i][x] == 1 \u0026amp;\u0026amp; !pColor[i]) // 原邻接矩阵的对称矩阵为反图 { dfs2(i); } } } ","date":"2013-11-04T10:14:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-kosaraju-algorithm/","title":"算法专题：强连通分量 - Kosaraju Algorithm"},{"content":"传递闭包（Transitive Closure）主要是研究图上两点之间的连通性。对于这个问题，我们只需要改进一下 Floyd-Warshall Algorithm 就可以很方便的求出它的解。\n我们这里主要研究的是有向图的传递闭包问题。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 10240; const int INF = 65536; int N, M; bool f[MAX][MAX], pMap[MAX][MAX]; void Floyd(); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { pMap[i][j] = f[i][j] = (i == j) ? 1 : 0; // 初始化 } } for(int i = 1; i \u0026lt;= M; i++) { int s, e; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; pMap[s][e] = pMap[e][s] = true; // 无向图 f[s][e] = f[e][s] = true; } Floyd(); return 0; } void Floyd() { for(int k = 1; k \u0026lt;= N; k++) // 最外层必须是k { for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { f[i][j] = f[i][j] || (f[i][k] \u0026amp;\u0026amp; f[k][j]); // 判断连通性 } } } for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { cout \u0026lt;\u0026lt; f[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } 这个算法还是比较简单的，只要在 Floyd-Warshall Algorithm 的基础上修改一下就行了。\n","date":"2013-11-03T19:48:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/","title":"算法专题：传递闭包"},{"content":"欧拉回路（Euler Circuit）是指：在一个无向图中，一条包含所有边，且其中每一条边只经过一次的路径。欧拉回路最常见的应用是一笔画。\n下面介绍几个用于判断给定的图 $ G=\\left(V,E\\right) $ 中是否欧拉通路或欧拉回路：\n一个图有欧拉回路当且仅当它是连通的且每个顶点都有偶数度。 一个图有欧拉通路当且经当它是连通的且除两个顶点外，其他顶点都有偶数度。 在第二个定理下，含奇数度的两个节点中，一个必为欧拉通路起点，另一个必为欧拉通路的终点。 这样，我们就可以很容易想出程序的思路：\n计算各个顶点的度，如果存在 1 个奇数度，或者奇数度个数大于 2，则不存在欧拉回路。 选择奇数度的一个顶点作为欧拉回路的起点，如果不存在奇数度的顶点，则任意选取一个，在这里我们选取第一个顶点。 每次遍历与该点相连的边，删去该条边，则原图就转化成了一个更小的图，求它的欧拉通路，这样递归即可求解。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 10240; int N, M, pCnt[MAX]; int pMap[MAX][MAX]; vector\u0026lt;int\u0026gt; pVec; void Search(int x); void Euler_Circuit(); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; memset(pMap, 0, sizeof(pMap)); for(int i = 1; i \u0026lt;= M; i++) { int s, e; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; pMap[s][e] = pMap[e][s] = 1; // 无向图 } Euler_Circuit(); return 0; } void Euler_Circuit() { int nStart = 1, nOddNum = 0; // nStart保存起点，nOddNum保存有几个顶点有奇数度 memset(pCnt, 0, sizeof(pCnt)); for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { pCnt[i] += pMap[i][j]; // 计算各个顶点的度 } } for(int i = 1; i \u0026lt;= N; i++) // 统计奇数度顶点的个数 { if(pCnt[i] \u0026amp; 1) { nStart = i; nOddNum++; } } if(nOddNum \u0026gt; 2 || nOddNum == 1) // 不存在欧拉回路 { cout \u0026lt;\u0026lt; \u0026#34;Not Exsit Euler Circuit\u0026#34; \u0026lt;\u0026lt; endl; } else { Search(nStart); for(int i = 0; i \u0026lt; pVec.size(); i++) { cout \u0026lt;\u0026lt; pVec[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } void Search(int x) { for(int i = 1; i \u0026lt;= N; i++) { if(pMap[x][i] == 1) { pMap[x][i] = pMap[i][x] = 0; // 删边 Search(i); } } pVec.push_back(x); } 欧拉回路我至今也没有在做题目的时候用到过，不知道是不是这类题目比较少见。\n","date":"2013-11-03T19:43:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/","title":"算法专题：欧拉回路"},{"content":"拓扑排序（Topological Sorting）是图论中一个比较重要的概念。它主要用来解决下面这类问题：\n给定一个 AOV 网（Activity On Vertex Network）， $ A\\rightarrow B $ 表示活动 $ A $ 必须在活动 $ B $ 之前完成。请给出一个合理的活动顺序。\n当然，AOV 网中不可能出现环，因为出现了环就无法拓扑排序。因此可以用拓扑排序来判断图中是否存在环。\n关于拓扑排序，我们来看一下下面这张图片：\nToplogical Sorting\n我们可以用队列来实现这个算法，具体改进的过程如下：\n记录每个点的入度； 将入度为 0 的顶点加入队列； 依次对入度为 0 的点进行删边操作，同时将新得到的入度为零的点加入队列； 重复上述操作，直至队列为空。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 10240; int N, M, pDegree[MAX]; queue\u0026lt;int\u0026gt; Q; vector\u0026lt;int\u0026gt; pMap[MAX], pVec; void TopSort(); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; memset(pDegree, 0, sizeof(pDegree)); for(int i = 1; i \u0026lt;= M; i++) { int s, e; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; pMap[s].push_back(e); // 有向图 pDegree[e]++; // 计算入度 } TopSort(); return 0; } void TopSort() { for(int i = 1; i \u0026lt;= N; i++) { if(pDegree[i] == 0) // 入度为0的点入队 { Q.push(i); } } while(!Q.empty()) { int x = Q.front(); Q.pop(); pVec.push_back(x); // 出队顺序即为拓扑序列 for(int i = 0; i \u0026lt; pMap[x].size(); i++) { pDegree[pMap[x][i]]--; // 删边 if(pDegree[pMap[x][i]] == 0) // 新的入度为0的点 { Q.push(pMap[x][i]); } } } for(int i = 1; i \u0026lt;= N; i++) { if(pDegree[i] != 0) // 若存在入度不为0的点，则存在环 { cout \u0026lt;\u0026lt; \u0026#34;Exsit Loop\u0026#34; \u0026lt;\u0026lt; endl; return; } } for(int i = 0; i \u0026lt; pVec.size(); i++) // 顺序输出即为拓扑序列 { cout \u0026lt;\u0026lt; pVec[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } {% endhighlight %} 对于这一问题，我们也可以用DFS来解决它，代码如下： {% highlight cpp linenos %} #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 10240; int N, M, pVisited[MAX]; // 0-未访问 1-正在访问 2-已访问 vector\u0026lt;int\u0026gt; pMap[MAX], pVec; void TopSort(); bool DFS(int v); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= M; i++) { int s, e; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e; pMap[s].push_back(e); // 有向图 } TopSort(); return 0; } void TopSort() { memset(pVisited, 0, sizeof(pVisited)); for(int i = 1; i \u0026lt;= N; i++) // 所有顶点都访问一遍 { if(!pVisited[i]) { if(!DFS(i)) { cout \u0026lt;\u0026lt; \u0026#34;Exsit Loop\u0026#34; \u0026lt;\u0026lt; endl; } } } for(int i = pVec.size() - 1; i \u0026gt;= 0; i--) // 倒序输出拓扑序列 { cout \u0026lt;\u0026lt; pVec[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } bool DFS(int v) // false-有环 true-无环 { pVisited[v] = 1; // 正在访问 for(int i = 0; i \u0026lt; pMap[v].size(); i++) // 搜索它的前驱 { if(pVisited[pMap[v][i]] == 1) { return false; } // 该点进入两次则有环 else if(pVisited[pMap[v][i]] == 0) { if(!DFS(pMap[v][i])) { return false; } } } pVisited[v] = 2; // 访问完毕 pVec.push_back(v); // 加入拓扑序列 return true; } 相较这两种算法，我更倾向于用队列来实现，毕竟这种方法符合求解拓扑排序的一般思路。至于这两种算法的复杂度，在这里就不再分析了。\n","date":"2013-11-03T19:17:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","title":"算法专题：拓扑排序"},{"content":"这次我们来讨论一下关于多源最短路径 APSP（All-Pairs Shortest Paths）。即求出给定的图 $ G=\\left ( V,E \\right ) $ 中任意两对顶点 $ V_{i},V_{j} $ 之间的最短路径。我们根据下面这幅图来理解一下这个概念：\n多源最短路径\n对于这一问题，比较有效的算法是 Floyd-Warshall Algorithm，简称 Floyd。它是基于动态规划的一种最短路径的算法。\n我们用 $ f^{k}\\left ( i,j \\right ) $ 来表示从顶点 $ i $ 到顶点 $ j $ 不经过索引比 $ k $ 大的点的最短路径。这样一来，我们就可以根据 $ f^{k-1}\\left ( i,j \\right ) $ 推出 $ f^{k}\\left ( i,j \\right ) $ 。\n假设我们目前已知 $ f^{k-1}\\left ( i,j \\right ) $ ，要推出 $ f^{k}\\left ( i,j \\right ) $ ，无外乎两种情况：\n经过顶点 $ k $ ； 不经过顶点 $ k $ 。 对于第一种情况，显然有 $ f^{k}\\left ( i,j \\right )=f^{k-1}\\left ( i,k \\right )+f^{k-1}\\left ( k,j \\right ) $ 。对于第二种情况，我们也很容易得到 $ f^{k}\\left ( i,j \\right )=f^{k-1}\\left ( i,j \\right ) $ 。这样一来，状态转移方程也就确定了：\n$$ f^{k}\\left ( i,j \\right )=\\min{\\left \\{ f^{k-1}\\left ( i,k \\right )+f^{k-1}\\left ( k,j \\right ),f^{k-1}\\left ( i,j \\right ) \\right \\}} $$\n这样一来，也就解决了为什么 Floyd-Warshall Algorithm 的最外层循环必须是 $ k $ 这一问题。很显然，Floyd-Warshall Algorithm 的时间复杂度为 $ O\\left(V^{3}\\right) $ 。\n当然，这个算法还可以用来求最小环，具体求法请参考代码，应该能看懂，就不再多说。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX = 10240; const int INF = 65536; int N, M; int f[MAX][MAX], pMap[MAX][MAX]; void Floyd(); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { pMap[i][j] = f[i][j] = (i == j) ? 0 : INF;\t// 初始化 } } for(int i = 1; i \u0026lt;= M; i++) { int s, e, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; v; pMap[s][e] = v; pMap[e][s] = v;\t// 无向图 f[s][e] = v; f[e][s] = v; } Floyd(); return 0; } void Floyd() { int nLen = 65536; for(int k = 1; k \u0026lt;= N; k++)\t// 最外层必须是k { for(int i = 1; i \u0026lt;= k; i++)\t// 求解最小环 { for(int j = 1; j \u0026lt;= k; j++) { nLen = min(nLen, pMap[i][j] + f[i][k] + f[k][j]); } } for(int i = 1; i \u0026lt;= N; i++)\t// 求解APSP { for(int j = 1; j \u0026lt;= N; j++) { if(f[i][k] + f[k][j] \u0026lt; f[i][j])\t// 是否需要松弛 { f[i][j] = f[i][k] + f[k][j]; } } } } cout \u0026lt;\u0026lt; \u0026#34;Shortest Loop is \u0026#34; \u0026lt;\u0026lt; nLen \u0026lt;\u0026lt; endl; for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { if(f[i][j] == INF) { cout \u0026lt;\u0026lt; \u0026#34;-1 \u0026#34;; } else { cout \u0026lt;\u0026lt; f[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; } } ","date":"2013-11-03T16:30:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-floyd-warshall-algorithm/","title":"算法专题：多源最短路径 - Floyd-Warshall Algorithm"},{"content":"SPFA 是 Shortest Path Fast Algorithm 的缩写，它是之前介绍的 Bellman-Ford Algorithm 的一种队列实现，减少了不必要的冗余计算。\n算法的基本步骤如下：\n初始化队列和标记数组，将源点入队。 每次取队首元素，对其发出的所有边进行松弛。并将松弛过的且不在队列中的顶点加入到队列中。 重复第二步直至队列为空。 若要判断负环，则当某个顶点松弛超过V次，即存在负环。\n对于SPFA还是比较容易理解的，它的复杂度为 $O\\left(kE\\right)$。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 10240; bool pQueue[MAX]; int N, M, pDist[MAX], pCnt[MAX];\t// pCnt[]记录顶点i松弛的次数 vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; pMap[MAX]; queue\u0026lt;int\u0026gt; Q; void SPFA(int s); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= M; i++) { int s, e, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; v; pMap[s].push_back(make_pair(e, v));\t// 无向图 pMap[e].push_back(make_pair(s, v)); } SPFA(1); return 0; } void SPFA(int s) { bool bNativeLoop = false;\t// 判断负环的变量 for(int i = 1; i \u0026lt;= N; i++)\t// 初始化 { pDist[i] = 2147483647; } memset(pQueue, false, sizeof(pQueue)); pDist[s] = 0; Q.push(s);\t// 源点入队 pQueue[s] = true; while(!Q.empty()) { int x = Q.front(); Q.pop();\t// 取出队首元素 pQueue[x] = false;\t// 出队 for(int i = 0; i \u0026lt; pMap[x].size(); i++) { if(pDist[pMap[x][i].first] \u0026gt; pDist[x] + pMap[x][i].second)\t// 松弛 { pDist[pMap[x][i].first] = pDist[x] + pMap[x][i].second; if(!pQueue[pMap[x][i].first])\t// 如果未入队 { Q.push(pMap[x][i].first); pQueue[pMap[x][i].first] = true;\t// 入队 if(++pCnt[pMap[x][i].first] \u0026gt; N) { bNativeLoop = true;\t// 存在负环 while(!Q.empty()) { Q.pop(); }\t// 立即退出循环 } } } } } if(bNativeLoop) { cout \u0026lt;\u0026lt; \u0026#34;Exist Negative Loop\u0026#34; \u0026lt;\u0026lt; endl; } else { for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; pDist[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } 至此，单源最短路的算法基本复习结束。细究这三种算法，个人觉得 SPFA 的编程复杂度较低。而 Dijkstra Algorithm 也挺实用的。不过在一般情况下我比较倾向于 SPFA。\n","date":"2013-11-03T15:50:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-spfa/","title":"算法专题：单源最短路径 - SPFA"},{"content":"上一篇文章介绍了一下 Dijkstra Algorithm，但是它仅局限于处理非负权值的图。若图中出现负边，Dijkstra Algorithm 就会出现错误。这时候就需要使用其他的算法来求解单源最短路径。\nBallman-Ford 是一个非常实用的算法，它是由美国数学家 Richard Ballman 和 Lester Ford 发明的。Ballman-Ford 算法的基本流程如下：\n初始化 $ pDist\\left [ \\right ] $ 数组。 检查每一条边，如果源点到该条边的起点有通路，则更新原点到该条边的终点的最短路径。循环 $ V $ 次即可得到结果。 如若要检测是否存在负环，则再检查每一条边，若可以松弛，则有负环。\n我们来看一张图片具体体会一下 Bellman-Ford Algorithm：\nBellman-Ford 算法\n这个算法相对而言比较容易实现，复杂度为 $ O\\left ( VE \\right ) $ 。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 10240; const int INF = 2147483647; struct Edge { Edge(int _s, int _e, int _v) { s = _s; e = _e; v = _v; } int s, e, v; }; int N, M; int pDist[MAX]; vector\u0026lt;Edge\u0026gt; pEdge;\t// 边集数组 void Ford(int s); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= M; i++) { int s, e, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; v; pEdge.push_back(Edge(s, e, v));\t// 无向图 pEdge.push_back(Edge(e, s, v)); } Ford(1); return 0; } void Ford(int s) { bool bNativeLoop = false;\t// 记录是否存在负环 for(int i = 1; i \u0026lt;= N; i++)\t// 初始化 { pDist[i] = INF; } pDist[s] = 0; for(int i = 1; i \u0026lt;= N; i++)\t// 循环N次 { for(int j = 0; j \u0026lt; pEdge.size(); j++)\t// 每次检查每一条边 { int s = pEdge[j].s, e = pEdge[j].e, v = pEdge[j].v; if(pDist[s] != INF)\t// 如果源点可以到达顶点s则进行松弛 { pDist[e] = min(pDist[e], pDist[s] + v); } } } for(int i = 0; i \u0026lt; pEdge.size(); i++)\t// 检查负环 { int s = pEdge[i].s, e = pEdge[i].e, v = pEdge[i].v; if(pDist[e] \u0026gt; pDist[s] + v)\t// 若松弛完毕后还能松弛，则存在负环 { bNativeLoop = true; break; } } if(bNativeLoop == true) { cout \u0026lt;\u0026lt; \u0026#34;Exist Native Loop\u0026#34; \u0026lt;\u0026lt; endl; } else { for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; pDist[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } ","date":"2013-11-03T10:13:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-bellman-ford-algorithm/","title":"算法专题：单源最短路径 – Bellman-Ford Algorithm"},{"content":"这个星期开始复习最短路的一些算法。\n单源最短路径（Single Source Shortest Paths），简称 SSSP。这是图论中非常重要的一类算法。解决这一问题有多种算法，今天先来介绍一下 Dijkstra Algorithm。\n首先介绍一下单源最短路径的概念，通俗的讲，就是给定一个源点 $ s $ （即起点），求这个源点到其他各个顶点的最短路径。最短路径，通俗的来讲，我们称使得顶点 $ V_{i} $ 到顶点 $ V_{j} $ 所经过的路径的权值之和最小的一条路径，称为从顶点 $ V_{i} $ 到顶点 $ V_{j} $ 的最短路径。\n单源最短路径\n上面这幅图标出了从源点 $ s $ 到各个顶点的最短路径，大家可以根据图片自己体会一下最短路径的含义。其中 $ -\\infty $ 表示到该点的最短路径是负无穷，因为我们发现存在负环，所以我们利用负环，使得最短路径达到负无穷，但是这个一般不在我们一般的算法的讨论范围内。\n下面来介绍一下 Dijkstra Algorithm。\n首先将所有的顶点分成两个集合 $ A $ 、 $ B $ ，其中集合 $ A $ 表示已经求得最短路径的顶点集合，集合 $ B $ 为待求解的顶点集合。初始时有 $ A=\\left { V_{0} \\right } $ 。 将集合 $ A $ 与集合 $ B $ 相连的边按照递增次序排序，取最短的边，将该条边在集合 $ B $ 中所对应的顶点加入到集合 $ A $ 中。 重复第二步，直至集合 $ B $ 为空集。\n我们通过下面一幅图来理解一下 Dijkstra Algorithm：\nDijkstra 算法\n下面我们来考虑算法的实现方式，显然，我们需要每次在集合 $ A $ 中发出的所有边中找到最小的一条边，而每次这样找的话，复杂度很高，我们可以考虑用优先队列来优化这个步骤。这样的话复杂度就下降到了 $ O\\left ( \\left ( V+E \\right )\\cdot \\log{E} \\right ) $ 。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int MAX = 10240; typedef pair\u0026lt;int,int\u0026gt; pii; int N, M; int pDist[MAX]; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; pMap[MAX]; priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt; \u0026gt; Q;\t// 优先队列 void Dijkstra(int s); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= M; i++) { int s, e, v; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; e \u0026gt;\u0026gt; v;\t// 无向图 pMap[s].push_back(make_pair(e, v)); pMap[e].push_back(make_pair(s, v)); } Dijkstra(1); return 0; } void Dijkstra(int s) { for(int i = 1; i \u0026lt;= N; i++)\t// 初始化 { pDist[i] = 2147483647; } pDist[s] = 0； Q.push(make_pair(pDist[s], s));\t// 将源点加入队列 while(!Q.empty()) { pii x = Q.top(); Q.pop();\t// 取最短的边 if(x.first != pDist[x.second]) { continue; }\t// 防止重复计算 for(int i = 0; i \u0026lt; pMap[x.second].size(); i++) { int v = pMap[x.second][i].first;\t// 待松弛的顶点 int w = pMap[x.second][i].second;\t// 从顶点x.second到顶点i的距离 if(pDist[v] \u0026gt; pDist[x.second] + w) { pDist[v] = pDist[x.second] + w;\t// 松弛 Q.push(make_pair(pDist[v], v)); } } } for(int i = 1; i \u0026lt;= N; i++) { cout \u0026lt;\u0026lt; pDist[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } ","date":"2013-11-03T09:22:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra-algorithm/","title":"算法专题：单源最短路径 – Dijkstra Algorithm"},{"content":"今天来介绍一下最小生成树的另外一种算法：Kruskal Algorithm。这个算法是基于贪心实现的，算法的大体过程如下：\n取权值最小的边，如果加入这条边以后，不会出现环，那么就加入这条边。 重复上述操作，直至加入了 $ N-1 $ 条边。 我们还是先来看一张图片来理解一下这个算法：\nKruskal 算法\n下面我们来考虑这个算法，最棘手的问题是判断是否构成环，这里我们采用并查集来处理这个问题，它的复杂度是 $ O\\left(V*\\alpha\\left(V\\right)\\right) $ 。对于每次寻找权值最小的边，复杂度是 $ O\\left(E\\right) $ 。这样一来，复杂度将高达 $ O\\left(V*\\alpha\\left(V\\right)+VE\\right) $ ，即 $ O\\left(VE\\right) $ 。\n我们考虑优化，每次寻找权值最小的边，可以考虑先将权值从小到大排序。这样复杂度就下降到 $ O\\left(V*\\alpha\\left(V\\right)+E\\log{E}\\right) $ ，即 $ O\\left(E\\log{E}\\right) $ 。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 1024; struct Edge { Edge(int _u, int _v, int _w) { u = _u; v = _v; w = _w; } int u, v, w; }; struct Set { int nParent, nCount; }; int cmp(Edge x, Edge y) { return x.w \u0026lt; y.w; } int N, M; vector\u0026lt;Edge\u0026gt; pEdge; Set pSet[MAX]; void Kruskal(); void Init(); int Find(int x); void Union(int x, int y); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= M; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; pEdge.push_back(Edge(u, v, w)); } Kruskal(); return 0; } void Kruskal() { int nCost = 0, nPos = 0; vector\u0026lt;Edge\u0026gt; pMST; sort(pEdge.begin(), pEdge.end(), cmp); Init(); while(pMST.size() != N - 1) // 直到MST中有N-1条边 { Edge minEdge = pEdge[nPos++]; if(Find(minEdge.u) != Find(minEdge.v)) // 如果加入后不构成环 { nCost += minEdge.w; pMST.push_back(minEdge); Union(minEdge.u, minEdge.v); } } cout \u0026lt;\u0026lt; \u0026#34;The MST Cost is \u0026#34; \u0026lt;\u0026lt; nCost \u0026lt;\u0026lt; endl; } void Init() { for(int i = 1; i \u0026lt;= N; i++) { pSet[i].nParent = i; pSet[i].nCount = 1; } } int Find(int x) { if(pSet[x].nParent != x) { return pSet[x].nParent = Find(pSet[x].nParent); // 路径压缩 } else { return x; } } void Union(int x, int y) { int fx = Find(pSet[x].nParent); int fy = Find(pSet[y].nParent); if(fx != fy) // 启发式合并，减小树的高度 { if(pSet[fx].nCount \u0026gt; pSet[fy].nCount) { pSet[fy].nParent = fx; pSet[fx].nCount += pSet[y].nCount; } else { pSet[fx].nParent = fy; pSet[fy].nCount += pSet[x].nCount; } } } 至此，最小生成树的算法基本复习完毕。\n分析两种算法，Prim Algorithm的复杂度是 $ O\\left(V^{2}\\right) $ ，适用于稠密图；而Kruskal Algorithm的复杂度是 $ O\\left(E\\log{E}\\right) $ ，适用于疏密图。各有所长，需要根据不同的情况选择不同的算法。\n","date":"2013-10-20T21:33:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-kruskal-algoritm/","title":"算法专题：最小生成树 – Kruskal Algoritm"},{"content":"最近开始准备 NOIP 复赛，发现很多算法已经不会了。只能一个个的捡起来，慢慢复习，顺便做点笔记。\n最小生成树（Minimum Spanning Trees），简称 MST。是图论中一个非常重要的概念。解决这个问题有两种算法，今天暂且先来讨论一下 Prim Algorithm。不做特别说明，讨论的都是无向图。\n首先介绍一下最小生成树的概念，我们知道，图可以这样定义 $ G=\\left(V,E\\right) $ ，其中 $ G $ 表示图， $ V $ 表示顶点集合， $ E $ 表示边集合。最小生成树是这样一棵树，它满足 $$ w\\left ( T \\right )=\\min {\\left \\{ \\sum_{\\left ( u,v \\right )\\in T}w\\left ( u,v \\right ) \\right \\}} $$ 通俗地讲，就是使得图 $ G $ 连通时，所选取的边的长度的和最小。\n最小生成树\n如上图，加粗的路径就是在最小生成树上的路径。\n现在，我们开始讨论Prim Algorithm。这个算法可以分为下面几个步骤：\n将顶点集 $ V $ 分成两个集合 $ A $ 和 $ B $ ，其中集合 $ A $ 表示目前已经在MST中的顶点，而集合 $ B $ 则表示目前不在 MST 中的顶点。 寻找与集合 $ A $ 连通的最短的边 $ \\left(u,v\\right) $ ，将这条边加入最小生成树中。（此时，与 $ \\left(u,v\\right) $ 相连的顶点，不妨设为 $ B_{i} $ ，也应加入集合 $ A $ 中） 重复第二步，直至集合 $ B $ 为空集。 算法的大体思想就是这样了。为了方便理解，我们先来看一下下面一张图片：\nPrim 算法\n对照上面的图片，想必对于 Prim Algorithm 也有了一定的理解。\n下面我们来设计算法，显然，我们需要遍历集合 $ A $ 中所有顶点及与之相连的边，取连接到集合 $ B $ 的权值最小的边，加入最小生成树。这样一来，复杂度将达到 $ O\\left(n^{3}\\right) $ 。\n我们可以对这个想法进行优化。我们维护一个 $ pCost\\left [ i \\right ] $ 数组，用来表示从集合 $ A $ 到与之相邻的节点的最小费用。这样，我们只要每次取这个数组中的最小值，把它在集合 $ B $ 中所对应的结点 $ V_{i} $ 加入到集合 $ A $ 中。每次加入结束以后，都要更新 $ pCost\\left [ i \\right ] $ 数组。即枚举所有与结点 $ V_{i} $ 相连的边，判断是否比 $ pCost\\left [ i \\right ] $ 数组中的最小费用小，如果比它小，则更新。这样可以将算法优化到 $ O\\left(n^{2}\\right) $ 。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 1024; const int INF = 2147483647; // 设置最大权值 int N, M; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; pMap[MAX]; // 邻接表 void Prim(); int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= M; i++) { int u, v, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; pMap[u].push_back(make_pair(v, w)); pMap[v].push_back(make_pair(u, w)); } Prim(); return 0; } void Prim() { int nCost = 0; vector\u0026lt;int\u0026gt; pMST; // 储存MST的结点 int pCost[MAX]; // 储存与集合A相邻的顶点的最小权值，0表示该结点已经在MST中 pMST.push_back(1); // 将结点1加入MST pCost[1] = 0; for(int i = 2; i \u0026lt;= N; i++) // 初始化，切记要将除1以外的都置为INF { pCost[i] = INF; } for(int i = 0; i \u0026lt; pMap[1].size(); i++) // 处理与结点1相连的顶点 { pCost[pMap[1][i].first] = pMap[1][i].second; } for(int i = 1; i \u0026lt;= N - 1; i++) // 剩余N-1个顶点，循环N-1次 { int nVertex = 0, nWeight = INF; // 用于寻找最短的边 for(int j = 1; j \u0026lt;= N; j++) { if(nWeight \u0026gt; pCost[j] \u0026amp;\u0026amp; pCost[j] != 0) { nVertex = j; nWeight = pCost[j]; } } pCost[nVertex] = 0; pMST.push_back(nVertex); // 将节点nVertex加入MST nCost += nWeight; // 计算MST的费用 for(int j = 0; j \u0026lt; pMap[nVertex].size(); j++) // 更新pCost数组 { if(pCost[pMap[nVertex][j].first] != 0 \u0026amp;\u0026amp; pCost[pMap[nVertex][j].first] \u0026gt; pMap[nVertex][j].second) { pCost[pMap[nVertex][j].first] = pMap[nVertex][j].second; } } } cout \u0026lt;\u0026lt; \u0026#34;MST Cost is \u0026#34; \u0026lt;\u0026lt; nCost \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;The vertexs in MST are \u0026#34;; for(int i = 0; i \u0026lt; pMST.size(); i++) { cout \u0026lt;\u0026lt; pMST[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } ","date":"2013-10-19T21:30:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim-algoritm/","title":"算法专题：最小生成树 – Prim Algoritm"},{"content":"随便写写，记录一下最近发生的事情。\n高中最后一次运动会居然是在停课中度过的。不过比起化学组去省选的那些人还算幸运的，至少也参与了一点，虽然成绩只有一个引体向上。\n29号晚自习，我在机房给高二的上课，讲解初赛的选择题。真正感觉到了「后生可畏」的感觉。本来想冲个省队的，但是我们的国赛在明年7月份，那时候我们已经毕业了，所以不能代表江苏省参赛。信息学竞赛就这点不好，各门竞赛大多高三才到炉火纯青的地步，却不给省队资格。虽然我们全国各地的高三选手联名向CCF抗议，但还是无疾而终。挺可惜的，但至少可以拿个省一回来，给竞赛画上圆满的句号。\n我们开发团队的一个初三的学生，把我之前的一篇日志《中秋望月感怀》当做语文作业的作文交了上去，受宠若惊。\n前几天和上一届高三的物理竞赛保送大神杨文杰聊了一会儿。咨询了一下高考，自招，交大的相关事宜。总结下来一句话：\n踏踏实实做学问。\n关于这方面，张兴也给我讲过他静心治学的经历。\n今天下午，黄旸洋给我打了个电话，聊了一下他的近况，各种感慨涌上心头。我也不知道该怎么平心静气的把它们记录下来，暂且按下不表。\n高考要开始报名了。我也不知道最后会是什么结果，但是我清楚我想要的是什么结果。\n我还记得，暑假在数学组的时候，袁秦盟经常喜欢说一句话\n是的，我可以的！\n是的，我可以的！\n","date":"2013-09-30T21:01:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9D%82%E8%AE%B020130930/","title":"杂记（20130930）"},{"content":"在我的印象中，从来没有过真正意义上的赏月。小时候虽然每年都会如约赏月，但那时候年纪尚小，即使望月，也不会有什么特别的感触。\n自从高二受了周红娟老师的耳濡目染，再者，加上《唐诗之旅》的熏陶，开始对明月产生了一种别样的情怀。自此以后，每当看到明月，想到的不再时冷冰冰的月球，而是嫦娥玉兔，吴刚伐树。有时候甚至会像李白一样「举杯邀明月，对影成三人」。\n前几天住宿的时候，便已经感到了中秋的到来。熄灯后，一束月光打在床上，真如太白所记「床前明月光，疑是地上霜」。\n今天晚上看新闻，提到瘦西湖是最佳赏月之地，不禁想起徐凝的一句诗「天下三分明月夜，二分无赖是扬州」。好在身处农乡，不像城市中有高大的建筑物遮挡视线，也不用担心刺眼的霓虹灯会干扰赏月的心情。四下只有明亮的月光，别有一番意境。望着皎洁的月亮，一时思绪纷飞。\n窗外响起了爆竹声，大家都对一年一度的中秋佳节抱有极大的好感。这么多年没有观赏月色，突然在中秋佳节赏月，心中有种说不出的感觉。为大自然的美妙所折服，人类终究还是渺小的。真希望可以和苏子一样「挟飞仙以遨游，抱明月而长终」。但到最后还是意识到「知不可乎骤得，托遗响于悲风」。\n如此一来，不禁想到人事变迁。最先进入脑海的，是周红娟老师，说实话，跟她学到了很多东西。尤其是一种热爱生活、积极生活的态度。或许作为电教员跟她接触的机会多一点吧，感觉周红娟还是挺不错的一个老师，虽然有时候方式方法不太得当，但至少初衷还是好的。或许语文所要教会我们的，便是如何去生活，而不是如何去得分。就像高冰峰老师，一大把年纪了，还如此文艺，不得不说这是一种乐观积极的生活态度。对于周红娟老师的离开，早在她告诉我们她高三只能带一个班的时候，便已料到。后来在暑假里遇到她，得到了确定的消息，当时的确有些不舍，但有些事情总是不可避免的。不过还得谢谢她在大夏天来给我们送清凉。\n明月自古便非常的忙碌，我也极少的去麻烦它。至多只是让它捎个信，带个问候罢了。我想今天的月亮一定会非常乐意的将我的思念传递给我的小伙伴们吧。古人是极富浪漫主义色彩的，只要双方都望着明月，明月就会帮他们传递心绪。这远比现代的即时通讯工具高级，靠的是人与自然的融合与共生。相较而言，我更喜欢后者。\n高考是个不可避免的话题。虽然已经填完了大学的目标，但现在与之差距着实太大。在高一的时候，我曾幻想着可以拿到计算机一等，然后保送。这个五彩的肥皂泡最终随着竞赛保送制度的取消而破灭。接着，便想着自主招生，这是一条非常好的路径，考的还好可以本一即录，相当于报送。\n但是，目睹了几位过来人的事迹，也对它产生了怀疑。就拿去年2013届高三（15）班的胡宇涛来说吧。他和我一起搞竞赛的。去年我们一起去南航参加复赛，第一天下午，2012届高三（15）班的缪晓伟（也是信息组的）带领我们参观南大（仙林校区），当时胡宇涛就表明了要进南大的意愿，他也是这样做的。平时模拟考390左右，有时候还上过400。后来参加了南大自主招生，考的时候差几分面试，只加了10分。到最后，高考却挂了。加来的10分就也形同虚设了。\n有一首打油诗，感觉讲的非常在理：\n自招毁一生，竞赛穷三代。要考好大学，还得语数外。\n当然了，也不是让大家消极的对待自主招生，但是不要花太多精力，这种东西如同竞赛，全靠运气。时也，命也。当然，要考非常好的大学，还是需要自招降降门槛的。所以，这样说来，还是老老实实搞语数外来的实在。\n细察为什么大家如此热衷保送，自招，无非就是「逃避」。逃避高考，保送是最好的道路；既然保送取消了，那只好拿自招来当垫背。细想来，这些又是何必呢，高考，终究还是要降临在我们的头上，也会给予我们相对客观公正的评价。\n最后一句话，与大家共勉：\n说出来被嘲笑的梦想，才有去实现的必要。\n月色，还是那样的澄澈明净……\n","date":"2013-09-19T20:03:00+08:00","permalink":"https://ivy-end.github.io/p/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%802013/","title":"中秋望月感怀（2013）"},{"content":"新版高中教材对复数内容进行了极大的删减，使得我们对于复数的认知还停留在最原始的阶段。殊不知，复数的应用非常广泛。现参考《高中数学·甲种本》以及搜集的一些资料，包括做过的例题，整理一下关于复数的内容。\n一、复数的概念 1.1 数的概念的发展 数的概念是从实践中产生和发展起来的。早在原始社会末期，由于记数的需要，人们就建立起自然熟的概念。自然数的全体构成自然数集$\\mathbf{N}$。\n随着生产和科学的发展，熟的概念也得到了发展。\n为了表示各种具有相反意义的量以及满足记数法的要求，人们引进了零和负数，把自然数看作正整数，把正整数、零、负整数合并在一起，构成整数集$\\mathbf{Z}$。\n为了解决测量、分配中遇到的将某些量进行等分的问题，人们又引进了有理数，规定他们就是一切形如$\\frac{m}{n}$的数，其中$m\\in \\mathbf{Z},n\\in \\mathbf{N}$。这样，就把整数集$\\mathbf{Z}$扩大为有理数集$\\mathbf{Q}$。显然，$\\mathbf{Z}\\subset \\mathbf{Q}$。如果把整数看作分母为$1$的分数，那么有理数实际上就是分数集。\n每一个有理数都可以表示成整数、有限小数或循环节不为$0$的循环小数；反过来，整数、有限小数或循环节不为$0$的循环小数也都是有理数。如果把整数、有限小数都看作循环节为$0$的循环小数，那么有理数集实际上就是循环小数的集合。\n为了解决有些量与量之间的比值（例如用正方形的边长去度量它的对角线所得结果）不能用有理数表示的矛盾，人们又引入了无理数。所谓无理数，就是无限不循环小数。有理数集与无理数集合并在一起，构成实数集$\\mathbf{R}$。因为有理数都可以看作循环小数（包括整数、有限小数），无理数都是无限不循环小数，所以实数集就是小数集。\n从解方程来看，方程$x+5=3$在自然数集$\\mathbf{N}$中无解，在整数集$\\mathbf{Z}$中就有一个解$x=-2$；方程$3x=5$字整数集$\\mathbf{Z}$中无解，在有理数集$\\mathbf{Q}$中就有一个解$x=\\frac{5}{3}$；方程$x^{2}=2$在有理数集$\\mathbf{Q}$中无解，在实数集$\\mathbf{R}$中就有两个解$x=\\pm \\sqrt{2}$。但是，熟的范围扩充到实数集$\\mathbf{R}$以后，象$x^{2}=-1$这样的方程还是无解，因为没有一个实数的平方等于$-1$。在十六世纪，由于解方程的需要，人们开始引进一个新数$i$，叫做虚数单位，并规定：\n它的平方等于$-1$，即\n$$ i^{2}=-1 $$\n实数与它进行四则运算时，所有的加、乘运算律仍然成立。\n在这种规定下，$i$可以与实数$b$相乘，再同实数$a$相加，由于满足乘法交换律及加法交换律，从而可以把结果写成$a+bi$。人们把它们叫做复数。全体复数所成的集合，一般用字母$\\mathbf{C}$来表示。1\n在这种规定下，$i$就是$-1$的一个平方根。因此，方程$x^{2}=-1$在复数集$\\mathbf{C}$中就至少有一个解$x=i$。\n十八世纪以后，复数在数学、力学和电学中得到了应用。从此对它的研究日益展开。现在复数已成为科学技术中普遍使用的一种数学工具。\n1.2 复数的有关概念 复数$a+bi$（$a,b\\in\\mathbf{R}$。以后说复数$a+bi$时，都有$a,b\\in\\mathbf{R}$），当$b=0$时，就是实数；当$b\\neq 0$时，叫做虚数，当$a=0,b\\neq 0$时，叫做纯虚数；$a$与$b$分别叫做复数$a+bi$的实部与虚部。例如，$3+4i,-\\frac{1}{2}-\\sqrt{2}i,-0.5i$都是虚数，它们的实部分别是$3,-\\frac{1}{2},0$，虚部分别是$4,-\\sqrt{2},-0.5$。\n显然，实数集$\\mathbf{R}$是复数集$\\mathbf{C}$的真子集，即$\\mathbf{R}\\subset \\mathbf{C}$。\n如果两个复数$a+bi$与$c+di$的实部与虚部分别相等，我们就说这两个复数相等，记作$a+bi=c+di$，这就是说，如果$a,b,c,d\\in\\mathbf{R}$，那么 $$ a+bi=c+di \\Leftrightarrow a=c,b=d $$ $$ a+bi=0\\Leftrightarrow a=b=0 $$\n例：已知$\\left ( 2x-1 \\right )+i=y-\\left ( 3-y \\right )i$，其中$x,y\\in\\mathbf{R}$。求$x$与$y$。\n解：根据复数相等的定义，得方程组$\\begin{cases} 2x-1=y,\\\\ 1=-\\left ( 3-y \\right ) \\end{cases}$解得$x=\\frac{5}{2},y=4$。\n从复数相等的定义，我们知道，任何一个复数$z=a+bi$，都可以由一个有顺序的实数对$\\left ( a,b \\right )$唯一确定。这就使我们能借用平面直角坐标系来表示复数$z=a+bi$。如图1，点$Z$的横坐标是$a$，纵坐标是$b$，复数$z=a+bi$可用点$Z\\left ( a,b \\right )$来表示。这个建立了直角坐标系表示复数的平面叫做复平面，$x$轴叫做实轴，$y$轴除去原点的部分叫做虚轴（因为原点表示实数$0$，原点不在虚轴上）。表示实数的点都在实轴上，表示纯虚数的点都在轴上。\n复数的复平面表示法\n很明显，按照这种表示方法，每一个复数，有复平面内唯一的一个点和它对应；反过来，复平面内的每一个点，有唯一的一个复数和它对应。由此可知，复数集$\\mathbf{C}$和复平面内所有的点所成的集合是一一对应的。这是复数的一个几何意义。\n当两个复数实部相等，虚部互为相反数时，这两个复数叫做互为共轭复数（当虚部不等于$0$时也叫做互为共轭虚数）。复数$z$的共轭复数可以用$\\overline{z}$来表示，也就是说，复数$z=a+bi$的共轭复数是$\\overline{z}=a-bi$。显然，复平面内表示两个互为共轭复数的点$Z$与$\\overline{Z}$关于实轴对称（图2），而实数$a$（即虚部为$0$的复数）的共轭复数仍是$a$本身。\n两个实数可以比较大小。但是两个复数，如果不全是实数，就不能比较它们的大小。对于这个命题的证明，将稍后给出。\n1.3 复数的向量表示 在物理学中，我们经常遇到力、速度、加速度、电场强度等，这些量，除了要考虑它们的绝对值大小以外，还要考虑它们的方向。我们把这种既有绝对值大小又有方向的量叫做向量。向量可以用有向线段来表示，线段的长度就是这个向量的绝对值（叫做这个向量的模），线段的方向（用箭头表示）就是这个向量的方向。模相等且方向相同的向量，不管它们的起点在哪里，都认为是相等的向量。在这一规定下，向量可以根据需要进行平移。模为零的向量（它的方向是任意的）叫做零向量。规定所有零向量相等。\n复数的向量表示法\n复数可以用向量来表示。如图 3，设复平面内的点$Z$表示复数$z=a+bi$，连结$OZ$，如果我们把有向线段$OZ$（方向是从点$O$指向点$Z$）看成向量，记作$\\overrightarrow{OZ}$，就把复数同向量联系起来了。很明显，向量$\\overrightarrow{OZ}$是由点$Z$唯一确定的；反过来，点$Z$也可由向量$\\overrightarrow{OZ}$唯一确定。因此，复数集$C$与复平面内所有以原点$O$为起点的向量所成的集合也是一一对应的。为方便起见，我们常把复数$z=a+bi$说成点$Z$或者说成向量$\\overrightarrow{OZ}$。此外，我们还规定，相等的向量表示同一个复数。\n图3中的向量$\\overrightarrow{OZ}$的模（即有向线段$OZ$的长度）$r$叫做复数$z=a+bi$的模（或绝对值）记作 $\\left | z \\right |$或$\\left | a+bi \\right |$ 。如果$b=0$，那么$z=a+bi$是一个实数$a$它的模就等于 $\\left | a \\right |$ （即$a$在实数意义上的绝对值）。容易看出，\n$\\left | z \\right |=\\left | a+bi \\right |=r=\\sqrt{a^{2}+b^{2}}.$\n例1：求复数$z_{1}=3+4i$及$z_{2}=-\\frac{1}{2}-\\sqrt{2}i$的模，并且比较它们的模的大小。\n解： $\\left| z_{1} \\right|=\\sqrt{3^{2}+4^{2}}=5,\\left | z_{2} \\right |=\\sqrt{\\left ( -\\frac{1}{2} \\right )^{2}+\\left ( \\sqrt{2} \\right )^{2}}=\\frac{3}{2}.$又$5 \u0026gt; \\frac{3}{2}$ ，故$\\left | z_{1} \\right | \u0026gt; \\left | z_{2} \\right |$。\n例2：设$z\\in\\mathbf{C}$，满足下列条件的点$Z$的集合是什么图形？ （1）$\\left | z \\right |=4$；（2）$2 \u0026lt; \\left | z \\right | \u0026lt; 4$。\n解：\n（1）复数$z$的模等于$4$，就是说，向量$\\rightarrow{OZ}$的模（即点$Z$与原点$O$的距离）等于$4$，所以满足条件 $\\left | z \\right |=4$ 的点$Z$的集合是以原点$O$为圆心，以$4$为半径的圆。\n（2）不等式$2 \u0026lt; \\left | z \\right | \u0026lt; 4$可化为不等式组$\\begin{cases}\\left | z \\right | \u0026lt; 4\\\\ \\left | z \\right | \u0026gt; 2\\end{cases}$。不等式$\\left | z \\right | \u0026lt; 4$的解集是圆$\\left | z \\right | = 4$内部所有的点组成的集合，不等式$\\left | z \\right | \u0026gt; 2$的解集是圆$\\left | z \\right | = 2$外部所有的点组成的集合，这两个集合的交集，就是上述不等式组的解集，也就是满足条件$2 \u0026lt; \\left | z \\right | \u0026lt; 4$的点$Z$的集合。容易看出，所求的集合是以原点$O$为圆心，以$2$及$4$为半径的圆所夹的圆环，但不包括圆环的边界（图 4）。\n圆\n二、复数的运算 2.1 复数的加法与减法 复数的加法规定按照以下的法则进行：设$z_{1}=a+bi,z_{2}=c+di$是任意两个复数，那么它们的和：$$ \\left ( a+bi \\right )+\\left ( c+di \\right )=\\left ( a+c \\right )+\\left ( b+d \\right )i $$ 很明显，两个复数的和仍然是一个复数。\n容易验证，复数的加法满足交换律、结合律，即对任意$z_{1},z_{2},z_{3}\\in\\mathbf{R}$，有 $$ z_{1}+z_{2}=z_{2}+z_{1} $$ $$ \\left ( z_{1}+z_{2} \\right )+z_{3}=z_{1}+\\left ( z_{2}+z_{3} \\right ) $$ 现在我们来看复数加法的几何意义。\n从物理学知道，要求出作用于同一点$O$、但不在同一直线上的两个力$\\overrightarrow{F_{1}}$与$\\overrightarrow{F_{2}}$的合力，只要用表示$\\overrightarrow{F_{1}}$与$\\overrightarrow{F_{2}}$的向量为相邻的两边画一个平行四边形，那么，平行四边形中，以力的作用点$O$为起点的那条对角线所表示的向量就是合力$\\overrightarrow{F}$（图5-1）。这个法则通常叫做向量加法的平行四边形法则。\n复数加法的几何意义\n复数用向量来表示，如果与这些复数对应的向量不在同一直线上，那么这些复数的加法就可以按照向量加法的平行四边形法则来进行。下面我们来证明这一事实。\n设$\\overrightarrow{OZ_{1}}$及$\\overrightarrow{OZ_{2}}$分别与复数$a+bi$及$c+di$对应，且$\\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}}$不在同一直线上（图5-2）。以$\\overrightarrow{OZ_{1}}$及$\\overrightarrow{OZ_{2}}$为两条邻边画平行四边形$OZ_{1}ZZ_{2}$，画$x$轴的垂线$PZ_{1},QZ_{2}$及$RZ$，并且画$Z_{1}S\\perp RZ$，容易证明\n$\\triangle ZZ_{1}S\\cong \\triangle Z_{2}OQ,$\n并且四边形$Z_{1}PRS$是矩形，因此\n$OR=OP+PR=OP+Z_{1}S=OP+OQ=a+c$\n$RZ=RS+SZ=PZ_{1}+QZ_{2}=b+d.$\n于是点$Z$的坐标是$\\left ( a+c,b+d \\right )$，这说明设$\\overrightarrow{OZ}$就是于复数$\\left ( a+c \\right )+\\left ( b+d \\right )i$对应的向量。\n由此可知，求两个复数的和，可以先画出这两个复数对应的向量$\\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}}$，如果$\\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}}$不在同一直线上，再以这两个向量为两条邻边画平行四边形，那么与这个平行四边的对角线$OZ$所表示的向量$\\overrightarrow{OZ}$对应的复数，就是所求两个复数的和。\n如果$\\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}}$在同一直线上，我们可以画出一个“压扁”了的平行四边形，并据此画出它的对角线来表示$\\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}}$的和。\n总之，复数的加法可以按照向量的加法法则来进行，这是复数加法的几何意义。\n下面再来看复数的减法。\n复数的减法规定是加法的逆运算，即把满足 $$ \\left ( c+di \\right )+\\left ( x+yi \\right )=a+bi $$ 的复数$x+yi$，叫做复数$a+bi$减去复数$c+di$的差。记作$\\left ( a+bi \\right )-\\left ( c+di \\right )$，根据复数相等的定义，有 $$ c+x=a,d+y=b $$ 由此 $$ x=a-c,y=b-d, $$ 所以 $$ x+yi=\\left ( a-c \\right )+\\left ( b-d \\right )i, $$ 即 $$ \\left ( a+bi \\right )-\\left ( c+di \\right )=\\left ( a-c \\right )+\\left ( b-d \\right )i $$ 这就是复数的减法法则。由此可见，两个复数的差是一个唯一确定的复数。\n现设$\\overrightarrow{OZ}$与复数$a+bi$对应，$\\overrightarrow{OZ_{1}}$与复数$c+di$对应（图6）。以$\\overrightarrow{OZ}$为一条对角线，$\\overrightarrow{OZ_{1}}$为一条边画平行四边形，那么这个平行四边形的另一边，$\\overrightarrow{OZ_{2}}$所表示的向量，$\\overrightarrow{OZ_{2}}$就与复数$\\left ( a-c \\right )+\\left ( b-d \\right )i$对应。因为$Z_{1}Z\\stackrel{;//;}{=}OZ_{2}$，所以向量$\\overrightarrow{Z_{1}Z}$也与这个差对应。\n复数减法的几何意义\n这就是说，两个复数的差$z-z_{1}$（即$\\overrightarrow{OZ}-\\overrightarrow{OZ_{1}}$）与连结两个向量终点并指向被减数的向量对应。这就是复数减法的几何意义。\n由上所述，我们可以看出，复数的加（减）法与多项式的加（减）法是类似的，就是把复数的实部与实部、虚部与虚部分别相加（减），即\n$$ \\left ( a+bi \\right )\\pm \\left ( c+di \\right )=\\left ( a\\pm c \\right )+\\left ( b\\pm d \\right ) $$\n例1：计算$\\left ( 5-6i \\right )+\\left ( -2-i \\right )-\\left ( 3+4i \\right )$。\n解：$\\left ( 5-6i \\right )+\\left ( -2-i \\right )-\\left ( 3+4i \\right )=\\left ( 5-2-3 \\right )+\\left ( -6-1-4 \\right )i=-11i$。\n例2：根据复数的几何意义及向量表示，求复平面内两点间的距离公式。\n复平面两点距离\n解：如图 7，设复平面内的任意两点$Z_{1},Z_{2}$分别表示复数$z_{1}=x_{1}+y_{1}i,z_{2}=x_{2}+y_{2}i$，那么$\\overrightarrow{Z_{1}Z_{1}}$就是与复数$z_{2}-z_{1}$对应的向量。如果用$d$表示点$Z_{1},Z_{1}$之间的距离，那么$d$就是向量$\\overrightarrow{Z_{1}Z_{2}}$的模，即复数$z_{2}-z_{1}$的模，所以 $$ d=\\left | z_{2}-z_{1} \\right |=\\left | \\left ( x_{2}+y_{2}i \\right )-\\left ( x_{1}+y_{1}i \\right ) \\right |=\\left | \\left ( x_{2}-x_{1} \\right )+\\left ( y_{2}-y_{1} \\right )i \\right |=\\sqrt{\\left ( x_{2}-x_{1} \\right )^2+\\left ( y_{2}-y_{1} \\right )^2} $$ 这与我们之前导出的两点间的距离公式一致。\n例3：根据复数的几何意义及向量表示，求复平面内的圆的方程。\n复平面圆\n解：如图8，设圆心为$P$，点$P$与复数$p=a+bi$对应，圆的半径为$r$，圆上任意一点$Z$与复数$z=a+bi$对应，那么 $$ \\left | z-p \\right |=r $$ 这就是复平面内的圆的方程。特别地，当点$P$在原点时，圆的方程就成了 $$ \\left | z \\right |=r $$\n请读者利用复数的减法法则，把圆的方程 $$ \\left | z-p \\right |=r $$ 化成用实数表示的一般形式 $$ \\left ( x-a \\right )^{2}+\\left ( y-b \\right )^{2}=r^{2} $$\n2.2 复数的乘法与除法 复数的乘法规定按照以下的法则进行：设$z_{1}=a+bi,z_{2}=c+di$是任意两个复数，那么它们的积 $$ \\left ( a+bi \\right )\\left ( c+di \\right )=ac+bci+cdi+bdi^{2}=\\left ( ac-bd \\right )+\\left ( bc+ad \\right )i $$\n也就是说，复数的乘法与多项式的乘法是类似的，但必须在所得的结果中把$i^{2}$换成$-1$，并且把实部和虚部分别合并。\n很显然，两个复数的积仍然是一个复数。\n容易验证，复数的乘法满足交换律、结合律以及乘法对加法的分配律，即对任何$z_{1},z_{2},z_{3}\\in\\mathbf{C}$，有 $$ z_{1}\\cdot z_{2}=z_{2}\\cdot z_{1} $$ $$ \\left ( z_{1}\\cdot z_{2} \\right )\\cdot z_{3}=z_{1}\\cdot\\left ( z_{2}\\cdot z_{3} \\right ) $$ $$ z_{1}\\cdot \\left ( z_{2}+z_{3} \\right )=z_{1}\\cdot z_{2}+z_{1}\\cdot z_{3} $$\n根据复数的乘法法则，对于任何复数$z=a+bi$，有 $$ \\left ( a+bi \\right )\\left ( a-bi \\right )=a^{2}+b^{2}+\\left ( ab-ab \\right )i=a^{2}+b^{2} $$\n因此，两个共轭复数$z,\\overline{z}$的积是一个实数，这个实数等于每一个复数的模的平方，即 $$ z\\cdot \\overline{z}=\\left | z \\right |^{2}=\\left | \\overline{z} \\right |^{2} $$\n例1：计算$\\left ( 1-2i \\right )\\left ( 3+4i \\right )\\left ( -2+i \\right )$。\n解：$\\left ( 1-2i \\right )\\left ( 3+4i \\right )\\left ( -2+i \\right )=\\left ( 11-2i \\right )\\left ( -2+i \\right )=-20+15i$。\n计算复数的乘方，要用到虚数单位$i$的乘方。因为复数的长发满足交换律与结合律，所以实数集$\\mathbf{R}$中正整数指数幂的运算律，在复数集$\\mathbf{C}$中仍然成立，即对任何$z,z_{1},z_{2}\\in\\mathbf{C}$及$m,n\\in\\mathbf{N}$，有 $$ z^{m}\\cdot z^{n}=z^{m+n} $$ $$ \\left ( z^{m} \\right )^{n}=z^{mn} $$ $$ \\left ( z_{1}\\cdot z_{2} \\right )^{n}=z_{1}^{n}\\cdot z_{1}^{n} $$ 另一方面，我们有 $$ i^{1}=i $$ $$ i^{2}=-1 $$ $$ i^{3}=i^{2}\\cdot i=-i $$ $$ i^{4}=i^{3}\\cdot i=-i\\cdot i=-i^{2}=1 $$ 从而，对于任何$n\\in\\mathbf{N}$，我们都有 $$ i^{4n+1}=i^{4n}\\cdot i=\\left ( i^4 \\right )^{n}\\cdot i=1^{n}\\cdot i=i $$ 同理可证 $$ i^{4n+2}=-1 $$ $$ i^{4n+3}=-i $$ $$ i^{4n}=1 $$ 这就是说，如果$n\\in\\mathbf{N}$，那么 $$ i^{4n+1}=i,i^{4n+2}=-1,i^{4n+3}=-i,i^{4n}=1 $$\n例2：计算$\\left ( \\frac{1}{2}-\\frac{\\sqrt{3}}{2}i \\right )^{3}$。\n解： $$ \\begin{align*} \\left ( \\frac{1}{2}-\\frac{\\sqrt{3}}{2}i \\right )^{3}\u0026amp;=\\left ( \\frac{1}{2} \\right )^3-3\\left ( \\frac{1}{2} \\right )^{2}\\left ( \\frac{\\sqrt{3}}{2}i \\right )+3\\left ( \\frac{1}{2} \\right )\\left ( \\frac{\\sqrt{3}}{2}i \\right )^{2}-\\left ( \\frac{\\sqrt{3}}{2} \\right )^{3}\\\\ \u0026amp;=\\frac{1}{8}-\\frac{3\\sqrt{3}}{8}i-\\frac{9}{8}+\\frac{3\\sqrt{3}}{8}i\\\\ \u0026amp;=-1\\end{align*} $$\n复数的除法规定是乘法的逆运算，即把满足 $$ \\left ( c+di \\right )\\left ( x+yi \\right )=a+bi\\left ( c+di\\neq 0 \\right ) $$ 的复数$x+yi$，叫做复数$a+bi$除以复数$c+di$的商，记作 $$ \\left ( a+bi \\right )\\div \\left ( c+di \\right ) $$ 或 $$ \\frac{a+bi}{c+di} $$\n我们知道，两个共轭复数的积是一个实数，因此，两个复数相除，可以先把它们的商写成分式的形式，然后把分子与分母都乘以分母的共轭复数，并且把结果化简，即 $$ \\frac{a+bi}{c+di}=\\frac{\\left ( a+bi \\right )\\left ( c-di \\right )}{\\left ( c+di \\right )\\left ( c-di \\right )}=\\frac{\\left ( ac+bd \\right )+\\left ( bc-ad \\right )i}{c^{2}+d^{2}}=\\frac{ac+bd}{c^{2}+d^{2}}+\\frac{bc-ad}{c^{2}+d^{2}}i\\left ( c+di\\neq 0 \\right ) $$\n因为$c+di\\neq 0$，所以$c^{2}+d^{2}\\neq 0$。由此可见，商$\\frac{a+bi}{c+di}$是一个唯一确定的复数。\n例3：计算$\\left ( 1+2i \\right )\\div \\left ( 3-4i \\right )$。\n解：$\\left ( 1+2i \\right )\\div \\left ( 3-4i \\right )=\\frac{1+2i}{3-4i}=\\frac{\\left ( 1+2i \\right )\\left ( 3+4i \\right )}{\\left ( 3-4i \\right )\\left ( 3+4i \\right )}=\\frac{-5+10i}{25}=-\\frac{1}{5}+\\frac{1}{2}i$。\n三、复数的三角形式 3.1 复数的三角形式 我们知道，与复数$z=a+bi$对应的向量$\\overrightarrow{OZ}$（图9）的模$r$叫做这个复数的模，并且 $$ r=\\sqrt{a^{2}+b^{2}} $$\n复数的模\n以$x$轴的正半轴为始边、向量$\\overrightarrow{OZ}$所在的射线（起点是$O$）为终边的角$\\theta$，叫做复数$z=a+bi$的辐角。\n不等于零的复数$z=a+bi$的辐角有无限多个值，这些值相差$2\\pi$的整数倍。例如，复数$i$的辐角是$\\frac{\\pi}{2}+2k\\pi$，其中$k$可以取任何整数。\n适合于$0\\leq \\theta \u0026lt; 2\\pi$的辐角$\\theta$的值，叫做辐角的主值。记作$\\textrm{arg} z$，即$0\\leq \\textrm{arg} z \u0026lt; 2\\pi$。\n每一个不等于零的复数有唯一的模与辐角的主值，并且可由它的模与辐角的主值唯一确定。因此，两个非零复数相等当且仅当它们的模与辐角的主值分别相等。\n很明显，当$a\\in\\mathbf{R^{+}}$时，$$ \\textrm{arg}\\alpha=0 $$ $$ \\textrm{arg}\\left ( -\\alpha \\right )=\\pi $$ $$ \\textrm{arg}\\left ( ai \\right )=\\frac{\\pi}{2} $$ $$ \\textrm{arg}\\left ( -ai \\right )=\\frac{3\\pi}{2} $$ 如果$z=0$，那么与它对应的向量$\\overrightarrow{OZ}$缩成一个点（零向量），这样的向量的方向是任意的，所以复数$0$的辐角也是任意的。\n从图 9 可以看出： $$ \\begin{cases} a=r\\cos{\\theta}\\\\ b=r\\sin{\\theta} \\end{cases} $$ 因此 $$ a+bi=r\\cos{\\theta}+ir\\sin{\\theta}=r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $$ 其中 $$ r=\\sqrt{a^{2}+b^{2}},\\cos{\\theta}=\\frac{a}{r},\\sin{\\theta}=\\frac{b}{r} $$\n当与$z$对应的点$Z$不在实轴或虚轴上时，$z$的辐角$\\theta$的终边所在的象限就是点$Z$所在的象限；当点$Z$在实轴或虚轴上时，辐角$\\theta$的终边就是从原点$O$出发、经过点$Z$的板条坐标轴。\n因此我们可以说，任何一个复数$z=a+bi$都可以表示成$r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )$的形式。\n$$ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $$ 叫做复数$a+bi$的三角形式。为了同三角形式区别开来，$a+bi$叫做复数的代数形式。\n例1：把复数$\\sqrt{3}+i$表示成三角形式。\n解：$r=\\sqrt{3+1}=2,\\cos{\\theta}=\\frac{\\sqrt{3}}{2}.$因为与$\\sqrt{3}+i$对应的点在第一象限，所以$\\textrm{arg}\\left ( \\sqrt{3}+i \\right )=\\frac{\\pi}{6}$，于是$\\sqrt{3}+i=2\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right ).$\n例2：把复数$1-i$表示成三角形式。\n解：$r=\\sqrt{1+1}=\\sqrt{2},\\cos{\\theta}=\\frac{1}{\\sqrt{2}}=\\frac{\\sqrt{2}}{2}.$因为与$1-i$对应的点在第四象限，所以$\\textrm{arg}\\left ( 1-i \\right )=\\frac{7\\pi}{4}$，于是$1-i=\\sqrt{2}\\left ( \\cos{\\frac{7\\pi}{4}}+i\\sin{\\frac{7\\pi}{4}} \\right ).$\n例3：把复数$-1$表示成三角形式。\n解：$r=\\sqrt{1+0}=1.$因为与$-1$对应的点在$x$轴的负半轴上，所以$\\textrm{arg}\\left ( -1 \\right )=\\pi$，于是$-1=\\cos{\\pi}+i\\sin{\\pi}.$\n当然，把一个复数表示成三角形式时，辐角$\\theta$不一定要取主值。例如，$\\sqrt{2}\\left [ \\cos{\\left ( -\\frac{\\pi}{4} \\right )}+i\\sin{\\left ( -\\frac{\\pi}{4} \\right )} \\right ]$也是复数$1-i$的三角形式。\n3.2 复数的三角形式的运算 3.2.1 乘法与乘方 如果把复数$z_{1},z_{2}$分别写成三角形式 $$ z_{1}=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right ) $$ $$ z_{2}=r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right ) $$ 故有 $$ \\begin{align*} z_{1}\\cdot z_{2} \u0026amp;=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\\\ \u0026amp;=r_{1}r_{2}\\left [ \\left (\\cos{\\theta_{1}}\\cos{\\theta_{2}}-\\sin{\\theta_1}\\sin{\\theta_{2}} \\right ) + i\\left ( \\sin{\\theta_{1}}\\cos{\\theta_{2}}+\\cos{\\theta_{1}}\\sin{\\theta_{2}} \\right ) \\right ]\\\\ \u0026amp;=r_{1}r_{2}\\left [ \\cos{\\left (\\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}+\\theta_{2} \\right )} \\right ] \\end{align*} $$ 即 $$ r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )=r_{1}r_{2}\\left [ \\cos{\\left (\\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}+\\theta_{2} \\right )} \\right ] $$ 这就是说，两个复数相乘，积的模等于各复数的模的积，积的辐角等于各复数的辐角之和。\n据此，两个复数$z_{1},z_{2}$相乘时，可以先画出分别与$z_{1},z_{2}$对应的向量$\\overrightarrow{OP_{1}},\\overrightarrow{OP_{2}}$，然后把向量$\\overrightarrow{OP_{1}}$按逆时针方向旋转一个角度$\\theta_{2}$（如果$\\theta \u0026lt; 0$，就要把$\\overrightarrow{OP_{1}}$按顺时针方向旋转一个角度 $\\left | \\theta_{2} \\right |$ ），在把它的模变为原来的$r_{2}$倍，所得的向量$\\overrightarrow{OP}$，就表示积$z_{1}\\cdot z_{2}$（图 10）。这就是复数乘法的几何意义。\n复数乘法的几何意义\n用数学归纳法容易证明（读者自己证明），上面的结论可以推广到$n$个复数相乘的情况，就是：\n$$ \\begin{align*} z_{1}\\cdot z_{2}\\cdot\\cdots\\cdot z_{n} \u0026amp;=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\cdot\\cdots\\cdot r_{n}\\left ( \\cos{\\theta_{n}}+i\\sin{\\theta_{n}} \\right )\\\\ \u0026amp;=r_{1}r_{2}\\cdots r_{n}\\left [ \\cos{\\left ( \\theta_{1}+\\theta_{2}+\\cdots +\\theta_{n} \\right )} + i\\sin{\\left ( \\theta_{1}+\\theta_{2}+\\cdots +\\theta_{n} \\right )}\\right ] \\end{align*} $$\n因此，如果 $$ r_{1}=r_{2}=\\cdots=r_{n}=r,\\theta_{1}=\\theta_{2}=\\cdots=\\theta_{n}=\\theta $$ 时，就有 $$ \\left [ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )^n \\right ]=r^{n}\\left ( \\cos{n\\theta}+i\\sin{n\\theta} \\right )\\left ( n\\in\\mathbf{N} \\right ) $$\n这就是说，复数的$n\\left(n\\in\\mathbf{N}\\right)$次幂的模等于这个复数的模的$n$次幂，它的辐角等于这个复数的辐角的$n$倍。这个定理叫做棣莫佛2定理。\n例1：计算$\\sqrt{2}\\left ( \\cos{\\frac{\\pi}{12}}+i\\sin{\\frac{\\pi}{12}} \\right )\\cdot\\sqrt{3}\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right )$。\n解：$\\sqrt{2}\\left ( \\cos{\\frac{\\pi}{12}}+i\\sin{\\frac{\\pi}{12}} \\right )\\cdot\\sqrt{3}\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right )\\ =\\sqrt{6}\\left [ \\cos\\left ( \\frac{\\pi}{12}+\\frac{\\pi}{6} \\right )+i\\sin\\left ( \\frac{\\pi}{12}+\\frac{\\pi}{6} \\right ) \\right ]\\ =\\sqrt{6}\\left ( \\cos{\\frac{\\pi}{4}}+i\\sin{\\frac{\\pi}{4}} \\right )\\ =\\sqrt{6}\\left ( \\frac{\\sqrt{2}}{2}+\\frac{\\sqrt{2}}{2}i \\right )\\ =\\sqrt{3}+\\sqrt{3}i$。\n例2：计算$\\left ( \\sqrt{3}-i \\right )^{6}$。\n解：因为$\\sqrt{3}-i=2\\left ( \\cos{\\frac{11\\pi}{6}}+i\\sin{\\frac{11\\pi}{6}} \\right )$，所以$\\left (\\sqrt{3}-i \\right )^{6}\\ =\\left [2\\left ( \\cos{\\frac{11\\pi}{6}}+i\\sin{\\frac{11\\pi}{6}} \\right ) \\right ]^{6}\\ =2^{6}\\left ( \\cos{11\\pi}+i\\sin{11\\pi} \\right )\\ =64\\left ( \\cos{\\pi}+i\\sin{\\pi} \\right )\\ =64\\cdot\\left ( -1 \\right )=-64$。\n例3：如图11，向量$\\overrightarrow{OZ}$与复数$-1+i$对应，把$\\overrightarrow{OZ}$按逆时针方向旋转$120^\\circ$，得到$\\overrightarrow{OZ‘}$。求与向量$\\overrightarrow{OZ\u0026rsquo;}$对应的复数（用代数形式表示）。\n复数的旋转\n解：所求的复数就是$-1+i$乘以一个复数$z_{0}$的积，这个复数$z_{0}$的模是$1$，辐角的主值是$120^\\circ$。\n所以所求的复数是$(-1+i)\\cdot 1\\left ( \\cos{120^\\circ}+i\\sin{120^\\circ} \\right )\\ =(-1+i)\\left ( -\\frac{1}{2}+\\frac{\\sqrt{3}}{2}i \\right )\\ =\\frac{1-\\sqrt{3}}{2}-\\frac{1+\\sqrt{3}}{2}i$\n例4：如图 12，已知平面内并列的三个相等的正方形，利用复数证明\n$\\angle 1+\\angle 2+\\angle 3=\\frac{\\pi}{2}.$\n例 4 图例\n证明：如图建立坐标系（确定复平面），由于平行线的内错角相等，$\\angle 1,\\angle 2,\\angle 3$分别等于复数$1+i,2+i,3+i$的辐角的主值，这样$\\angle 1+\\angle 2+\\angle 3$就是积$\\left ( 1+i \\right )\\left ( 2+i \\right )\\left ( 3+i \\right )$的辐角，而 $$ \\left ( 1+i \\right )\\left ( 2+i \\right )\\left ( 3+i \\right )=10i $$ 其辐角的主值是$\\frac{\\pi}{2}$，并且$\\angle 1,\\angle 2,\\angle 3$都是锐角，于是 $$ 0\u0026lt;\\angle 1+\\angle 2+\\angle 3\u0026lt;\\frac{3\\pi}{2} $$ 所以 $$ \\angle 1+\\angle 2+\\angle 3=\\frac{\\pi}{2} $$\n3.2.2 除法 设$z_{1}=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right ),z_{2}=r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )$，且$z_{2}\\neq 0$。因为 $$ r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\cdot \\frac{r_{1}}{r_{2}}\\left [ \\cos{\\left (\\theta_{1}-\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}-\\theta_{2} \\right )} \\right ]=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right ) $$ 所以根据复数的除法的定义，有 $$ \\frac{r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )}{r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )}=\\frac{r_{1}}{r_{2}}\\left [ \\cos{\\left (\\theta_{1}-\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}-\\theta_{2} \\right )} \\right ] $$\n这就是说，两个复数相除，商的模等于被除数的模除以除数的模所得的商，商的辐角等于被除数的辐角减去除数的辐角所得的差。\n例5：计算$4\\left ( \\cos{\\frac{4\\pi}{3}}+i\\sin{\\frac{4\\pi}{3}} \\right )\\div 2\\left ( \\cos{\\frac{5\\pi}{6}}+i\\sin{\\frac{5\\pi}{6}} \\right )$。\n解：$4\\left ( \\cos{\\frac{4\\pi}{3}}+i\\sin{\\frac{4\\pi}{3}} \\right )\\div 2\\left ( \\cos{\\frac{5\\pi}{6}}+i\\sin{\\frac{5\\pi}{6}} \\right )\\ =\\frac{4\\left ( \\cos{\\frac{4\\pi}{3}}+i\\sin{\\frac{4\\pi}{3}} \\right )}{2\\left ( \\cos{\\frac{5\\pi}{6}}+i\\sin{\\frac{5\\pi}{6}} \\right )}\\ =2\\left [ \\cos{\\left ( \\frac{4\\pi}{3}-\\frac{5\\pi}{6} \\right )}+i\\sin{\\left ( \\frac{4\\pi}{3}-\\frac{5\\pi}{6} \\right )} \\right ]\\ =2\\left [ \\cos{\\frac{\\pi}{2}}+i\\sin{\\frac{\\pi}{2}} \\right ]=2\\left ( 0+i \\right )=2i$。\n3.2.3 开方 设$\\rho \\left ( \\cos{\\phi}+i\\sin{\\phi} \\right )$是复数$r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )$的$n\\left ( n\\in\\mathbf{N} \\right )$次方根，那么 $$ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )=\\left [ \\rho \\left ( \\cos{\\phi}+i\\sin{\\phi} \\right ) \\right ]^{n}=\\rho^{n} \\left ( \\cos{n\\phi}+i\\sin{n\\phi} \\right ) $$\n因为相等的复数，它们的模相等，辐角可以相差$2\\pi$的整数倍，所以 $$ \\begin{cases} \\rho^{n}=r\\\\ n\\phi=\\theta+2k\\pi\\left ( k\\in\\mathbf{Z} \\right ) \\end{cases} $$ 由此可知，$$ \\rho=\\sqrt[n]{r},\\phi=\\frac{\\theta+2k\\pi}{n} $$ 因此$r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )$的$n$次方根是 $$ \\sqrt[n]{r}\\left ( \\cos{\\frac{\\theta+2k\\pi}{n}} +i\\sin{\\frac{\\theta+2k\\pi}{n}}\\right ) $$\n当$k$取$0,1,\\cdots,n-1$各值时，就可以得到上式的$n$个值。由于正弦、余弦函数的周期都是$2\\pi$，当$k$取$n,n+1$以及其他各个整数值时，又重复出现$k$取$0,1,\\cdots,n-1$时的结果。所以复数$r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )$的$n$次方根3是 $$ \\sqrt[n]{r}\\left ( \\cos{\\frac{\\theta+2k\\pi}{n}} +i\\sin{\\frac{\\theta+2k\\pi}{n}}\\right )\\left ( k=0,1,\\cdots,n-1 \\right ) $$\n这就是说，复数的$n\\left ( n\\in\\mathbf{N} \\right )$次方根是$n$个复数，它们的模都等于这个复数的模的$n$次算术根，它们的辐角分别等于这个复数的辐角与$2\\pi$的$0,1,\\cdots,n-1$倍的和的$n$分之一。\n例6：求$1-i$的立方根。\n解：因为 $$ 1-i=\\sqrt{2}\\left ( \\cos{\\frac{7\\pi}{4}}+i\\sin{\\frac{7\\pi}{4}} \\right ) $$ 所以$1-i$的立方根是 $$ \\sqrt[6]{2}\\left ( \\cos{\\frac{\\frac{7\\pi}{4}+2k\\pi}{3}}+i\\sin{\\frac{\\frac{7\\pi}{4}+2k\\pi}{3}} \\right )=\\sqrt[6]{2}\\left ( \\cos{\\frac{7\\pi+8k\\pi}{12}}+i\\sin{\\frac{7\\pi+8k\\pi}{12}} \\right )\\left ( k=0,1,2 \\right ] $$ 即$1-i$的立方根是下面三个复数：$$ \\sqrt[6]{2}\\left ( \\cos{\\frac{7\\pi}{12}}+i\\sin{\\frac{7\\pi}{12}} \\right ) $$ $$ \\sqrt[6]{2}\\left ( \\cos{\\frac{5\\pi}{4}}+i\\sin{\\frac{5\\pi}{4}} \\right ) $$ $$ \\sqrt[6]{2}\\left ( \\cos{\\frac{23\\pi}{12}}+i\\sin{\\frac{23\\pi}{12}} \\right ) $$\n例7：设$a\\in\\mathbf{R^{+}}$，求$-a$的平方根。\n解：因为$-a=a\\left(\\cos{\\pi}+i\\sin{\\pi}\\right)$，所以$-a$的平方根是 $$ \\sqrt{a}\\left ( \\cos{\\frac{\\pi+2k\\pi}{2}}+i\\sin{\\frac{\\pi+2k\\pi}{2}} \\right )\\left ( k=0,1 \\right ) $$ 即$-a$的平方根是下面两个复数：$$ \\sqrt{a}\\left ( \\cos{\\frac{\\pi}{2}}+i\\sin{\\frac{\\pi}{2}} \\right ),\\sqrt{a}\\left ( \\cos{\\frac{3\\pi}{2}}+i\\sin{\\frac{3\\pi}{2}} \\right ) $$ 或 $$ \\sqrt{a}i,-\\sqrt{a}i $$\n从例7可以看到，$a\\in\\mathbf{R^{+}}$时，$-a$的平方根是$\\pm\\sqrt{a}i$。\n我们知道，对于实系数一元二次方程$ax^{2}+bx+c=0$，如果$b^{2}-4ac\u0026lt; 0$，那么它在实数集$\\mathbf{R}$中没有根。现在我们在复数集$\\mathbf{C}$中考察这种情况。经过变形，原方程可化为 $$ x^{2}+\\frac{b}{a}x=-\\frac{c}{a} $$ 所以 $$ x^{2}+2\\cdot x\\cdot \\frac{b}{2a}+\\left ( \\frac{b}{2a} \\right )^{2}=\\left ( \\frac{b}{2a} \\right )^{2}-\\frac{c}{a} $$ 进一步化简得 $$ \\left ( x+\\frac{b}{2a} \\right )^{2}=\\frac{b^{2}-4ac}{\\left ( 2a \\right )^2} $$ 即 $$ \\left ( x+\\frac{b}{2a} \\right )^{2}=-\\left [ \\frac{-\\left ( b^{2}-4ac \\right )}{\\left ( 2a \\right )^2} \\right ] $$\n由于$\\frac{-\\left ( b^{2}-4ac \\right )}{\\left ( 2a \\right )^2}\\in\\mathbf{R^{+}}$，根据例 7，我们得到 $$ x+\\frac{b}{2a}=\\frac{\\pm\\sqrt{\\left ( b^{2}-4ac \\right )}i}{2a} $$ 所以方程$ax^{2}+bx+c=0$在复数集$\\mathbf{C}$中有两个根 $$ x=\\frac{-b\\pm\\sqrt{-\\left ( b^{2}-4ac \\right )}i}{2a}\\left ( b^{2}-4ac\u0026lt; 0 \\right ) $$ 显然，它们是一对共轭复数。\n例8：在复数集$\\mathbf{C}$中解方程$x^{2}-4x+5=0$。\n解：因为$b^{2}-4ac=16-20=-4\u0026lt; 0$，所以$x=\\frac{4\\pm 2i}{2}=2\\pm i$。\n根据以前学过的一元二次方程的有关知识，我们知道，例8中方程左边的二次三项式$x^2-4x+5$在复数集$\\mathbf{C}$中就可以通过求根的方法分解成两个一次因式的积，即 $$ x^{2}-4x+5=\\left [ x-\\left ( 2+i \\right ) \\right ]\\left [ x-\\left ( 2-i \\right ) \\right ]=\\left ( x-2-i \\right )\\left ( x-2+i \\right ) $$ 形如$a_{n}x^{n}+a_{0}=0$（$a_{0},a_{n}\\in\\mathbf{C}$，且$a_{n}\\neq 0$）的方程叫做二项方程。任何一个二项方程都可以化成$x^{n}=b\\left(b\\in\\mathbf{C}\\right)$的形式，因此，都可以通过复数开方来求根。\n例9：在复数集$C$中解方程$x^{5}=32$。\n解：原方程就是 $$ x^{5}=32\\left ( \\cos{0}+i\\sin{0} \\right ) $$ 所以 $$ x=\\sqrt[5]{32}\\left ( \\cos{\\frac{0+2k\\pi}{5}}+i\\sin{\\frac{0+2k\\pi}{5}} \\right )\\ =2\\left [ \\cos{\\left ( k\\cdot\\frac{2\\pi}{5} \\right )}+i\\sin{\\left ( k\\cdot\\frac{2\\pi}{5} \\right )} \\right ]\\left ( k=0,1,2,3,4 \\right ) $$ 就是 $$ x_{1}=2\\left ( \\cos{0}+i\\sin{0} \\right )=2 $$ $$ x_{2}=2\\left ( \\cos{\\frac{2\\pi}{5}}+i\\sin{\\frac{2\\pi}{5}} \\right ) $$ $$ x_{3}=2\\left ( \\cos{\\frac{4\\pi}{5}}+i\\sin{\\frac{4\\pi}{5}} \\right ) $$ $$ x_{4}=2\\left ( \\cos{\\frac{6\\pi}{5}}+i\\sin{\\frac{6\\pi}{5}} \\right ) $$ $$ x_{5}=2\\left ( \\cos{\\frac{8\\pi}{5}}+i\\sin{\\frac{8\\pi}{5}} \\right ) $$\n这个方程的根的几何意义是复平面内的五个点，这些点均匀分布在以原点为圆心，以$2$为半径的圆上（圆13）。\n一般地，方程$x^{n}=b\\left(b\\in\\mathbf{C}\\right)$的根的几何意义是复平面内的$n$个点，这些点均匀分布在以原点为圆心，以 $\\sqrt[n]{\\left | b \\right |}$ 为半径的圆上。\n复数根式的几何意义\n*四、复数的指数形式 在科学技术，特别实在电工和无线电计算中，为了方便起见，还采用复数的另一种表示——复数的指数形式。\n我们把模为$1$，辐角为$\\theta$（以弧度为单位）的复数 $$ \\cos{\\theta}+i\\sin{\\theta} $$ 用记号$e^{i\\theta}$来表示，即4 $$ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $$ 例如， $$ e^{i\\frac{\\pi}{2}}=\\cos{\\frac{\\pi}{1}+i\\sin{\\frac{\\pi}{1}}}=i $$ $$ e^{i\\frac{\\pi}{3}}=\\cos{\\frac{\\pi}{3}+i\\sin{\\frac{\\pi}{3}}}=\\frac{1}{2}+\\frac{\\sqrt{3}}{2}i $$ 又如，$$ \\cos{\\frac{5\\pi}{6}}+i\\sin{\\frac{5\\pi}{6}} $$ 可以写成 $$ e^{i\\frac{5\\pi}{6}} $$ $$ \\frac{\\sqrt{2}}{2}+\\frac{\\sqrt{2}}{2}i=\\cos{\\frac{\\pi}{4}}+i\\sin{\\frac{\\pi}{4}} $$ 可以写成 $$ e^{i\\frac{\\theta}{4}} $$\n引入记号$e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta}$之后，任何一个复数 $$ z=r\\left(\\cos{\\theta}+i\\sin{\\theta}\\right) $$ 就可以表示成 $$ z=re^{i\\theta} $$ 的形式。我们把这一表达式叫做复数的指数形式。\n根据复数的指数形式的定义，我们有 $$ e^{i\\theta_{1}}\\cdot e^{i\\theta_{2}}\\ =\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\ =\\cos{\\left ( \\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left ( \\theta_{1}+\\theta_{2} \\right )}\\ =e^{i\\left ( \\theta_{1}+\\theta_{2} \\right )} $$ 即 $$ e^{i\\theta_{1}}\\cdot e^{i\\theta_{2}}=e^{i\\left ( \\theta_{1}+\\theta_{2} \\right )} $$\n同样可证 $$ \\left ( e^{i\\theta} \\right )^{n}=e^{in\\theta}\\left ( n\\in\\mathbf{N} \\right ) $$ $$ \\frac{e^{i\\theta_1}}{e^{i\\theta_{2}}}=e^{i\\left ( \\theta_{1}-\\theta_{2} \\right )} $$ 上述性质与我们过去学过的实数指数幂的性质一致，所以把复数从三角形式改写成指数形式后，可以运用实数集$\\mathbf{R}$中的幂运算律（注意：乘方的指数限于自然数）来进行运算。这里我们仿照实数集$\\mathbf{R}$中的说法，把$e^{i\\theta}$叫做以$e$为底、$i\\theta$为指数的幂。\n对于开方运算，复数$re^{i\\theta}$的$n\\left(n\\in\\mathbf{N}\\right)$次方根是 $$ \\sqrt[n]{r}e^{i\\frac{\\theta+2k\\pi}{n}}\\left ( k=0,1,\\cdots,n-1 \\right ) $$\n例1：把复数$z=2i$表示成指数形式。\n解：$z=2i=2\\left ( \\cos{\\frac{\\pi}{1}}+i\\sin{\\frac{\\pi}{2}} \\right )=2e^{i\\frac{\\pi}{2}}$。\n例2：把$\\sqrt{2}e^{-i\\frac{\\pi}{4}},\\sqrt{5}e^{i\\frac{2\\pi}{3}}$表示成三角形式及代数形式。\n解： $$ \\sqrt{2}e^{-i\\frac{\\pi}{4}}=\\sqrt{2}\\left [ \\cos\\left ( -\\frac{\\pi}{4} \\right )+i\\sin{\\frac{\\pi}{4}} \\right ]=1-i $$ $$ \\sqrt{5}e^{i\\frac{2\\pi}{3}}=\\sqrt{5}\\left [ \\cos\\left ( -\\frac{2\\pi}{3} \\right )+i\\sin{\\frac{2\\pi}{3}} \\right ]=-\\frac{\\sqrt{5}}{2}+\\frac{\\sqrt{15}}{2}i $$\n例3：用$e^{i\\theta}$与$e^{-i\\theta}$表示$\\cos{\\theta}$与$\\sin{\\theta}$。\n解：因为 $$ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $$ $$ e^{-i\\theta}=\\cos{\\left ( -\\theta \\right )}+i\\sin\\left ( -\\theta \\right )=\\cos{\\theta}-i\\sin{\\theta} $$ 因此 $$ \\cos{\\theta}=\\frac{e^{i\\theta}+e^{-i\\theta}}{2},\\quad \\sin{\\theta}=\\frac{e^{i\\theta}-e^{-i\\theta}}{2i} $$\n$\\mathbf{C}$是英文词组Complex numbers（复数）的第一个字母。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n棣莫佛（Abrabam de Moivre, 1667-1754年），法国数学家。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n采用这个符号时，一定要记住$\\sqrt[n]{z}$表示$n$个复数。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这里的$e=2.71828\\cdots$，就是自然对数的底数。这个公式叫做欧拉（Leonhard Euler，1707-1783年，瑞士数学家）公式。在“复变函数论”中可以证明这个公式。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2013-08-30T20:16:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/","title":"关于复数的一些补充"},{"content":"忠诚 2 是忠诚的一个提升版本。我们在之前的一篇文章线段树 – 无改动求解区间最值 – 忠诚简单的谈了一下关于无改动求解区间最值的问题。现在我们来研究一下有改动求解区间最值。\n首先，我们考虑改动某个值以后，对整棵树重新进行维护。但是很快我们发现，这样的复杂度太大。因为每次只更改一个值，所以只涉及到一条路径，因此我们考虑在递归修改数值的时候，可以标记一下经过的结点，修改完成以后，只对标记过的结点进行维护。这样我们的代码就出来了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int Update(Node *pNode) { if(pNode-\u0026gt;nLeft == pNode-\u0026gt;nRight || pNode-\u0026gt;nMoney != 2147483647) { return pNode-\u0026gt;nMoney; } else { return pNode-\u0026gt;nMoney = min(Update(pNode-\u0026gt;pLeft), Update(pNode-\u0026gt;pRight)); } } void Change(Node *pNode, int x, int nValue) { pNode-\u0026gt;nMoney = 2147483647; if(pNode-\u0026gt;nLeft == x \u0026amp;\u0026amp; x == pNode-\u0026gt;nRight) { pNode-\u0026gt;nMoney = nValue; } else { if(x \u0026lt;= (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { Change(pNode-\u0026gt;pLeft, x, nValue); } else { Change(pNode-\u0026gt;pRight, x, nValue); } } } 这样，除了第一次维护外，每次我们只需要维护一条路径，复杂度也大大降低低了。\n附上忠诚 2 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; Node *pRoot; int N, M, nTmp, T, L, R, ans; vector\u0026lt;int\u0026gt; pMoney; Node* Build(int l, int r); int Update(Node *pNode); void Change(Node *pNode, int x, int nValue); int Query(Node *pNode, int l, int r); int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; nTmp; pMoney.push_back(nTmp); } pRoot = Build(1, N); Update(pRoot); for(int i = 1; i \u0026lt;= M; i++) { cin \u0026gt;\u0026gt; T \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; if(T == 1) { ans = 2147483647; cout \u0026lt;\u0026lt; Query(pRoot, L, R) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } else { Change(pRoot, L, R); Update(pRoot); } } cout \u0026lt;\u0026lt; endl; return 0; } Node* Build(int l, int r) { Node *pNode = new Node(); if(l == r) { pNode-\u0026gt;nMoney = pMoney[l - 1]; } else { pNode-\u0026gt;nMoney = 2147483647; } pNode-\u0026gt;nLeft = l; pNode-\u0026gt;nRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u0026gt;pLeft = Build(l, nMid); pNode-\u0026gt;pRight = Build(nMid + 1, r); return pNode; } int Update(Node *pNode) { if(pNode-\u0026gt;nLeft == pNode-\u0026gt;nRight || pNode-\u0026gt;nMoney != 2147483647) { return pNode-\u0026gt;nMoney; } else { return pNode-\u0026gt;nMoney = min(Update(pNode-\u0026gt;pLeft), Update(pNode-\u0026gt;pRight)); } } void Change(Node *pNode, int x, int nValue) { pNode-\u0026gt;nMoney = 2147483647; if(pNode-\u0026gt;nLeft == x \u0026amp;\u0026amp; x == pNode-\u0026gt;nRight) { pNode-\u0026gt;nMoney = nValue; } else { if(x \u0026lt;= (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { Change(pNode-\u0026gt;pLeft, x, nValue); } else { Change(pNode-\u0026gt;pRight, x, nValue); } } } int Query(Node *pNode, int l, int r) { if(pNode-\u0026gt;nLeft == l \u0026amp;\u0026amp; r == pNode-\u0026gt;nRight) { return pNode-\u0026gt;nMoney; } else { if(r \u0026lt;= (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { return Query(pNode-\u0026gt;pLeft, l, r); } else if(l \u0026gt; (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { return Query(pNode-\u0026gt;pRight, l, r); } else { int nMid = (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2; return min(Query(pNode-\u0026gt;pLeft, l, nMid), Query(pNode-\u0026gt;pRight, nMid + 1, r)); } } } ","date":"2013-08-27T21:16:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%89%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A-2/","title":"线段树 – 有改动求解区间最值 – 忠诚 2"},{"content":"昨天研究了一下线段树，发现原来线段树有这么多实现方式。当然，对于非递归自底向上线段树，俗称 ZKW 线段树还是不太理解。而且我的实现方式还是用的指针，所以效率不是特别高。首先记录一下自己对于线段树的理解吧。我们用忠诚这道题目来做例子。\n线段树可以直观的表示为下面这张图：\n线段树示意图\n对于一个给定的区间，不断的二分，直到区间变为一个点为止。当然，平时我们所需要的线段树不是这么简陋的，我们需要一些数据域：\n1 2 3 4 5 6 struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; 有了节点的数据结构，我们需要构建这棵树，我们使用递归的方式生成这棵树，当然，在生成的过程中也可以进行一些初始化操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Node* Build(int l, int r) { Node *pNode = new Node(); // Init data if(l == r) { pNode-\u0026gt;nMoney = pMoney[l - 1]; } else { pNode-\u0026gt;nMoney = 0; } pNode-\u0026gt;nLeft = l; pNode-\u0026gt;nRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u0026gt;pLeft = Build(l, nMid); pNode-\u0026gt;pRight = Build(nMid + 1, r); return pNode; } 接下来就是线段树最核心的部分了，查找。查找的时候可能有三种情况：\n所需要查询的区间全部落在左儿子的区间中，递归左儿子。 所需要查询的区间全部落在右儿子的区间中，递归右儿子。 所需要查询的区间一部分在左儿子的区间中，另一部分在右儿子的区间中，递归左儿子，右儿子，根据需要进行一些操作，例如相加，取最大最小等。 实现部分如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int Query(Node *pNode, int l, int r) { if(pNode-\u0026gt;nLeft == l \u0026amp;\u0026amp; r == pNode-\u0026gt;nRight) { return pNode-\u0026gt;nMoney; } else { if(r \u0026lt;= (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { return Query(pNode-\u0026gt;pLeft, l, r); } else if(l \u0026gt; (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { return Query(pNode-\u0026gt;pRight, l, r); } else { int nMid = (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2; return min(Query(pNode-\u0026gt;pLeft, l, nMid), Query(pNode-\u0026gt;pRight, nMid + 1, r)); } } } 但是上面的代码要递归很久才返回数据，有很多的重复运算，这样在数据量很大的情况下非常不理想，所以我们需要进行一些优化。我们可以考虑提前把每个区间的最值求出来，因为原来只有点区间才有数据：\n1 2 3 4 5 6 7 8 9 int Update(Node *pNode) { if(pNode-\u0026gt;nLeft == pNode-\u0026gt;nRight) { return pNode-\u0026gt;nMoney; } else { return pNode-\u0026gt;nMoney = min(Update(pNode-\u0026gt;pLeft), Update(pNode-\u0026gt;pRight)); } } 这样，这棵线段树的效率就得到了很大的提高。\n附上忠诚代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; Node *pRoot; int N, M, nTmp, L, R, ans; vector\u0026lt;int\u0026gt; pMoney; Node* Build(int l, int r); int Update(Node *pNode); int Query(Node *pNode, int l, int r); int main() { ios::sync_with_stdio(false); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for(int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; nTmp; pMoney.push_back(nTmp); } pRoot = Build(1, N); Update(pRoot); for(int i = 1; i \u0026lt;= M; i++) { cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; ans = 2147483647; cout \u0026lt;\u0026lt; Query(pRoot, L, R) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } Node* Build(int l, int r) { Node *pNode = new Node(); if(l == r) { pNode-\u0026gt;nMoney = pMoney[l - 1]; } else { pNode-\u0026gt;nMoney = 0; } pNode-\u0026gt;nLeft = l; pNode-\u0026gt;nRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u0026gt;pLeft = Build(l, nMid); pNode-\u0026gt;pRight = Build(nMid + 1, r); return pNode; } int Update(Node *pNode) { if(pNode-\u0026gt;nLeft == pNode-\u0026gt;nRight) { return pNode-\u0026gt;nMoney; } else { return pNode-\u0026gt;nMoney = min(Update(pNode-\u0026gt;pLeft), Update(pNode-\u0026gt;pRight)); } } int Query(Node *pNode, int l, int r) { if(pNode-\u0026gt;nLeft == l \u0026amp;\u0026amp; r == pNode-\u0026gt;nRight) { return pNode-\u0026gt;nMoney; } else { if(r \u0026lt;= (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { return Query(pNode-\u0026gt;pLeft, l, r); } else if(l \u0026gt; (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2) { return Query(pNode-\u0026gt;pRight, l, r); } else { int nMid = (pNode-\u0026gt;nLeft + pNode-\u0026gt;nRight) / 2; return min(Query(pNode-\u0026gt;pLeft, l, nMid), Query(pNode-\u0026gt;pRight, nMid + 1, r)); } } } ","date":"2013-08-27T21:06:00+08:00","permalink":"https://ivy-end.github.io/p/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%97%A0%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A/","title":"线段树 – 无改动求解区间最值 – 忠诚"},{"content":"题目是经典的采药问题。也是最基础的 0/1 背包问题。\n我们约定有$N$件物品和一个容量为$C$的背包。第$i$件物品的重量是$w\\left [ i \\right ]$，价值是$v\\left [ i \\right ]$。这样，我们所需要求解将哪些物品装入背包可使价值总和最大。\n二维数组表示 定义状态：$f\\left [ i \\right ]\\left [ c \\right ]$表示前$i$件物品恰放入一个容量为$c$的背包可以获得的最大价值。\n状态转移方程：$f\\left [ i \\right ]\\left [ c \\right ]=\\max\\left \\{ f\\left [ i-1 \\right ]\\left [ c \\right ],f\\left [i-1 \\right ]\\left [ c-w\\left [ i \\right ] \\right ] +v\\left [ i \\right ]\\right \\}$\n代码模版：\n1 2 3 4 5 6 7 8 9 for(int i = 1; i \u0026lt;= N; i++) { for(int c = 0; c \u0026lt;= C; c++) { f[i][c] = f[i - 1][c]; if(c \u0026gt;= w[i]) { f[i][c] = max(f[i][c], f[i - 1][c - w[i]] + v[i]); } } } 时间复杂度、空间复杂度：$O\\left ( NC \\right )$\n一维数组表示 定义状态：由于$i$基本没有什么用处，所以我们把它省略。\n状态转移方程：$f\\left [ c \\right ]=\\max\\left \\{ f\\left [ c \\right ],f\\left [ c-w\\left [ i \\right ] \\right ] +v\\left [ i \\right ]\\right \\}$需要注意的是，这时候，我们需要将$c$从$C$开始，倒着推。\n代码模版：\n1 2 3 4 5 6 7 8 for(int i = 1; i \u0026lt;= N; i++) { for(int c = C; C \u0026gt;= 0; C--) { if(c \u0026gt;= w[i]) { f[c] = max(f[c], f[c - w[i]] + v[i]); } } } 时间复杂度：$O\\left ( NC \\right )$\n空间复杂度：$O\\left ( C \\right )$\n一维数组表示下的常数优化 内层循环的下限不需要为 0。\n代码模版：\n1 2 3 4 5 6 7 8 9 10 11 int bound, sumw = 0; for(int i = 1; i \u0026lt;= N; i++) { sumw += w[i]; bound = max(C - sumw, w[i]); for(int c = C; C \u0026gt;= bound; C--) { if(c \u0026gt;= w[i]) { f[c] = max(f[c], f[c - w[i]] + v[i]); } } } 初始化的细节：\n若要求“恰好装满”：$f\\left [ 0 \\right ]=0$，其他$f\\left [ i \\right ]=\\textrm{-INF}$。 若不用“恰好装满”：$f\\left [ 0 \\right ]=0$。 最后附上 NOIP2005P3 的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int MAX = 1024; int C, N; int pC[MAX], pW[MAX], f[MAX]; int main() { cin \u0026gt;\u0026gt; C \u0026gt;\u0026gt; N; for(int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; pC[i] \u0026gt;\u0026gt; pW[i]; } memset(f, 0, sizeof(f)); for(int i = 0; i \u0026lt; N; i++) { for(int j = C; j \u0026gt;= pC[i]; j--) { f[j] = max(f[j], f[j - pC[i]] + pW[i]); } } cout \u0026lt;\u0026lt; f[C] \u0026lt;\u0026lt; endl; return 0; } ","date":"2013-08-23T09:03:00+08:00","permalink":"https://ivy-end.github.io/p/0/1-%E8%83%8C%E5%8C%85-noip2005p3/","title":"0/1 背包 - NOIP2005P3"},{"content":"一个暑假很快就过去了，还有一个多星期就要高三了。回顾这个暑假，总感觉比之前任何一个暑假都要充实，这种感觉就如同大块朵颐后的欣悦。简略的说几类事情吧，希望这次不会沉到草稿箱里。\n学习 大部分时间都在学校参加数学竞赛辅导。上午自习，下午讲课，最近加入了晚自习。 去扬州进行了为期十天的培训，留下了一篇游记。本来想把课上的讲义发上来的，但是没时间编辑，就一拖再拖。 读完了《博弈论导论》，并初步的学习了一下博弈论。 读完了《看见》，没来得及写下读书笔记。 坚持每天做英语阅读，有来不及的次日补上。 开始刷数学、物理的自主招生题目。 制订了阅读英文书籍的计划。 翻译了一篇论文：Methods of Computing Square Roots。 研究了一大堆闻所未闻的定理。 组织了一次 NOIP 模拟赛，取得了较好的效果。 进一步深入学习了数论，动态规划，树，图论，为 NOIP 2013 奠定基础。 学习使用 LaTeX 编辑文章，制作了一份 2012 年数学初赛试题的集锦，并在扬州坚持每天做一份。 学习使用 git 托管项目。 学习 Qt，并独立写出了第一个 IDE：Light-Cpp。有望参加明年的程序设计比赛。 加入了 Smart Online Judge 开发团队，进行网页的后台开发。 优化了博客的 UI，提高了用户体验质量。 娱乐 为了解决我们中午吃何种外卖，哪些人去拿的难题，制作了人员随机系统。 成功在 Ubuntu 系统下实现 GoAgent 翻墙。 学习了通过 PhotoShop 制作移轴摄影的特效。 新增了若干友链。 将博客的文章整理成书，并通过 LaTeX 编辑。 资金 通过写程序，赚到了真正意义上的第一桶金。这个暑假收入共计 1800。 琐事 有一天在学校上课，正好乘电梯回教室。巧遇周红娟，她兴高采烈的拉住我，和我唠嗑。大概讲了这些事情：\n她下学期要去她老家那边支教，不教我们了； 她老公在篮球队当总教练，今天她来看比赛，顺便收拾东西； 不说也罢，影响不好。 对于周红娟，虽然只教了我一年，但是感觉特别亲切，可能由于电教员经常和她接触吧。过一阵子写篇文章，聊表纪念吧。\n感悟 假作真来真亦假，无为有处有还无。 其实有时候忙碌的生活未必有想象中那么痛苦，反而可以从中找到很多乐趣。发现以前从未发现的风景。 高三 一切都会好起来的。\n","date":"2013-08-22T21:15:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/","title":"暑假小结"},{"content":"题目是经典的导弹拦截。第一问很有信心的写下了最长非增序列。第二问就懵了。后来看了题解，有一个“Dilworth 定理”，现在将定理的表述和证明整理如下：\n这是一个关于偏序集的定理。偏序集即偏序集合。\n偏序的概念：设$\\textbf{A}$是一个非空集合。$P$是$\\textbf{A}$上的一个关系，若关系$P$是自反的、反对称的、传递的，则称$P$是集合$\\textbf{A}$上的偏序关系。\n即$P$满足下列条件：\n$\\forall a\\in\\textbf{A},\\left ( a,a \\right )\\in P$； 若$\\left ( a,b \\right )\\in P,\\left ( b,a \\right )\\in P$，则$a=b$； 若$\\left ( a,b \\right )\\in P,\\left ( b,c \\right )\\in P$，则$\\left ( a,c \\right )\\in P$。 我们用$a\\leq b$表示$\\left ( a,b \\right )\\in P$。 注：“$\\leq$”只是符号，不代表不等关系。\n例如，$\\left ( \\textbf{A},\\leq \\right )$是一个偏序集，我们定义$A=\\left \\{ 1,2,3 \\right \\}$，偏序$\\leq$在$\\textbf{A}$上表现为大于等于关系，则有：$\\leq =\\left \\{ \\left \\langle 3,3 \\right \\rangle,\\left \\langle 3,2 \\right \\rangle,\\left \\langle 3,1 \\right \\rangle\\left \\langle 2,2 \\right \\rangle,\\left \\langle 2,1 \\right \\rangle,\\left \\langle 1,1 \\right \\rangle \\right \\}$。\n我们再来通过下面几个例子进一步了解偏序集：\n实数集上的小于等于关系是一个偏序关系。 设$\\textbf{S}$是集合，$P\\left(\\textbf{A}\\right)$是$\\textbf{S}$的所有子集构成的集合，定义$P\\left(\\textbf{A}\\right)$中两个元素$\\textbf{A}\\leq \\textbf{B}$当且仅当$\\textbf{A}$是$\\textbf{B}$的子集，则$P\\left(\\textbf{A}\\right)$在这个关系下成为偏序集。 设$\\textbf{N}$是正整数集，定义$m\\leq n$当且仅当$m$能整除$n$，不难验证这是一个偏序关系。 在偏序集中，有一个非常著名的定理，叫做“Dilworth 定理”。在介绍这个定理之前，我们需要介绍几个术语：\n令$\\left ( \\textbf{A},\\leq \\right )$是一个偏序集，对于集合中的两个元素$a,b$，如果有$a\\leq b$或者$b\\leq a$，则称$a$和$b$是可比的，否则$a$和$b$不可比。\n例：$\\left ( \\textbf{A},\\leq \\right )$是偏序集，其中$\\textbf{A}=\\left \\{ 1,2,3,4,5 \\right \\}$，其中$\\leq$是整除关系，那么对任意的$x\\in P$都有$1\\leq x$,所以$1$和$1,2,3,4,5$都是可比的，但是$2$不能整除$3$，且$3$不能整除$2$，所以$2$和$3$是不可比的。\n在X中，对于元素$a$，如果任意元素$b$，由$b\\leq a$得出$b=a$，则称$a$为极小元。\n一个反链$\\textbf{A}$是$\\textbf{X}$的一个子集，它的任意两个元素都不能进行比较。 一个链$\\textbf{C}$是$\\textbf{X}$的一个子集，它的任意两个元素都可比。\n定理1：令$\\left ( \\textbf{A},\\leq \\right )$是一个有限偏序集，并令$r$是其最大链的大小。则$\\textbf{X}$可以被划分成$r$个但不能再少的反链。\n定理2（Dilworth 定理）：令$\\left ( \\textbf{A},\\leq \\right )$是一个有限偏序集，并令$m$是反链的最大的大小。则$\\textbf{X}$可以被划分成$m$个但不能再少的链。\n证明：这里只对定理1进行证明，定理2的证明留给读者自行证明。 设$p$为最少反链个数；\n先证明$\\textbf{X}$不能划分成小于$r$个反链。由于$r$是最大链$\\textbf{C}$的大小，$\\textbf{C}$中任两个元素都可比，因此$\\textbf{C}$中任两个元素都不能属于同一反链。所以$p\\geq r$。 设$\\mathbf{X_{1}}=\\mathbf{X}$，$\\mathbf{A_{1}}$是$\\mathbf{X_{1}}$中的极小元的集合。从$\\mathbf{X_{1}}$中删除$\\mathbf{A_{1}}$得到$\\mathbf{X_{2}}$。注意到对于$\\mathbf{X_{2}}$中任意元素$a_{2}$，必存在$\\mathbf{X_{1}}$中的元素$a_{2}$，使得$a_{1}\\leq a_{1}$。令$\\mathbf{A_{2}}$是$\\mathbf{X_{2}}$中极小元的集合，从$\\mathbf{X_{2}}$中删除$\\mathbf{A_{2}}$得到$\\mathbf{X_{3}}$……最终，会有一个$\\mathbf{X_{k}}$非空而$\\mathbf{X_{k+1}}$为空。于是$\\mathbf{A_{1}},\\mathbf{A_{2}},\\cdots ,\\mathbf{A_{k}}$就是$\\mathbf{x}$的反链的划分，同时存在链$a_{1}\\leq a_{2}\\leq\\cdots\\leq a_{k}$，其中$a_{i}$在$\\mathbf{A_{i}}$内。由于$r$是最长链大小，因此$r\\geq k$。由于$\\mathbf{x}$被划分成了$k$个反链，因此$r=k\\geq p$。因此$r=p$，得证。 那么这道题目就化简为求一遍最长非增序列和最长上升序列，DP 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAX = 128; int N, f1[MAX], f2[MAX], ans1, ans2; vector\u0026lt;int\u0026gt; pVec; int main() { cin \u0026gt;\u0026gt; N; int nTmp; for(int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; nTmp; pVec.push_back(nTmp); } for(int i = 0; i \u0026lt; pVec.size(); i++) { f1[i] = f2[i] = 1; } for(int i = 1; i \u0026lt; pVec.size(); i++) { for(int j = 0; j \u0026lt; i; j++) { if(pVec[j] \u0026gt;= pVec[i] \u0026amp;\u0026amp; f1[j] + 1 \u0026gt; f1[i]) { f1[i] = f1[j] + 1; } if(pVec[j] \u0026lt; pVec[i] \u0026amp;\u0026amp; f2[j] + 1 \u0026gt; f2[i]) { f2[i] = f2[j] + 1; } } } ans1 = 0; ans2 = 0; for(int i = 0; i \u0026lt; pVec.size(); i++) { if(f1[i] \u0026gt; ans1) { ans1 = f1[i]; } if(f2[i] \u0026gt; ans2) { ans2 = f2[i]; } } cout \u0026lt;\u0026lt; ans1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; ans2 \u0026lt;\u0026lt; endl; return 0; } ","date":"2013-08-22T16:32:00+08:00","permalink":"https://ivy-end.github.io/p/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/","title":"Dilworth 定理 - NOIP1999T1"},{"content":"题目描述是经典的蛇形填数问题。\n以前解决这类问题，通常是通过控制$i,j$的值来定位数组元素的位置，然后进行赋值。但是这种方法非常的繁琐，且难于理解。容易出错。\n今天在做这道题目的时候，通过搜索资料，思索出了一种新解法，相较于原来的解法更以理解，且时间复杂度更低。解法的基本思想是 BFS。下面我们仔细来探讨一下。\n首先我们定义一组偏移量数组：\n1 2 const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 }; 这个数组的顺序必须和填数的顺序一致。在这里，它被定义为逆时针填数。\n然后我们需要设置 BFS 的起点：\n1 2 x = 1; y = N; i = 0; f[x][y] = nNum++; 其中，$x,y$用来保存当前坐标，$i$则是保存当前偏移量的数组下标。$f\\left [ x \\right ]\\left [ y \\right ]$表示需要填充的矩阵，$nNum$则是所需要填的数。\n我们来简单的模拟以下，假设现在坐标为$\\left ( 1,n \\right )$，偏移量下标$i=0$。首先尝试向右扩展标$\\left ( 1,n+1 \\right )$，不合法，于是返回到坐标$\\left ( 1,n \\right )$再先下扩展，检测合法后，进行填充，当填充到最下端时，又不合法，这样，返回到坐标$\\left ( n,n \\right )$后向左扩展，同理，填充到最左端后又会向上扩展，这里还需要检测当前扩展结点是否已经填数。如果已经填数，则不合法，需要返回上一个坐标。\n这样我们模拟一遍 BFS 就可以知道，这种解法是正确的，所以这里略过证明。\n基本代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory.h\u0026gt; using namespace std; const int MAX = 16; const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 }; int x, y, i, nNum = 1; int N, f[MAX][MAX]; int main() { memset(f, 0, sizeof(f)); cin \u0026gt;\u0026gt; N; x = 1; y = N; i = 0; f[x][y] = nNum++; while(nNum \u0026lt;= N * N) { x += dx[i]; y += dy[i]; if(x \u0026gt;= 1 \u0026amp;\u0026amp; x \u0026lt;= N \u0026amp;\u0026amp; y \u0026gt;= 1 \u0026amp;\u0026amp; y \u0026lt;= N \u0026amp;\u0026amp; f[x][y] == 0) { f[x][y] = nNum++; } else { x -= dx[i]; y -= dy[i]; i = (i + 1) % 4; } } for(int i = 1; i \u0026lt;= N; i++) { for(int j = 1; j \u0026lt;= N; j++) { if(N * N \u0026gt; 99 \u0026amp;\u0026amp; f[i][j] \u0026lt; 100) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } if(N * N \u0026gt; 9 \u0026amp;\u0026amp; f[i][j] \u0026lt; 10) { cout \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; f[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } ","date":"2013-08-22T10:36:00+08:00","permalink":"https://ivy-end.github.io/p/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/","title":"BFS 解决蛇形填数 - NOIP1995P2"},{"content":"今天同学聚会，感慨颇多。彼此分别已有两年，有些人还是像以前一样，有些人却已很难辨认。不禁喟叹「时间」的伟大。还是简单的提一下今天聚会的事情吧。\n最令我意外的，是虞永春老师。没想到时隔三四年他还记得那次我踢球撞破眼睑去医院缝了好几针。一见面直接就问，上次缝针的那里还看得出吗。还有就是以前宿舍里的兄弟们，大家还是这么亲近，随意的开玩笑，嬉戏打闹，感觉很好。还有小伙伴们，我想死你们了！有些话无须多言，好兄弟们！\n下面讲讲最近发生的一些事情吧，太零碎，将就着看吧。\n有评价说我现在的博客学术味太浓厚，我也不知道该如何回复他，只是报以尴尬的笑。想来放暑假已经有一个月了，却感觉这个暑假充实无比，基本每天都会做做《英语5·3》，刷上一两张数学试卷。说实话，对于这种生活挺期待，也挺喜欢。因为在某些时候我的自制力的确很差。以至于最近不太想写一些文字记录生活，而是写一大堆关于数竞的文章。其实本来写了好几篇，只是大多写了一半就写不下去了，于是只好保存为草稿，最后不了了之。\n我记得刚开始申请域名，搭建博客的时候，我的目的仅仅是将这个博客作为生活的一个备份，而不是一大堆关于学术的文章。显然，近阶段我没有做好这一点。不过回过头来想一想，这些学术的内容也是生活的一部分，作为生活的备份也无可厚非。实质原因则是不想写一些回忆性的文字，所以只好发一些学术方面的文章，免得博客变成一潭死水。\n足球赛，上午在四十摄氏度的高温下，踢一个多小时，下午我们有时候提早放学，继续踢一会儿，感觉非常舒服。踢完以后整个人什么都不想做。但是后来物理组还是被王惠峰发现了。\n每天数学课都是做题目，讲题目，期间接触了许多很有趣的题目，比如海盗船长分金币的题目。\n这个暑假终于写出了像样的程序，卖出了像样的价格。还是很兴奋的。\n这次就到这吧，有点急事，仓促停笔。\n","date":"2013-08-09T21:22:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%9D%82%E8%AE%B020130809/","title":"杂记（20130809）"},{"content":"注：这篇文章在草稿箱里沉睡了许久，现在勉强将其写完，可能有所遗漏。\n7月15日至7月24日去扬州参加了数学夏令营。现在将沿途一些所见所闻所感记录于此。这几天的经历可以用一句话来概括「生活单调的像巴甫洛夫的狗，日子凄惨的如薛定谔的猫。」\n7月15日中午我们乘坐大巴从学校赶往扬州。当大巴驶在宽阔的长江大桥上，我被长江的宽阔与雄壮所折服。从杨舍到扬州有将近2小时45分钟的车程。去的路上大家都很激动，不断的拍照直播。\n我们入住的宾馆叫做辰源宾馆，双人间，自由组合，我便和陈力江住在了一起。刚进入房间，一股恶臭扑面而来，打电话给总台叫人来处理，他却说这里的下水道本来就堵住的，没办法。还说的振振有词。打开电视机，不是看不清就是没声音。在床上躺了一会儿，就去吃晚饭了。晚饭自然是张伟新请客的，就在宾馆的对面——三道菜。那边的菜都有点辣，而且很多菜都长一个样。不得不说他们店里的招牌冷饮——酸梅汤。免费而且无限续杯，口感的确不错。\n当天晚上是开班会，我们一个班将近两百多人。班主任自称扬州大学大三学生，自我介绍时说，“我会成为你们既恨又爱的班主任之一”。这句话的前半部分很快就得到了验证，他要核对身份证信息，还要关注一些注意点。但是他只会串行运行，不会并行处理。在他让我们核对身份证期间，居然干巴巴在上面站着，一句话也不说。好不容易核对好了，开始讲一些注意事项。居然重复了五六遍！每次讲完都说“我再强调一遍”，导致最后直接有学生拍桌子起哄。最后处理了一下座位的问题，初步定为抢座位。对了，补充一句，一开始只有我们学校住在外面宾馆，其他学校一律住的宿舍，所以他们有晚自习，我们没有。\n班会结束后从大教室走出来，天上早已繁星点点。由于那个老师拖了很久，大家心情本来就不怎么好。又遇到蛮横的门卫，差点起了争执。最后还是打通了张伟新的电话才放我们出校门。相比较而言，其实我们这里的门卫一点都不凶。\n对于门卫的做法，或许他是为了学校和学生的安全考虑，但是那天晚上他所表现出来的行为实在是令人大跌眼镜，一副气势汹汹，妄图吓住我们的样子。这种表现让我有种「扬州人都是这种样子。」的感觉。当然，我们学校也有人在趁门卫拦截别人时走了出来，虽然有违规矩，但在这种背景下却也无可厚非。只是觉得门卫实在没有必要到如此地步。\n回到宾馆洗漱，整理，大家说明天早点起来去抢位置。我们第一天6点起床，顺利的抢到了第一排。当我们到教室的时候只有7点，8点上课。那个班主任还在睡觉。他就这样被我们吵醒了去开门。结果开了门说，我们以后排座位吧，要考虑到别人的休息。\n对于这件事情，班主任为排座位找到了一个非常冠冕堂皇的理由，我们要考虑到住在校外的学生（也就是指我们，但是我们抢到了第一排），这个理由显然是行不通的。感觉这个班主任办事能力太差劲，而且找理由却一点都不让人信服。而不像某些老师，即使你知道他是在找理由，但却心甘情愿跟着他做。\n讲函数的老师是个佛教徒。上课讲的一些禅语倒是很值得推敲。\n因空见色，由色生情，传情入色，自色悟空。\n首先，佛学中的「色」和道家中的「道」有异曲同工之妙，皆是指天地万物。这几句话在《石头记》中也有出现过，是空空道人所说。结合《好了歌》，我们可以这样理解这几句话：从「无」了解表象，接着从表象懂得人间的感情和苦恼，然后从中解脱，懂得此皆因表象而起，最后懂得外物表象终究是「无」。从人情方面理解，这几句话的意思和老子的「超然出世」并无太大区别。从学术上理解，则表示了从无知到理解到运用自如的过程，而最高境界，则是「无招胜又招」。\n一个讲排列组合的老师叫刘凯峰。他给我们讲了两个自身的故事。应该算是在警醒我们吧。「我们那时候学习压力几乎没有，初三的时候我们班的男生还在玩水枪。我当时胆子小，所以没和他们一起玩。结果就我考上了高中。」「我在高考前几天还在研究三等分角，结果高考考了个师范。」毕竟，竞赛仅仅是磨练意志和开拓眼界的。真正属于我们的舞台，还是高考。\n他还讲了一些他以前出过的一些高考题，还讲了一道数列题，他说是用来准备作为2013年高考附加题最后一题的。但是命题组换了人，所以没叫他去。那道题目相当难，除了第一问可以猜出答案，第二问的证明根本不会。而他也洋洋自得的说，第二问的证明不仅要用到螺旋归纳法，还要如何如何。而且很大气的说，这道题目就没准备让你们拿分，除了第一问有个别人可以猜出答案。\n最后一天讲平面几何的老师讲课方式非常奇特。偌大的教室，有投影不用，偏偏用黑板。说话听不清，黑板看不清，而且讲题目喜欢只讲一半。以至于他讲的调和点列似懂非懂，谁知道第二天就考到了调和点列和梅涅劳斯定理综合的平几题。\n上课基本就是这样。接下来讲讲课余生活吧，应该算不上太丰富。每天早上7点起床，中午12点休息一会，然后午睡到2点半。晚上6点下课，吃完晚饭买杯奶茶，接着大家串门娱乐。玩到8点左右开始做题目。\n某天晚上大家守着信号极差的有线电视，好不容易调到一个清晰的频道，中国好声音，居然还没有声音。\n期间大家商量了准备去瘦西湖玩的，可惜有人夜探瘦西湖带回来的消息是：瘦西湖没有夜游，于是只能作罢。本来我们还想像周红娟一样，去瘦西湖上撑一支竹篙，在星辉斑斓里放歌。\n比较有印象的应该是那天足球赛，中国队VS日本队。一大群男生在一个房间里看球赛。张伟新来查房，还以为我们在做什么不法勾当。\n还有不得不提的一件事情，就是宾馆的隔音效果。中午睡觉，楼上一位大妈在打电话，声音非常大，时不时发出恐怖的大笑声。搞得一个中午没睡觉。晚上，本来快睡着了，隔壁传来一阵电视机的声音。\n某天中午，我们准备去大润发逛逛，人生地不熟，遂向一报亭老人问路，他说直走右拐再直走，跑半分钟就到了。结果我们走了十多分钟才看见。回酒店的路上顺便逛了一下酒店后面的所谓步行街，感觉非常的冷清，而且有点邋遢。\n最后一天，那个班主任说下午提前40分钟到，要发准考证。谁知我们到了，他还没到。\n复赛，有一道题目上课讲过类似的方法，但是考完后还是感觉很虚。但有80%的通过率也放下了心。自己在知识的海洋面前，实在是非常的渺小。\n我还像以前一样疯狂的热爱数学！\n","date":"2013-08-01T18:57:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E9%9B%B6/","title":"扬州拾遗（零）"},{"content":"一、函数问题基本方法 1. 数型结合法 例1：求方程 $ \\left | x-1\\right |=\\frac{1}{x} $ 的正根的个数。\n解：作图像得，正根个数为 $ 1 $ 。\n例2：求函数 $ f\\left(x\\right)=\\sqrt{x^{4}-3x^{2}-6x+13}-\\sqrt{x^{4}-x^{2}+1} $ 的最大值。\n解： $ f\\left(x\\right)=\\sqrt{\\left(x^{2}-2\\right)^{2}+\\left(x-3\\right)^{2}}-\\sqrt{\\left(x^{2}-1\\right)^{2}+x^{2}} $ 即表示点 $ P\\left(x,x^{2}\\right) $ 到点 $ A\\left(3,2\\right),B\\left(0,1\\right) $ 的距离之差，点 $ P $ 在抛物线 $ y=x^{2} $ 上。\n易得点 $ P $ 在直线 $ l_{AB}:x-3y+3=0 $ 上，因此得到 $ P\\left(\\frac{1-\\sqrt{37}}{6},\\frac{19-\\sqrt{37}}{18}\\right) $ ，故 $$ \\begin{align*} f\\left(x\\right)_{max} \u0026amp;=\\sqrt{\\left[\\left(\\frac{1-\\sqrt{37}}{6}-3\\right)^{2}+\\left(\\frac{19-\\sqrt{37}}{18}-2\\right)^{2}\\right]-\\left[\\left(\\frac{1-\\sqrt{37}}{6}\\right)^{2}+\\left(\\frac{19-\\sqrt{37}}{18}-1\\right)^{2}\\right]} \\\\ \u0026amp;=\\frac{2\\sqrt{245+34\\sqrt{37}}}{9} \\end{align*}$$\n2. 函数性质的应用 例3：设 $ x,y\\in\\mathbf{R} $ ，且满足 $ \\begin{cases} \\left ( x-1 \\right )^{3}+1997\\left ( x-1 \\right )=-1\\\\ \\left ( y-1 \\right )^{3}+1997\\left ( y-1 \\right )=1 \\end{cases} $ ，求 $ x+y $ 。\n解：考虑函数 $ f\\left(s\\right)=s^{3}+1997s $ ，该函数既是奇函数又是增函数。又 $ f\\left(x-1\\right)=-f\\left(y-1\\right) $ ，得 $ \\left(x-1\\right)+\\left(y-1\\right)=0 $ ，因此 $ x+y=2 $ 。\n例4：奇函数 $ f\\left(x\\right) $ 在定义域 $ \\left(-1,1\\right) $ 内是减函数，又 $ f\\left(1-a\\right)+f\\left(1-a^{2}\\right)\u0026lt;0 $ ，求 $ a $ 的取值范围。\n解：首先由函数的定义域得 $ \\begin{cases} -1\u0026lt;1-a\u0026lt;1\\\\ -1\u0026lt;1-a^{2}\u0026lt;1 \\end{cases} $ ，解得 $ 0\u0026lt; a\u0026lt; \\sqrt{2} $ 。下面进行分类讨论：\n$ 1^{\\circ} \\left | 1-a \\right |\u0026lt; 1-a^{2}\\Rightarrow 0\u0026lt; a\u0026lt; 1 $\n$ 2^{\\circ}\\left | 1-a^{2} \\right |\u0026lt; 1-a\\Rightarrow -2\u0026lt; a\u0026lt; 0 $ （不符题意）。\n综上所述， $ a\\in\\left ( 0,1 \\right ) $ 。\n例5：设 $ f\\left(x\\right) $ 是定义在 $ \\left(-\\infty,+\\infty\\right) $ 上以 $ 2 $ 为周期的函数，对 $ k\\in\\mathbf{Z} $ ，用 $ I_{k} $ 表示区间 $ \\left(2k-1,2k+1\\right] $ ，已知当 $ x\\in I_{0} $ 时， $ f\\left(x\\right)=x^{2} $ ，求 $ f\\left(x\\right) $ 在 $ I_{k} $ 上的解析式。\n解：根据图像的平移，易得 $ f\\left(x\\right)=\\left(x-2k\\right)^{2} $ 。\n例6：解方程 $$ \\left(3x-1\\right)\\left(\\sqrt{9x^{2}-6x+5}+1\\right)+\\left ( 2x-3 \\right )\\left ( \\sqrt{4x^{2}-12x+13}+1 \\right )=0 $$\n解：首先进行因式分解： $$ \\left(3x-1\\right)\\left(\\sqrt{\\left ( 3x-1 \\right )^{2}+4}+1\\right)+\\left ( 2x-3 \\right )\\left ( \\sqrt{\\left ( 2x-3 \\right )^{2}+4}+1 \\right )=0 $$ 考察函数 $$ f\\left ( s \\right )=s\\left ( \\sqrt{s^{2}+4}+1 \\right ) $$ 它既是奇函数又是增函数。因此上述方程转化为 $$ \\left ( 3x-1 \\right )+\\left ( 2x-3 \\right )=0 $$ 解得 $ x=\\frac{4}{5} $ 。\n3. 配方法 例7：求函数 $ y=x+\\sqrt{2x+1} $ 的值域。\n解：首先考虑定义域得 $ D_{y}=\\left [ -\\frac{1}{2},+\\infty \\right ) $ 。又 $$ y=\\left ( \\sqrt{x+\\frac{1}{2}}+\\sqrt{\\frac{1}{2}} \\right )^{2}-1\\geq -\\frac{1}{2} $$ 因此该函数的值域为 $ R_{y}=\\left [ -\\frac{1}{2},+\\infty \\right ) $ 。\n4. 换元法 例8：求函数 $ y=\\left ( \\sqrt{1+x}+\\sqrt{1-x}+2 \\right )\\left ( \\sqrt{1-x^{2}}+1 \\right ),x\\in\\left [ 0,1 \\right ] $ 的值域。\n解：令 $ s=\\sqrt{1+x}+\\sqrt{1-x} $ ，则 $ s^{2}=2\\left ( \\sqrt{1-x^{2}}+1\\right ) $ ，且 $ s\\in\\left [ -\\sqrt{2},\\sqrt{2} \\right ] $ 。代入得 $ y=\\frac{1}{2}\\cdot \\left ( s+2 \\right )\\cdot s^{2}=\\frac{1}{2}s^{3}+s^{2} $ ，易得该函数的值域为 $ R_{y}=\\left [ 2+\\sqrt{2},8 \\right ] $ 。\n5. 关于反函数 例9：若函数 $ y=f\\left ( x \\right ) $ 定义域、值域均为 $ \\mathbf{R} $ ，且存在反函数。若 $ y=f\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增，求证： $ y=f^{-1}\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增。\n解：不妨设 $ x_{1}\u0026gt;x_{2} $ ，则 $ f\\left ( x_{1} \\right )\u0026gt;f\\left ( x_{2} \\right ) $ ，因此 $$ f^{-1}\\left ( f\\left ( x_{1} \\right ) \\right )-f^{-1}\\left ( f\\left ( x_{2} \\right ) \\right )=x_{1}-x_{2}\u0026gt;0 $$ 所以 $ y=f^{-1}\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增。证毕。\n例10：设函数 $ f\\left ( x \\right )=\\sqrt[4]{\\frac{4x+1}{3x+2}} $ ，解方程 $ f\\left ( x \\right )=f^{-1}\\left ( x \\right ) $ 。\n解：即 $ \\sqrt[4]{\\frac{4x+1}{3x+2}}=x $ ，整理得 $$ \\left ( x-1 \\right )\\left ( 3x^{4}+5x^{3}+5x^{2}+5x+1 \\right )=0 $$ 显然 $ 3x^{4}+5x^{3}+5x^{2}+5x+1\u0026gt;0 $ ，故 $ x=1 $ 。\n二、典型例题 题1：已知不等式 $ \\sin^{2}x+a\\cos x+a^{2}\\geq 1+\\cos x $ 对一切 $ x\\in\\mathbf{R} $ 恒成立，求 $ a $ 的取值范围。\n解： $ \\cos^{2}x+\\left ( 1-a \\right )\\cos x - a^{2}\\leq 0 $ ，其中 $ \\cos x\\in\\left [ -1,1 \\right ] $ 。令 $$ f\\left ( x \\right )=\\cos^{2}x+\\left ( 1-a \\right )\\cos x - a^{2} $$ 则 $$ \\begin{cases} f\\left ( -1 \\right )\\leq 0\\\\ f\\left ( 1 \\right )\\leq 0 \\end{cases} \\Rightarrow \\begin{cases} a^{2}-a\\geq 0\\leq 0\\\\ a^{2}-a-2\\geq 0\\leq 0 \\end{cases} \\Rightarrow a\\in\\left ( -\\infty,-2 \\right ]\\cup\\left [ 1,+\\infty \\right ) $$\n题2：已知函数 $ f\\left ( x \\right ) $ 的定义域是 $ \\left [ -\\frac{1}{2},\\frac{1}{2} \\right ] $ ，求函数 $ g\\left ( x \\right )=f\\left ( ax \\right )+f\\left ( \\frac{x}{a} \\right ) $ 的定义域 $ \\left ( a\u0026gt; 0\\right ) $ 。\n解：根据函数函数 $ f\\left ( x \\right ) $ 的定义域很容易得到以下不等式 $ \\begin{cases} -\\frac{1}{2}\\leq ax\\leq \\frac{1}{2}\\\\ -\\frac{1}{2}\\leq \\frac{x}{a}\\leq \\frac{1}{2} \\end{cases} $ 。即 $ \\begin{cases} -\\frac{1}{2a}\\leq x\\leq \\frac{1}{2a}\\\\ -\\frac{a}{2}\\leq x\\leq \\frac{a}{2} \\end{cases} $ 分类讨论得：\n$ 1^{\\circ}0\u0026lt; a\\leq 1,D_{g}=\\left [ -\\frac{a}{2},\\frac{a}{2} \\right ] $\n$ 2^{\\circ}a\u0026gt; 1,D_{g}=\\left [ -\\frac{1}{2a},\\frac{1}{2a} \\right ] $\n题3：已知 $ f\\left(x\\right) $ 是定义在 $ \\mathbf{R} $ 上的函数， $ f\\left(1\\right)=1 $ ，且对任意 $ x\\in\\mathbf{R} $ 都有 $ f\\left(x+5\\right)\\geq f\\left(x\\right) + 5,f\\left(x+1\\right)\\leq f\\left(x\\right)+1 $ ，且 $ g\\left ( x \\right )=f\\left ( x \\right )+1-x $ 求 $ g\\left(2012\\right) $ 。\n解： $ f\\left ( x+5 \\right )\\leq f\\left ( x+4 \\right )+1\\leq \\cdots \\leq f\\left ( x \\right )+5 $ ，又 $ f\\left ( x \\right )\\geq f\\left ( x \\right )+5 $ ，故 $ f\\left ( x \\right )= f\\left ( x \\right )+5 $ 。运用数学归纳法，并结合 $ f\\left ( 1 \\right )=1 $ ，不难得到 $ f\\left ( x \\right )=x $ 。因此 $ g\\left ( 2012 \\right )=f\\left ( 2012 \\right )+1-2012=1 $ 。\n题4：设函数 $ f:\\mathbf{N^{*}}\\rightarrow \\mathbf{N^{*}} $ ，且严格递增。当 $ m,n $ 互质时， $ f\\left ( m\\cdot n \\right )=f\\left ( m \\right )\\cdot f\\left ( n \\right ) $ 。若 $ f\\left ( 19 \\right )=19 $ ，求 $ f\\left ( f\\left ( 19 \\right ) \\right )\\cdot f\\left ( 98 \\right ) $ 的值。\n解：由题意得，当 $ x\\leq 19 $ 时，有 $ f\\left ( x \\right )=x $ 。又 $ f\\left ( 17\\cdot 19 \\right )=f\\left ( 17 \\right )\\cdot f\\left ( 19 \\right )=323 $ ，则当 $ x\\leq 323 $ 时，有 $ f\\left ( x \\right )=x $ 。所以 $$ f\\left ( f\\left ( 19 \\right ) \\right )\\cdot f\\left ( 98 \\right )=f\\left ( 19 \\right )\\cdot f\\left ( 98 \\right )=19*98=1862 $$\n题5：设函数 $ f:\\mathbf{N^{*}}\\rightarrow \\mathbf{N^{*}} $ ，且严格递增。 $ f\\left ( f\\left ( n \\right ) \\right )=3n $ 。求 $ f\\left ( 1 \\right )+f\\left ( 9 \\right )+f\\left ( 36 \\right ) $ 。\n解：首先可以得到 $ f\\left ( f\\left ( 1 \\right ) \\right )=3 $ 。不妨假设 $ f\\left ( 1 \\right )=1 $ ，代入得 $ f\\left ( f\\left ( 1 \\right ) \\right )=f\\left ( 1 \\right )=1\\neq 3 $ ，矛盾。因此易证 $ f\\left ( 1 \\right )=2 $ 。于是可以列出： $$ f\\left ( 2 \\right )=f\\left ( f\\left ( 1 \\right ) \\right )=3,f\\left ( 3 \\right )=f\\left ( f\\left ( 2 \\right ) \\right )=6,f\\left ( 6 \\right )=f\\left ( f\\left ( 3 \\right ) \\right )=9,f\\left ( 9 \\right )=f\\left ( f\\left ( 6 \\right ) \\right )=18 $$ 于是得到 $ f\\left ( 9 \\right )=18 $ 。由 $ f\\left ( 3 \\right )=6,f\\left ( 6 \\right )=9 $ 再结合题中所给条件，得 $ f\\left ( 4 \\right )=7 $ 。因此 $$ f\\left ( 7 \\right )=f\\left ( f\\left ( 4 \\right ) \\right )=12,f\\left ( 12 \\right )=f\\left ( f\\left ( 7 \\right ) \\right )=21,f\\left ( 21 \\right )=f\\left ( f\\left ( 12 \\right ) \\right )=36,f\\left ( 36 \\right )=f\\left ( f\\left ( 21 \\right ) \\right )=63 $$ 于是得到 $ f\\left ( 36 \\right )=63 $ ，将以上的结果相加得 $ f\\left ( 1 \\right )+f\\left ( 9 \\right )+f\\left ( 36 \\right )=2+18+63=83 $ 。\n题6：已知函数 $ f\\left ( x \\right )=\\log_{x}{\\left ( x+1 \\right )},x\\in\\left ( 1,+\\infty \\right ) $ ，试比较 $ f\\left ( x \\right ),f\\left ( x+1 \\right ) $ 的大小。\n解： $ \\frac{f\\left ( x+1 \\right )}{f\\left ( x \\right )}=\\frac{\\log{\\left (x+2 \\right )}}{\\log{\\left (x+1 \\right )}}\\cdot \\frac{\\log{\\left (x+1 \\right )}}{\\log{x}}=\\frac{\\log{\\left ( x+2 \\right )}}{\\log{x}}\u0026gt; 1 $ ，所以 $ f\\left ( x+1 \\right )\u0026gt; f\\left ( x \\right ) $ 。\n题7：已知 $ 3^{a}+13^{b}=17^{a},5^{a}+7^{b}=11^{b} $ ，试判断实数 $ a,b $ 的大小关系，并证明之。\n解：当 $ a=1 $ 时， $ b\u0026gt; 1 $ ，得 $ b\u0026gt; a $ 。假设 $ b\\leq a $ ，易得 $$ \\begin{cases} 17^{a}\\leq 3^{a}+13^{a}\\\\ 5^{b}+7^{b}\\leq 11^{b} \\end{cases} \\Rightarrow \\begin{cases}1\\leq \\left ( \\frac{3}{17} \\right )^{a}+\\left ( \\frac{13}{17} \\right )^{a}\\\\ 1\\geq \\left ( \\frac{5}{11} \\right )^{b}+\\left ( \\frac{7}{11} \\right )^{b} \\end{cases} $$ 不妨令 $$ f\\left ( x \\right )=\\left ( \\frac{3}{11} \\right )^{x}+\\left ( \\frac{13}{17} \\right )^{x},g\\left ( x \\right )=\\left ( \\frac{5}{11} \\right )^{x}+\\left ( \\frac{7}{11} \\right )^{x} $$ 易得 $ f\\left ( 1 \\right )=\\frac{16}{17}\u0026lt; g\\left ( 1 \\right )=\\frac{12}{11} $ 。不成立。综上所述 $ b\u0026gt; a $ 。\n题8：设 $ f\\left ( x \\right )=x^{n}+ax^{2}+bx+c $ ， $ n $ 为自然数。已知 $ f\\left ( -1 \\right )=0,f\\left ( 1 \\right )=-6,f\\left ( 2 \\right )=-9,f\\left ( 3 \\right )=-4,f\\left ( 6 \\right )=119 $ ，求 $ f\\left ( x \\right ) $ 。\n解：将所给条件代入得 $ \\begin{cases} \\left ( -1 \\right )^{n}+a-b+c=0\\\\ 1+a+b+c=-6\\\\ 2^{n}+4a+2b+c=-9\\\\ 3^{n}+9a+3b+c=-4\\\\ 6^{n}+36a+6b+c=119 \\end{cases} $ 对 $ n $ 进行分类讨论：\n$ 1^{\\circ}n $ 为奇数，上述方程组可化简得 $ \\begin{cases}-1+a-b+c=0\\\\ 1+a+b+c=-6\\\\ 2^{n}+4a+2b+c=-9\\\\ 3^{n}+9a+3b+c=-4\\\\ 6^{n}+36a+6b+c=119 \\end{cases} $ ，解得 $ \\begin{cases}n=3\\\\ a=-2\\\\ b=-4\\\\ c=-1 \\end{cases} $ 。\n$ 2^{\\circ}n $ 为偶数，上述方程组可化简得 $ \\begin{cases} 1+a-b+c=0\\\\ 1+a+b+c=-6\\\\ 2^{n}+4a+2b+c=-9\\\\ 3^{n}+9a+3b+c=-4\\\\ 6^{n}+36a+6b+c=119 \\end{cases} $ ，不成立。\n综上所述 $ f\\left ( x \\right )=x^{3}-2x^{2}-4x-1 $ 。\n题9：已知 $ a,b,c $ 为非零实数， $ f\\left ( x \\right )=\\frac{ax+b}{cx+d},x\\in\\mathbf{R} $ ，且 $ f\\left ( 19 \\right )=19,f(97)=97 $ 。若当 $ x\\neq -\\frac{d}{c} $ 时，对于任意实数 $ x $ ，均有 $ f\\left ( f\\left ( x \\right ) \\right )=x $ ，试求出 $ f\\left ( x \\right ) $ 值域以外的唯一数。\n解：易知 $ x=19,x=97 $ 即为不动点，又为稳定点，又 $ f\\left(x\\right) $ 是经过反比例函数平移得到，很容易得到 $ f\\left ( x \\right )=\\frac{58x-1843}{x-58} $ ，故所求数为 $ 58 $ 。\n题10：设有函数 $ f\\left ( x \\right )=\\sin{\\left ( x+a_{1} \\right )}+\\frac{1}{1\\times 2}\\sin{\\left ( x+a_{2} \\right )}+\\cdots +\\frac{1}{\\left ( n-1 \\right )\\times n}\\sin{\\left ( x+a_{n} \\right )} $ ，其中 $ a_{1},a_{2},\\cdots ,a_{n} $ 为常数，证明：（1）至少有一个实数，使 $ f\\left ( x_{0} \\right )\\neq 0 $ ；（2）如果 $ f\\left ( x_{1} \\right )=f\\left ( x_{2} \\right )=0 $ ，则 $ x_{1}-x_{2}=m\\pi $ （ $ m $ 是一个整数）。\n解：\n（1）令 $ x_{0}=\\frac{\\pi}{2}-a_{1} $ ，则 $ f\\left ( x_{0} \\right )\\geq 1-\\left ( \\frac{1}{1\\times 2}+\\frac{1}{2\\times 3}+\\frac{1}{\\left ( n-1 \\right )\\times n} \\right )=1-\\frac{n-1}{n}=\\frac{1}{n}\u0026gt; 0 $ 。\n（2） $$ \\begin{align*} f\\left ( x \\right )\u0026amp;=\\sin{x}\\cos{a_{1}}+\\cos{x}\\sin{a_{1}}+\\sum_{i=2}^{n}{\\frac{1}{\\left ( i-1 \\right )\\times i}\\left ( \\sin{x}\\cos{a_{i}}+\\cos{x}\\sin{a_{i}} \\right )} \\\\ \u0026amp;=\\left ( \\cos{a_{1}}+\\sum_{i=2}^{n}{\\frac{1}{\\left ( i-1 \\right )\\times i}\\cdot \\cos{a_{i}}} \\right )\\cdot \\sin{x}+\\left ( \\sin{a_{1}}+\\sum_{i=2}^{n}{\\frac{1}{\\left ( i-1 \\right )\\times i}\\cdot \\sin{a_{i}}} \\right )\\cdot \\cos{x}\\\\ \u0026amp;=A\\sin{\\left (x+\\varphi \\right ) } \\\\ A \u0026amp;=\\sqrt{\\left ( \\cos{a_{1}}+\\sum_{i=2}^{n}{\\frac{1}{\\left ( i-1 \\right )\\times i}\\cdot \\cos{a_{i}}} \\right )^{2}+\\left ( \\sin{a_{1}}+\\sum_{i=2}^{n}{\\frac{1}{\\left ( i-1 \\right )\\times i}\\cdot \\sin{a_{i}}} \\right )^{2}}\\\\ \\tan{\\varphi } \u0026amp;=\\frac{\\left ( \\cos{a_{1}}+\\sum_{i=2}^{n}{\\frac{1}{\\left ( i-1 \\right )\\times i}\\cdot \\cos{a_{i}}} \\right )}{\\left ( \\sin{a_{1}}+\\sum_{i=2}^{n}{\\frac{1}{\\left ( i-1 \\right )\\times i}\\cdot \\sin{a_{i}}} \\right )}\\end{align*}$$ 由 $ A\\sin{x+\\varphi }=0 $ 得 $ x+\\varphi=k\\pi $ ，于是 $ x_{1}-x_{2}=\\left(k_{1}-k_{2}\\right)\\pi=m\\pi $ 。证毕。\n题11：设正实数 $ x,y $ 满足 $ xy=1 $ ，求函数 $ f\\left ( x,y \\right )=\\frac{x+y}{\\left [ x \\right ]\\cdot \\left [ y \\right ]+\\left [ x \\right ]+\\left [ y \\right ]+1} $ 的值域（这里 $ \\left [ z \\right ] $ 表示不超过 $ z $ 的最大整数）。\n解：\n$ 1^{\\circ} x=y=1,f\\left ( 1,1 \\right )=\\frac{1}{2} $\n$ 2^{\\circ} $ 不妨设 $ x\u0026gt;1 $ ，则 $ \\left [ y \\right ]=0 $ ，记 $ x=m+\\lambda $ ，其中 $ m=\\left [ x \\right ],\\lambda =\\left \\{ x \\right \\} $ 。则 $$ f\\left ( x,y \\right )=\\frac{x+\\frac{1}{x}}{\\left [ x \\right ]+1}=\\frac{x+\\frac{1}{x}}{m+1}=\\frac{m+\\lambda +\\frac{1}{m+\\lambda }}{m+1} $$ 令 $ a_{m}=\\frac{m+\\frac{1}{m}}{m+1} $ ，则 $$ a_{m}\\leq f\\left ( x,y \\right )\u0026lt; \\frac{m+1+\\frac{1}{m+1}}{m+1} $$ 又 $ a_{m+1}-a_{m}=\\frac{m-2}{\\left ( m-2 \\right )m\\left ( m+1 \\right )}\\Rightarrow a_{1}\u0026gt; a_{2}\u0026lt; a_{3}\u0026lt; \\cdots \u0026lt; a_{m} $ 。因此 $$ \\frac{5}{6}\\leq f\\left ( x,y \\right )\u0026lt; 1 + \\frac{1}{\\left ( m+1 \\right )^{2}}\\leq \\frac{5}{4} $$ 故值域为 $ R_{f}=\\left [ \\frac{5}{6},\\frac{5}{4} \\right ) $ 。\n三、二次函数 例1：已知 $ f\\left ( x \\right )=ax^{2}+bx $ ，满足 $ 1\\leq f\\left ( -1 \\right )\\leq 2 $ 且 $ 2\\leq f\\left ( 1 \\right )\\leq 4 $ ，求 $ f\\left ( -2 \\right ) $ 的取值范围。\n解：\n法一：由题设得， $ \\begin{cases} 1\\leq a-b\\leq 2 \u0026amp; \\left ( \\textrm{i} \\right )\\\\ 2\\leq a+b\\leq 4 \u0026amp; \\left ( \\textrm{ii} \\right ) \\end{cases} $ ，由 $ 3\\times \\left ( \\textrm{i} \\right )+\\left ( \\textrm{ii} \\right ) $ 得 $ 5\\leq f\\left ( -2 \\right )\\leq 10 $ 。\n法二： $ \\begin{cases} f\\left ( -1 \\right )=a-b\\\\ f\\left ( 1 \\right )=a+b \\end{cases} \\Rightarrow \\begin{cases} a=\\frac{1}{2}\\cdot \\left [ f\\left ( 1 \\right ) + f\\left ( -1 \\right ) \\right ]\\\\ b=\\frac{1}{2}\\cdot \\left [ f\\left ( 1 \\right ) - f\\left ( -1 \\right ) \\right ] \\end{cases} $ ，因此 $ f\\left ( -2 \\right )=f\\left ( 1 \\right )+3f\\left ( -1 \\right )\\in\\left [ 5,10 \\right ] $ 。\n","date":"2013-07-25T20:01:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/","title":"扬州拾遗（一）：竞赛中的函数"},{"content":"鸽巢原理：如果 $k+1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 $2$ 个或更多的物体。\n有时候鸽巢原理也被称为抽屉原理，更准确地说应该叫做“狄利克雷抽屉原理”。至于狄利克雷这个名字，还有有趣的函数也是用他的名字命名的。它就是大名鼎鼎的狄利克雷函数 $$f\\left(x\\right)=\\begin{cases}1,\u0026amp;x\\in\\mathbf{Q}\\\\ 0,\u0026amp;x\\not\\in\\mathbf{Q}\\end{cases}$$ 这个函数的有趣之处就在于它没有对应的图像。扯远了。\n下面给出鸽巢原理的证明：假定 $k$ 个盒子中没有一个盒子包含的物体多余 $1$ 个，那么物体总数至多是 $k$，这与至少有 $k+1$ 物体矛盾。证毕。\n例1：在一组 $367$ 个人中一定至少有 $2$ 个人有相同的生日，这是由于只有 $366$ 个可能的生日。\n例2：在 $27$ 个英文单词中一定至少有 $2$ 个单词以同一个字母开始，因为英文字母表中只有 $26$ 个字母。\n例3：证明对每个整数 $n$，存在一个数是 $n$ 的倍数，且在它的是进制表示中只出现 $0$ 和 $1$。\n证明：令 $n$ 为正整数。考虑 $n$ 个整数 $1,11,111,\\cdots,11\\cdots 1$（在这个数表中，最后一个整数的十进制表示中具有 $n+1$ 个 $1$）。注意到当一个整数被 $n$ 整除时存在 $n$ 个可能的余数。因为这个数表中有 $n+1$ 个整数，由鸽巢原理必有两个整数在除以 $n$ 时有相同的余数。这两个整数之差的十进制表示中只含有 $0$ 和 $1$，且它能被 $n$ 整除。\n广义鸽巢原理：如果 $N$ 个物体放入 $k$ 个盒子，那么至少有一个盒子包含了至少 $\\left \\lceil \\frac{N}{k} \\right \\rceil$ 个物体。\n证明：假定没有盒子包含了比 $\\left\\lceil \\frac{N}{k} \\right\\rceil-1$ 多的物体，那么物体总数至多是 $$k\\left (\\left\\lceil \\frac{N}{k} \\right \\rceil -1\\right) \u0026lt; k\\left(\\left(\\frac{N}{k}+1\\right)-1\\right)=N$$ 这与存在有总数 $N$ 个物体矛盾。证毕。\n例4：在 $100$ 个中至少有 $\\left\\lceil \\frac{100}{12}\\right\\rceil=9$ 个人生在同一个月。\n例5：为保证一个州的 $2500$ 万个电话有不同的 $10$ 位电话号码，所需地区代码的最小数是多少？（假定电话号码是 $\\textrm{NXX-NXX-XXXX}$ 形式，其中前 $3$ 位是地区代码，$N$ 表示从 $2$ 到 $9$ 包含的十进制数字，$X$ 表示任何十进制数字）。\n解：有 $800$ 万个形如 $\\textrm{NXX-NXX-XXXX}$ 的不同的电话号码。因此，由广义鸽巢原理，在 $2500$ 万个电话号码中，一定至少有 $\\left\\lceil\\frac{25000000}{8000000}\\right\\rceil$ 个同样的电话号码。因而至少需要 $4$ 个地区代码来保证所有的 $10$ 位号码是不同的。\n例6：证明在不超过 $2n$ 的任意 $n+1$ 个正整数中一定存在一个正整数被另一个正整数整除。\n证明：把 $n+1$ 个整数 $a_{1},a_{2},\\cdots,a_{n}$ 中的每一个都写成 $2$ 的幂与一个奇数的乘积，换句话说，令 $a_{j}=2^{k_{j}}\\cdot q_{j},j=1,2,\\cdots,n+1$，其中 $k_{j}$ 是非负整数，$q_{j}$ 是奇数。整数 $q_{1},q_{2},\\cdots,q_{m+1}$ 都是小于 $2n$ 的正奇数。因为只存在 $n$ 个小于 $2n$ 的正奇数，由鸽巢原理，$q_{1},q_{2},\\cdots,q_{n+1}$ 中必有两个相等。于是，存在整数 $i,j$ 使得 $q_{i}=q_{j}$。令 $q_{i}=q_{j}=q$，那么 $a_{i}=2^{k_{i}}\\cdot q,a_{j}=2^{k_{j}}\\cdot q$。因而，若 $k_{i} \u0026lt; k_{j}$，则 $a_{i}$ 整除 $a_{j}$；反之，则 $a_{j}$ 整除 $a_{i}$。\n","date":"2013-07-13T20:27:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%B5%85%E8%B0%88%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","title":"浅谈鸽巢原理及其应用"},{"content":"翻书复习之时，看到斐波那契数列，于是将一些关于数列递推关系方面的内容整理了一下。\n定义1：一个常系数的 $k$ 阶线性齐次递推关系是形如 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}+\\cdots+c_{k}a_{n-k}$ 的递推关系，其中 $c_{1},c_{2},\\cdots,c_{k}$ 是实数，$c_{k}\\neq 0$。\n这个定义中递推关系是线性的，因为它的右边是数列前项的倍数之和。这个递推关系是齐次的，因为所出现的各项都是 $a_{j}$ 的倍数。数列各项的系数都是常数而不是依赖于 $n$ 的函数。阶为 $k$ 是因为 $a_{n}$ 由序列前面的 $k$ 项来表示。\n例1：递推关系 $p_{n}=2p_{n-1}$ 是 $1$ 阶的线性齐次递推关系。递推关系 $f_{n}=f_{n-1}+f_{n-2}$ 是 $2$ 阶的线性齐次递推关系。\n例2：递推关系 $a_{n}=a_{n-1}+a_{n-2}^{2}$ 不是线性的。递推关系 $h_{n}=2h_{n-1}+1$ 不是齐次的。递推关系 $b_{n}=nb_{n-1}$ 不是常系数的。\n求解常系数线性齐次递推关系的基本方法是寻找形如 $a_{n}=r^{n}$ 的解，其中 $r$ 是常数。注意 $a_{n}=r^{n}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}+\\cdots+c_{k}a_{n-k}$ 的解，当且仅当 $$r^{n}=c_{1}r^{n-1}+c_{2}r^{n-2}+\\cdots+c_{k}r_{n-k}$$ 当等式两边除以 $r^{n-k}$ 并且从左边减去右边时，我们得到等价的方程 $$r^{k}-c_{1}r^{k-1}-c_{2}r^{k-2}-\\cdots-c_{k-1}r-c_{k}=0$$ 因此，数列 $\\left\\{a_{n}\\right\\}$ 以 $a_{n}=r^{n}$ 作为解，当且仅当 $r$ 使者后一个方程的解。这个方程叫作该递推关系的特征方程。方程的解叫做该递推关系的特征根。\n我们首先看一个 $2$ 阶常系数线性齐次递推关系的处理结果。然后，叙述相应的阶可能大于 $2$ 的一般性结果。\n定理1：设 $c_{1}$ 和 $c_{2}$ 是实数。假设 $r_{2}-c_{1}r-c_{2}=0$ 有两个不等的根 $r_{1}$ 和 $r_{2}$，那么数 $\\left\\{a_{n}\\right\\}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}$ 的解，当且仅当 $a_{n}=\\alpha_{1}\\cdot r_{1}^{n}+\\alpha_{2}\\cdot r_{2}^{n},n=0,1,2,\\cdots$，其中 $\\alpha_{1}$ 和 $\\alpha_{2}$ 是常数。\n例3：求斐波那契数列的通项公式。\n解：斐波那契数列满足递推关系 $f_{n}=f_{n-1}+f_{n-2}$ 和初始条件 $f_{1}=f_{2}=1$。特征方程 $r^{2}-r-1=0$ 的两个根是 $r_{1,2}=\\frac{1\\pm\\sqrt{5}}{2}$。因此，由定理 1 的斐波那契数列通项公式为：$$f_{n}=\\alpha_{1}\\cdot \\left(\\frac{1+\\sqrt{5}}{5}\\right)^{n}+\\alpha_{2}\\cdot \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}$$ 其中 $\\alpha_{1},\\alpha_{2}$ 为常数。可由初始条件 $f_{1}=f_{2}=1$ 确定这两个常数，我们有 $$\\begin{cases} f_{1}=\\alpha_{1}\\cdot \\left ( \\frac{1+\\sqrt{5}}{2} \\right )+\\alpha {2}\\cdot \\left ( \\frac{1-\\sqrt{5}}{2} \\right )=1 \\\\ f{2}=\\alpha_{1}\\cdot \\left ( \\frac{1+\\sqrt{5}}{2} \\right )^{2}+\\alpha {2}\\cdot \\left ( \\frac{1-\\sqrt{5}}{2} \\right )^{2}=1 \\end{cases}$$ 从而得到 $\\alpha{1}=\\frac{\\sqrt{5}}{5},\\alpha_{2}=-\\frac{\\sqrt{5}}{5}$，于是斐波那契数列的通项公式为：$$f_{n}=\\frac{\\sqrt{5}}{5}\\left(\\frac{1+\\sqrt{5}}{5}\\right)^{n}-\\frac{\\sqrt{5}}{5}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}$$\n当存在二重特征根的时候，定理1不再适用。如果遇到这种情况，当 $r_{0}$ 是特征方程的一个二重根时，那么 $a_{n}=nr_{0}^{n}$ 是递推关系的另一个解。\n定理2：设 $c_{1}$ 和 $c_{2}$ 是实数。假设 $r_{2}-c_{1}r-c_{2}=0$ 只有一个根 $r_{0}$。数列 $\\left{a_{n}\\right}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}$ 的解，当且仅当 $a_{n}=\\alpha_{1}\\cdot r_{0}^{n}+\\alpha_{2}\\cdot n\\cdot r_{0}^{n},n=0,1,2,\\cdots$，其中 $\\alpha_{1}$ 和 $\\alpha_{2}$ 是常数。\n例4：数列 $\\left\\{a_{n}\\right\\}$ 满足 $a_{n}=6a_{n-1}-9a_{n-2}$，且$a_{1}=6，a_{2}=27$，求数列 $\\left\\{a_{n}\\right\\}$ 的通项公式。\n解：$r^{2}-6r+9=0$ 唯一的根是 $r=3$。因此这个递推关系的解是 $$a_{n}=\\alpha_{1}\\cdot 3^{n}+\\alpha_{2}\\cdot n\\cdot 3_{n}$$ 其中 $\\alpha_{1},\\alpha_{2}$ 是常数。使用初始条件得 $\\alpha_{1}=\\alpha_{2}=1$，所以 $\\left\\{a_{n}\\right\\}$ 的通项公式为 $$a_{n}=3^{n}+n\\cdot 3^{n}$$\n例5：求满足 $a_{1}=5,a_{2}=15,a_{3}=47$ 的递推关系 $a_{n}=6a_{n-1}-11a_{n-2}+6a_{n-3}$ 的通项公式。\n解：有这个递推关系的特征方程 $r^{3}-6r^{2}+11r-6=0$ 得到三个特征根 $r_{1}=1,r_{2}=2,r_{3}=3$，于是递推关系的解的形式为：$$a_{n}=\\alpha_{1}\\cdot 1^{n}+\\alpha_{2}\\cdot 2^{n}+\\alpha_{3}\\cdot 3^{n}$$ 通过初始条件得到 $\\alpha_{1}=1,\\alpha_{2}=-1,\\alpha_{3}=2$。于是通项公式为：$$a_{n}=1-2^{n}+2\\cdot 3^{n}$$\n","date":"2013-07-12T16:03:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%B5%85%E8%B0%88%E6%95%B0%E5%88%97%E4%B8%AD%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B1%82%E8%A7%A3/","title":"浅谈数列中常系数线性齐次递推关系的求解"},{"content":"好久没来打理博客了，一直没时间。有时候想要写些文字也就这样耽搁了。比如说《谁是少数幸福的人——读\u0026lt;红与黑\u0026gt;有感》，这篇文章我写在了随笔本上，却一直没时间把它发到博客上来。慢慢发现现在我们自由支配的时间越来越少了，想要安安静静地阅读名家大作也就成了一种奢望。\n高考三天在学校上课，我们在图文信息楼四楼最西边的小教室里。根据张伟兴的暗示，隔壁就成了食堂和棋牌室。三天上课，我们一共吃了三顿东池。中午休息的时候看电影，躲在心缘爱心社玩。还差点被周汉东抓到。高一的就没这么幸运了，第一天晚自习就吵得不得了，被王胖子轻而易举地抓了现行，揪去见张新宇了。然后王胖子带着他的战利品笑嘻嘻的来到我们教室说：高二的和高一的就是不一样，到底是有追求的了。\n三天做了很多题目，其中最有趣的，被我们改编成课余娱乐项目的便是这道题目：\n桌上放有$n$根火柴，甲乙二人轮流从中取走火柴。甲先取，第一次可取走至多$n-1$根火柴，此后没人每次至少取走1根火柴。但是不超过对方刚才取走火柴数目的2倍。取得最后一根火柴者获胜。问：当$n=100$时，甲是否有获胜策略？请详细说明理由。\n但是每次玩的时候总是遇到一些小意外，明明处在必胜态，却一不小心走向了必败态。大家有兴趣的可以玩玩。\n三天上课，也给了我近距离接触高考的机会。每场考试结束以后，我们可以近距离的接触考生，听他们谈论题目，甚至可以和他们进行一些交流。最激动人心的莫过于听了一次高考英语听力，当时走廊里站满了高二搞竞赛的人，努力的捕捉广播里蹦出的每一个词句。听完听力，我却有些迷惘了。是啊，我们马上就要高三了，要准备自主招生，准备高考。事情越来越多，任务也越来越繁重了。我也不知道高考那天我会是发挥的怎么样，或许命运的神奇之处就在于它的不可捉摸吧。\n我最近时常在想一件事情，究竟什么才能够使得一个人获得真正的快乐。曾经在心理学的书中看到过这个问题，它所给出的解答是一种被誉为“自我实现”的马斯洛理论，也就是需求层次理论。以前我对于这一理论是非常认同的，不过现在我的想法开始有了些细微的改变。在我很小的时候，大概是小学吧，我总是喜欢和别人分享自己取得的成绩，获得的荣誉。或许这就是所谓的“自我实现”。但是现在我却更愿意藏巧于拙，将有才能的一方面隐藏起来，而显露出一些比较拙劣的方面。也不知道为什么，陈季伦总是叫我大神，搞得我不知所措。也有人说我是信息学大神，但是我却不是很喜欢这个头衔，所以每次有人问到我关于计算机方面的问题，除非特殊情况，我都会向他推荐李老师。有时候取得了一些小小的成绩，总想和朋友们一起分享，但是却发现大家都很忙，也就只好作罢了。\n更多的时候，我在思考这样一件事情，为什么我和同龄的一些人差距这么大呢。为什么我不像他们一样好玩，为什么我不像他们一样喜欢玩游戏，为什么我不像他们一样满脑低俗的思想······相比之下，我却喜欢看各种书籍、资料，有时候甚至对他们的生存状态嗤之以鼻，究竟那种才是真正的，属于我们现在的，符合我们年龄的生存状态呢？并没有谁对谁错，谁是谁非，后来想想，仅仅是个人的选择不一样罢了。但我相信，十年后，二十年后，我不会为我现在所选择的不堕落的向上的生存状态而后悔，而他们，却谁也说不准。\n最近发现了自己身上一个很大的毛病，我也不知道如何用语言来描述。或者可以称之为——不成熟。遇人遇事，处理的不够好，就比如说那次和舍管阿姨的争执。完全没必要那么激动。当然，也没惹出什么后果，甚至我开始怀疑那舍管阿姨是想自己讹点钱。因为如果真是学校要求我们赔偿，那么她没有理由不再来向我要钱。但是既然过去了，也就不管它了。但是有的是还是不能太冲动，做事不能不考虑后果。\n言归正传，又瞎扯了好多，本来想好好规划一下接下来的极为珍贵的一年时光。\n首先是在七月份的数学复赛，前几天和朱宇聊了聊，听他所说，通过这次选拔并不难，只需要做出那道平几。尽人事，听天命。很多事情都是这样的。\n接下来当然是自主招生，根据近几年的招生简章，我应该是选择数学、物理这两门考试科目。对于数学学科，现在在数学组上课，接下来又要去扬州培训，这样下来，对于自主招生问题应该不会很大，只要平时在多刷刷题。物理却有点难度，因为物理竞赛的书很难啃啊。也不知道自主招生物理竞赛内容会占多大比例。\n目前比较现实的学习方面的计划就是这两个了。\n路漫漫其修远兮，吾将上下而求索！\n","date":"2013-06-12T17:37:00+08:00","permalink":"https://ivy-end.github.io/p/%E5%91%93%E8%AF%AD%E4%B8%89%E5%BD%B7%E5%BE%A8/","title":"呓语（三）：彷徨"},{"content":"前几天在数学组听课的时候，做平面几何的题目，遇到了塞瓦定理。当时赵诚宇给我讲了一遍，现在再把它整理一下。\n塞瓦定理：在 $\\triangle ABC$ 中，若线段 $AD$、$BE$、$CF$ 通过同一点 $O$，则 $\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} =1$。\n塞瓦定理逆定理：在 $\\triangle ABC$ 中，若点 $D$、$E$、$F$ 分别在边 $AD$、$BE$、$CF$ 上，且满足 $\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} =1$，则线段 $AD$、$BE$、$CF$ 共点或彼此平行。（我们在此只研究共点的情形）\nCeva 定理示意图\n证明如下：\n首先 $$\\frac {BD} {DC}=\\frac {S_{\\triangle ABD}}{S_{\\triangle ADC}}=\\frac {S_{\\triangle OBD}}{S_{\\triangle ODC}} \\Rightarrow \\frac {BD} {DC}=\\frac {S_{\\triangle ABD}-S_{\\triangle OBD}}{S_{\\triangle ADC}-S_{\\triangle ODC}}=\\frac {S_{\\triangle ABO}}{S_{\\triangle CAO}}$$ 同理 $$\\frac {CE} {EA}=\\frac {S_{\\triangle BCO}}{S_{\\triangle ABO}},\\frac {AF} {FB}=\\frac {S_{\\triangle CAO}}{S_{\\triangle BCO}}$$ 因此 $$\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} = \\frac{S_{\\triangle ABO}}{S_{\\triangle CAO}} \\cdot \\frac{S_{\\triangle BCO}}{S_{\\triangle ABO}} \\cdot \\frac{S_{\\triangle CAO}}{S_{\\triangle BCO}}=1$$ 证毕。\n例：在筝形 $ABCD$ 中，$AB=AD$，$BC=CD$，经 $AC$、$BD$ 的交点 $O$ 任做两条直线，分别交 $AD$ 于 $E$，交 $CD$ 于 $H$。$GF$、$EH$ 分别交 $BD$ 于 $I$，$J$。求证：$IO=OJ$。\nCeva 定理例题图\n证明如下：\n作 $\\triangle ABC$ 的关于 $AC$ 的对称图形，记 $E^{\u0026rsquo;}H^{\u0026rsquo;} \\cap BB=M$ 设 $\\angle GOB=\\angle BOH^{\u0026rsquo;}=\\alpha,\\angle E^{\u0026rsquo;}OG=\\angle FOH^{\u0026rsquo;}=\\beta$ 则有：$$\\frac{E^{\u0026rsquo;}G}{GB} \\cdot \\frac{BH^{\u0026rsquo;}}{H^{\u0026rsquo;}F} \\cdot \\frac{FM}{ME^{\u0026rsquo;}}=\\frac{OE^{\u0026rsquo;}\\sin \\beta}{OB \\sin \\alpha} \\cdot \\frac{OB \\sin \\alpha}{OF \\sin \\beta} \\cdot \\frac{OF \\sin \\left ( \\alpha + \\beta \\right )}{OE^{\u0026rsquo;} \\sin \\left ( \\alpha + \\beta \\right )}=1$$ 由塞瓦定理得：$MB$、$E^{\u0026rsquo;}H^{\u0026rsquo;}$、$GF$ 共点，因此 $IO=OJ$。证毕。\n","date":"2013-06-01T19:43:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%B5%85%E8%B0%88%E5%A1%9E%E7%93%A6%E5%AE%9A%E7%90%86%E5%9C%A8%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","title":"浅谈塞瓦定理在平面几何中的应用"},{"content":" NOIP 2012 获奖证书\n上面这张证书是星期四下午拿到的，至此 NOIP 2012 画上了一个不完美但却圆满的句号。\n由于最近的一系列事件，加之以徐丹的高压政策下，我们被迫交出了机房的钥匙。一开始当然不会同意，但最后还是交出了钥匙。因为想明白了一些事情。首先，钥匙交给我们保管，是为了让我们在老师不在的时候可以进入机房得到联系。信息学不像数理化，只要一本题典，一堆草稿纸就可以应付的。但是，如果我们在机房，并不能干很多事情，并不能把时间全部高效利用，并不能 AC 更多的题目，而更多的时候是在磨洋工。那么这把钥匙给了我们，又有什么积极用处呢？在上交钥匙的时候，便决定以后周六、周日不再踏入机房。而周四，本来还想去联合电子看看的。不过徐丹非要把我们押在那里，看来计划又要有变化了。对于徐丹，并不是不尊重，而是她有时候说话的气焰太嚣张了。一个连 C++ 语法都讲不连贯的人，居然妄想着辅导我们算法，简直是可笑不自量。\n本来打算彻底退出竞赛编制，自己在家里有空的时候刷题，毕竟距离初赛还有很长一段时间。但一时不知道怎么开口。至于原因，请允许我使用历史学科教导我的方法来简要分析一下：直接原因是徐丹索要钥匙事件；根本原因是对于竞赛时间不能得到合理利用的难以容忍，在此不一一例证。这样一来，便可心如不系之舟了。至于高三的竞赛，张兴老师希望我可以继续努力，争取拿到国一。只是担心那时候是否有足够的精力和时间，或者有没有别的优惠政策。毕竟取消报送，不论自己是否热爱这门竞赛，在高考这座大山的压迫下，还是会或多或少的丧失一点积极性的。\n对于高一到高二复赛结束，这段竞赛经历将成为我永久的记忆。从中学到的领悟到的，远比寒窗十年所得要多得多。这一点，或许同样搞竞赛的人会有同感吧。接下来的内容是对于那段过往的一些回忆。\n说起信息学竞赛，不得不提一提冯璞。我记得那时在高一上学期刚开学的时候，有一天中午和她聊天，说到赵之赫在跟一个老师（张兴）学编程，问我要不要一起去。说实话，我并不需要学，因为那些早就会了，只是对于这个话题比较感兴趣，所以就答应了。于是她把赵之赫妈妈的电话给了我。于是我便和赵之赫妈妈取得了联系，她又给了我张兴老师的电话，就这样，辗转多方，终于和张兴老师取得了联系。他和我说让我第二天下午早点去和他谈谈。\n第一次，跑到信息楼三楼，等候在网管室门口。由于紧张，甚至误将一名学生认做了老师，搞得好尴尬。终于，张兴老师到了，给我第一印象是高级知识分子，技术宅，再后来的接触过程中也印证了我的想法。那天他和我谈了好多，关于编程，设计，美学……\n就这样，我通过非正当途径，成为了信息组的一员。那时候的信息组还是非常强大的，例如缪晓伟、张宇辰、周弋渊、王俊涛（《坐在生活的前排》范文的作者之一），这是我印象中高三神犇。在当时，高二的选手还欠火候，例如项业成、王意天、胡宇涛。不过有一点让我非常钦佩，他们在没有老师的情况下，都在认真刷题，也是由于受到他们的影响，为了竞赛，我戒了游戏。自此以后，再也没有碰过任何游戏。\n第一次初赛，说实话，大家都没重视。毕竟只有高一嘛，还有机会。于是乎，差了 7 分出线，两道选择题。不过对我来说已经是一个非常好的成绩了。因为我是在十一长假七天内飞快的看完一本初赛书，就这样去裸考的。再加上一些自己曾经写代码的经验。几个辅导竞赛的老师大吃一惊，甚至说后悔当初没有考前专门辅导一下我。\n初赛结束以后，距离信息组正式报名还有一段时间，这段时间内，我便在张兴老师的办公室内，有时候和他聊聊天，有时候他教我一些基本的算法。下学期，开始了正式的上课。内容分为三大块：C++、数据结构、算法。C++ 部分还是很轻松的，我还上了几节课。数据结构就不好说了，深似海啊。在讲到树、图的时候，已经缴械投降了。而且带着侥幸的想法，认为这就是最难的内容了。不过当时老师安慰我们说我们暑假要去常州培训，那个时候他们会给你们讲清楚的。\n就这样，我们一直上课到暑假。期间我还去数学组客串了几节课，本想去听数论的，结果张伟兴就是不讲。到了暑假里，八月份的时候，我们又集中起来上课，每天晚上在机房里对着电脑调试代码到九点半。期间自称蒟蒻的神犇缪晓伟来给我们上了半天课。项业成给我们讲了并查集。后来又把我叫到准备室，给我讲了 DFS。\n接下来就是振奋人心的常州之行。本以为可以疯玩了，结果除了第一天下午张春华老师带着我们参观了一个公园，以后就每天六点半起，十二点半睡，其余时间都在写代码，持续了一个星期。到最后整个人都瘫掉了。不过还是觉得很开心，因为学到了很多，见到了很多神犇。\n就这样，迎来了初赛。在初赛前，抽了几节晚自习复习。初赛前一天本来是放假，但我还是留了下来，和项业成、王意天、胡宇涛一起复习，就这样看书看到第二天一点。初赛启程。2 个小时一会儿就过去了。我记得的玉米是第一个交卷的，不过出来的成绩并不理想。玉米和项业成都挺可惜的。我和胡宇涛过了初赛，接下来就是暗无天日的复赛刷题了。\n停课刷题，我记得在短短的十几天里，我们一共刷了上百道题目。把前几年的复赛都做过了，并且立志要拿一等。在出征前，张春华老师还请我们吃了一顿饭，虽然是在学校食堂吃的，不过这份心意还是领了。\n南航，淅淅沥沥的小雨。我们两个学生，加上张兴，三个人走在大道上，显得尤为渺小。复赛很快就结束了，唯一留下印象的，是南航极其优越的伙食。\n等待结果是一个非常揪心的过程，因为有所期待。最后出来是二等，失落是肯定的，不过那个时候已经完全看透了。\n随着高三神犇的离开，现在的信息组毫无生机，都是一些像我这样的蒟蒻。不堪回首。\n","date":"2013-05-18T20:38:00+08:00","permalink":"https://ivy-end.github.io/p/to-noip/","title":"To NOIP"},{"content":"我记得在计算机复赛前一天晚上本想看看同余方程的解法，结果第二天就考到了。明天是数学竞赛初赛，简略的复习一下线性同余及中国剩余定理，顺便记下一些笔记。\n定理1：令 $m$ 为正整数。若 $\\begin{cases} a \\equiv b \\pmod m \\\\ c \\equiv d \\pmod m \\end{cases}$，那么 $\\begin{cases} a+c \\equiv b+d \\pmod m \\\\ ac \\equiv bd \\pmod m\\end{cases}$。\n证明：因为 $\\begin{cases} a \\equiv b \\pmod m \\\\ c \\equiv d \\pmod m\\end{cases}$，所以有整数 $s$ 和 $t$ 使 $\\begin{cases} b=a+sm \\\\ d=c+tm\\end{cases}$。于是 $$ \\begin{cases} b+d=(a+sm)+(c+tm)=(a+c)+m(s+t)\\\\ bd=(a+sm)(c+tm)=ac+m(at+cs+stm) \\end{cases} \\Rightarrow \\begin{cases} a+c \\equiv b+d \\pmod m \\\\ ac \\equiv bd \\pmod m \\end{cases}$$\n例：由于 $\\begin{cases} 7 \\equiv 2 \\pmod 5 \\\\ 11 \\equiv 1 \\pmod 5\\end{cases}$，从定理1知 $\\begin{cases} 18 = 7+11 \\equiv 2+1=3 \\pmod 5 \\\\ 77 = 7 \\cdot 11 \\equiv 2 \\cdot 1=2 \\pmod 5\\end{cases}$。\n定理2：如果 $a$ 和 $m$ 为互素的整数，$m \u0026gt; 1$，则存在 $a$ 的模 $m$ 的逆。而且这个逆模 $m$ 是唯一的。（即有小于 $m$ 的唯一正整数 $\\overline{a}$，如果这样的 $\\overline{a}$ 存在的话。这样的 $\\overline{a}$ 称为 $a$ 模 $m$ 逆，且 $a$ 的任何别的模 $m$ 逆均和 $\\overline{a}$ 模 $m$ 同余。）\n证明：由定理 1 及 $\\gcd \\left ( a,m \\right )=1$ 知，有整数 $s$ 和 $t$ 使 $$sa+tm=1$$ 于是 $$sa+tm \\equiv 1 \\pmod m$$ 由于 $tm \\equiv 0 \\pmod m$，所以 $$sa \\equiv 1 \\pmod m$$ 结论是 $s$ 为 $a$ 的模 $m$ 逆。\n例：求 $3$ 的模 $7$ 逆。\n解：由于 $\\gcd \\left ( 3,7 \\right )=1$，定理 3 说明存在 $3$ 模 $7$ 的逆。若用欧几里得算法求 $3$ 和 $7$ 的最大公约数，算法很快结束：$$7=2 \\cdot 3 + 1$$ 从这一等式看到 $$-2 \\cdot 3 + 1 \\cdot 7=1$$ 这说明 -2 是 3 模 7 的一个逆。（注意，模 $7$ 同余于 $-2$ 的每个整数也是 $3$ 的逆，例如 $5,-9,12$ 等。）\n例：求线性同余 $3x \\equiv 4 \\pmod 7$ 的解。\n解：易知 $-2$ 是 $3$ 模 $7$ 的逆。在同余式的两边同乘以 $-2$ 得 $$-2 \\cdot 3x \\equiv -2 \\cdot 4 \\pmod 7$$ 因为 $\\begin{cases} -6 \\equiv 1 \\pmod 7 \\\\ -8 \\equiv 6 \\pmod 7\\end{cases}$，所以若 $x$ 是解，必有 $$x \\equiv -8 \\equiv 6 \\pmod 7$$ 于是由定理 1，有 $$3x \\equiv 3 \\cdot 6 \\equiv 18 \\equiv 4 \\pmod 7 $$ 这说明所有这种 $x$ 满足问题中的同余式。结论是，同余方程的解是使 $x \\equiv 6 \\pmod 7$ 的整数。\n从有关线性同余系统的中国古典问题而得名的中国剩余定理，可以这样叙述：只要线性同余系统的模数两两互素，则该系统有解，而且以所有模数之乘积取模，解是唯一的。\n定理3（中国剩余定理）：令 $m_{1},m_{2},\\cdots,m_{n}$ 为两两互素的正整数，则同余方程组 $$ \\begin{cases} x \\equiv a_{1} \\pmod {m_{1}}\\\\ x \\equiv a_{2} \\pmod {m_{2}}\\\\ \\vdots \\\\ x \\equiv a_{1} \\pmod {m_{n}} \\end{cases}$$ 唯一的模 $m=m_{1}m_{2} \\cdots m_{n}$ 解。（即有一个解 $x$，使 $0 \\leq x \\leq m$，且所有其他的解均与此解模 $m$ 同余。）\n证明：要建立这一定理，需要证明有一个解存在，而且是模 $m$ 唯一的。下面将给出构造这样一个解的方法以证明解的存在。\n要构造一个适合各方程的解，首先对 $k=1,2, \\cdots ,n$，令 $M_{k}=\\frac{m}{m_{k}}$，即 $M_{k}$ 是除 $m_{k}$ 以外所有模数的乘积。由于 $i \\neq k$ 时，$m_{i}$ 和 $m_{k}$ 没有大于 1 的公因子，所以 $\\gcd \\left ( m_{k},M_{k} \\right )=1$。从而由定理 2 知有整数 $y_{k}$，即 $M_{k}$ 模 $m_{k}$ 的逆，使得 $$M_{k}y_{k} \\equiv 1 \\pmod {m_{k}}$$ 要得到适合所有方程的解，令 $$x=a_{1}M_{1}y_{1}+a_{2}M_{2}y_{2}+\\cdots+a_{n}M_{n}y_{n}$$ 现要证明 $x$ 就是这样一个解。\n首先注意，由于只要 $j \\neq k$，就有 $M_{j} \\equiv 0 \\pmod {m_{k}}$，在 $x$ 的求和表达式中除第 $k$ 项以外的各项模 $m_{k}$ 均同余于 $0$。由于 $M_{k}y_{k} \\equiv 1 \\pmod {m_{k}}$，可以看出对 $k=1,2, \\cdots ,n$，均有 $$x \\equiv a_{n}M_{n}y_{n} \\equiv a_{k} \\pmod {m_{k}}$$。这就证明了 $x$ 是这 $n$ 个同余方程的公共解。\n例：求同余方程组 $\\begin{cases} x \\equiv 2 \\pmod 3\\\\ x \\equiv 3 \\pmod 5\\\\ x \\equiv 2 \\pmod 7 \\end{cases}$ 的解。\n解：首先令 $m=3 \\cdot 5 \\cdot 7=105$，$M_{1}=\\frac {m} {3}=35$，$M_{2}=\\frac {m} {5}=21$，$M_{3}=\\frac {m} {7}=15$。可看到 $2$ 是 $M_{1}=35$ 的模 $3$ 逆，因为 $35 \\equiv 2 \\pmod 3$；$1$ 是 $M_{2}=21$ 的模 $5$ 逆，因为 $21 \\equiv 1 \\pmod 5$；$1$ 也是 $M_{3}=15$ 的模 $7$ 逆，因为 $15 \\equiv -1 \\pmod 4$。于是这一方程组的解是满足下列式子的那些 $x$： $$ x \\equiv a_{1}M_{1}y_{1}+a_{2}M_{2}y_{2}+a_{3}M_{3}y_{3}=2 \\cdot 35 \\cdot 2 + 3 \\cdot 21 \\cdot 1 + 2 \\cdot 15 \\cdot 1=233 \\equiv 23 \\pmod {105} $$\n可以见 $23$ 是所有解当中最小的正整数。结论是 $23$ 是最小的正整数，除以 $3$ 时余 $2$，除以 $5$ 时余 $3$，除以 $7$ 时余 $2$。\n","date":"2013-05-04T21:31:00+08:00","permalink":"https://ivy-end.github.io/p/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E5%8F%8A%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","title":"浅谈线性同余及中国剩余定理"},{"content":"向生命的来处张望，不禁唏嘘，时光竟如此匆匆流过。\n现在的我已是一名高二的学生，想想明年就要高考，却和理想的大学相差一些距离。前一阵子看了一本书，讲的是一个英语成绩班级倒数的人通过三年的努力成为全省第五的故事。当时感到了一股强大的正能量，过了几天，我根据自己的情况，也制定了一份计划，把刷英语由原来的自发变成了自觉。最近各门科目，尤其是理科上课教的非常快。似乎老师们都认为，把知识讲完了，通过做题就可以把那些没弄懂的都巩固了。这种思维固然不错，但是却显露着填压式教育的影子。\n最近慢慢的，真的懂得了学习。以前就好比是在黑暗的泥泞中摸着石头过河，却总是失足落水。我们的学习并不是为了老师，并不是为了父母，抑或其他。不认真便是对自己的不负责任。但是尽力的，却另当别论。但是科学研究表明，人类的潜力是非常巨大的，所以对于这五门学科，只要肯下工夫，并不存在任何问题。但是如果把所有的经历都放在了这上面，生活就未免有些单调。对我来说，也是不现实的。\n喜欢在闲暇的午后，泡上一杯茶，预约一本好书。对于这个信息爆炸的时代，基本上任何人都可以写上一本书。但是那些所谓所谓的作家也仅仅是徒有其表。我对于书籍一直有一种纯净的观念，认为那些毫无思考力的言情玄幻等根本无法称作是书籍。否则，为什么历史上没有流传下来任何类似的书籍呢。个人比较倾向于文学，哲学，历史。这里不得不提一提历史方面的书籍，自从当年明月的《明朝那些事》出版以后，各种类似的书就层出不穷，质量也是良莠不齐。我觉得对于这种现代人改写的历史小说，一定程度上加入了作者自己的观点和看法，并不能很好的还原事情的真实面貌。由于吃过几次这样的亏。所以对于历史方面，我便倾向于看二十四史。虽然是拗口难懂的文言文，但是读上去比那些白话文的改编版清爽多了。\n最近很喜欢品茶。一来它可以提神醒脑，而且不像咖啡一样对神经系统具有副作用；二来它可以是一个人静下来，更可以洗净一个人内心的浮躁与污垢。感觉灵魂更加纯洁，高尚。周红娟戏称为养生，或许这也是一个原因吧。但对于我来说，最重要的是第二点。最近总有些莫名其妙的浮躁，可能是气温升高了，功课也比较繁重，这主观与客观的交汇导致的吧。\n最近在看《红与黑》，目前为止看完了上卷，却给了我很深的思考。让我联想到了当初学习《周易》时候的一句话：\n看到的都是表象。\n我们在这个世界，看到的是不是也都是表象？我来创造一个词，暂且叫作“快餐式友情”。我想大家身边都不缺乏朋友，而且我们也可以很快的和陌生人聊得很好，成为朋友。但是，你们之间有足够的信任吗？不要急着给出答案，仔细思考。\n最近自己变得不怎么喜欢说话了，追根溯源，竟是张兴曾经和我说过的一句话：\n不要和那些人一样，整天谈那些无聊没用的东西。说话要一针见血。\n要忍住寂寞，才能成功。\n这两句话给我的影响的确很大，本来我就感觉自己和他们在讨论一些无聊的话题时很不自在。不讨论反倒好多了。这样也就有更多的精力去考虑别的我感兴趣的事情了。对于第二句话，应该是放之四海皆准的真理吧，纵观古今之外，哪一个成功的人不是如此？如果有例外，那一定是他不够成功。\n本来有很多想写的，写到这突然没了思绪了，那就到这吧。\n","date":"2013-04-29T21:03:00+08:00","image":"https://ivy-end.github.io/images/cover.jpg","permalink":"https://ivy-end.github.io/p/ramblings-part-2-reflections/","title":"呓语（二）：感悟"},{"content":"最近数学课上讲了矩阵，很久以前便对矩阵很有兴趣，但由于一些原因没有深入学习。正好趁这个机会，有思考了一下关于矩阵的内容。目前应用较广的应该是运用逆矩阵求解线性方程组，尤其对于三元一次方程组，运用逆矩阵求解会非常方便。\n一个方形矩阵的伴随矩阵是一个类似于逆矩阵的概念。如果矩阵可逆，那么它的逆矩阵和它的伴随矩阵之间只差一个系数。然而，伴随矩阵对不可逆的矩阵也有定义，并且不需要用到除法。我们对这种情况不做深入讨论。\n引理1：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，以及两个整数 $i,j$，其中 $1\\leq i,j\\leq n$。去掉 $\\mathbf{A}$ 的第 $i$ 行以及第 $j$ 列，得到一个 $n-1$ 阶子矩阵。记这个子矩阵的行列式为 $\\mathbf{M}_{ij}$。称为余子式。\n引理2：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，代数余子式是余子式 $\\mathbf{M}_{ij}$ 与 $\\left ( -1 \\right )^{i+j}$ 的乘积，记作 $\\mathbf{C}_{ij}$。\n例：对于矩阵 $\\begin{bmatrix} 1 \u0026amp; 4 \u0026amp; 7\\\\ 3 \u0026amp; 0 \u0026amp; 5\\\\ -1 \u0026amp; 9 \u0026amp; 11 \\end{bmatrix} $，计算它的代数余子式 $\\mathbf{C}_{23}$。\n解：首先计算余子式 $\\mathbf{M}_{23}$，即原矩阵去掉第二行以及第三行所得的矩阵的行列式：$ \\begin{bmatrix} 1 \u0026amp; 4 \u0026amp; \\bigcirc \\\\ \\bigcirc \u0026amp; \\bigcirc \u0026amp; \\bigcirc \\\\ -1 \u0026amp; 9 \u0026amp; \\bigcirc \\end{bmatrix} $，即 $ \\begin{vmatrix} 1 \u0026amp; 4\\\\ -1 \u0026amp; 9 \\end{vmatrix} = \\left ( 9-\\left ( -4 \\right ) \\right )=13 $。因此 $ \\mathbf{C}_{23}=\\left ( -1 \\right )^{2+3}\\cdot M_{23}=-13$。\n引理3：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，由代数余子式组成的新的矩阵，称为该矩阵的余子矩阵。记作 $\\mathbf{C}$。\n引理4：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，定义它的转置矩阵 $\\mathbf{A^{T}}$。转置矩阵 $\\mathbf{A^{T}}$ 可以通过下列操作得到：把 $\\mathbf{A}$ 的横行写为 $\\mathbf{A^{T}}$ 的纵行，把 $\\mathbf{A}$ 的纵行写为 $\\mathbf{A^{T}}$ 的横行。\n例：$ \\begin{bmatrix} 1 \u0026amp; 2\\\\ 3 \u0026amp; 4 \\end{bmatrix}^{T}=\\begin{bmatrix} 1 \u0026amp; 3\\\\ 2 \u0026amp; 4 \\end{bmatrix} $。\n引理5：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，它的余子矩阵 $\\mathbf{C}$ 的转置矩阵称为矩阵 $\\mathbf{A}$ 的伴随矩阵。记作 $\\mathbf{A^{*}}=\\mathbf{C^{T}}$。\n例：对于矩阵 $ \\mathbf{A}=\\begin{bmatrix} a \u0026amp; b\\\\ c \u0026amp; d \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。\n解：$ \\mathbf{A^{*}}=\\begin{bmatrix} \\mathbf{C}_{11} \u0026amp; \\mathbf{C}_{12}\\\\ \\mathbf{C}_{21} \u0026amp; \\mathbf{C}_{22} \\end{bmatrix}^{T}=\\begin{bmatrix} \\mathbf{M}_{11} \u0026amp; -\\mathbf{M}_{12}\\\\ -\\mathbf{M}_{21} \u0026amp; \\mathbf{M}_{22} \\end{bmatrix}^{T}=\\begin{bmatrix} d \u0026amp; -c\\\\ -b \u0026amp; a \\end{bmatrix}^{T}=\\begin{bmatrix} d \u0026amp; -b\\\\ -c \u0026amp; a \\end{bmatrix}$。\n例：对于矩阵$ \\mathbf{A}=\\begin{bmatrix} a_{11} \u0026amp; a_{12} \u0026amp; a_{13}\\\\ a_{21} \u0026amp; a_{22} \u0026amp; a_{23}\\\\ a_{31} \u0026amp; a_{32} \u0026amp; a_{33} \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。\n解：$$\\begin{align*} \\mathbf{A^{*}} \u0026amp;=\\begin{bmatrix} \\mathbf{C}_{11} \u0026amp; \\mathbf{C}_{12} \u0026amp; \\mathbf{C}_{13}\\\\ \\mathbf{C}_{21} \u0026amp; \\mathbf{C}_{22} \u0026amp; \\mathbf{C}_{23}\\\\ \\mathbf{C}_{31} \u0026amp; \\mathbf{C}_{32} \u0026amp; \\mathbf{C}_{33} \\end{bmatrix}^{T}\\\\ \u0026amp;=\\begin{bmatrix} \\mathbf{M}_{11} \u0026amp; -\\mathbf{M}_{12} \u0026amp; \\mathbf{M}_{13}\\\\ -\\mathbf{M}_{21} \u0026amp; \\mathbf{M}_{22} \u0026amp; -\\mathbf{M}_{23}\\\\ \\mathbf{M}_{31} \u0026amp; -\\mathbf{M}_{32} \u0026amp; \\mathbf{M}_{33} \\end{bmatrix}^{T} \\\\ \u0026amp;= \\begin{bmatrix} \\begin{vmatrix} a_{22} \u0026amp; a_{23}\\\\ a_{32} \u0026amp; a_{33} \\end{vmatrix} \u0026amp; -\\begin{vmatrix} a_{21} \u0026amp; a_{23}\\\\ a_{31} \u0026amp; a_{33} \\end{vmatrix} \u0026amp; \\begin{vmatrix} a_{21} \u0026amp; a_{22}\\\\ a_{31} \u0026amp; a_{32} \\end{vmatrix}\\\\ -\\begin{vmatrix} a_{12} \u0026amp; a_{13}\\\\ a_{32} \u0026amp; a_{33} \\end{vmatrix} \u0026amp; \\begin{vmatrix} a_{11} \u0026amp; a_{13}\\\\ a_{31} \u0026amp; a_{33} \\end{vmatrix} \u0026amp; -\\begin{vmatrix} a_{11} \u0026amp; a_{12}\\\\ a_{31} \u0026amp; a_{32} \\end{vmatrix}\\\\ \\begin{vmatrix} a_{12} \u0026amp; a_{13}\\\\ a_{22} \u0026amp; a_{23} \\end{vmatrix} \u0026amp; -\\begin{vmatrix} a_{11} \u0026amp; a_{13}\\\\ a_{21} \u0026amp; a_{23} \\end{vmatrix} \u0026amp; \\begin{vmatrix} a_{11} \u0026amp; a_{12}\\\\ a_{21} \u0026amp; a_{22} \\end{vmatrix} \\end{bmatrix}^{T}\\\\ \u0026amp;=\\begin{bmatrix} \\begin{vmatrix} a_{22} \u0026amp; a_{23}\\\\ a_{32} \u0026amp; a_{33} \\end{vmatrix} \u0026amp; -\\begin{vmatrix} a_{12} \u0026amp; a_{13}\\\\ a_{32} \u0026amp; a_{33}\\end{vmatrix} \u0026amp; \\begin{vmatrix} a_{12} \u0026amp; a_{13}\\\\ a_{22} \u0026amp; a_{23} \\end{vmatrix}\\\\ -\\begin{vmatrix} a_{21} \u0026amp; a_{23}\\\\ a_{31} \u0026amp; a_{33} \\end{vmatrix} \u0026amp; \\begin{vmatrix} a_{11} \u0026amp; a_{13}\\\\ a_{31} \u0026amp; a_{33} \\end{vmatrix} \u0026amp; -\\begin{vmatrix} a_{11} \u0026amp; a_{13}\\\\ a_{21} \u0026amp; a_{23} \\end{vmatrix}\\\\ \\begin{vmatrix} a_{21} \u0026amp; a_{22}\\\\ a_{31} \u0026amp; a_{32} \\end{vmatrix} \u0026amp; -\\begin{vmatrix} a_{11} \u0026amp; a_{12}\\\\ a_{31} \u0026amp; a_{32} \\end{vmatrix} \u0026amp; \\begin{vmatrix} a_{11} \u0026amp; a_{12}\\\\ a_{21} \u0026amp; a_{22} \\end{vmatrix} \\end{bmatrix} \\end{align*} $$ 其中 $\\begin{vmatrix} a_{im} \u0026amp; a_{in}\\\\ a_{jm} \u0026amp; a_{jn} \\end{vmatrix}=a_{im}\\cdot a_{jn}-a_{in}\\cdot a_{jm}$。\n例：对于矩阵 $\\mathbf{A}=\\begin{bmatrix}-3 \u0026amp; 2 \u0026amp; -5\\\\ -1 \u0026amp; 0 \u0026amp; -2\\\\ 3 \u0026amp; -4 \u0026amp; 1 \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。\n解：通过计算不难得出 $\\mathbf{A^{*}}=\\begin{bmatrix} -8 \u0026amp; 18 \u0026amp; -4\\\\ -5 \u0026amp; 12 \u0026amp; -1\\\\ 4 \u0026amp; -6 \u0026amp; 2 \\end{bmatrix}$。\n引理6：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，它的逆矩阵 $\\mathbf{A^{-1}}$ 与伴随矩阵 $\\mathbf{A^{*}}$ 满足 $ \\mathbf{A^{-1}} = \\frac{\\mathbf{A^{*}}}{\\begin{vmatrix} \\mathbf{A} \\end{vmatrix}} $。其中 $ \\begin{vmatrix*} \\mathbf{A} \\end{vmatrix*} $ 为矩阵 $\\mathbf{A}$ 的行列式。\n例：对于矩阵 $\\mathbf{A}=\\begin{bmatrix} 3 \u0026amp; 2\\\\ 2 \u0026amp; 1 \\end{bmatrix}$，求它的逆矩阵 $\\mathbf{A^{-1}}$。\n解：$\\mathbf{A^{*}}=\\begin{bmatrix} 1 \u0026amp; -2\\\\ -2 \u0026amp; 3 \\end{bmatrix},\\begin{vmatrix} \\mathbf{A} \\end{vmatrix}=\\begin{vmatrix} 3 \u0026amp; 2\\\\ 2 \u0026amp; 1 \\end{vmatrix}=-1,\\mathbf{A^{-1}}=\\frac{1}{\\begin{vmatrix} \\mathbf{A} \\end{vmatrix}}\\cdot \\mathbf{A^{*}}=\\begin{bmatrix} -1 \u0026amp; 2\\\\ 2 \u0026amp; -3 \\end{bmatrix}$。\n例：对于矩阵 $\\mathbf{A}=\\begin{bmatrix} 3 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 2 \u0026amp; -1\\\\ -1 \u0026amp; -1 \u0026amp; 1 \\end{bmatrix} $，求它的逆矩阵 $\\mathbf{A^{-1}}$。\n解：$\\mathbf{A^{*}}=\\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1\\\\ 2 \u0026amp; 3 \u0026amp; 3\\\\ 3 \u0026amp; 4 \u0026amp; 5 \\end{bmatrix},\\begin{vmatrix} \\mathbf{A} \\end{vmatrix}=\\begin{vmatrix} 3 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 2 \u0026amp; -1\\\\ -1 \u0026amp; -1 \u0026amp; 1 \\end{vmatrix}=1,\\mathbf{A^{-1}}=\\frac{1}{\\begin{vmatrix} \\mathbf{A} \\end{vmatrix}}\\cdot \\mathbf{A^{*}}=\\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; 1\\\\ 2 \u0026amp; 3 \u0026amp; 3\\\\ 3 \u0026amp; 4 \u0026amp; 5\\end{bmatrix}$。\n运用伴随矩阵来求解逆矩阵会方便很多，尤其是对于高阶矩阵。且使得逆矩阵的求法有规律可循，不需要死记公式。\n","date":"2013-04-29T15:30:00+08:00","image":"https://ivy-end.github.io/p/application-of-adjoint-matrix-in-inverse-matrix-solution/images/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_3799990_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/application-of-adjoint-matrix-in-inverse-matrix-solution/","title":"浅谈伴随矩阵在逆矩阵求解中的应用"},{"content":"description: \u0026ldquo;本文介绍了欧拉公式在富勒烯及其衍生物中的应用，特别是如何通过欧拉公式计算其中的五边形、六边形及单键的个数。\u0026rdquo;\n前几天在做化学竞赛初赛试题时遇到一道关于富勒烯衍生物的习题。大意是求 $\\mathrm{C_{50}Cl_{10}}$ 中单键的个数。但是去问浦建芳，她把施锦元叫了上来，大师兄便给我讲了欧拉公式。当天晚上没有完全弄清楚，回家谷歌以后，现在将内容整理如下。（以 $\\mathrm{C_{50}Cl_{10}}$ 为例）\n1、求 $\\mathrm{C_{50}Cl_{10}}$ 中五边形以及六边形的个数 这类题目可以应用欧拉公式，设 $\\mathrm{C_{50}Cl_{10}}$ 中存在 $x$ 个五边形及 $y$ 个六边形。由欧拉公式可以得到结果：\n$$ \\begin{cases} 50+x+y=\\frac{5x+6y}{2}+2 \\\\ 50\\times \\frac{3}{2}=\\frac{5x+6y}{2} \\end{cases}\\Rightarrow \\begin{cases}x=12 \\\\ y=15\\end{cases} $$\n2、求 $\\mathrm{C_{50}Cl_{10}}$ 中单键的个数 对于这类题目，可以考虑这样的一个加成反应：$\\mathrm{C_{50}+5Cl_{2}} \\rightarrow \\mathrm{C_{50}Cl_{10}}$。这样的话，我们可以首先考虑 $\\mathrm{C_{50}}$，根据（1）中方法求出其中五边形以及六边形的个数。从而得到一共有 75 根碳碳键。\n考虑到 $\\mathrm{C_{50}}$ 中每个碳原子边上有两个碳碳单键一根碳碳双键，即可得到碳碳单键数目是碳碳双键数目的两倍。这样可以确定 $\\mathrm{C_{50}}$ 中有 50 根碳碳单键，25 根碳碳双键。\n接着考虑加成的过程，在上述加成反应的过程中，断开了 5 根碳碳双键，这样就新形成了 5 根碳碳单键，从而得到 $\\mathrm{C_{50}Cl_{10}}$ 中共有碳碳单键 55 根。\n","date":"2013-04-21T14:12:00+08:00","image":"https://ivy-end.github.io/images/cover.jpg","permalink":"https://ivy-end.github.io/p/application-of-euler-formula-in-fullerenes-and-derivatives/","title":"浅谈欧拉公式在富勒烯及其衍生物中的应用"},{"content":"好久没更新博客了。英语课上把博客地址写在了黑板上，不知道郭华老师和周红娟老师会不会光临这么一个小角落。第一反应是博客的访问量可能会增加，接着就想到：如果周红娟老师看到我写的这些文章，岂不是贻笑大方。\n先来说说卖泡面的事情吧。经过一个寒假的考虑和筹划。准备这个学期搞得稍微正规点。所以在开学的时候准备发行债券，无奈去年出现一例质量问题，所以没人敢买债券。既然这条融资途径无效，那么只能自己先垫出一部分。于是乎，昨天又去进货了，而且列了进货清单。还得感谢 Microsoft OneNote——这款平时用来记笔记的软件，在这种情况下也可以用来记录销售情况。\n前段时间给自己的小卖部起了个名字——斯凯泰。开发了一个网上订购系统，主要解决有的时候同学来买泡面，却发现水不够了，或者卖完了。通过网上订购系统，可以提前预订，这样就可以预留出订购者所需要的数目。网站做的很简单，只是实现了基本功能。\n对于卖泡面，完全没有什么资本家的意思。只是为了娱乐一番，同时积累积累经验。所以这学期价格会有所下调。\n时间过得好快，转眼一年又过去了。昨天晚上黄旸洋打来电话，聊了好久。彼此好久没联系了，但还是感觉那么亲近，或许这就是王勃所说的“海内存知己，天涯若比邻。”吧。聊的内容自然无外乎那几样，只是感觉大家似乎变了，似乎又没变。他还提起了很久以前的一个项目，重新做一下初中的毕业视频。他说，为了这个，他在学 PS, PR, AE。一直有这么一个想法，只是心有余而力不足。现在总算空下来了，也该把这个未完成的项目继续下去。\n通知：\n烦请张家港市常青藤实验中学 2011 级初三（3）班的同学将你们对于接下来我和黄旸洋合作的这一毕业视频提供可行性建议以及必要的素材。建议包括整体构思，画面效果等；素材包括图片，声音，文字，视频等。一切内容请发到邮箱：admin@ivy-end.com，发送时请注明姓名。\n小高考结束以后，的确像玉米他们所说，很空。数学，化学，生物三门竞赛的轮番轰炸让人喘不过气来。对于生物竞赛，没有资料，也未曾深入了解，所以只能作罢。对于数学和化学，倒是有希望出线。但是一节晚自习只能做两道不等式或者 15 道化学选择题。这的确让人感到无奈。\n化学很多内容没教过，工艺流程完全不会。而且化学反应平衡和离子反应都没讲，很多以前学过的都忘记了。不过想想也对，如果这么简单就让我们过了初赛，那岂不是太看不起化学竞赛了。只是一点想不通，为什么数理化生初赛学校都会派出分母，而我们信息学却完全没有。而且我们的试卷费只要 10 元。\n这段比较空闲的时间应该规划一下，好好利用。语文上的古诗，的确挺诗情画意的，但是我们却始终无法达到唐人的那种境界，只能以一种仰望的姿态去欣赏。首先当然是数学竞赛，好好准备一下吧。其次，最近冒出一个很奇怪的想法，想系统的看一下关于中医方面的书。或许只是想法吧。\n宿舍又扣分了，作为室长的我免不了背黑锅。权利和义务是相统一的嘛。\n古人云：一日三省吾身。最近又冒出一个想法，还是关于理性和感性的问题。或许大多数在不涉及原则问题的情况下还是感性比理性更为好吧。很多事情没必要寻根问底。以前可能太过于理性了吧。有个称呼叫死理性派。这样不好。\n我也不知道自己写了些什么，感觉最近一段时间，想说的内容很多，却发现写不下来什么了。\n好吧，先到这。\n","date":"2013-04-04T20:02:00+08:00","image":"https://ivy-end.github.io/p/miscellaneous-notes-20130404/images/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_2705979_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/miscellaneous-notes-20130404/","title":"杂记（20130404）"},{"content":"高中的一个重要的转折点——小高考，就这样过去了。写下一篇日志来记录一下小高考复习期间的一些感受和想法。打点计时器真可谓是人类一项伟大的发明。\n这段时间，思考了很多，体会了很多，感悟了很多。且听我慢慢道来。\n江畔何人初见月？江月何年初照人？\n人生代代无穷已，江月年年只相似。\n短短的四句诗，却透出了人生渺小宇宙无限的感慨。我们终究是很渺小的，微不足道，试问千万年后，我们又在哪里呢？生命是那么渺小，于己，对于这个世界，我们有多大的意义呢？或许最大的意义就是不要让生命留下遗憾吧。于他，我们又为何要让俗世凡尘的喧杂打搅了平静的内心呢。或许庄子是正确的，我们的确应该逍遥游。感觉很多事情是没有结果的，很多事情是徒劳无功的。是我超脱了，还是我才是真正蒙在鼓里的人。或许我们都只是上帝的玩偶，不幸的是，上帝喜欢掷骰子。突然想起一首诗：\n虞美人·听雨 —宋·蒋捷\n少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低断雁叫西风。\n而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前点滴到天明。\n人生无常，总有许多美好的事物，在你还没来得及珍惜的时候悄然逝去，不论是亲人，信念，抑或其他。而对于我们，所能做的，也唯有好好珍惜每一天吧。一直很欣赏乔布斯的一句话“记住你即将死去。”，但是我始终无法做到。或许是因为他的经历使然吧。\n对于人生的思考大概就是这样了，接下里就是对马克思主义哲学的怀疑了。\n首先，根据“矛盾是普遍的。我们要用一分为二的观点看问题。”那么，马克思主义哲学是否具有另一面呢。这不禁引起了我的思考。后来，对这一原理越来越感到不可信，事事有矛盾，时时有矛盾。而且还要求我们用联系，发展，全面的观点看问题，试问，这样一来，岂不是陷入了相对主义的泥潭？再者，马克思主义哲学中的辩证法是从黑格尔那里继承下来的。大家都知道，黑格尔是近代西方唯心主义的集大成者。而对于这一继承，居然只是简简单单的说“马克思主义哲学剔除了黑格尔辩证法中唯心主义的成分”，这显然是不现实的。所以说辩证法有唯心主义的漏洞，这也就很容易解释为什么它会陷入相对主义了。\n对于世界观这一方面，我比较倾向于老子。对于庄子也有些可借鉴之处。\n以上便是我最近思想方面的记录了。下面主要来谈谈生活和学习方面的吧。\n最让我感到吃惊的是历史成绩吧，从一模 53 到二模 77 再到三模 85 。该怎么评价这件事情呢，该说我有潜力呢，还是该说我以前根本不认真呢。刚开始觉得半个月背书一定很无趣，没想到还真挺充实的。因为一根弦紧绷着，就没时间去管别的了。\n考试前一天，感冒了，到了晚上发烧。幸好及时吃了退烧药。虽然考试的时候没有头痛，但还是感到很困。不过到了下午考生物的时候已经基本清醒了，至于政治，其实没什么区别，因为用不着动脑子，只要把背的搬上去。总之，小高考已经考完了，对于过程，无怨无悔。至于结果怎么样，还是得看运气。\n越来越有种感觉，考试结果，和水平没有太大的关系，最主要的是运气。就好比上次有一场比赛，一位神犇辛辛苦苦花了一个多小时写了几百行代码，0 分；一位蒟蒻，几分钟写了个随机数，100 分。这就是运气。我们无法把握，因为是上帝在掷骰子。人生的戏剧性就在于，你可以努力的很多很多，虽然它占据了 99% 的比例，但取决定作用的 1% 却在上帝手中。就好比爱迪生的名言“成功是 99% 的勤奋加上 1% 的天才，但往往那 1% 是最重要的”。\n以后我再也不用知道如何促进我国国民经济又好又快发展了\n以后我再也不用知道如何正确看待反经济全球化了\n以后我再也不用知道如何防治我国西北荒漠化了\n以后我再也不用知道生一个即患白化又患色盲的孩子的概率了\n这究竟是福是祸，以后我们就再也见不到小四门老师了。马静华，翟玉明，盛费兵，张书玉。学了那么多仅仅是为了一场考试？突然想起中考，是淡淡的忧伤吗？\n不管怎么说吧，既然考完了，也就过去了。感觉一个人突然松了下来。又发现还有很多事情等着我去处理，不管是生活，学习，竞赛。是该好好缕缕了。接下来应该要开始准备自招吧。也不知道玉米考的咋样，到现在也不透个风声。为了吸取了玉米来不及准备的经验，所以过一段时间就开始吧。至于竞赛，张兴让我给高一竞赛的上课。所以还要做课件。讲课对于自己巩固所学，的确很有帮助。主要讲数据结构。\n好了，就这样吧。\n接下来的道路会更崎岖。\n","date":"2013-03-17T19:30:00+08:00","image":"https://ivy-end.github.io/p/reflections-on-mini-gaokao/images/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_768635_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/reflections-on-mini-gaokao/","title":"为小高考打个点"},{"content":"先来谈谈最近很火的《新笑傲江湖》吧。抱着对金庸小说《笑傲江湖》的喜爱，尝试得看了第一集，细细的看了第二集，忍耐的看了第三集，然后，就没有然后了。\n首先引用一些外界评论吧：\n看于正才知张纪中厚道\n大家都知道，张纪中拍摄的《新西游记》对原著改变有点大，所以放映出来大家反应很强烈。当时也尝试性得看了几集《新西游记》，还可以接受一部分。但是《新笑傲江湖》简直无法直视。没看到几个原著中的剧情。还有人物塑造方面，就拿令狐冲来说吧，毫无洒脱、侠义之气，说文明些，完全就是一个嬉皮士。当然这是由于我们和编剧的世界观差异导致的。最主要的问题是色彩绚丽，华而不实，毫无一点武侠的痕迹。而且很多台词不符合客观规律。不论是改编的内容还是剧中传递出来的一种精神，都与原著差距甚远。可能编剧只是考虑到了部分受众的喜好以及经济利益吧。\n再来看看很久以前金庸接受南方周末采访的记录，虽然是家比较早，但却可以看出金老先生对改编电视剧的态度：\n南方周末：您的作品大部分被改成了电视剧和电影，早期的香港版追求娱乐性，台湾版追求煽情，大陆版看重的是小说的道德意识和精神高度，正剧色彩比较浓，您喜欢哪一种风格的改编？\n金庸：小说是当文学作品来看的，人家都说文学作品有真、善、美的追求，在作品里我只追求美的范畴，跟真、善没有关系，把我所喜好的所见的美好融到作品里面去。两岸三地拍电视剧我不关心，他们追求什么样的风格，和他们的市场有关，跟我没有关系，人家喜欢拍就拍，我只关注电视剧是否忠实于小说原著，这一点我比较在乎。\n再引用金庸以前接受采访时说过的一句话：\n那些作品都好比是我的儿子，而改编就好比他要出远门，把儿子托付给别人照顾，结果回家时发现儿子被打得面目全非。\n对于一部电视剧的看法与个人世界观以及以往接触的人、事、物都有关系，所以对于《新笑傲江湖》，虽然不喜欢看，但它总有存在的意义，或积极，或消极。如若想真正品味《笑傲江湖》，还是推荐看原著。至于这本书，我的感想很多，有很多细枝末节的感触，大体就像《笑傲江湖李亚鹏版》的插曲《天地作合》所描述的那样吧——凌万物而超脱。\n扯远了。最近在思考一些问题，好像有点宽泛而且不切实际，却着实让自己感到迷茫。算是哲学范畴的吧——我们如何才能在这个世界上活得更有意义？\n只有献身社会，才能找出那实际上最短暂而有风险的生命的意义。——爱因斯坦\n人的意义在于为社会创造出价值，从而以人类的进步推动社会的进步。——马克思\n生命是有限的，但为人民服务是无限的，我要把有限的生命投入到无限的为人民服务之中去。——雷锋\n类似的话语还有很多，那么当时间以万亿年为尺度向前行进，那么现在的人类社会又会在哪里呢？我们对社会的贡献、付出有在哪里呢？难道我们就应该享受生活，放任自流？整日这样的生活未免像一潭死水，太无趣。那我们到底在追求什么呢？或许这就是短暂生命和永恒宇宙的矛盾吧。我们该怎么做呢，思前想后，还是感到活在当下，不留遗憾最为实际。至于怎么活，Steven Jobs 的观点十分值得借鉴：\nFollow your heart. Stay hungry, stay foolish.\n或许思考这些没有太多的现实意义，但的确可以让自己找到一点方向。每天，太阳还是依旧升起，一切还是依旧，所以也就没必要想那么多了。接着再来说一些感悟吧。假期不知不觉就过去了，曾经在《呓语（一）：无题》中引用过一句话：\n而放假绝不是最终的出路，因为我们并没有假期，所谓的假期也只是自我欺骗。\n当时仅仅觉得这句话很有意味，这几天却突然领悟了。人生就像一场旅行，我们需要不断拼搏，所谓的假期，只是另外一种形式的奋斗罢了。这些动力，并不仅仅是为了 4A。\n再说说前几天修改的网站副标题——“上善若水，大道至简。”。第二句很容易理解，主要谈谈第一句：\n上善若水。水善利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，政善治，事善能，动善时。夫唯不争，故无尤。——老子《道德经》\n翻译想必是没有必要了。其中几句值得斟酌，“处众人之所恶，故几于道”。是因为“处众人之所恶”导致了“故几于道”还是“故几于道”引起了“处众人之所恶”？个人认为可能是后者，在当代社会中，毕竟糊涂人远多于明白人，而明白人中又有糊涂人。所以说真正的明白人才可以达到“故几于道”的境界。但这样又产生了一个问题，我们首先参考一下马克思主义哲学的相关内容：\n物质决定意识，意识对物质具有反作用。\n价值观作为一种社会意识，对社会存在具有重大的反作用，对人们的行为具有重要的驱动、制约和导向作用。\n价值观对人们认识世界和改造世界的活动具有重要的导向作用。\n价值观对人生道路的选择具有重要的导向作用。\n有了这些内容作为指导，我们不难得出，当那些真正的明白人到达一定境界时，所作所为就会与常人不同。而这时候人们却常常鄙夷的称他们清高。岂不冤哉？（排除某些故意装作清高之人，此类人无法称之为明白人）这类问题在生活中经常出现，两个世界观不同的人争论问题是毫无意义的。世界观在不违背到的前提下本没有对错。面对这些，还是那句老话：\n穷则独善其身，达则兼济天下。\n有个比较远的话题吧——人生漫漫长路，会遇到很多人，很多事，我们怎么面对现在呢？欢迎来这里讨论。\n扯了好多，这也许就是我目前的思想状态吧。\n最后推荐几个网站吧：\n果壳网·科技真有意思 SegmentFault Stack Overflow ","date":"2013-02-21T20:49:00+08:00","image":"https://ivy-end.github.io/p/miscellaneous-notes-20130221/images/cover_hu0411f91d919d890909c078c099858ea7_135242_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/miscellaneous-notes-20130221/","title":"杂记（20130221）"},{"content":"由于各种各样的原因，之前很多次向 Linux 迁移的计划未能实现。主要是因为有些程序只能在 Windows 上运行，比如我们最常用的 QQ。此次迁移的主要原因和以往大致相同：\nWindows 系列的系统臃肿而且不实用，很多东西华而不实。 Windows 系列的系统及其程序属于商业行为，为了追求自由、共享和开源。 我选择的是 Ubuntu 12.04 LTS，主要还是看中了 LTS（Long Term Support），这样可以获取更长时间的技术支持。\n安装过程就略过不提了。我采用的是 USB 安装，毕竟刻录光盘很奢侈。将移动硬盘分出一个 4GB 的分区，然后用 Universal USB Installer 写了启动引导，接下去的过程就很简单了，因为都是 GUI 界面，相对容易些。\n装完系统就是折腾了，Linux 就是用来折腾的。下面慢慢介绍。\n换上 Gnome3 由于 Ubuntu 自带的 Unity 界面非常不稳定，主要是个人不喜欢那种风格。所以毅然决然的换了 Gnome3。由于 Ubuntu 早已将其加入到了软件源中，所以直接 apt-get 就可以了。\n1 sudo apt-get install gnome-shell 安装结束以后就可以使用了。可能是个人癖好吧，我还是把 Unity 删了，命令如下：\n1 2 3 4 5 sudo apt-get --auto-remove purge unity sudo apt-get --auto-remove purge unity-commonp sudo apt-get --auto-remove purge unity-lens* sudo apt-get --auto-remove purge unity-services sudo apt-get --auto-remove purge unity-asset-pool 切记不可使用这条命令：\n1 sudo apt-get --auto-remove purge unity* 因为把所有关于 Unity 的东西都删除以后会无法进入系统。这样就基本完成了桌面的更换，为了操作方便，我们还需安装一个软件来配置 Gnome3 桌面：\n1 sudo apt-get install gnome-tweak-tool 软件整理 这个方面主要包括卸载一些不必要的软件以及安装一些必要的软件。卸载就不多说了，这是个智者见智，仁者见仁的事情。主要将一下软件安装。\n浏览器使用谷歌的 Chromium，输入法也使用了谷歌的 googlepinyin。个人很喜欢谷歌，简洁而且功能强大。\n接下去主要讲解一下在 Ubuntu 上使用 QQ 的方法——不用整天网页挂 WebQQ，不用 Wine。\n众所周知，在 Linux 下有一款支持多种即时通讯账户的软件叫做——Pidgin，默认不支持 QQ，我们只需要安装一个插件就行了。\nStep 1：安装 Pidgin 1 sudo apt-get install pidgin Step 2：安装插件 pidgin-lwqq 1 2 3 sudo add-apt-repository ppa:lainme/pidgin-lwqq sudo apt-get update sudo apt-get install libpurple0 pidgin-lwqq Step 3：Enjoy it! 不得不说，Pidgin 真是解决了一个大难题，因为很多同学都在用 QQ，所以不用 QQ 也很难取得联系。有了这款软件就方便多了。接下来是下载软件，我选择了 aria2。一来是终端模式的，看起来舒服；二来支持断点续传；这两样加起来也足够了。而且速度也很快。安装方法：\n1 sudo apt-get aria2 使用方法：\n1 2 3 4 5 #一般使用 aria2c #分段下载 为分段数目，取值介于1~5之间 aria2c -s #断点续传 aria2c -c #下载BitTorrent文件 aria2c -o 至于编程，已经做好放弃 VS 之类的准备了，转战 QT。主要方面应该是跨平台应用和网页开发吧。\n","date":"2013-02-18T20:35:00+08:00","image":"https://ivy-end.github.io/p/linux-migration-part-1/images/cover_huadbb670b28d18d83ed0fbaeabb5c3347_40266_120x120_fill_box_smart1_3.png","permalink":"https://ivy-end.github.io/p/linux-migration-part-1/","title":"Linux 迁移记（一）"},{"content":"其实这应该是很早以前写的，但是一直没时间静下来。\nNOIP 2012 复赛备战期间，让我体会到了什么是真正的刷题，这远比期末每天好几张的试卷来的恐怖。刷题，不仅仅是整日做题目，这只是基础。重要的是对于每道做过的题目做完后探寻更简便的方法来解决它。而且刷题注重的是效率，一道题刷过就必须 Accepted。任何不起眼的错误导致的 Wrong Answer 都必须避免。回想起那段刷题时光，现在的状态与那时相比，恐怕相差甚远。\n对于作业，还有些话要讲，首先引用一位神犇的分析：\n做作业的悲剧性在于，我们用有限的生命，去完成无限的作业。更可悲的是，速度或快或慢都无济于事——或因一日的拖延便往后日日无法完成当日作业，抑或是日日赶超但仍需要完成作业。悲剧的根源在于，以我们的微薄之力，一日完成的作业量不变，但所发作业却以亘古不变的步伐一日一日向前迈进。我们终究无法完成所有作业，终究会明白，最好不过是今日完成今日的作业，而所谓「急功近利」地积极完成明日作业，在作业们眼中看来，不过是可笑的雕虫小技。\n而放假绝不是最终的出路，因为我们并没有假期，所谓的假期也只是自我欺骗。\n但终有一日，什么都不会有意义，这也正是我们所恐惧地期盼之日。\n因此，每次发完作业，总是没日没夜做作业的，不能称之为刷题，而只能说是在运行程序罢了，因为他们沿着作业预算好的轨迹低头拉车，却从未抬头看天。仔细想来，低头拉车，抬头看天，本是一对客观矛盾。根据马克思主义哲学的科学指导，不难的出，在不同条件下，矛盾主次双方可以相互转化。我们不能一味低头拉车，这样只能成为程序，也不能一味抬头看天，这样只是好高骛远。由此得出，在适当的条件下，做适当的转化是非常有必要的。所谓“独阴不生，独阳不长”大概也可以从这个角度来理解吧。\n所谓假期，只是不受学校朝六晚十的时间约束，可以自由安排时间罢了。除去此项，或许放假与不放假也没头太大区别吧。但是，这项确是非常重要的。当然，自由安排也是“仁者见仁，智者见智”。自从两年前和游戏断绝以来，唯一可以打发时间的事情便成了阅读。这两年也发现，阅读，确实给了我们一片非常广阔的天地。一个午后，一本书，一杯水，就可以打发一个下午。在诸多类别的书籍中，个人尤爱哲学、历史。哲学的书总是给人对生命的思索，不停的回答着同样的问题：人生的意义何在？史书则可以不断给人以思索，唐太宗说到“以史为镜可以知兴替”。在 21 世纪的今天，我们虽然不用经历古代的战火纷飞，但是历史仍然给我们以启发，教给我们以做人的道理和是非的标准。文学类的文本个人觉得更多的是呼唤我们对于周围生活的关注。这些不能也不该成为炫耀的资本，而应该作为一种个人内在的修养积淀下来。看着别人大谈《孙子兵法》，批判老庄，笑而不语。一来他们在意的不是你说的道理，而是你不同意他们的观点，二来既然他们得出这种观点，那么以他们目前的阅读积累应该无法理解你的看法。\n在《苏东坡传》上看到林语堂老先生的一个观点，这里只能大致叙述一下了。世界上有两种人，一种市侩小人，整日说结论性话语；一种正人君子，会先分析问题，再给出参考性方案。但是现在社会太“急”，人们只在乎结果，而完全不注意过程，也就导致了小人横行，君子遭贬。这也是一件好事，因为小人，君子自此各司其职，都不违背各自的心愿。小人喜欢势利，居庙堂之高；君子独善其身，处江湖之远。结果只可能是朝政败坏，改朝换代。把这个观点运用到当代社会，或许大家也就明白一二了。无奈的是国民就是喜欢结果，就是喜欢听结论性话语。\n再来说说“友谊”吧。关于这个话题，仅仅是个人看法，不全面，因为无法将各个方面详尽表述出来。\n以前还是挺相信友情的，当然，也不是说现在不相信了。也交了很多朋友。当时大家都挺聊得来的，一些小事也可以相信的。但是，似乎忽视了中国古代劳动人民的思想成果“路遥知马力，日久见人心”、“患难见真情”。很多很多所谓的朋友，到后来，在你最关键的时刻，过河拆桥算是留情面了，有时会突然在背后捅你一刀。这又可以分为两种，一种是十分明显的，真刀实干。第二种是放冷箭，所谓“明枪易躲，暗箭难防”。这个从很多武侠小说中也可以得到证明，就比如《笑傲江湖》吧，定逸师太被岳不群杀死时，说的是“是你？”，显然，她也是被暗算了。如果她不认识凶手，应该说的是“你是？”。这样也就造成了许许多多的逢场作戏。对于此类问题，还是玉米的方法比较有效“你若对我报以真诚的微笑，我也回应你真诚的微笑；你若对我报以虚假的微笑，我也回应你真诚的微笑。”，有时候，心胸还是应该开阔，所谓“退一步海阔天空”，这些事情只不过给了我们一个看清事实真相的途径罢了。“害人之心不可有，防人之心不可无”。\n很多所谓“朋友”都只是逢场作戏罢了。冲突就发生在做戏的一方被看穿且毫不留情面的揭露出来，此人一定暴跳如雷，而且到处宣扬你的种种恶迹，毕竟“欲加之罪，何患无辞”。对于这些，笑笑罢了，“笑世间可笑之人，笑世间可笑之事”。因为任何一个人的评价，都必须由后世之人来评定，所有的当代人都只是当局者迷，当然也不排除自身个体。\n友情，还有一种同化功能，所谓“近朱者赤，近墨者黑”。一个个原本优秀的人因为善恶不分，交友不善，荒废了一生，这种事例实在多见。所以，择友时有一点很重要：慎重！\n好吧，到这里，呓语显现出来了，其实我也没看懂自己到底写了些什么。\n最后，还是想提一下张贤明，这个已经远离我们一年多的名字。\n以前想起他，想到的是他教育我们的各种阴损招数，以及他惩罚我们的种种办法。后来想起他，想到的是和他在一起的快乐时光，每节语文课，班会课。如今想起他，想到的是他说的那些话，突然感觉很有道理，很值得揣摩，推敲。\n印象最深的，莫过于“输不丢人，怕才丢人。”这句话，每每想到，都会想起 Steven Jobs 的名言“听从你内心的声音”，或许很多事情前思后想，只会是顾此失彼。看似不明智的奋力一搏，可能收获意想不到的结果。\n就到这吧。\n","date":"2013-02-04T21:28:00+08:00","image":"https://ivy-end.github.io/p/ramblings-untitled/images/cover_huebbfad1edfa8e198fe68a27ac6a615ca_60590_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/ramblings-untitled/","title":"呓语（一）：无题"},{"content":"迷迷糊糊，期末复习，小高考补课就这么过去了。不得不提一下数学，没想到啊。就这样，迎来了这一不寻常的寒假。最后一天突然下起了雨，似乎把一切繁杂和浮躁都冲洗而去。\n仔细算来，从今天到开学前一共还有 23 天。时间不容我们挥霍。像以往一样制定一个计划吧（当然不是学校里那种按天数来划的），以前总是写在纸上，这次就直接发到博客上吧。\n寒假作业 语文 练字（黑色钢笔）。 专题摘抄 3000 字，并写一篇书评。 预习《唐诗宋词选读》，背诵 14 篇，熟读 2 篇。 关注时事，写一篇社会评论。 数学 复习必修 2、选修 2-1、选修 2-2。 寒假作业（好像只要做几张综合卷）。 综合练习。 附加题练习。 自选一本与本学期有关试题。 英语 暂无。\n物理 暂无。\n化学 复习《有机化学基础》、《物质结构与性质》。 预习《化学反应原理》。 小四门（政、史、地、生） 背诵。 完成考点等练习。 由于开学后离学业水平测试只有十多天，所以小四门成为了寒假的主要矛盾。\n学习计划 语文 按要求完成作业。\n数学 按要求完成作业。 加强运算能力。 英语 作业日：一篇阅读、一篇完形、若干单选。\n物理 无。\n化学 预习《化学反应原理》。\n小四门（政、史、地、生） 作业日：认真背诵，完成练习。\n争取小四门 4A 吧。\n阅读计划 史记（中华书局 1959 年版） 数学（甲种本） 代数 第一册 电子技术基础 准备开始看二十四史，不知道能不能坚持下去。《史记》作为二十四史之首，而且和上学期教学内容相近，所以先看。甲种本的数学，纯粹是兴趣，也算是为了自招吧。电子技术基础，总是在电脑上写程序也挺没意思的，所以要和单片机结合起来。\nOI 计划 怎么说了，没什么动力了。没保送，去年拿了个全国复赛二等奖，自招资格是有了。所以 OI 也就放下来了。高三的话，看运气吧。\nEE 计划 制作 AM/FM 调频收音机。 DIY 太阳能便携式充电器。 制作摄像小车。 第三项可能来不及。\n杂项 坚持每周更新 blog。 其他的想到再说吧。\n寒假就这么开始了……\n","date":"2013-02-02T09:15:00+08:00","image":"https://ivy-end.github.io/p/winter-vacation-arrives/images/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_806561_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/winter-vacation-arrives/","title":"寒假，来了！"},{"content":"本文主要整理了《中国通史：诸葛亮治蜀》的解说稿。\n东汉末年，各个地方势力，各据一方，天下大乱。公元 208 年，在曹操百万大军的高压下，刘备派诸葛亮出使山东，与孙权结盟。孙刘联军在赤壁大破曹军，魏、蜀、吴三分天下之势初步形成。公元 219 年，刘备北伐，孙权偷袭荆州，杀死关羽，刘备北伐失败。公元 221 年，刘备亲率数万大军讨伐孙权，双方在夷陵相持。第二年，刘备被孙权的军队连连击败。夷陵之战惨败，刘备忧愤成疾。弥留之际，刘备将儿子刘禅，托付给诸葛亮，随即病逝。后主刘禅，封诸葛亮为武乡侯，领益州牧1，总理朝政。自此，举国重任，落在诸葛亮一人肩上。\n这是一条使命之船，船上的主人名叫邓芝2，在蜀汉政权中担任尚书。蜀汉建兴元年十月，也就是夷陵之战的第二年，邓芝受诸葛亮的委派，前往东吴。孙权背盟，偷袭荆州，按照一般的情理，蜀汉与东吴从此应该结下不共戴天的深仇大恨。然而，这时的诸葛亮，却做出了一个惊人的决策——再次与东吴结盟。\n赞曰：国家利益是国际关系的决定因素，只有永远的利益。面对强大的曹魏政权，蜀汉也只有和东吴结盟才得存活下去。\n这个时候的东吴政权，跟曹魏政权仍旧藕断丝连，是否接见邓芝，孙权心中犹豫不决。邓芝便给孙权写了封信，信中说道，自己今天来到这里，不仅是为了蜀汉的利益，也是为了东吴的利益。孙权读到这句话受到触动，决定接见邓芝。见面后，邓芝依照诸葛亮的嘱托，详细分析了当前的形势，阐明了吴与蜀唇亡齿寒的道理。很快，孙权跟曹魏断绝了藩属3关系，转而与蜀汉结为盟友。\n沈伯俊：蜀汉的开国君主，刘备去世以后，诸葛亮就面临着如何治理蜀汉的艰巨任务。经过荆州之失，夷陵之败，蜀汉的疆域，只剩下了一个益州。精兵良将折损过半，开国元勋逐步凋零，吴蜀同盟不复存在，就像诸葛亮后来在《出师表》里边讲的，天下三分，益州疲弊，此诚危急存亡之秋也。\n然而，就在所有人以为，蜀汉和东吴从此将和平相处，再无战事的时候，一个震惊天下的消息突然从东吴传来。这一次，诸葛亮的外交策略即将遭到前所未有的挑战。公元 229 年，孙权经过多年的犹豫后决定称帝。为了让自己这个皇帝能够得到蜀汉的认可，孙权决定先将此事通报蜀汉。消息传到蜀汉，一石激起千层浪，朝中群臣一片愤慨。自古天无二日，国无二主，只有蜀汉才是天下正统。曹贼窃国，必须诛而伐之。现在，孙权也要称帝，更是大逆不道，蜀汉应与之绝交，并且立即出兵讨伐。\n赞曰：孙权这一招妙极。此这个时候提出称帝，对于蜀汉来说从原则上是绝对不能接受的，但是又不得不接受。毕竟在这种时刻，生存才是蜀汉的主要矛盾。而孙权正好抓住了这一点。\n孙权称帝，到底应该如何应对，对于诸葛亮来说，这是一个两难的决定。如果要承认孙权这个皇帝，等于损害了蜀汉自身的正统性与合法性。如果不接受，那么两国将重新回到敌对状态，之前的努力将付之东流。然而，对于现在的蜀汉来说，根本无力承受任何一场大规模的军事行动。这是诸葛亮总理朝政以来，面临的最大的一次考验。\n楼劲：在一个通达的政治家看起来，你的意识形态立场，是要服从于你的现实利益的立场。这个时候他是为自我的生存着想。你要生存下去，你必须跟孙权、必须跟东吴政权保持一种联手的关系。否则你无法抗住北方的压力，因为北方现在越来越强大。\n愤怒的群臣终于被诸葛亮说服了。随后诸葛亮派出使臣，祝贺孙权称帝。孙权闻讯大喜，随即决定于蜀汉升坛歃盟，对天发誓，戮力同心，同讨魏贼。这样的结果，是蜀汉和东吴都很渴求的，而对于蜀汉来说，却显得更加重要。因为，当外部环境基本平稳之后，诸葛亮终于可以腾出手来，去解决一个令蜀汉头疼多年的问题，那就是，南中叛乱。\n这里是云南省西盟佤族自治县。这里居住着一支中国西南最古老的少数民族之一——佤族。每逢重大的民族节日，佤族人都会敲起木鼓，挥舞着战刀，跳着世代传承下来的舞蹈，以此纪念祖先的勇敢和不屈不挠的战斗精神。三国时期，整个云南、贵州和四川西南部都隶属于蜀汉政权，统称南中。南中地区世代居住着众多少数民族。东汉末年，腐败政权对南中地区搜刮无度，很多民众不断反抗，一些豪强趁机煽动叛乱，企图割据称雄。刘备当政时形势本有所好转，但在他病逝之后，一些豪强再次趁机叛乱。\n赞曰：典型的官逼民反。而且中国民众普遍思想意识落后，很容易被一些有非分之想的人利用，造反也就自然了。\n北有曹魏政权重压，南有豪强叛乱，南中之乱不平，蜀汉将两面受敌。诸葛亮决定亲自征讨南方。蜀汉建兴三年春三月，几万蜀兵，在诸葛亮的亲自率领下，浩浩荡荡地向南中地区进发。然而，要想征服这片广袤的荒蛮之地绝非易事。广大南中地区山高林密，危险重重，瘴疠之乡，到处都有充满敌意的眼睛。佤族人历来骁勇善战，每一次战胜敌人，他们都会用特别的仪式进行庆祝。然而，当诸葛亮进入南中之后，向来以凶悍著称的叛乱部队，却没有得到庆祝胜利的机会。他们在训练有素的蜀汉正规军面前，一触即溃，蜀汉大军很快向叛军首领孟获展开攻击，并最终将孟获擒住。让孟获想不到的是，诸葛亮虽然擒住了他，却并没有伤害他的意思，而是请他观看汉军阵营，孟获不以为然，对诸葛亮说，如果能放他回去再决一战，他一定可以打败诸葛亮。诸葛亮哈哈一笑，将孟获放走，约他择日再战。其实，在诸葛亮的心中，平定叛乱，绝不是依靠武力杀伐这么简单。对于南中，诸葛亮有着一个更为长远的打算。史书记载，诸葛亮七擒孟获，七纵孟获，最后，孟获输得心服口服，诸葛亮还要放他，孟获再也不肯回去了，说：公，天威也，南人不复反矣。\n赞曰：得民心者得天下。\n沈伯俊：诸葛亮在军事上发展非常顺利，因为他赢得了民心。得到了少数（民）族民众的欢迎，史书记载，建兴三年春南征，其秋悉平。到了秋天就全部平定了。\n收服孟获之后，南中各个部族纷纷归附。佤族人说，他们的祖先还与诸葛亮结下誓盟，生生世世镇守边关，永不叛乱。不过，结束叛乱只是平定南中的第一步。接下来，诸葛亮要真正开始实施自己对于南中的计划了。\n这里是云南省西盟佤族自治县爬街村。 1970 年代，尼桑老人，作为西盟民族工作队队长，被派到这里，帮助村民们发展农业生产。老人至今还记得，比他更老的老人们给他讲的关于诸葛亮的故事。\n尼桑：我主要是跟一个名字叫艾初（音）的一个老人，死了可能是十多年吧，还有一个叫艾桑（音）的，死了可能五六年了。按照他们说那些，佤族（语）说，也就是两千年以前，就在这个时候呢，因为（粮食）产量很低，他（诸葛亮）就教（我们）如何耕种，如何选种，如何把这个种子管好。\n约一千八百年前，一些蜀汉的官员被诸葛亮派到这里。他们带来了当时最先进的农耕技术，教会了南中人民盖房子，种水稻，使用耕牛，植桑养蚕，纺纱织布，改变了这里刀耕火种的原始生产方式。\n这里是云南省普洱市，是闻名中外的普洱茶的最主要的产地之一。相传，当年正是诸葛亮在这里大规模的推广茶叶种植，才有了后来的普洱茶。今天，普洱茶已经是中国人最日常的生活茶饮之一。为了纪念诸葛亮，与其他地区不同，这里的人们奉诸葛亮为茶祖。像这样的关于诸葛亮的故事，在广大的西南地区有很多，这些美丽的故事，宛若普洱茶的茶香，越是经历久远的年代，越是厚重，香醇。\n赞曰：至此，诸葛亮对与南中的改革也就差不多了，农业是立根之本。而茶叶又可以带来一定的经济利益，使人民安居乐业。\n沈伯俊：早在《隆中对》中，诸葛亮就提出了他的治理南中的原则，南抚夷越。既然是南抚夷越，那他的原则就是，但欲服其心，不欲灭其类也。\n七擒孟获，南抚夷越，最终让这里的人们过上真正稳定的生活。这才是诸葛亮心中真正的队南中的平定。经过几年的努力，蜀汉政权终于拥有了一个相对和平安稳的环境。而此时，诸葛亮所推行的内政改革\u0026gt; ，也已经全面展开。\n内政，第一位重要的因素，就是人才。诸葛亮选拔人才，不拘资历，不拘地域，尤其注重德才兼备。张裔，益州太守，在南中叛乱时期，被反叛首领抓获献给了孙权。在这之后的数年里，诸葛亮的心里一直牵挂着这个才识过人的张裔，后来，在邓芝出使东吴期间，邓芝遵照诸葛亮的嘱托，向孙权提出，希望能够放张裔回蜀。适逢两国重新修好，孙权痛快答应了邓芝的要求，然而，事后孙权很快发现，张裔是一位博学多才之士。十分后悔放虎归山，于是立即派人去追，而张裔早已连夜返回蜀地去了。张裔归来，诸葛亮立即委以重任，蜀汉又有了一位得力的官员。蒋琬，费祎，董允，王连，陈震，张裔，费诗，秦宓等等，像这样被诸葛亮发现并任用的官员数不胜数。一时间，人尽其才，才尽其用，巴蜀地区有才能的人才争相为国家效劳。\n沈伯俊：他善于发现人才，诸葛亮本人就是刘备慧眼识才才走上政治舞台的。诸葛亮怎么识才？怎么衡量一个才？他始终坚持德才兼备。\n内政建设，除了需要得力的人才，更需要建立一套完善的法律体系。诸葛亮亲自主持制定了蜀汉的国家法典《蜀科》。以法治蜀，从严治国。公元 228 年，这一天，蜀汉的刑场周围挤满了文武群臣和围观的百姓。行刑时间将至，只见一个人缓缓来到刑场，这个人正是诸葛亮最疼爱的谋士，马谡。马谡，因为违反军令，导致战略要地街亭失守，兵败失守后，马谡又临阵逃脱，论罪当斩。临刑前，马谡给诸葛亮写信，信中，他视诸葛亮为自己的父亲，并将一家老小托付给诸葛亮，围观的百姓无不动容流泪，群臣纷纷向诸葛亮求情，然而，此时的马谡却十分清楚，自己罪无可赦，丞相绝不会姑息。马谡被斩首后，诸葛亮伤心欲绝，久久难以平复。\n法律面前，人人平等。在诸葛亮所惩处的人里面，既有亲贵，也有功臣，无论是什么人，一旦触犯刑律，诸葛亮一律严办，绝不偏袒。然而，诸葛亮的以法治蜀，绝不是依靠简单的严刑酷法，而是建立在教化的基础上，并充满了人性关怀。同为先帝托孤大臣的李严4，因为弄权而贻误军机，被诸葛亮弹劾流放。之后，诸葛亮给李严的儿子李丰写了一封信，信中，诸葛亮诚恳地说明了流放的理由，并希望李丰能够说服他的父亲，充分认识到自己的错误。李严得知之后，十分感动。多年以后，当李严在流放地听到诸葛亮逝世的消息，一时悲痛激愤，发病而死。\n诸葛亮的法治，饱含了劝善惩恶的一片赤诚。上至王公大臣下至黎民百姓，无不对他畏威怀德，心悦诚服。百姓怨声载道，沸反盈天，这是法治的最低层次；百姓道路以目，敢怒不敢言，这是法治的次低层次；百姓口无怨言，依法守法，这是法治的最高层次；百姓口无怨言，心有服意，受刑者刑之而不怨，诛之而不怒，这是先秦法家实践不可能达到的层次。\n梁满仓：诸葛亮他这个治理国家，我说就是儒法融合，融合是有机的，就是你中有我，我中有你。\n沈伯俊：我们可以用四句话来概括：教化为先，法治为后，执法严明，公正守信。\n招贤纳才，以法治蜀，在诸葛亮的治理下，蜀汉政通人和，吏风廉洁，巴蜀大地，开始呈现一派崭新的气象。现在，正是到了大刀阔斧，进行经济治理的时候了。\n都江堰，这个由秦国李冰父子开凿建设的水利工程，两千多年来，无论是岷江出现洪峰还是枯水，它都忠实地把农业所需要的水量源源不断地送往成都平原，成就着天府之国的富庶。张开勇，四川省都江堰管理局副局长，张开勇和他所在的都江堰管理局的主要工作就是维护都江堰水利工程能够正常发挥作用，以保证对成都平原超过一千万亩的农田的灌溉。\n张开勇：李冰在整个三大布局，三大工程布局是非常科学，非常伟大的，但是并不是说他把所有的问题全部都解决了，正因为历朝历代都重视水利重视都江堰，对都江堰根据生产力的发展，科学技术的进步，不断地注入新的材料，新的技术，然后不断地完善。\n这一年，一队 1200 人的士兵突然进驻这里，这些士兵是诸葛亮派来专门保护和维护都江堰的。作为水利工程，都江堰需要不断地进行维护，诸葛亮深知这一点。\n张开勇：现在我们看的就是竹笼和杩槎的结合。这是杩槎，杩槎呢……\n古代修建水利工程，没有现在的钢筋水泥，要以竹篾为兜，内装鹅卵石，逐层累叠而成堤坝。这样的建筑材料要是遇上特大洪峰，就有决堤的危险。多年的战乱，都江堰已经年久失修，为此，诸葛亮专设堰官对都江堰加强管理。一千二百人既是士兵，又是维护河堤的河工。他们长年驻守，日夜巡视，对都江堰进行保护和疏浚。\n沈伯俊：诸葛亮的这一举措呢，又被后来的历代王朝仿效，沿袭，这才使都江堰能够两千年来持续发挥功效。所以我们可以说，都江堰这个世界闻名的水利工程，李冰有开创之功，诸葛亮则有维护之功。\n在诸葛亮的呵护之下，都江堰发挥了它应有的作用。而诸葛亮所首设的堰官制度，则一直被沿袭下来。水利是农业之本，而农业是立国之本，经过几年的发展，蜀汉农业生产欣欣向荣，粮食连年丰收。晋人左思，在他的《蜀都赋》中，对当时成都平原稻黍千重的景象有着这样的描述：沟洫脉散，疆里绮错，黍稷油油，稉稻莫莫。\n梁满仓：本来四川就是个天府之国，它有了一个稳定的环境，又有了一个很好的政策，那么农业它很快地就会发展起来。\n巴蜀地区历来物产丰富，井盐是巴蜀地区最主要的物产之一。东汉末年以来，井盐的生产管理一度混乱，生产效率低下。诸葛亮决定，强化食盐官卖政策5，增加盐井的数量，同时对生产技术加以改进。井盐，是通过掘井汲取地下盐水熬制而成的。传统的熬制方法用所谓的家火熬制，诸葛亮大力改进和推广火井煮盐的技术。火井，就是指天然气井，史料记载，巴蜀地区是中国最早发现和利用火井的地方。一直以来，火井并没有得到充分的利用，诸葛亮对火井的井口进行了改进，使得火井煮盐的效率大大提高，产盐量是家火煮盐的一倍以上。直到今天，四川的盐井依然在使用火井煮盐。在今天的四川长宁、自贡等地，依然有很多古代留下来的盐井遗址。在诸葛亮治蜀期间，蜀地盐井遍地开花。盐，成了蜀地的重要物产之一，而盐税也因此成为蜀汉经济收入的重要来源，后世有人因此称诸葛亮此举为以盐立国。\n在古代，可以与盐相提并论的只有一样东西，那就是铁。如果说蜀汉是以盐立国，那么还可以说蜀汉政权是以铁强国。三国时期，中国的冶铁技术得到高速发展，百炼钢、灌钢、淬火法等新的冶炼技术都在这个时期出现。史书记载，诸葛亮任命精于冶炼的巧匠蒲元在汉中铸造宝刀。蒲元对淬火用的水要求极高，专用蜀水淬火。一次，他命人从成都取蜀水回来，蒲元一试，说里面掺杂了八升涪水，不能用。取水者大惊，立即叩头谢罪，承认路上因不小心，洒掉了一部分蜀水，而掺进了八升涪水。蒲元用精湛的淬火技术，打造的刀具锋利无比，被誉为神刀。他命人往竹筒里装满铁珠用刀切之，竹筒应声而断。而他所打造的甲胄则异常坚固，据《南史》记载，蒲元为诸葛亮打造的筒袖铠帽，二十五石弩射之不能入。据说，以此甲胄技术，结合南中地区的藤甲，能造出一种既坚固又轻便的盔甲，这种盔甲，就是传说中软猬甲的原型。\n沈伯俊：冶金业他不仅可以制造兵器，更多的他是制造农具。他是促使铁器的运用和推广，所以蜀汉不仅兵器有名，农具也做的很好。\n蜀汉生产的铁器，更多地用于农业生产。这些质地优良的铁制农具，使用起来省时省力，便于精耕细作，有力推动了蜀汉的农业发展。盐业和铁业，在诸葛亮的治理下，得到了充分的发展，成为蜀汉经济的重要基础。然而，在蜀汉地区，还有一样更为特殊的物产，这种物产堪称稀世珍品，它不仅是王公贵族们竞相收藏的瑰宝，皇帝更是拿它作为赏赐臣子的重要赐物，它就是蜀锦。巴蜀之地，自古就有养蚕造丝的传统，而用蜀地所产的蚕丝织成的锦，因其工艺精湛、质地坚韧、色彩华美而闻名天下，故名蜀锦。诸葛亮曾经说过，决敌之资，惟仰锦耳。为了鼓励农桑，诸葛亮亲自垂范，种桑八百株，从事养蚕和织锦生产。为了提高蜀锦的产量，诸葛亮设立了专门的官员，负责管理蜀锦的生产。这样的官员叫做锦官。正是从诸葛亮开始，蜀锦的生产开始变成规模化的国家行为。在诸葛亮的治理下，蜀锦生产在规模和产量上都达到了历史上前所未有的程度。西晋文学家左思，在《蜀都赋》中说，蜀汉境内桑园遍地，城内大街小巷家家机杼之声相和，织锦人家千户万户，花纹装饰的织锦斐然成章，经过江水洗濯的织锦，色泽分外鲜艳。蜀锦，成为了蜀汉的重要出口产品。史书记载，曹操一家祖孙三代都十分喜欢蜀锦，曾经多次派人秘密来到西蜀购锦。孙权，经常用蜀锦奖励手下的大臣。不仅如此，蜀锦还远销至巴基斯坦、印度、阿富汗、伊朗、中东和欧洲地区。蜀锦，成为诸葛亮闭关息农、养育民物政策的最重要经济保障。\n沈伯俊：当时，工匠们集中居住、生产的地方叫做锦里。衙门所在地呢，就叫做锦官城。于是乎，锦里、锦官城、锦城便成了成都的别名，今天还在使用。你看，有司盐校尉、有司金中郎将、有锦官，这几个专门官职的设置，再加上前面的堰官，可见诸葛亮是何等地重视巴蜀地区经济的发展。这方面做好了，就起到什么作用呢？富国安民，蜀中大治。\n公元 234 年，早春时节，蜀地还未从漫长的寒冷中完全苏醒过来。蜀汉丞相诸葛亮决定再次率军北伐。这是诸葛亮一生中最后一次北伐。此时，距离刘备托孤已经十一年了。这十一年，诸葛亮倾尽全力治理蜀汉，蜀汉的国力已经全面恢复。这十一年，蜀汉经历了一次南征，四次北伐，抵御了一次魏国的侵略。前四次北伐，蜀汉都没能实现既定的战略目标。现在，诸葛亮即将再次踏上征程，北伐曹魏。难道，这位著名的军事家真的可以消灭人口和军队数量已经五倍于自己的曹魏政权、从而复兴心目中的大汉王朝吗？早在第一次出征之前，诸葛亮曾经上疏后主刘禅，表达心志。\n臣亮言：先帝创业未半，而中道崩殂；今天下三分，益州疲敝，此诚危急存亡之秋也……今南方已定，兵甲已足，当奖帅三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都……深追先帝之遗诏。臣不胜受恩感激！今当远离，临表涕泣，不知所言。\n楼劲：这个时候他《隆中对》的当时的那种理想，应该说已经离他（理想）的实现已经越来越远了。已经是一种知其不可而为之了。明明知道我就是能够延长它的运作而已，不可能再实现我的预定目标，但他依然坚定地走到了底。鞠躬尽瘁，死而后已。\n蜀汉建兴十二年二月，诸葛亮举全国之力，亲率十万大军由斜谷口向北进军。早已得知消息的魏军统帅司马懿，在渭水之滨五丈原率领大军严阵以待。汉军与魏军对峙于五丈原。跟前几次交战一样，司马懿依然采取严防死守的战术，只是死守，决不出战。任由诸葛亮派人到魏军阵前百般辱骂。魏军将士个个忿恨，人人引为奇耻大辱，司马懿就是坚决不战。汉魏两军在渭水之滨相持数月。最终，诸葛亮无计可施，进退两难，终于一病不起。\n赞曰：诸葛亮第五次北伐，当时已 53 岁，而且事事亲力亲为，食少事烦。司马懿正是看到了这一点才坚守不战，果然，不久诸葛亮病逝。这期间还有个小插曲，诸葛亮见司马懿久不迎战，就派人送了套女人衣物给他，意在说司马懿像个女人一样。但是这次激将法并没有起到什么作用。\n重病中的诸葛亮知道，自己命数已定，北伐难成。弥留之际，专程从成都赶来的尚书仆射李福问诸葛亮百年之后谁可接任，诸葛亮说蒋琬可任。李福又问，蒋琬之后谁可接任，诸葛亮说费祎可任。李福第三次问话后，诸葛亮再也没有说话。此时的五丈原正值深夜，传说中，诸葛亮病逝之时，一颗流星划破长空，从东北落向西南，由大而小，陨落在诸葛亮的军营之中。出师未捷身先死，长使英雄泪满襟。三国时代著名的政治家、军事家，中国历史上最杰出的知识分子和贤臣诸葛亮，怀着北伐中原复兴汉室的未竟之志，离开了这个纷乱的世界。\n赞曰：李福第三次问话，诸葛亮没回答，也就意味着蜀汉政权无法在传递下去了。即使诸葛亮做的再好，无人继承大业也是没有用处的。\n梁满仓：他是生于乱世，他亲眼看到乱世给人们带来的种种灾难。他所追求的、兴复的汉朝，不是（东汉）末期的、桓帝灵帝那种黑暗的、四分五裂的汉朝，他是追求（汉）光武帝刘秀初建东汉的那种统一的、蓬勃的、欣欣向荣的这种汉朝。\n楼劲：这就是为理想而死，为信念而死，为承诺而死。是这样，这是无论从哪个方面来看，从普通的老百姓，还是从大政治家这个角度来说，这都是最为可贵的品质之一。\n自诸葛亮逝世以来，千百篇诗文讴歌他，无数的百姓颂扬他，遍布各地的文物古迹是对他最好的纪念。一批又一批仁人志士，沿着他的足迹，继承他的遗志，为中华民族鞠躬尽瘁死而后已。\n沈伯俊：诸葛亮的品格可以说是我们中华民族优秀品格的集中体现。一是忠贞，这个忠是忠于理想、忠于事业，加以升华就是忠于国家、忠于民族。二是智慧，这种智慧是大智慧，这种智慧还包括军事智慧、科技智慧、以及更深刻的人生智慧。\n诸葛大名垂宇宙，万古云霄一羽毛。忠诚、敬业、自强、公正、廉明、勤政、淡泊，中国古代知识分子和贤臣的所有美德集于诸葛亮一身，成就了诸葛亮的伟大人格和精神魅力。成为所有时代衡量为官者贤愚忠奸的标尺。虽然诸葛亮的肉体生命早已不在，但他的精神生命光耀千秋。诸葛亮的名字，已经变成一个文化符号，成为中华民族优秀传统文化的组成部分和全民族共同的精神财富，深深地影响着今天乃至明天的中国社会。\n后人对诸葛亮的评价很多，这里引用一段《三国志》作者陈寿的话：\n“诸葛亮之为相国也，抚百姓，示仪轨，约官职，从权制，开诚心，布公道；尽忠益时者虽仇必赏，犯法怠慢者虽亲必罚，服罪输情者虽重必释，游辞巧饰者虽轻必戮；善无微而不赏，恶无纤而不贬；庶事精练，物理其本，循名责实，虚伪不齿；终于邦域之内，咸畏而爱之，刑政虽峻而无怨者，以其用心平而劝戒明也。可谓识治之良才，管、萧之亚匹矣。然连年动众，未能成功，盖应变将略，非其所长欤！”\n由此观之，陈寿认为其带兵不懂随机应变。毕竟军师和将领还是有很大差距的。这就好比让子房代替韩信，刘邦肯定夺不了天下。如果诸葛亮身在太平之年，必定是治国栋梁。然而却时逢乱世，岂非天命也？\n益州牧：牧之一职，起源极早。传说舜时置天下为十二州，设立州牧，一称州伯，牧是管理的意思，也就是各个州的行政长官。益州牧，总理益州的治安、民政、军事的最高长官。益州是东汉时最大的州，有汉中、蜀、永安等郡。治所（即州政府）在蜀郡的成都。它包括今天的四川省、重庆市全境和陕西省南部，云南省西北部。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n邓芝：（？—251）字伯苗，汉族，义阳新野（今河南新野）人，三国时期蜀汉重要朝臣。251 年病逝，官至车骑将军、假节。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n藩属：旧指属国或属地。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n李严：（？－234），后改名李平，字正方，南阳（今河南南阳）人。三国时期蜀汉重臣，与诸葛亮同为刘备临终前的托孤之臣。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n食盐官卖政策：中国封建社会政府为打击富商大贾，增加财政收入而实行的对盐和铁的垄断经营政策。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2013-01-26T16:32:00+08:00","image":"https://ivy-end.github.io/p/china-history-documentary-031-zhuge-liang/images/cover_hu309dfbba780a9e35fd37305d1c61e62d_972347_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/china-history-documentary-031-zhuge-liang/","title":"《中国通史》纪录片：031 诸葛亮治蜀"},{"content":"充满传奇色彩的 2012 年就这样过去了。自从上了高中以后，总觉得时间好快，有种跟不上节奏的感觉。\n先简单总结一下过去的一年。高一下学期，为了一个信念努力拼搏，虽然如愿以偿，但总是觉得怪怪的。高二，一直被一种莫名的情绪笼罩。\n可能是因为生活节奏太快的缘故，对于很多事情都没有什么记忆了。以至于周五回想周一的事情都感觉过了好久。推究这种感觉的原因，可能是被迫习惯了这些不习惯的事实吧。这一年也对我的思想转变起了很大的影响。下面主要讲几件事例吧，也不可能面面俱到。\n申明：本人对下述事件所涉及的个人或集体不带任何恶意。\n一开始来到新班级，有点诧异。没过几天，就感觉很不习惯。对于自己以前所在班级的留恋无可非议，每天在走廊里搞聚会，利用优势地理位置也无可厚非，但是大声喧哗，影响公共秩序好像不太好吧。\n课间我们在走廊里乘凉，看着一群男男女女大吵大叫，玩一些不上大雅之堂的游戏或者说些带着痞子气的话语，只能说，他们没事干吧。或许我们根本不了解他们才下的这个结论吧。不过这样的印象谁又敢去了解呢。\n对于一些人，尤其是男生，都高二了，遇到事情推卸责任，耍脾气，真是不可理喻，在此也不想指出，毕竟，他们早晚会为自己的行为付出代价。也许只有这样他们才会明白吧。\n还有个不得不提的话题，为什么现在的女生会如此随意呢，对此，只能是敬而远之了。\n上评论可能是从我个人想法出发吧。当初建立世界观的时候受老子、周易的影响较大，所以有些思想比较传统吧，对于这些过于现代的元素感到无法接受吧。有了上述的事例，自然就造成了现在自己宁可一个人看看课外书，刷刷作业，也不想去接触外界那些令人无法接受的事情。就好像文化夜市我和张程晔、子敬兄、昊阳兄一起在教室刷作业，然后去小店解决了晚饭。\n对于日后，我想我还是会坚持我的世界观不动摇吧，毕竟现在看到的事情不会也不可能会是社会的走向。所以，必须坚定信念。\n另外一件对于我影响比较大的事情是一个人的一句话，大意是，不一定朋友就一定会是非常好的，也可能是没办法的。这也就好比戴着面具生活，只是要记得对谁带着面具，对谁毫无掩饰。虽然说这样做可以建立和谐的人际关系，但是总觉得有点违背个人内心道德，但是有时候还不得不这样。\n思想上的转变大致如上所述，经历了很大的斗争，最终结果是，坚持自己以往的根本思想，对于一些新思想，取精去糟的吸收。\n再讲讲 NOIP 吧，这是个不得不提的话题，虽然竞赛过去几个月了，成绩也已经尘埃落定，但是这次比赛却给我很大的启发。做人做事就好比代码。有时候一步走错，满盘皆输；有时候贪心的选择了自己不熟练的算法，可能直接导致了 0 分；有时候把问题复杂化，结果只能是 0 分。虽然过程非常艰辛，但是拿到了全国复赛二等奖的通知还是挺开心的。不知道能不能获得 Winter Camp 的资格。\n对于新班主任，郭华。宿舍扣分扣得我都不好意思见她了。进入高二，总感觉数学不对劲，明明都是会的内容，却不是算错，就是没过程。\n最近在宿舍里做起了泡面生意，到目前一共卖出了 12 箱，也有了些盈利。主要还是为了积累经验。做生意的确很苦，每天要去泡开水，风雨无阻。\n2013，新年快乐。\n","date":"2012-12-31T21:11:00+08:00","image":"https://ivy-end.github.io/p/ren-chen-2012-year-summary/images/cover_hu5fa5fb2ed6ce02ae74151f776475d89a_875375_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/ren-chen-2012-year-summary/","title":"壬辰志（2012 年度总结）"},{"content":"网站终于好了，在 2012 年的最后一天写下第一篇文章。\n搭建网站的想法很早就有了，由于一些事情耽搁了，主要是经济来源问题。由于前段时间在宿舍中卖泡面赚了些钱，所以才搭起了这个网站。搭建这个网站也不容易，从申请域名，设置 A 记录，配置 DNS 服务器，域名解析到空间的选择等，可以说又是一次历练吧。现在的网站还非常简陋，以后会慢慢完善。\n有人问我，什么不用 QQ 空间。我想还是因为这里比较自由吧。主要还是写一些关于生活的文章，包括一些杂感、竞赛，抑或其他。\n关于 Ivy - End，前者是我的母校，后者是我的 QQ 昵称。但现在有了更多的意义。将来也是。\n附上一段代码：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2012-12-31T15:30:00+08:00","image":"https://ivy-end.github.io/p/website-setup-journey/images/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_2677751_120x120_fill_q75_box_smart1.jpg","permalink":"https://ivy-end.github.io/p/website-setup-journey/","title":"Hello World"}]