<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>编程珠玑 on 退思轩</title>
    <link>https://kwang.life/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/</link>
    <description>Recent content in 编程珠玑 on 退思轩</description>
    <image>
      <title>退思轩</title>
      <url>https://kwang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kwang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 23 Aug 2013 09:03:00 +0800</lastBuildDate><atom:link href="https://kwang.life/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0/1 背包 - NOIP2005P3</title>
      <link>https://kwang.life/2013/08/0/1-%E8%83%8C%E5%8C%85-noip2005p3/</link>
      <pubDate>Fri, 23 Aug 2013 09:03:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/08/0/1-%E8%83%8C%E5%8C%85-noip2005p3/</guid>
      <description>题目是经典的采药问题。也是最基础的 0/1 背包问题。
我们约定有$N$件物品和一个容量为$C$的背包。第$i$件物品的重量是$w\left [ i \right ]$，价值是$v\left [ i \right ]$。这样，我们所需要求解将哪些物品装入背包可使价值总和最大。
二维数组表示 定义状态：$f\left [ i \right ]\left [ c \right ]$表示前$i$件物品恰放入一个容量为$c$的背包可以获得的最大价值。
状态转移方程：$f\left [ i \right ]\left [ c \right ]=\max\left \{ f\left [ i-1 \right ]\left [ c \right ],f\left [i-1 \right ]\left [ c-w\left [ i \right ] \right ] +v\left [ i \right ]\right \}$
代码模版：
for(int i = 1; i &amp;lt;= N; i++) { for(int c = 0; c &amp;lt;= C; c++) { f[i][c] = f[i - 1][c]; if(c &amp;gt;= w[i]) { f[i][c] = max(f[i][c], f[i - 1][c - w[i]] + v[i]); } } } 时间复杂度、空间复杂度：$O\left ( NC \right )$</description>
    </item>
    
    <item>
      <title>Dilworth 定理 - NOIP1999T1</title>
      <link>https://kwang.life/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/</link>
      <pubDate>Thu, 22 Aug 2013 16:32:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/</guid>
      <description>题目是经典的导弹拦截。第一问很有信心的写下了最长非增序列。第二问就懵了。后来看了题解，有一个“Dilworth 定理”，现在将定理的表述和证明整理如下：
这是一个关于偏序集的定理。偏序集即偏序集合。
偏序的概念：设 $ \textbf{A} $ 是一个非空集合。 $ P $ 是 $ \textbf{A} $ 上的一个关系，若关系 $ P $ 是自反的、反对称的、传递的，则称 $ P $ 是集合 $ \textbf{A} $ 上的偏序关系。
即 $ P $ 满足下列条件：
$ \forall a\in\textbf{A},\left ( a,a \right )\in P $ ； 若 $ \left ( a,b \right )\in P,\left ( b,a \right )\in P $ ，则 $ a=b $ ； 若 $ \left ( a,b \right )\in P,\left ( b,c \right )\in P $ ，则 $ \left ( a,c \right )\in P $ 。 我们用 $ a\leq b $ 表示 $ \left ( a,b \right )\in P $ 。 注：“ $ \leq $ ”只是符号，不代表不等关系。</description>
    </item>
    
    <item>
      <title>BFS 解决蛇形填数 - NOIP1995P2</title>
      <link>https://kwang.life/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/</link>
      <pubDate>Thu, 22 Aug 2013 10:36:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/</guid>
      <description>题目描述是经典的蛇形填数问题。
以前解决这类问题，通常是通过控制$i,j$的值来定位数组元素的位置，然后进行赋值。但是这种方法非常的繁琐，且难于理解。容易出错。
今天在做这道题目的时候，通过搜索资料，思索出了一种新解法，相较于原来的解法更以理解，且时间复杂度更低。解法的基本思想是 BFS。下面我们仔细来探讨一下。
首先我们定义一组偏移量数组：
const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 }; 这个数组的顺序必须和填数的顺序一致。在这里，它被定义为逆时针填数。
然后我们需要设置 BFS 的起点：
x = 1; y = N; i = 0; f[x][y] = nNum++; 其中，$x,y$用来保存当前坐标，$i$则是保存当前偏移量的数组下标。$f\left [ x \right ]\left [ y \right ]$表示需要填充的矩阵，$nNum$则是所需要填的数。
我们来简单的模拟以下，假设现在坐标为$\left ( 1,n \right )$，偏移量下标$i=0$。首先尝试向右扩展标$\left ( 1,n+1 \right )$，不合法，于是返回到坐标$\left ( 1,n \right )$再先下扩展，检测合法后，进行填充，当填充到最下端时，又不合法，这样，返回到坐标$\left ( n,n \right )$后向左扩展，同理，填充到最左端后又会向上扩展，这里还需要检测当前扩展结点是否已经填数。如果已经填数，则不合法，需要返回上一个坐标。
这样我们模拟一遍 BFS 就可以知道，这种解法是正确的，所以这里略过证明。</description>
    </item>
    
    <item>
      <title>Linux 迁移记（一）</title>
      <link>https://kwang.life/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Mon, 18 Feb 2013 20:35:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/</guid>
      <description>由于各种各样的原因，之前很多次向 Linux 迁移的计划未能实现。主要是因为有些程序只能在 Windows 上运行，比如我们最常用的 QQ。此次迁移的主要原因和以往大致相同：
Windows 系列的系统臃肿而且不实用，很多东西华而不实。 Windows 系列的系统及其程序属于商业行为，为了追求自由、共享和开源。 我选择的是 Ubuntu 12.04 LTS，主要还是看中了 LTS（Long Term Support），这样可以获取更长时间的技术支持。
安装过程就略过不提了。我采用的是 USB 安装，毕竟刻录光盘很奢侈。将移动硬盘分出一个 4GB 的分区，然后用 Universal USB Installer 写了启动引导，接下去的过程就很简单了，因为都是 GUI 界面，相对容易些。
装完系统就是折腾了，Linux 就是用来折腾的。下面慢慢介绍。
换上 Gnome3 由于 Ubuntu 自带的 Unity 界面非常不稳定，主要是个人不喜欢那种风格。所以毅然决然的换了 Gnome3。由于 Ubuntu 早已将其加入到了软件源中，所以直接 apt-get 就可以了。
sudo apt-get install gnome-shell 安装结束以后就可以使用了。可能是个人癖好吧，我还是把 Unity 删了，命令如下：
sudo apt-get --auto-remove purge unity sudo apt-get --auto-remove purge unity-commonp sudo apt-get --auto-remove purge unity-lens* sudo apt-get --auto-remove purge unity-services sudo apt-get --auto-remove purge unity-asset-pool 切记不可使用这条命令：</description>
    </item>
    
  </channel>
</rss>
