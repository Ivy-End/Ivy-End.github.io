<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编程珠玑 | 退思轩</title><meta name=keywords content><meta name=description content><meta name=author content="Kai Wang"><link rel=canonical href=https://kwang.life/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/><meta name=google-site-verification content="G-FVKQ0YJ3T3"><link crossorigin=anonymous href=/assets/css/stylesheet.ca147d49e8814c08e5d4b03afbfca66bd9776fb2666d476035e4b2854d94aaf7.css integrity="sha256-yhR9SeiBTAjl1LA6+/yma9l3b7JmbUdgNeSyhU2Uqvc=" rel="preload stylesheet" as=style><link rel=icon href=https://kwang.life/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://kwang.life/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://kwang.life/favicons/apple-touch-icon.png><link rel=apple-touch-icon href=https://kwang.life/favicons/apple-touch-icon.png><link rel=mask-icon href=https://kwang.life/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kwang.life/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css integrity=sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js integrity=sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:!0},{left:'$',right:'$',display:!1},{left:'\\(',right:'\\)',display:!1},{left:'\\[',right:'\\]',display:!0}],throwOnError:!1})})</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><script async src="https://www.googletagmanager.com/gtag/js?id=G-FVKQ0YJ3T3"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-FVKQ0YJ3T3',{anonymize_ip:!1})}</script><meta property="og:title" content="编程珠玑"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://kwang.life/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"><meta name=twitter:card content="summary"><meta name=twitter:title content="编程珠玑"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://kwang.life accesskey=h title="退思轩 (Alt + H)"><img src=https://kwang.life/favicons/apple-touch-icon.png alt aria-label=logo height=35>退思轩</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kwang.life/ title=🏠首页><span>🏠首页</span></a></li><li><a href=https://kwang.life/archives/ title=📔归档><span>📔归档</span></a></li><li><a href=https://kwang.life/tags/ title=🏷️标签><span>🏷️标签</span></a></li><li><a href=https://kwang.life/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://kwang.life/categories/ title=🗂️分类><span>🗂️分类</span></a></li><li><a href=https://kwang.life/friends/ title=🌏邻居><span>🌏邻居</span></a></li><li><a href=https://kwang.life/about/ title=📜关于><span>📜关于</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>编程珠玑
<a href=/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>算法专题：单源最短路径 – Bellman-Ford Algorithm</h2></header><div class=entry-content><p>上一篇文章介绍了一下 Dijkstra Algorithm，但是它仅局限于处理非负权值的图。若图中出现负边，Dijkstra Algorithm 就会出现错误。这时候就需要使用其他的算法来求解单源最短路径。 Ballman-Ford 是一个非常实用的算法，它是由美国数学家 Richard Ballman 和 Lester Ford 发明的。Ballman-Ford 算法的基本流程如下： 初始化 $ pDist\left [ \right ] $ 数组。 检查每一条边，如果源点到该条边的起点有通路，则更新原点到该条边的终点的最短路径。循环 $ V $ 次即可得到结果。 如若要检测是否存在负环，则再检查每一条边，若可以松弛，则有负环。 我们来看一张图片具体体会一下 Bellman-Ford Alg...</p></div><footer class=entry-footer><span title='2013-11-03 10:13:00 +0800 +0800'>2013年11月3日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;667 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to 算法专题：单源最短路径 – Bellman-Ford Algorithm" href=https://kwang.life/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-bellman-ford-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>算法专题：单源最短路径 – Dijkstra Algorithm</h2></header><div class=entry-content><p>这个星期开始复习最短路的一些算法。 单源最短路径（Single Source Shortest Paths），简称 SSSP。这是图论中非常重要的一类算法。解决这一问题有多种算法，今天先来介绍一下 Dijkstra Algorithm。 首先介绍一下单源最短路径的概念，通俗的讲，就是给定一个源点 $ s $ （即起点），求这个源点到其他各个顶点的最短路径。最短路径，通俗的来讲，我们称使得顶点 $ V_{i} $ 到顶点 $ V_{j} $ 所经过的路径的权值之和最小的一条路径，称为从顶点 $ V_{i} $ 到顶点 $ V_{j} $ 的最短路径。 单源最短路径 上面这幅图标出了从源点 $ s $ 到各个顶点的最短路径，大家可以根...</p></div><footer class=entry-footer><span title='2013-11-03 09:22:00 +0800 +0800'>2013年11月3日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;927 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to 算法专题：单源最短路径 – Dijkstra Algorithm" href=https://kwang.life/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra-algorithm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>算法专题：最小生成树 – Kruskal Algoritm</h2></header><div class=entry-content><p>今天来介绍一下最小生成树的另外一种算法：Kruskal Algorithm。这个算法是基于贪心实现的，算法的大体过程如下： 取权值最小的边，如果加入这条边以后，不会出现环，那么就加入这条边。 重复上述操作，直至加入了 $ N-1 $ 条边。 我们还是先来看一张图片来理解一下这个算法： Kruskal 算法 下面我们来考虑这个算法，最棘手的问题是判断是否构成环，这里我们采用并查集来处理这个问题，它的复杂度是 $ O\left(V*\alpha\left(V\right)\right) $ 。对于每次寻找权值最小的边，复杂度是 $ O\left(E\right) $ 。这样一来，复杂度将高达 $ O\left(V*\alpha\left(V\right)+VE\right) $ ，即 $ O\left(VE\right) $ 。 我们考虑优化，每次寻找权值最小的边，可以...</p></div><footer class=entry-footer><span title='2013-10-20 21:33:00 +0800 +0800'>2013年10月20日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;785 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to 算法专题：最小生成树 – Kruskal Algoritm" href=https://kwang.life/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-kruskal-algoritm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>算法专题：最小生成树 – Prim Algoritm</h2></header><div class=entry-content><p>最近开始准备 NOIP 复赛，发现很多算法已经不会了。只能一个个的捡起来，慢慢复习，顺便做点笔记。 最小生成树（Minimum Spanning Trees），简称 MST。是图论中一个非常重要的概念。解决这个问题有两种算法，今天暂且先来讨论一下 Prim Algorithm。不做特别说明，讨论的都是无向图。 首先介绍一下最小生成树的概念，我们知道，图可以这样定义 $ G=\left(V,E\right) $ ，其中 $ G $ 表示图， $ V $ 表示顶点集合， $ E $ 表示边集合。最小生成树是这样一棵树，它满足 $$ w\left ( T \right )=\min {\left \{ \sum_{\left ( u,v \right )\in T}w\left ( u,v \right ) \right \}} $$ 通俗地讲，就是使得图 $ G $ 连通时，所选取的...</p></div><footer class=entry-footer><span title='2013-10-19 21:30:00 +0800 +0800'>2013年10月19日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;1238 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to 算法专题：最小生成树 – Prim Algoritm" href=https://kwang.life/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim-algoritm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>线段树 – 有改动求解区间最值 – 忠诚 2</h2></header><div class=entry-content><p>忠诚 2 是忠诚的一个提升版本。我们在之前的一篇文章线段树 – 无改动求解区间最值 – 忠诚简单的谈了一下关于无改动求解区间最值的问题。现在我们来研究一下有改动求解区间最值。 首先，我们考虑改动某个值以后，对整棵树重新进行维护。但是很快我们发现，这样的复杂度太大。因为每次只更改一个值，所以只涉及到一条路径，因此我们考虑在递归修改数值的时候，可以标记一下经过的结点，修改完成以后，只对标记过的结点进行维护。这样我们的代码就出来了： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int Update(Node *pNode) { if(pNode->nLeft == pNode->nRight || pNode->nMoney != 2147483647) { return pNode->nMoney; } else { return pNode->nMoney =...</p></div><footer class=entry-footer><span title='2013-08-27 21:16:00 +0800 +0800'>2013年8月27日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;775 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to 线段树 – 有改动求解区间最值 – 忠诚 2" href=https://kwang.life/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%89%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>线段树 – 无改动求解区间最值 – 忠诚</h2></header><div class=entry-content><p>昨天研究了一下线段树，发现原来线段树有这么多实现方式。当然，对于非递归自底向上线段树，俗称 ZKW 线段树还是不太理解。而且我的实现方式还是用的指针，所以效率不是特别高。首先记录一下自己对于线段树的理解吧。我们用忠诚这道题目来做例子。 线段树可以直观的表示为下面这张图： 线段树示意图 对于一个给定的区间，不断的二分，直到区间变为一个点为止。当然，平时我们所需要的线段树不是这么简陋的，我们需要一些数据域： 1 2 3 4 5 6 struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; 有了节点的数据结构，我们需要构建这棵树，我们使用递归的方式生成这棵树...</p></div><footer class=entry-footer><span title='2013-08-27 21:06:00 +0800 +0800'>2013年8月27日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;1082 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to 线段树 – 无改动求解区间最值 – 忠诚" href=https://kwang.life/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%97%A0%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>0/1 背包 - NOIP2005P3</h2></header><div class=entry-content><p>题目是经典的采药问题。也是最基础的 0/1 背包问题。 我们约定有$N$件物品和一个容量为$C$的背包。第$i$件物品的重量是$w\left [ i \right ]$，价值是$v\left [ i \right ]$。这样，我们所需要求解将哪些物品装入背包可使价值总和最大。 二维数组表示 定义状态：$f\left [ i \right ]\left [ c \right ]$表示前$i$件物品恰放入一个容量为$c$的背包可以获得的最大价值。 状态转移方程：$f\left [ i \right ]\left [ c \right ]=\max\left \{ f\left [ i-1 \right ]\left [ c \right ],f\left [i-1 \right ]\left [ c-w\left [ i \right ] \right ] +v\left [ i \right ]\right \}$ 代码模版： 1 2 3 4 5 6 7 8 9 for(int i = 1; i &lt;= N; i++) { for(int c =...</p></div><footer class=entry-footer><span title='2013-08-23 09:03:00 +0800 +0800'>2013年8月23日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;778 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to 0/1 背包 - NOIP2005P3" href=https://kwang.life/2013/08/0/1-%E8%83%8C%E5%8C%85-noip2005p3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Dilworth 定理 - NOIP1999T1</h2></header><div class=entry-content><p>题目是经典的导弹拦截。第一问很有信心的写下了最长非增序列。第二问就懵了。后来看了题解，有一个“Dilworth 定理”，现在将定理的表述和证明整理如下： 这是一个关于偏序集的定理。偏序集即偏序集合。 偏序的概念：设$\textbf{A}$是一个非空集合。$P$是$\textbf{A}$上的一个关系，若关系$P$是自反的、反对称的、传递的，则称$P$是集合$\textbf{A}$上的偏序关系。 即$P$满足下列条件： $\forall a\in\textbf{A},\left ( a,a \right )\in P$； 若$\left ( a,b \right )\in P,\left ( b,a \right )\in P$，则$a=b$； 若$\left ( a,b \right...</p></div><footer class=entry-footer><span title='2013-08-22 16:32:00 +0800 +0800'>2013年8月22日</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;2250 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to Dilworth 定理 - NOIP1999T1" href=https://kwang.life/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>BFS 解决蛇形填数 - NOIP1995P2</h2></header><div class=entry-content><p>题目描述是经典的蛇形填数问题。 以前解决这类问题，通常是通过控制$i,j$的值来定位数组元素的位置，然后进行赋值。但是这种方法非常的繁琐，且难于理解。容易出错。 今天在做这道题目的时候，通过搜索资料，思索出了一种新解法，相较于原来的解法更以理解，且时间复杂度更低。解法的基本思想是 BFS。下面我们仔细来探讨一下。 首先我们定义一组偏移量数组： 1 2 const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 }; 这个数组的顺序必须和填数的顺序一致。在这里，它被定义为逆时针填数。 然后我们需要设置 BFS 的起点： 1 2 x = 1; y = N; i = 0; f[x][y] = nNum++;...</p></div><footer class=entry-footer><span title='2013-08-22 10:36:00 +0800 +0800'>2013年8月22日</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;784 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to BFS 解决蛇形填数 - NOIP1995P2" href=https://kwang.life/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Linux 迁移记（一）</h2></header><div class=entry-content><p>由于各种各样的原因，之前很多次向 Linux 迁移的计划未能实现。主要是因为有些程序只能在 Windows 上运行，比如我们最常用的 QQ。此次迁移的主要原因和以往大致相同： Windows 系列的系统臃肿而且不实用，很多东西华而不实。 Windows 系列的系统及其程序属于商业行为，为了追求自由、共享和开源。 我选择的是 Ubuntu 12.04 LTS，主要还是看中了 LTS（Long Term Support），这样可以获取更长时间的技术支持。 安装过程就略过不提了。我采用的是 USB 安装，毕竟刻录光盘很奢侈。将移动硬盘分出一个 4GB 的分区，然后用 Universal USB Installer 写了启动引导，接下去的过程就很简单了，因为都是...</p></div><footer class=entry-footer><span title='2013-02-18 20:35:00 +0800 +0800'>2013年2月18日</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;1017 字&nbsp;·&nbsp;Kai Wang</footer><a class=entry-link aria-label="post link to Linux 迁移记（一）" href=https://kwang.life/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://kwang.life/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/page/6/>«&nbsp;上一页&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://kwang.life>退思轩</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><br><div class=busuanzi-footer><span id=busuanzi_container_site_pv>总访问量&nbsp<span id=busuanzi_value_site_pv></span>&nbsp次
       </span>
&nbsp;·&nbsp;
<span id=busuanzi_container_site_uv>总访客数&nbsp<span id=busuanzi_value_site_uv></span>&nbsp位
       </span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>