<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>传递闭包 on 退思轩</title>
    <link>https://kwang.life/tags/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/</link>
    <description>Recent content in 传递闭包 on 退思轩</description>
    <image>
      <title>退思轩</title>
      <url>https://kwang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kwang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 03 Nov 2013 19:48:00 +0800</lastBuildDate><atom:link href="https://kwang.life/tags/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法专题：传递闭包</title>
      <link>https://kwang.life/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/</link>
      <pubDate>Sun, 03 Nov 2013 19:48:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/</guid>
      <description>传递闭包（Transitive Closure）主要是研究图上两点之间的连通性。对于这个问题，我们只需要改进一下 Floyd-Warshall Algorithm 就可以很方便的求出它的解。
我们这里主要研究的是有向图的传递闭包问题。
代码如下：
#include &amp;lt;iostream&amp;gt; using namespace std; const int MAX = 10240; const int INF = 65536; int N, M; bool f[MAX][MAX], pMap[MAX][MAX]; void Floyd(); int main() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; for(int i = 1; i &amp;lt;= N; i++) { for(int j = 1; j &amp;lt;= N; j++) { pMap[i][j] = f[i][j] = (i == j) ? 1 : 0; // 初始化 } } for(int i = 1; i &amp;lt;= M; i++) { int s, e; cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; e; pMap[s][e] = pMap[e][s] = true; // 无向图 f[s][e] = f[e][s] = true; } Floyd(); return 0; } void Floyd() { for(int k = 1; k &amp;lt;= N; k++) // 最外层必须是k { for(int i = 1; i &amp;lt;= N; i++) { for(int j = 1; j &amp;lt;= N; j++) { f[i][j] = f[i][j] || (f[i][k] &amp;amp;&amp;amp; f[k][j]); // 判断连通性 } } } for(int i = 1; i &amp;lt;= N; i++) { for(int j = 1; j &amp;lt;= N; j++) { cout &amp;lt;&amp;lt; f[i][j] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; } cout &amp;lt;&amp;lt; endl; } } 这个算法还是比较简单的，只要在 Floyd-Warshall Algorithm 的基础上修改一下就行了。</description>
    </item>
    
  </channel>
</rss>
