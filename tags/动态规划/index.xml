<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>动态规划 on 退思轩</title>
    <link>https://kwang.life/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <description>Recent content in 动态规划 on 退思轩</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 14 Mar 2015 13:22:00 +0800</lastBuildDate><atom:link href="https://kwang.life/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>动态规划 - HDU</title>
      <link>https://kwang.life/2015/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-hdu/</link>
      <pubDate>Sat, 14 Mar 2015 13:22:00 +0800</pubDate>
      
      <guid>https://kwang.life/2015/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-hdu/</guid>
      <description>HDU 2955 这是一道概率 DP，我第一次的想法是把概率 $P$ 乘以 100，变成一个背包然后做 0/1 背包，后来发现这样做是错误的。 原因：概率应该是相乘，而不是相加。 后来看了题解想到了另外一种方法，使用逃脱概率来计算，用 $f[j]$ 表示偷走 $j$ 价值后逃脱的概率。易知，多次逃脱概率为每次逃脱概率相乘。这里不使用被逮捕的概率是因为被逮捕的情况比较复杂（例如偷第一件物品不被逮捕，偷第二件物品被逮捕，被逮捕的概率应该为头第一件物品不被逮捕的概率乘以偷第二件物品不被逮捕的概率。），而当我们转而考虑它的对立事件——逃脱时，问题就会变得容易了，</description>
    </item>
    
    <item>
      <title>0/1 背包 - NOIP2005P3</title>
      <link>https://kwang.life/2013/08/0/1-%E8%83%8C%E5%8C%85-noip2005p3/</link>
      <pubDate>Fri, 23 Aug 2013 09:03:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/08/0/1-%E8%83%8C%E5%8C%85-noip2005p3/</guid>
      <description>题目是经典的采药问题。也是最基础的 0/1 背包问题。 我们约定有$N$件物品和一个容量为$C$的背包。第$i$件物品的重量是$w\left [ i \right ]$，价值是$v\left [ i \right ]$。这样，我们所需要求解将哪些物品装入背包可使价值总和最大。 二维数组表示 定义状态：$f\left [ i \right ]\left [ c \right ]$表示前$i$件物品恰放入一个容量为$c$的背包可以获得的最大价值。 状态转移方程：$f\left [ i \right ]\left [ c \right ]=\max\left \{ f\left [ i-1 \right ]\left [ c \right ],f\left [i-1 \right ]\left [ c-w\left [ i \right ] \right ] +v\left [ i \right ]\right \}$ 代码模版： 1 2 3 4 5 6 7 8 9 for(int i = 1; i &amp;lt;= N; i++) { for(int c =</description>
    </item>
    
    <item>
      <title>Dilworth 定理 - NOIP1999T1</title>
      <link>https://kwang.life/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/</link>
      <pubDate>Thu, 22 Aug 2013 16:32:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/</guid>
      <description>题目是经典的导弹拦截。第一问很有信心的写下了最长非增序列。第二问就懵了。后来看了题解，有一个“Dilworth 定理”，现在将定理的表述和证明整理如下： 这是一个关于偏序集的定理。偏序集即偏序集合。 偏序的概念：设$\textbf{A}$是一个非空集合。$P$是$\textbf{A}$上的一个关系，若关系$P$是自反的、反对称的、传递的，则称$P$是集合$\textbf{A}$上的偏序关系。 即$P$满足下列条件： $\forall a\in\textbf{A},\left ( a,a \right )\in P$； 若$\left ( a,b \right )\in P,\left ( b,a \right )\in P$，则$a=b$； 若$\left ( a,b \right</description>
    </item>
    
  </channel>
</rss>
