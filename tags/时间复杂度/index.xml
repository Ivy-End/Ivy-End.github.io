<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>时间复杂度 on 退思轩</title>
    <link>https://kwang.life/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
    <description>Recent content in 时间复杂度 on 退思轩</description>
    <image>
      <title>退思轩</title>
      <url>https://kwang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://kwang.life/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 23 Aug 2013 09:03:00 +0800</lastBuildDate><atom:link href="https://kwang.life/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0/1 背包 - NOIP2005P3</title>
      <link>https://kwang.life/2013/08/0/1-%E8%83%8C%E5%8C%85-noip2005p3/</link>
      <pubDate>Fri, 23 Aug 2013 09:03:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/08/0/1-%E8%83%8C%E5%8C%85-noip2005p3/</guid>
      <description>题目是经典的采药问题。也是最基础的 0/1 背包问题。
我们约定有$N$件物品和一个容量为$C$的背包。第$i$件物品的重量是$w\left [ i \right ]$，价值是$v\left [ i \right ]$。这样，我们所需要求解将哪些物品装入背包可使价值总和最大。
二维数组表示 定义状态：$f\left [ i \right ]\left [ c \right ]$表示前$i$件物品恰放入一个容量为$c$的背包可以获得的最大价值。
状态转移方程：$f\left [ i \right ]\left [ c \right ]=\max\left \{ f\left [ i-1 \right ]\left [ c \right ],f\left [i-1 \right ]\left [ c-w\left [ i \right ] \right ] +v\left [ i \right ]\right \}$
代码模版：
for(int i = 1; i &amp;lt;= N; i++) { for(int c = 0; c &amp;lt;= C; c++) { f[i][c] = f[i - 1][c]; if(c &amp;gt;= w[i]) { f[i][c] = max(f[i][c], f[i - 1][c - w[i]] + v[i]); } } } 时间复杂度、空间复杂度：$O\left ( NC \right )$</description>
    </item>
    
    <item>
      <title>BFS 解决蛇形填数 - NOIP1995P2</title>
      <link>https://kwang.life/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/</link>
      <pubDate>Thu, 22 Aug 2013 10:36:00 +0800</pubDate>
      
      <guid>https://kwang.life/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/</guid>
      <description>题目描述是经典的蛇形填数问题。
以前解决这类问题，通常是通过控制$i,j$的值来定位数组元素的位置，然后进行赋值。但是这种方法非常的繁琐，且难于理解。容易出错。
今天在做这道题目的时候，通过搜索资料，思索出了一种新解法，相较于原来的解法更以理解，且时间复杂度更低。解法的基本思想是 BFS。下面我们仔细来探讨一下。
首先我们定义一组偏移量数组：
const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 }; 这个数组的顺序必须和填数的顺序一致。在这里，它被定义为逆时针填数。
然后我们需要设置 BFS 的起点：
x = 1; y = N; i = 0; f[x][y] = nNum++; 其中，$x,y$用来保存当前坐标，$i$则是保存当前偏移量的数组下标。$f\left [ x \right ]\left [ y \right ]$表示需要填充的矩阵，$nNum$则是所需要填的数。
我们来简单的模拟以下，假设现在坐标为$\left ( 1,n \right )$，偏移量下标$i=0$。首先尝试向右扩展标$\left ( 1,n+1 \right )$，不合法，于是返回到坐标$\left ( 1,n \right )$再先下扩展，检测合法后，进行填充，当填充到最下端时，又不合法，这样，返回到坐标$\left ( n,n \right )$后向左扩展，同理，填充到最左端后又会向上扩展，这里还需要检测当前扩展结点是否已经填数。如果已经填数，则不合法，需要返回上一个坐标。
这样我们模拟一遍 BFS 就可以知道，这种解法是正确的，所以这里略过证明。</description>
    </item>
    
  </channel>
</rss>
