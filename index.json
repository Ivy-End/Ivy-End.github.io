[{"categories":["码志"],"content":"这一节我们将介绍结束游戏的方法，以及一些整体方面的完善。首先考虑失败的情况，它会将所有的地雷都显示出来。我们新建一个 GameLost 函数： private void GameLost() { for(int i = 1; i\u003c= nWidth; i++) { for(int j = 1; j\u003c= nHeight; j++) { if(pMine[i, j] == -1 \u0026\u0026 (pState[i, j] == 0 || pState[i, j] == 3)) // 未点开或者标记为问号的雷 { pState[i, j] = 1; // 点开该地雷 } } } } 在游戏结束的地方调用 GameLost 函数，因为我们上一节中讲述的游戏结束都是失败的情况： if(nFlagCnt == nSysCnt || nFlagCnt + nDoubtCnt == nSysCnt) // 打开九宫格 { bool bFlag = OpenMine(MouseFocus.X, MouseFocus.Y); if(!bFlag) // 周围有地雷 { // 结束游戏 GameLost(); } } if(pMine[MouseFocus.X, MouseFocus.Y] != -1 \u0026\u0026 pState[MouseFocus.X, MouseFocus.Y] == 0) { dfs(MouseFocus.X, MouseFocus.Y); } else { // 地雷，游戏结束 GameLost(); } 我们发现游戏结束的时候，虽然所有的格子都打开了，但是并没有显示出地雷的图标，我们将地雷的图标调整为 20×20，并且按照上一节的方法将它将入到 Resources.resx 文件中。同时修改 PaintGame 函数点开部分的代码如下： else if(pState[i, j] == 1) // 点开 { // 绘制背景 if(MouseFocus.X == i \u0026\u0026 MouseFocus.Y == j) { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.LightGray)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.LightGray, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } // 绘制数字 if(pMine[i, j] != 0) { Brush DrawBrush = new SolidBrush(Color.Blue); // 定义钢笔 // 各个地雷数目的颜色 if (pMine[i, j] == 2) { DrawBrush = new SolidBrush(Color.Green); } if (pMine[i, j] == 3) { DrawBrush = new SolidBrush(Color.Red); } if (pMine[i, j] == 4) { DrawBrush = new SolidBrush(Color.DarkBlue); } if (pMine[i, j] == 5) { DrawBrush = new SolidBrush(Color.DarkRed); } if (pMine[i, j] == 6) { DrawBrush = new SolidBrush(Color.DarkSeaGreen); } if (pMine[i, j] == 7) { DrawBrush = new SolidBrush(Color.Black); } if (pMine[i, j] == 8) { DrawBrush = new SolidBrush(Color.DarkGray); } SizeF Size = g.MeasureString(pMine[i, j].ToString(), new Font(\"Consolas\", 16)); g.DrawString(pMine[i, j].ToString(), new Font(\"Consolas\", 16), DrawBrush, nOffsetX + 34 * (i - 1) + 1 + (32 - Size.Width) / 2, nOffsetY + 34 * (j - 1) + 1 + (32 - Size.Height) / 2); } // 绘制地雷 if(pMine[i, j] == -1) { g.DrawImage(Properties.Resources.Mine, nOffsetX + 34 * (i - 1) + 1 + 4, nOffsetY + 34 * (j - 1) + 1 + 2); // 绘制地雷 } } 此时，我们再次测试的时候，就会看到地雷的图标了： 阶段性效果\" 阶段性效果 然而，我们发现有一个问题，当我们单击数字的时候，会把所有的地雷都显示出来，也就是游戏结束。我们修改左击的事件： else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1) { if(pState[MouseFocus.X, MouseFocus.Y] == 0) { dfs(MouseFocus.X, MouseFocus.Y); } } else { // 地雷，游戏结束 GameLost(); } } 这时候，刚才的问题就得到了修复。但是我们却又发现了一个问题——游戏结束的时候，还是可以继续单击雷区，打开区域。为此，我们增加一个变量检测游戏是否结束，如果结束，则任何按键都视为无效。首先定义一个变量： bool bGame; // 游戏是否结束 我们在游戏开始的时候对它进行初始化，在 New Game 菜单事件处理函数的末尾修改代码如下： Label_Mine.Text = nMineCnt.ToString(); // 显示地雷数目 Label_Timer.Text = \"0\"; // 计时器清零 Timer_Main.Enable = true; // 启动计时器计时 bGame = false; // 游戏暂未结束 将 GameLost 函数修改如下： private void GameLost() { for(int i = 1; i\u003c= nWidth; i++) { for(int j = 1; j\u003c= nHeight; j++) { if(pMine[i, j] == -1 \u0026\u0026 (pState[i, j] == 0 || pState[i, j] == 3)) // 未点开或者标记为问号的雷 { pState[i, j] = 1; // 点开该地雷 } } } bGame = true; } 同时修改 MouseUp 事件，将开头代码修改如下： private void Form_Main_MouseUp(object sender, MouseEventArgs e) { if(MouseFocus.X == 0 \u0026\u0026 MouseFocus.Y == 0 || bGame) // 不在地雷区域或游戏结束 { return; // 不做任何处理 } 至此，这个问题已经得到了修复。我们可以运行查看结果。 但是，我们现在还有一个判断游戏胜利的函数没有写，我们在每次打开地雷区域的时候判断游戏者是否胜利，首先定义一个 GameWin 函数如下： private void GameWin() { int nCnt = 0; // 用户标记红旗数目、问号数目、以及无标记未点开区域总数 for(int i = 1; i \u003c= nWidth; i++) { for(int j = 1; j \u003c= nHeight; j++) { if(pState[i, j] == 0 || pState[i, j] == 2 || pState[i, j] == 3) // 对应标记未点开区域、红旗区域、问号区域 { nCnt++; } } } if(nCnt == nMineCnt) // 胜利条件 { Timer_Main.Enabled = false; // 关闭计时器 MessageBox.Show(String.Format(\"游戏胜利，耗时：{0} 秒\", Label_Timer.Text), \"提示\", MessageBoxButtons.OK); // 更新记录 if (nWidth == 10 \u0026\u0026 nHeight == 10 \u0026\u0026 nMineCnt == 10) // 初级 { if (Properties.Settings.Default.Beginner \u003e Convert.ToInt32(Label_Timer.Text)) // 更新记录 { Properties.Settings.Default.Beginner = Convert.ToInt32(Label_Timer.Text) Properties.Settings.Default.Beginner.Save(); } } else if (nWidth == 16 \u0026\u0026 nHeight == 16 \u0026\u0026 nMin","date":"2015-05-02","objectID":"/2015/05/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%85%AB%E8%8A%82%E6%95%B4%E4%BD%93%E5%AE%8C%E5%96%84/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第八节、整体完善","uri":"/2015/05/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%85%AB%E8%8A%82%E6%95%B4%E4%BD%93%E5%AE%8C%E5%96%84/"},{"categories":["码志"],"content":"这一节我们主要讲解扫雷时鼠标单击的事件。我们首先介绍左键单击的事件，分为两种情况——遇到地雷，游戏结束；不是地雷，自动点开相邻的非地雷区域，并且显示对应地雷区域周围地雷的数目。 我们首先需要为 Form_Main 添加 MouseDown 以及 MouseUp 事件，分别用来监测鼠标按下以及弹起的事件信息。再定义两个全局变量，用来标识鼠标左键以及右键是否被按下，代码如下： bool bMouseLeft; // 鼠标左键是否被按下 bool bMouseRight; // 鼠标右键是否被按下 在 MouseDown 事件中输入下面的代码： private void Form_Main_MouseDown(object sender, MouseEventArgs e) { if(e.Button == MouseButtons.Left) // 鼠标左键被按下 { bMouseLeft = true; } if(e.Button == MouseButtons.Right) // 鼠标右键被按下 { bMouseRight = true; } } 在 MouseUp 事件中，我们需要获取鼠标弹起前按下的鼠标按键的状态信息，代码如下： private void Form_Main_MouseUp(object sender, MouseEventArgs e) { if(bMouseLeft \u0026\u0026 BMouseRight) // 左右键同时按下 { } else if(bMouseLeft) // 左键被按下 { } else if(bMouseRight) // 右键被按下 { } } 我们首先处理鼠标左键按下的情况，这里分为两种情况，在前文中已经介绍过。但是在处理之前，我们需要获取游戏者单击的是哪个雷区，因此我们需要加入一些用以判断当前鼠标所属区域的代码。但是回顾一下，我们上一节中在 MouseMove 事件中已经获得了当前鼠标所属的区域，并且保存在了全局变量中，因此，我们直接调用即可： private void Form_Main_MouseUp(object sender, MouseEventArgs e) { if(MouseFocus.X == 0 \u0026\u0026 MouseFocus.Y == 0) // 不在地雷区域 { return; // 不做任何处理 } if(bMouseLeft \u0026\u0026 BMouseRight) // 左右键同时按下 { } else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1) { // 非地雷，自动打开周围非地雷区域 } else { // 地雷，游戏结束 } } else if(bMouseRight) // 右键被按下 { } bMouseLeft = bMouseRight = false; } 我们首先来处理非地雷的情况。也就是说我们需要寻找所有相邻的非地雷区域，这里我们才有深度优先搜索（Depth First Search），首先定义一个函数如下： private void dfs(int sx, int sy) { pState[sx, sy] = 1; // 访问该点 for(int i = 0; i \u003c 4; i++) { // 获取相邻点的坐标 int x = sx + px[i]; int y = sy + py[i]; if(x \u003e= 1 \u0026\u0026 x \u003c= nWidth \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= nHeight \u0026\u0026 pMine[x, y] != -1 \u0026\u0026 pMine[sx, sy] == 0 \u0026\u0026 (pState[x, y] == 0 || pState[x, y] == 3)) // 不是地雷，处于地雷区域，且未点开，或者标记为问号 { dfs(x, y); // 访问该点 } } } 在 MouseUp 函数中调用，并且刷新绘图区域： else if(bMouseLeft) // 左键被按下 { if(pMine[MouseFocus.X, MouseFocus.Y] != -1) { dfs(MouseFocus.X, MouseFocus.Y); } else { // 地雷，游戏结束 } } 此时，我们运行程序，单击雷区，与上一节结束时的程序没有什么区别，因为我们还没有更新绘图函数，用下面的代码更新 PaintGame 函数主循环中的代码： /// \u003csummary\u003e /// 绘制游戏区 /// \u003c/summary\u003e private void PaintGame(Graphics g) { g.Clear(Color.White); // 清空绘图区 // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u003c= nWidth; i++) // 绘制行 { for (int j = 1; j \u003c= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 if(pState[i, j] == 0) // 未点开 { if(i == MouseFocus.X \u0026\u0026 j == MouseFocus.Y) // 是否为高亮点 { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.SandyBrown)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } } else if(pState[i, j] == 1) // 点开 { if(pMine[i, j] != -1) // 非地雷 { // 绘制背景 if(MouseFocus.X == i \u0026\u0026 MouseFocus.Y == j) { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.LightGray)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.LightGray, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } // 绘制数字 if(pMine[i, j] != 0) { Brush DrawBrush = new SolidBrush(Color.Blue); // 定义钢笔 // 各个地雷数目的颜色 if (pMine[i, j] == 2) { DrawBrush = new SolidBrush(Color.Green); } if (pMine[i, j] == 3) { DrawBrush = new SolidBrush(Color.Red); } if (pMine[i, j] == 4) { DrawBrush = new SolidBrush(Color.DarkBlue); } if (pMine[i, j] == 5) { DrawBrush = new SolidBrush(Color.DarkRed); } if (pMine[i, j] == 6) { DrawBrush = new SolidBrush(Color.DarkSeaGreen); } if (pMine[i, j] == 7) { DrawBrush = new SolidBrush(Color.Black); } if (pMine[i, j] == 8) { DrawBrush = new SolidBrush(Color.DarkGray); } SizeF Size = g.MeasureString(pMine[i, j].ToString(), new Font(\"Consolas\", 16)); g.DrawString(pMine[i, j].ToString(), new Font(\"Consolas\", 16), DrawBrush, nOffsetX + 34 * (i - 1) + 1 + (32 - Size.Width) / 2, nOffsetY + 34 * (j - 1) + 1 + (32 - Size.Height) / 2); } ","date":"2015-05-01","objectID":"/2015/05/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%83%E8%8A%82%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%AD/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第七节、内部实现（续）","uri":"/2015/05/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%83%E8%8A%82%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%AD/"},{"categories":["码志"],"content":"在进行内部实现之前，我们先来考虑一下扫雷的内部逻辑。首先，我们需要保存每个点上是否有地雷，如果没有地雷，那么要显示与它紧邻的八个格子中一共有多少的地雷。还需保存每个雷区的状态（点开，未点开，红旗，问号）。我们考虑定义两个常量，表示地雷的最大范围： const int MAX_WIDTH = 64; // 最大宽度 const int MAX_HEIGHT = 32; // 最大高度 接下来定义两个数组，用来保存上述两种数据。对于第一类数据，我们使用 -1 表示该区域有地雷，使用数字表示与它紧邻的八个格子中一共有多少地雷；对于第二类数据，我们使用 0 表示未点开，1 表示点开，2 表示红旗，3 表示问号。如下图所示： int[,] pMine = new int[MAX_WIDTH, MAX_HEIGHT]; // 第一类数据 int[,] pState = new int[MAX_WIDTH, MAX_HEIGHT]; // 第二类数据 接下来我们需要初始化游戏数据，双击 New Game 菜单，输入游戏的初始化代码： private void newGameNToolStripMenuItem_Click(object sender, EventArgs e) { // 以下两行清空数组 Array.Clear(pMine, 0, pMine.Length); Array.Clear(pState, 0, pState.Length); // 初始化地雷数据 Random Rand = new Random(); for(int i = 1; i \u003c= nMineCnt; ) // 地雷总数 { // 随机地雷坐标 (x, y) int x = Rand.Next(nWidth) + 1; int y = Rand.Next(nHeight) + 1; if (pMine[x, y] != -1) { pMine[x, y] = -1; i++; } } for(int i = 1 ; i \u003c= nWidth; i++) // 枚举宽度 { for(int j = 1; j \u003c= nHeight; j++) // 枚举高度 { if(pMine[i, j] != -1) // 不是地雷，显示周围地雷数 { for(int k = 0; k \u003c 8; k++) // 八个方向拓展 { if(pMine[i + dx[k], j + dy[k]] == -1) // 找到地雷 { pMine[i, j]++; // 地雷数自增 } } } } } } 其中涉及到了 dx 以及 dy 这两个偏移量常量数组的定义，如下图所示： int[] dx = new int[] { -1, 0, 1, -1, 1, -1, 0, 1 }; // x 坐标偏移量 int[] dy = new int[] { 1, 1, 1, 0, 0, -1, -1, -1 }; // y 坐标偏移量 接下来我我们来实现一些特效，例如高亮当前鼠标悬浮位置的雷区，打开设计窗口，添加 MouseMove 事件： private void Form_Main_MouseMove(object sender, MouseEventArgs e) { int x = (e.X - 6) / 36 + 1; // 获取 x 位置 int y = (e.Y - MenuStrip_Main.Height - 6) / 36 + 1; // 获取 y 位置 MouseFocus.X = x; MouseFocus.Y = y; // 设置当前高亮点 PaintGame(); // 重绘雷区 } 为此，我们还需要定义一个变量 MouseFocus 来记录当前的高亮点，代码分别如下： Point MouseFocus; // 高亮点记录 同时，我们需要在初始化的时候对它进行清零操作，将下面的清零代码加入到刚才的初始化函数中： // 重置高亮点 MouseFocus.X = 0; MouseFocus.Y = 0; 接下来我们需要修改 PaintGame 函数，添加对高亮点的绘制： /// \u003csummary\u003e /// 绘制游戏区 /// \u003c/summary\u003e private void PaintGame() { Graphics g = this.CreateGraphics(); // 创建绘图句柄 g.FillRectangle(Brushes.White, new Rectangle(0, 0, this.Width, this.Height)); // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u003c= nWidth; i++) // 绘制行 { for (int j = 1; j \u003c= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 if(i == MouseFocus.X \u0026\u0026 j == MouseFocus.Y) // 是否为高亮点 { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.SandyBrown)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); } else { g.FillRectangle(Brushes.SandyBrown, new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + 1, 32, 32)); // 绘制雷区方块 } } } } 此时，我们可以尝试运行，然而却发现界面会一直在闪，使得游戏体验急剧下降，为了修复这个问题，我们只需要在构造函数中添加一句代码，开启双缓冲即可，代码如下： public Form_Main() { InitializeComponent(); this.DoubleBuffered = true; // 开启双缓冲 // 初始化游戏参数 nWidth = Properties.Settings.Default.Width; nHeight = Properties.Settings.Default.Height; nMineCnt = Properties.Settings.Default.MineCnt; // 初始化 bMark = Properties.Settings.Default.Mark; bAudio = Properties.Settings.Default.Audio; markMToolStripMenuItem.Checked = bMark; audioMToolStripMenuItem.Checked = bAudio; UpdateSize(); SelectLevel(); } 然而我们发现效果并没有很大的提升，这是由于我们之前定义的 PaintGame 函数所导致的，它不断的定义新的 Graphics 实例，使得这个过程变得很慢，我们可以直接使用 Paint 事件中的 Graphics 实例。首先修改 PaintGame 函数的定义以及部分实现，如下图所示： /// \u003csummary\u003e /// 绘制游戏区 /// \u003c/summary\u003e private void PaintGame(Graphics g) { g.Clear(Color.White); // 清空绘图区 // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u003c= nWidth; i++) // 绘制行 { for (int j = 1; j \u003c= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的间隔，因此还需要加 1 // 由此可以得到每个方块在雷区中的位置，然后利用循环绘制出来 if(i == MouseFocus.X \u0026\u0026 j == MouseFocus.Y) // 是否为高亮点 { g.FillRectangle(Brushes.SolidBrush(Color.FromArgb(100, Color.SandyBrown)), new Rectangle(nOffsetX + 34 * (i - 1) + 1, nOffsetY + 34 * (j - 1) + ","date":"2015-04-30","objectID":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%85%AD%E8%8A%82%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第六节、内部实现","uri":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%85%AD%E8%8A%82%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/"},{"categories":["码志"],"content":"上一节中，我们还剩下 Setting 和 Rank 两个菜单项目没有设置事件，是因为它们都涉及到了弹出一个新的窗口。这一节，我们将主要介绍创建窗口的方法，以及窗口之间的数据通信。 首先，我们新建一个窗口，在右侧找到解决方案资源管理器，右击 Minesweeper 项目名，选择添加，如图所示： 菜单示意图\" 菜单示意图 选择新建项，如图所示： 菜单示意图\" 菜单示意图 在弹出的窗口中选择 Windows 窗体，并将名称修改为 Form_Setting.cs，单击确定，如图所示： 新建窗口示意图\" 新建窗口示意图 将新建的窗口 Icon 属性修改为扫雷的图标，将 MaximizeBox 属性修改为 False，将 Name 属性修改为 Form_Setting，将 BackColor 属性修改为 White，将 Text 属性修改为 Minesweeper，将 FormBorderStyle 属性改为 FixedSingle。 在左边工具箱面板下公共控件中找到 Label 控件，双击添加到窗口中，将它的 Name 属性修改为 Label_Width，Text 属性修改为“Width:”，并移动到合适的位置，再在工具箱面板中找到 NumericUpDown 控件，双击添加到窗口中，将它的 Name 属性修改为 NumericUpDown_Width，Minimum 属性修改为 1，Maximun 属性修改为 30，（其中 Minimum 以及 Maximum 的属性表示为数字的变化范围。）TextAlign 属性修改为 Center。其中 Minimum以 及 Maximum 的属性表示为数字的变化范围。如下图所示： 窗口示意图\" 窗口示意图 重复上述操作，添加雷区高度（Height），地雷数目（Mine）的控件，其中高度的变化范围为 1 至 16，数目的变化范围为 1 至 99。如下图所示： 窗口示意图\" 窗口示意图 接下来我们需要添加两个按钮，用来确定修改以及取消修改。在左侧工具箱面板的公共控件中找到 Button 控件，双击添加到窗体中，将它的 Name 属性修改为 Button_OK，Text 属性修改为 OK。同时添加一个取消按钮（Cancel），如下图所示： 窗口示意图\" 窗口示意图 然后拖动窗口右下方的白点，调整窗口大小到合适的位置，如下图所示： 窗口示意图\" 窗口示意图 接下来我们用同样的方法和设置来创建一个排行榜的窗口（Form_Rank）。 放置三个标签，分别表示初级（Label_Beginner）、中级（Label_Intermediate）、高级（Label_Expert）的最高分，并且加入两个按钮，表示重新计分（Button_Reset）、确定（OK），如图所示： 窗口示意图\" 窗口示意图 接下来，我们就可以调用这两个窗口了。打开 Form_Main 窗口，为 Setting 和 Rank 分别添加单击事件（双击菜单项，程序自动添加该时间），并且写下如下代码： private void settingSToolStripMenuItem_Click(object sender, EventArgs e) { Form_Setting Setting = new Form_Setting(); Setting.ShowDialog(); } private void rankRToolStripMenuItem_Click(object sender, EventArgs e) { Form_Rank Rank = new Form_Rank(); Rank.ShowDialog(); } 这样，我们就完成了对窗口的调用。接下去，我们先来实现较为简单的 Rank 窗口。每次读取最高分的数据，这也就要求我们每次记录得分。 打开 Settings 文件，添加三种等级的最高分，并且将初始值都设置为 999，如下图所示： Setting 示意图\" Setting 示意图 打开排名窗口，双击窗口标题栏，程序会自动添加一个 Load 事件，我们在这里添加如下代码： private void Form_Rank_Load(object sender, EventArgs e) { // 读取数据 int nBeginner = Propoerties.Settings.Default.Beginner; int nIntermediate = Propoerties.Settings.Default.Intermediate; int nExport = Propoerties.Settings.Default.Export; // 显示内容 Label_Beginer.Text = String.Format(\"Beginner: {0}\", nBeginner); Label_Intermeidate.Text = String.Format(\"Intermediate: {0}\", nIntermediate); Label_Expert.Text = String.Format(\"Expert: {0}\", nExpert); } 这样，我们调试一下，就可以看到排名的效果了： Rank 示意图\" Rank 示意图 接下去我们需要为 Reset 以及 OK 按钮添加事件。首先考虑 OK 按钮，双击按钮，添加单击事件，并且添加如下代码： private void Button_OK_Click(object sender, EventArgs e) { this.close(); // 关闭窗口，非退出程序 } 对于 Reset 按钮，我们添加如下代码： private void Button_Reset_Click(object sender, EventArgs e) { // 将所有记录设置为 999 即完成初始化 Propoerties.Settings.Default.Beginner = 999; Propoerties.Settings.Default.Intermediate = 999; Propoerties.Settings.Default.Export = 999; Propoerties.Settings.Default.Save(); // 保存设置 } 这样，我们就完成了排行榜的功能。接下来我们来考虑设置窗口的功能。我们首先为 Cancel 按钮添加如下代码： private void Button_Cancel_Click(object sender, EventArgs e) { this.close(); // 关闭窗口，非退出程序 } 我们考虑 OK 按钮，我们需要和 Form_Main 窗口进行通信，修改 Form_Setting 的构造函数，如图所示： Form_Main Main; public Form_Setting(Form_Main _Main) { InitializeComponent(); Main = _Main; // 传递父窗口实例 } 接着将 Form_Main 中 nWidth、nHeight、nMine 变量设置为公有类型： public int nWidth; // 表示雷区的宽度 public int nHeight; // 表示雷区的高度 public int nMineCnt; // 表示地雷的数量 然后修改对 Setting 窗口的调用函数： private void settingSToolStripMenuItem_Click(object sender, EventArgs e) { Form_Setting Setting = new Form_Setting(this); // 将本身作为参数传递过去 Setting.ShowDialog(); } 至此，我们就完成了 Setting 窗口和 Main 窗口的信息连接，双击 Setting 窗口的标题栏，修改它的 Load 事件如下，以实现对 Main 窗口中原有游戏参数的读取： private void Form_Setting_Load(object sender, EventArgs e) { NumericUpDown_Width.Value = Convert.ToDecimal(Main.nWidth); NumericUpDown_Height.Value = Convert.ToDecimal(Main.nHeight); NumericUpDown_Mine.Value = Convert.ToDecimal(Main.nMineCnt); } 这样，我们运行的时候就可以看到 Setting 窗口自动获取了 Main 中的游戏参数： Setting 窗口示意图\" Setting 窗口示意图 接下来我们为 OK 按钮添加如下的事件： private void Button_OK_Click(object sender, EventArgs e) { Main.nWidth = Convert.ToDecimal(NumericUpDown_Width.Value); Main.nHeight = Convert.ToDecimal(NumericUpDown_Height.Value); Main.nMineCnt = Convert.ToDecimal(NumericUpDown_Mine.Value); this.Close(); } 这样，我们就完成了游戏规模的设置，有时候，我们发","date":"2015-04-24","objectID":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%94%E8%8A%82%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C%E7%BB%AD/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第五节、菜单操作（续）","uri":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%94%E8%8A%82%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C%E7%BB%AD/"},{"categories":["码志"],"content":"我们现在的程序单击菜单的时候不会有任何反应，这一节我们主要介绍菜单的相关代码，使得菜单能够正常使用。 在第二节中，我们曾经提出希望在对应级别（初级、中级、高级、自定义）的按钮的显示勾，以表示目前的游戏等级。我们有两个时候需要对它进行操作，一个是加载上次游戏设置的时候，一个是在游戏过程中进行设置的时候，我们先介绍第一种情况。按照下图修改代码： /// \u003csummary\u003e /// 选择对应的游戏等级 /// \u003c/summary\u003e private void SelectLevel() { if (nWidth == 10 \u0026\u0026 nHeight == 10 \u0026\u0026 nMineCnt == 10) { beginnerBToolStripMenuItem.Checked = true; intermediateIToolStripMenuItem.Checked = false; expertEToolStripMenuItem.Checked = false; settingSToolStripMenuItem.Checked = false; } else if (nWidth == 16 \u0026\u0026 nHeight == 16 \u0026\u0026 nMineCnt == 40) { beginnerBToolStripMenuItem.Checked = false; intermediateIToolStripMenuItem.Checked = true; expertEToolStripMenuItem.Checked = false; settingSToolStripMenuItem.Checked = false; } else if (nWidth == 30 \u0026\u0026 nHeight == 16 \u0026\u0026 nMineCnt == 99) { beginnerBToolStripMenuItem.Checked = false; intermediateIToolStripMenuItem.Checked = false; expertEToolStripMenuItem.Checked = true; settingSToolStripMenuItem.Checked = false; } else { beginnerBToolStripMenuItem.Checked = false; intermediateIToolStripMenuItem.Checked = false; expertEToolStripMenuItem.Checked = false; settingSToolStripMenuItem.Checked = true; } } 注意到 beginnerBToolStripMenuItem、intermediateIToolStripMenuItem、expertEToolStripMenuItem、settingSToolStripMenuItem 分别表示四个等级的菜单的名称，通过修改它们的 Checked 属性来达到修改对应项目前面勾的状态。我们还需要在初始化函数中调用这个函数： /// \u003csummary\u003e /// 游戏参数设置 /// \u003c/summary\u003e /// \u003cparam name=\"Width\"\u003e雷区宽度\u003c/param\u003e /// \u003cparam name=\"Height\"\u003e雷区高度\u003c/param\u003e /// \u003cparam name=\"MineCnt\"\u003e地雷数目\u003c/param\u003e private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; UpdateSize(); SelectLevel(); } 这时候，我们运行就会发现Beginner菜单前面的勾被选中了： 菜单示意图\" 菜单示意图 下面我们来处理一下各个菜单按钮的事件，我们只需要双击菜单上的按钮，程序会自动创建对应的单击事件，我们只需要在其中书写代码即可。我们首先来创建 Beginner、Intermediate、Expert、Exit、About 菜单项目对应的事件。我们先介绍 Beginner、Intermediate、Expert 菜单项目对应的代码： private void beginnerBToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 10; nHeight = 10; nMineCnt = 10; SelectLevel(); } private void intermediateIToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 16; nHeight = 16; nMineCnt = 40; SelectLevel(); } private void expertEToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 30; nHeight = 16; nMineCnt = 99; SelectLevel(); } 接下来，我们处理 Exit 事件，我们希望在退出游戏之前询问游戏者是否确认退出，代码如下： private void exitXToolStripMenuItem_Click(object sender, EventArgs e) { if(MessageBox.Show(\"Are you sure to exit the game?\", \"Exit\", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes) { Application.Exit(); } } 然后，我们来处理 About 事件，我们希望得到类似 Windows 默认关于窗口的界面。为此，首先我们需要引用一个类，在代码的开头部分加上下图高亮部分的代码： using System; using System.Collections.Generic; using System.ComponentModal; using System.Data; using System.Drawing; using System.Linq; using System.Runtime.InteropServices; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; 为了实现这样的功能，我们需要调用 Windows 系统内部的一个 API，添加这样一个函数： /// \u003csummary\u003e /// 系统关于对话框（API） /// \u003c/summary\u003e /// \u003cparam name=\"hWnd\"\u003e窗口句柄\u003c/param\u003e /// \u003cparam name=\"szApp\"\u003e标题文本\u003c/param\u003e /// \u003cparam name=\"szOtherStuff\"\u003e内容文本\u003c/param\u003e /// \u003cparam name=\"hIcon\"\u003e图标句柄\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e [DllImport(\"shell32.dll\")] public extern static int ShellAbout(IntPtr hWnd, string szApp, string szOtherStuff, IntPtr hIcon); 在 About 事件中添加如下代码进行调用： private void aboutAToolStripMenuItem_Click(object sender, EventArgs e) { ShellAbout(this.Handle, \"Minesweeper\", \"A minesweeper game using CSharp language.\", this.Icon.Handle); } 运行以后查看结果如下图所示： 关于\" 关于 可能细心的读者会发现，虽然我们通过菜单修改了游戏等级，但是我们窗口中的雷区却没有发生变化，因为我们没有在菜单被按下的时候没有调用 UpdateSize 函数。在三个按钮的事件中添加对 UpdateSize 函数的调用即可。代码如下： private void beginnerBToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 10; nHeight = 10; nMineCnt = 10; SelectLevel(); UpdateSize(); } private void intermediateIToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 16; nHeight = 16; nMineCnt = 40; SelectLevel(); UpdateSize(); } private void expertEToolStripMenuItem_Click(object sender, EventArgs e) { nWidth = 30; nHeight = 16; nMineCnt = 9","date":"2015-04-22","objectID":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%9B%9B%E8%8A%82%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第四节、菜单操作","uri":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E5%9B%9B%E8%8A%82%E8%8F%9C%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["码志"],"content":"这一节我们主要涉及界面中雷区的绘制方法。 首先来考虑几个问题。为了保存整个雷区的信息，我们需要哪些数据。显然，除了要保存雷区的宽度和高度（分别定义为宽和高方向上方块的个数）外，还需要保存地雷的数目。这样我们需要用到三个变量 nWidth, nHeight, nMineCnt 分别保存雷区的宽度、雷区的高度以及地雷的数目。 右击窗口，选择查看代码，也可以使用快捷键 F7，如下图所示： 菜单示意图\" 菜单示意图 可以看到这样的代码界面： 代码界面\" 代码界面 添加如下所示的代码，用来定义扫雷区域的基本变量，它们的含义在上文或者注释中都有提及： namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } } } 为了方便设置这三个参数，我们可以定义一个新的函数 SetGame，如下所示： namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } } } 这样，我们就可以通过调用 SetGame 函数来设置游戏的参数了。为了方便阅读，我们可以为这个函数加上一个注释，在函数名上方输入\"///\"，程序会自动生成一个注释块，如下所示： namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } /// \u003csummary\u003e /// /// \u003c/summary\u003e /// \u003cparam name=\"Width\"\u003e\u003c/param\u003e /// \u003cparam name=\"Height\"\u003e\u003c/param\u003e /// \u003cparam name=\"MineCnt\"\u003e\u003c/param\u003e private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } } } 输入相关信息，第二行的内容是用来对函数的作用进行说明，下面的三行分别用来对三个参数的作用进行说明，将它们修改如下： /// \u003csummary\u003e /// 游戏参数设置 /// \u003c/summary\u003e /// \u003cparam name=\"Width\"\u003e雷区宽度\u003c/param\u003e /// \u003cparam name=\"Height\"\u003e雷区高度\u003c/param\u003e /// \u003cparam name=\"MineCnt\"\u003e地雷数目\u003c/param\u003e private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } 这样当我们输入这个函数的时候（当然，我们目前还不需要调用这个函数。），就会显示出来对应的注释，如下图所示： 注释示意图\" 注释示意图 到目前为止，我们的代码应该是这样的： namespace Minesweeper { public partial class Form_Main : Form { int nWidth; // 表示雷区的宽度 int nHeight; // 表示雷区的高度 int nMineCnt; // 表示地雷的数目 public Form_Main() { InitializeComponent(); } /// \u003csummary\u003e /// 游戏参数设置 /// \u003c/summary\u003e /// \u003cparam name=\"Width\"\u003e雷区宽度\u003c/param\u003e /// \u003cparam name=\"Height\"\u003e雷区高度\u003c/param\u003e /// \u003cparam name=\"MineCnt\"\u003e地雷数目\u003c/param\u003e private void SetGame(int Width, int Height, int MineCnt) { nWidth = Width; nHeight = Height; nMineCnt = MineCnt; } } } 接下来我们可以定义几个辅助函数，分别表示设置游戏参数为初级、中级、高级，如下图所示： /// \u003csummary\u003e /// 设置游戏等级为初级 /// \u003c/summary\u003e private void SetGameBeginner() { SetGame(10, 10, 10); } /// \u003csummary\u003e /// 设置游戏等级为中级 /// \u003c/summary\u003e private void SetGameIntermediate() { SetGame(16, 16, 40); } /// \u003csummary\u003e /// 设置游戏等级为高级 /// \u003c/summary\u003e private void SetGameExpert() { SetGame(30, 16, 99); } 在我们开始游戏的时候，我们希望它自动获取上次的游戏设置，如果这是第一次开始游戏，那么将游戏设置为初级。 我们先来看一下第一个需求，自动获取上次的游戏设置，这就意味着我们需要在上次游戏关闭的时候将上次的游戏设置保存下来。保存到哪里呢，我们在这里采用 Setting 文件来保存这些数据。工程创建的时候，系统会自动生成一个 Setting 文件。因此我们不需要自己创建，只需要使用原有的 Setting 文件即可。在右方解决方案资源管理器面板中展开 Properties，右击 Settings.settings，选择打开即可。 解决方案资源管理器\" 解决方案资源管理器 打开后的界面如图所示： Settings.settings 示意图\" Settings.settings 示意图 按照下图对它进行设置，设置完成后按Ctrl + S进行保存。 Settings.settings 设置示意图\" Settings.settings 设置示意图 注意到第四栏值，我们将它初始化为初级的参数，也就完成了我们刚才的第二个需求——无法找到上一次设置的时候，我们将它置为初级模式。 就行了，我们需要通过代码将这些参数读入到定义的变量中去，加入如下图所示的代码： public Form_Main() { InitializeComponent(); // 初始化游戏参数 nWidth = Properties.Settings.Default.Width; nHeight = Properties.Settings.Default.Height; nMineCnt = Properties.Settings.Default.MineCnt; } 有了这些参数我们就可以绘制雷区了，我们假定雷区为 32×32 的小方块，并且四周有一圈宽度为 1 的留白，用于与其它雷区区别，这样，每个雷区的实际大小为 34×34。 接下去，我们将窗口切换到界面布局，选中主窗口，在左边的属性面板中，单击事件按钮，并找到 Paint 事件，双击该条目，系统会自动创建一个事件，我们将在这里绘制雷区。如下图所示： 创建事件\" 创建事件 添加 Paint 事件以后，程序会自动跳到代码编辑窗口，并且会看到如下的代码： private void Form_Main_Paint(object sender, PaintEventArgs e) { } 将Paint函数中的内容修改如下： private void Form_Main_Paint(object sender, PaintEventArgs e) { Graphics g = this.CreateGraphics(); // 创建绘图句柄 // 我们需要使雷区在用户显示的区域上下左右保持 6px 的偏移量，使得整体看起来更加协调 int nOffsetX = 6; // X 方向偏移量 int nOffsetY = 6 + MenuStrip_Main.Height; // Y 方向偏移量 for (int i = 1; i \u003c= nWidth; i++) // 绘制行 { for (int j = 1; j \u003c= nHeight; j++) // 绘制列 { // 第一个参数为笔刷，这里采用内置笔刷 SandyBrown // 第二个参数为方块的参数，这里采用左上角坐标以及长宽的形式给出 // 34 表示每个雷区的大小，再加上偏移量就是我们当前雷区的起始位置，由于要空出 1px 的","date":"2015-04-21","objectID":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E8%8A%82%E9%9B%B7%E5%8C%BA%E7%BB%98%E5%88%B6/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第三节、雷区绘制","uri":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%89%E8%8A%82%E9%9B%B7%E5%8C%BA%E7%BB%98%E5%88%B6/"},{"categories":["码志"],"content":"这一节我们主要介绍关于扫雷游戏界面的设计，此处我们借鉴经典扫雷界面的设计方法，首先需要创建一个菜单栏。具体方法在左边找到工具箱窗口，展开其中的菜单和工具栏，找到 MenuStrip 选项，如图所示： 添加 MenuStrip\" 添加 MenuStrip 只需要双击该条目就可以在窗口中新建一个菜单栏，如图所示： MenuStrip 添加效果\" MenuStrip 添加效果 对于这个控件（我们习惯上将窗口中的东西称作为控件），我们还是需要修改它的一些属性，对于个人习惯而言，我习惯于修改它的 Name 属性，这样编程的时候不至于将很多控件混淆。我们将它的 Name 属性修改为“MenuStrip_Main”。单击“请在此键入”，输入“Game(\u0026G)”，其中 \u0026G 整体会显示成 G 这个字母下面加一个下划线，这样在用户使用的时候就可以通过按下字母 G 来访问这个按键了。（当然，顶层菜单还需要按下 Alt 键，例如 Alt + G 键。）输入以后的界面如图所示： 添加菜单项\" 添加菜单项 使用同样的方法，创建如下图所示的一个菜单栏： 菜单示意图\" 菜单示意图 注意到，图中的分割线，只需要输入一个减号，即“-”，再按下回车键即可得到。 我们一次介绍一下各个选项的功能，以便读者对它们有一个基本的了解。菜单一共有两组，一个为游戏（Game），一个为帮助（Help）：其中游戏菜单下分别包含了新游戏（New Game）、初级（Beginner）、中级（Intermediate）、高级（Expert）、设置（Setting）、标记（Mark）、音效（Audio）、排行榜（Rank）、退出（Exit）；而帮助菜单下仅包含关于（About）。 其中新游戏用来开始一场新的游戏；初级、中级、高级，用于选择不同的游戏难度；设置用于自定义扫雷区域的大小以及地雷的数目；标记用于设置是否启用红旗、问号这一类的标记；音效用于设置是否启用音效；排行榜用于对游戏时间进行排名（仅记录初级、中级、高级的结果，对于自定义游戏的结果不进行记录）；退出用于退出游戏。最后，关于用来显示游戏的一些关于信息。 对于初级、中级、高级、标记、音效这几个菜单，我们需要在它的前面显示它的状态，即是否被选中，如果选中了就会在它的前面出现一个勾，如果没有选中，则没有，这是我们以后需要实现的功能，在此先进行说明。 至此，我们的菜单栏就制作完成了。接下来我们需要制作一个用来记录地雷数目以及用时的功能。我们选择工具箱中容器的 TableLayoutPanel，双击该项目，会在窗口中创建一个 TableLayoutPanel 控件。同样我们先将它的 Name 属性修改为“TableLayoutPanel_Main”。展开它的 Size 属性，将 Height 属性修改为 48。同时修改它的 Dock 属性，选择 Bottom，如图所示： TableLayoutPanel 属性设置\" TableLayoutPanel 属性设置 我们会发现它会自动吸附在底部，如果改成别的参数则会吸附在别的位置，这里我们设置为 Bottom。同时将 RowCount 属性设置为 1，ColumnCount 属性设置为 9。打开 Columns 属性对话框，按照下图进行修改： TableLayoutPanel 行列样式\" TableLayoutPanel 行列样式 这里进行一些解释，其中 Column1、Column3、Column5、Column7、Column9 为中心对称的，用来设置边距，不放置任何控件，纯粹为了排版需要。接下来我们需要在 Column2、Column8 中分别放置地雷（Mine_Show.png）以及秒表（Timer.png）的图标，表示剩余的地雷数目以及已用时长。而 Columns4、Columns6 中分别放置用于显示地雷数目以及已用时长的文本。下载地址：地雷、秒表。 在工具箱中展开公共控件，找到 PictureBox，将它拖动到 TableLayoutPanel 的第二个列中，同时将它的 Name 属性设置为“PictureBox_Mine”，Dock 属性设置为 Fill（表示充满整个页面，此处的页面即 TableLayoutPanel 中 Column2 全部），BackgroundImage 属性定位到Mine_Show.png文件（通过导入按钮），BackgroundImageLayout 属性设置为 Stretch（表示自动缩放图像大小）。使用同样的方法加入一个 PictureBox 控件，将它放到 Column8 中，同时将 Name 属性设置为“PictureBox_Timer”，BackgroundImage 属性定位到 Timer.png 文件，其余与 PictureBox_Mine 设置相同。其中图片导入的方法如下图所示： TableLayoutPanel PixtureBox 资源设置\" TableLayoutPanel PixtureBox 资源设置 接下来我们需要添加两个用于显示内容的 Label 控件，展开工具箱中的公共控件，找到 Label 控件，分别拖动到 Column4 和 Column6，并且将 Dock 属性设置为 Fill，TextAlign 属性设置为 MiddleCenter（使文字显示在控件中心），Font 属性设置为“Consolas, 16.2pt”（即 Consolas 字体，字号三号）。其 Name 属性及 Text 属性分别修改为“Label_Mine”和“Label_Timer”。同时将它们的 ForeColor 属性分别设置为“DarkRed”和“HotTrack”（这项属性用于设置文字显示的颜色）。 至此界面已经基本完成了，但是我们还需要增加一个控件——Timer，用来计时。展开工具箱中的组件，双击 Timer。这个控件不会在界面上显示，但是会在后台进行计时功能。同样，我们将它的 Name 属性修改为“Timer_Main”，Interval 属性修改为“1000”（这里为计时间隔，以毫秒为单位，此处为 1000 毫秒，即 1 秒计时一次）。 最后按下 Ctrl + F5 进行编译查看结果，相较于第一节中的界面已经有了很大的改观，如图所示： 运行效果\" 运行效果 到这里或许读者会问，最为重要的扫雷区域怎么制作呢，关于这个区域，我们将会使用程序来生成，而不是使用控件。我们将会在下一节中进行讲解。 ","date":"2015-04-20","objectID":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%8C%E8%8A%82%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第二节、界面设计","uri":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%BA%8C%E8%8A%82%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"},{"categories":["码志"],"content":"这一系列的文章主要受许宏旭的启发而来。他目前在连载更新一篇使用 C# 制作五子棋的教程。选择这一项目的主要原因是 Windows 8.1 系统上的扫雷需要前往应用商店下载，显得有些麻烦。因此想自己制作一个。主要采用 C# 语言进行实现。主要功能与原来的扫雷游戏基本相同，进行修改的地方主要是扫雷区的界面。如有不恰当的地方，还望指正。 该项目现已根据文章进度托管在GitHub上，读者可以自行查看。 玩过扫雷的读者应该知道，扫雷需要用到三种图片素材——地雷、红旗、问号。当右击一个方块的时候，会插上红旗，表示游戏者认为该方块内有地雷；再次右击该方块，会变成问号，表示不确定该方块内是否有地雷；第三次右击该方块，问号消失，恢复到初始的状态。我们前往Iconfinder寻找合适的图标，并且通过 Photoshop 或者 Illustrator 的处理得到我们所需要的图标。文章中含有下载地址的图标资源可以使用右键—目标另存为进行下载。 通过一定的搜索以及图片的处理，我们得到了下面一组素材图标。 Mine Sweeper 素材\" Mine Sweeper 素材 除了这些素材以外，我们还需要找一个图标，使得整个程序看上去更加正式一点，这里使用图标如下，注意程序图标的后缀为ico。 Mine Sweeper 图标\" Mine Sweeper 图标 接下来，我们打开Visual Studio 2013开始创建工程，界面如下： Visual Studio 2013\" Visual Studio 2013 依次展开文件—新建—项目，选择“Visual C#”中的“Windows 窗体应用程序”，项目名称填写为“Minesweeper”，单击确定创建项目。如下图所示： 创建项目\" 创建项目 创建好的项目如下图所示。 项目创建完毕\" 项目创建完毕 我们需要对这个窗口的几项属性进行修改，首先通过 Text 属性将它的标题修改为“Minesweeper”；通过FormBorderStyle属性将它的大小设置为“FixedSingle”，即为不可调节窗口大小；通过 MaximizeBox 属性将它的最大化按钮设置为“False”，即最大化按钮失效；通过 Name 属性将它的名称修改为“Form_Main”，修改这个属性主要用于后面书写代码的方便；通过 BackColor 属性将它的背景修改为“White”。如下图所示： 属性修改\" 属性修改 我们可以顺便修改一下这个窗口的代码文件的名称。在右上方找到解决方案资源管理器，右击Form_1.cs—重命名—Form_Main.cs，程序会自动将下面包含的文件名也都改成一致的名称。如图所示： 文件名修改\" 文件名修改 接下来我们需要修改一下程序的图标，将刚才下载的 favicon 文件放到 Minesweeper/Minesweeper 文件夹下，同时将三个图标资源放到 Minesweeper/Minesweeper/Resources 文件夹下（Resources 文件夹需要自己新建），如下图所示： 创建 Resources 文件夹\" 创建 Resources 文件夹 在属性栏中找到 Icon 属性，并且定位到 favicon.ico 文件，如下图所示： 设置 Icon\" 设置 Icon 此时，我们按下快捷键 Ctrl + S 对整个工程进行保存，并且按下快捷键 Ctrl + F5 运行查看我们的程序，效果如下： 运行结果\" 运行结果 到目前为止，我们的程序只是一个空白的界面，下一节中我们将介绍程序的界面布局的设计。 ","date":"2015-04-20","objectID":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%80%E8%8A%82%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/:0:0","tags":["CSharp"],"title":"扫雷游戏制作过程（CSharp 描述）：第一节、创建项目","uri":"/2015/04/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8Bcsharp-%E6%8F%8F%E8%BF%B0%E7%AC%AC%E4%B8%80%E8%8A%82%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/"},{"categories":["浮生杂记"],"content":"刚刚结束了 ACM 的集训，仔细反思了第一学期的大学学习生活。 首先要说的是上课，在一开始的时候，我每次都会提前很久去占座。但是这样的情况并没有持续很久，有一段时间由于感觉老师讲得太慢，经常上课开小差。但是事后自习想了想，还是决定回到开学时的状态。但是这时候我却惊讶的发现，并不需要占座了，就算是踩着上课铃去上课，也依旧可以坐到第一排（线性代数除外）。解决了态度问题，接下来还是有一个不可回避的问题，有时候觉得讲得太慢，不想听。所以就带了自己的书，讲到不懂的，就认真听课，其余时间就好好看自己的书，学习别的东西。 接下来是平时的自习，作业了。说来惭愧，一个学期都没有去过图书馆自习，一般都是晚自习做完作业，如果做不完就回宿舍做。因为是上床下桌，有一个隔板，所以我可以不受干扰的自己看书。在大一上学期，我自学了《数学文化》这门课程，并且进一步的了解了微分方程，以及线性代数。当然，还有很多没有做完的事情，比如《中国古代哲学史》没有如期看完，做志愿者时问学者要的《唐代文学研究》看了一篇《唐宋科举制度对诗词体裁的影响》就没有坚持看下去。 我感觉大学是一个非常适合学习的时间段。首先，没有太大的压力，其次， 可以利用的教育资源很多。这时候，只要我们想学的，都可以通过查阅资料，自己慢慢沉进去，总会有收获。大抵就这就是学习吧。孔子曰，有教无类，我想，学习也大抵如此。曾经听过这样一句话：未知是已知的边缘。已知的越多就会发现未知的越多。仔细想想，的确非常有道理。至于学习的方面，我想可以是多样化的，因为你无法预知你现在所学的或许在未来的某个时刻会派上用场。 我依稀记得张贤明说过的一个词「慎独」，当时只是觉得自己又知道了一个新的名词，现在想想，这中间寄托了他的多少期望。 现在回想起来，在中学时期，每到放假都会玩，但是现在，书桌前堆满了书和论文，只是想着什么时候把它们看完。或许这是我一个非常大的转变吧。 不得不提的是 ACM，经过了三次校内选拔，七天的留校集训，要开始准备四月份的邀请赛。希望今年的比赛能够夺得亚洲区金牌吧。 再来说说今天刚刚收到的成绩单，总评绩点 3.84 / 4.0，但是这似乎并不能使我感到满意。英语一如既往的成为短板。 或许我们可以比高三更加认真，付出的更多，谁又知道命运会在将来给你什么呢。 ","date":"2015-02-06","objectID":"/2015/02/reflections/:0:0","tags":["高中生活","NOIP"],"title":"REFLECTIONS","uri":"/2015/02/reflections/"},{"categories":["浮生杂记"],"content":"2015\" 2015 时光匆匆流去，转眼又已迎来新的一年。按照惯例，应该写篇文章总结一下，突然发现要说的事情太多了。各位看官且莫着急，听我慢慢道来。 总的来说，整个 2014 感觉过的很漫长，这似乎和某个研究结果相符：每天遇到的事件越多，觉得一天的时间越长。我想这大概是因为这一年发生过太多事情的缘故吧。面对着早已习惯的分别，也已变得不太在意。要说总结，我也不知道该怎么总结。对我来说，这一年只有两个阶段：为了高考奋斗、进入大学学习。当然，除此之外也干了很多有意义的事。且从头说起罢。 还记得刚过年的时候，想想上学这么多年也没怎么认真过，既然高考很重要，那就认真一次。自招、保送种种早已过去，以前还懊悔没有去数学决赛，到那时候也就完全没了这些想法。虽然多少分数并不是特别理想，但是想想也没什么，大不了重头再来。只是后来不知为什么没了那股冲劲，也自然就松懈了。要说那时候的状态，《他》无疑是最恰当的。就这样迎接了高考的洗礼。就这样结束了高中生涯。但是等到分数出来，却还是倍感意外，写下了《没有如果》。 其实就我个人而言，对于高中的印象不是特别的深刻，没有太多印象深刻的事情。也就感觉三年就这样过去了。如果非要说些什么，我想大概是NOIP、MOI了吧。 参加竞赛，是我个人觉得高中里非常正确的一个决定。如果再来一次，我还是会义无反顾的参加竞赛，即使没有取得非常好的成绩。它教给我的，远不止那几本高中教科书的内容，它使得我更有胆识去挑战更高更强的目标，同时也使得我对自己的能力有了更恰当的界定。 还有一件事情，对数学的热爱，也是在高中里正式发展出来的。在初中里，只是觉得自己数学比较好，比较喜欢钻研难题，但是对数学并没有特别的情感。直到听了老严讲了两年数学，对数学的热爱与日俱增。很多人对于老严教数学不置可否，甚至有人觉得老严不会教学。在这么多的评价中，我觉得只有一个评价比较符合老严： 老严教的是心，而不是学。 的确，老严从不注重一个个题目的教学，而是整体数学思维的建立。有了这些铺垫，也就很容易解释到了大学里的我，依旧非常的喜欢数学，虽然学的是高数，却刷着吉米多维奇。四级考试的时候，作文题目记最喜欢的一门课，我随手写下了高数。很多人并不是特别喜欢数学，特别是高数。其实仔细品品，就会发现数学难言的美。最近我有一个新的认识：数学是科学中的哲学，它的发展促进了其它科学的发展，其它科学的发展同时也促进了数学的发展。说了这么多，不如举两个例子，来体会一下数学的哲学之美。 首先要提到的，自然是欧拉公式，一个联系着 π、e、i 的等式。这已经被说烂了，并没有太多的心意。我们不妨来看一下我们所熟悉的方面——导数。大家应该都知道两个函数乘积的求导公式。但是这个小小的公式里，却蕴含着美妙的哲理：上帝是公平的，对每个函数都进行了一次求导。 学了将近一学期高数的我们，应该也清楚正无穷、负无穷、无穷这三个符号。所谓无穷，包含着正无穷、负无穷。我们可以将数轴的首尾粘连起来，那么正负无穷就得以相遇，那么我们只需要一步就可以从正无穷走向负无穷，亦或从负无穷走向正无穷，这不恰好预示着道家所说的物极必反吗？ 不知不觉就扯偏了，但不可否认，数学的确具有别致的美。 高考结束以后，的确轻松了很多。加入了钱老板的产业，成为了一名高三数学老师。幸苦了将近三个月，起早贪黑，没有旅游，没有太多的聚会。但是觉得很充实，学会了很多，收获了很多。当然，这中间也发生了很多故事，详见《P2P.edu - 个人总结》。一直的忙碌，以至于突然停下来以后感觉没什么事情可做，于是在某个夏夜翻来覆去的思索，记下了《夏夜寄思》。 第一次在家里看《开学第一课》，但是自己早已不是主角，只是看着屏幕里的孩子们笑，想想他们多年后也会像我一样，看着屏幕里另一群孩子笑吧。也就在这个时候，迎来了中秋，难得望月，记下一篇《中秋望月感怀》。而此时，小伙伴们大多都已经开学。 就这样，日子一天天的步入了大学，军训过后，开始了正式的大学生活，第一节慕课，校长讲了为什么要读大学，深有感触，思索了几天，写下了《我为什么要读大学》。等到一切慢慢步入正轨，才发现自己所选专业的课程非常多，而且作业也不少，每周都忙不过来。除此之外，并没有太多的不适应，六年的住宿生活，使得自己早已习惯了宿舍里的生活，也并不存在适应不适应的问题了。 进入大学以来，虽然也加了学生会，但是从不揽事，只是尽可能把本职工作做好，因为实在无心无力，忙不过来。但是最近作为团队项目负责人的我申报了一个 3I 工程的项目——基于 Android、iOS 的书院掌上 APP 客户端系统以及服务器开发。希望能够顺利结项吧。还有值得一提的事情是参加了 ACM 校选赛，认识了很多志同道合的同学、学长，但愿能够在今后的赛场上摘金夺银吧。 不知不觉写了那么多，但是感觉什么都没写，就这样吧。 2015 会更好。 ","date":"2014-12-31","objectID":"/2014/12/%E7%94%B2%E5%8D%88%E5%BF%972014-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:0","tags":["大学生活"],"title":"甲午志（2014 年度总结）","uri":"/2014/12/%E7%94%B2%E5%8D%88%E5%BF%972014-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["浮生杂记"],"content":"其实期中考试上上周就考完了，只是这几天才出分数。客观的来说，不算低了，却觉得不够。就好像今天刚刚结束的第二场ACM校选赛，第三名，却觉得为什么不是第一名。 很久之前就有人回复我说，为什么还不更新博客。自从开学以来，忙东忙西，一直没有时间，因为我自己也不知道大学究竟是什么，回想起之前写过的一篇《我为什么要上大学》，总觉得讲不到点子上，有很多想法没有表达出来，看来很有可能会诞生一篇续集吧。 几天前，Godaddy 给我发了一封电子邮件，说我的域名要到期了，突然意识到这个小小的博客已经存在了将近两年了。在这两年间，我也如当初创立博客的设想一样，记录着自己的生活，学习，也算是一笔宝贵的精神财富吧。 以上两个原因，促成了写这篇文章的外因，而主要的内因是这段时间事情没那么忙了，同时一些问题也思考的差不多了，所以记录下来。 开学这么久了，已经并不觉得大学有多么新鲜了，社团、学生会有多么好玩了。更加明白了我们导师说的，大学里最重要的还是成绩。很多东西都是形同虚设，作坊式的小打小闹，难成气候。与其在这上浪费时间，不如花时间多读几本好书。曾经在高中刷了很多的课外书，连图书馆的老师（阿姨）都认识我了，看见我还跟我打招呼。到了大学里，看见图书馆这么多的书，也不知道从何下手，不可能一个一个书架的刷，而我通常会找一些名著慢慢来啃，虽然很慢，却很有味道。 另一个很深的感触是空闲的时间变多了，我可以花时间捣鼓以前没时间折腾的东西。虽然有人觉得东一榔头西一棒槌成不了什么事，但是我总觉得这一榔头，一棒槌在未来会联系在一起，创造出一些改变我们的东西来。接触的东西越多，越觉得自己水平不够。就如同做数学题一样，第一个境界是觉得自己什么都不会，第二个境界是觉得自己什么都会，第三个境界是觉得自己太弱了。接触的多了，视野开阔了，心也自然的平静了。现在想想张兴老师的“静”字或许还有这层含义吧。 且再说些别的，上周回港一次，和同学出去玩，坐公交的时候，正好碰到我们那边的高中放学，一群高一的学生涌了上来，我坐在位置上，看着他们青涩的面庞，稚嫩的眼神，突然想起了多年前的我，是不是也如那般懵懂无知。只是希望他们不要再重蹈我的覆辙。基于这种心理，也慢慢理解了小时候父母的管教。那些年少时光，我们再也回不去了，但是我们拥有现在，也就拥有无限可能，未来 掌握在我们的手上。中学就如同围城一样，外面的人想进去，里面的人想出来；外面的人因为习惯了曾经被告知的目标，也就慢慢失去了自己找寻目标和方向的能力；里面的人整天被目标所烦恼，希望出去放松一下。但这终究只是念想，不可能成为事实，也就要求我们及时的找到自己的目标与方向，不要在一开始就放任自流，走上了令自己后悔的道路。 其实一开始我也不知道自己想写什么，写着写着就写到了这些。 最后还是讲讲刚刚结束的第二场ACM校选赛吧，很多题目做的感觉呼之欲出了，但是就是离正确答案差那么一点点。虽然这只是一点点，但是我想需要改进的就不止那么一点点了吧。 ","date":"2014-12-10","objectID":"/2014/12/%E6%9C%9F%E4%B8%AD%E9%9A%8F%E8%AE%B0/:0:0","tags":["大学生活"],"title":"期中随记","uri":"/2014/12/%E6%9C%9F%E4%B8%AD%E9%9A%8F%E8%AE%B0/"},{"categories":["数学之美"],"content":"高数教了一段时间了，对于等价无穷小量代换法求极限为什么只能在乘除中使用，而不能在加减的情况下使用的条件感到有些疑惑，于是找了一些资料，仔细的研究了这个问题，整理如下： ","date":"2014-11-01","objectID":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/:0:0","tags":["等价无穷小量"],"title":"浅谈等价无穷小量代换原理","uri":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["数学之美"],"content":"等价无穷小的定义及常用的等价无穷小 无穷小量是指某变化过程中极限为 $ 0 $ 的变量。而等价无穷小量是指在某变化过程中比值极限为 $ 1 $ 的两个无穷小量。 常用的等价无穷小有： $$ \\sin{x}\\sim \\tan{x}\\sim\\arctan{x}\\sim\\arcsin{x}\\sim \\ln{\\left(1+x \\right )}\\sim x\\left(x\\rightarrow 0\\right ) $$ $$ 1-\\cos{x}\\sim \\frac{x^{2}}{2},\\sqrt[n]{1+x}-1\\sim \\frac{x}{n} \\left(x\\rightarrow 0\\right ) $$ 等价无穷小量在求极限问题中非常重要。恰当的使用等价无穷小量代换常常使极限问题大大简化。但是有时却不能使用等价无穷小量代换。 ","date":"2014-11-01","objectID":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/:1:0","tags":["等价无穷小量"],"title":"浅谈等价无穷小量代换原理","uri":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["数学之美"],"content":"等价无穷小替换原理 定理1：设 $ \\displaystyle\\alpha,\\alpha_{1},\\beta,\\beta_{1} $ 是某一变化过程中的无穷小量，且 $ \\alpha \\sim \\alpha_{1},\\beta \\sim \\beta_{1} $ ，若 $ \\lim{\\frac{\\alpha}{\\beta}} $ 存在，则 $$ \\lim{\\frac{\\alpha}{\\beta}}=\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}} $$ 例1：$$ \\lim_{x\\rightarrow 0}{\\frac{\\ln{\\left(1+3x\\right)}}{\\sin{2x}}} $$ 解：$$ \\lim_{x\\rightarrow 0}{\\frac{\\ln{\\left(1+3x\\right)}}{\\sin{2x}}}=\\lim_{x\\rightarrow 0}{\\frac{3x}{2x}}=\\frac{3}{2} $$ 例2：$$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}} $$ 错误解法： $$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}}=\\lim_{x\\rightarrow 0}{\\frac{x-x}{x^3}}=0 $$ 正确解法：$$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}}=\\lim_{x\\rightarrow 0}{\\frac{\\sin{x}\\left(1-\\cos{x}\\right)}{x^{3}\\cdot\\cos{x}}}=\\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}}{x^{2}\\cdot\\cos{x}}}=\\lim_{x\\rightarrow 0}{\\frac{1}{2\\cos{x}}}=\\frac{1}{2} $$ 从上面的解法可以看出，该题分子不能直接用等价无穷小量替代来做，下面我们分析产生错误的原因：等价无穷小之间本身一般并不相等，它们之间一般相差一个较它们高阶的无穷小，由函数 $ f\\left(x\\right) $ 在点 $ x=0 $ 处的泰勒公式，即麦克劳林公式：$$ f\\left ( x \\right )=f\\left ( 0 \\right )+f'\\left ( 0 \\right )x+\\frac{f''\\left ( 0 \\right )}{2!}x^{2}+\\cdots+\\frac{f^{\\left ( n \\right )}\\left ( 0 \\right )}{n!}x^{n}+o\\left ( x^{n} \\right ) $$ 很容易有：$$ \\tan{x}=x+\\frac{x^{3}}{3}+\\frac{2x^5}{15}+o\\left ( x^{5} \\right ) \\quad \\left ( x\\rightarrow 0 \\right ) $$ $$ \\sin{x}=x+\\frac{x^{3}}{3!}+\\frac{x^{5}}{5!}+\\frac{x^{7}}{7!}+\\cdots+\\frac{\\left ( -1 \\right )^{m-1}x^{2m-1}}{\\left ( 2m-1 \\right )!}+o\\left ( x^{2m-1} \\right ) \\quad \\left ( x\\rightarrow 0 \\right ) $$ 由此可知， $ \\sin{x} $ 与 $ \\tan{x} $ 相差一个较 $ x $ 的三阶无穷小，此三阶无穷小与分母 $ x^{3} $ 相比不可忽略，因为把上述结论代入原式得 $$ \\lim_{x\\rightarrow 0}{\\frac{\\tan{x}-\\sin{x}}{x^{3}}}=\\lim{x\\rightarrow 0}{\\frac{\\frac{x^{3}}{3}+\\frac{x^{3}}{3!}+o\\left ( x^{3} \\right )}{x^{3}}}=\\frac{1}{2} $$ 由此，我们可以得出：加减情况下不能随便使用等价无穷小。 下面我们给出一个在加减情况下使用等价无穷小的定理并加以证明。在这里我们只讨论减的情况，因为我们知道加上一个数可以看成减去这个数的负数。为方便，首先说明下面的定理及推论中的无穷小量其自变量都是 $ x $ ，其趋近过程都相同： $ x\\rightarrow 0 $ ，在有关的极限中都省去了极限的趋近过程。 定理2：设 $ \\alpha,\\alpha_{1},\\beta,\\beta_{1} $ 是某一变化过程中的无穷小量，且 $ \\alpha \\sim \\alpha_{1},\\beta \\sim \\beta_{1} $ ，则 $ \\alpha-\\beta \\sim \\alpha_{1}-\\beta_{1} $ 的充分必要条件是 $ \\lim{\\frac{\\alpha}{\\beta}}=k\\neq 1 $ 。 证明： $ 1^{\\circ} $ 充分性：$$\\alpha\\sim\\alpha_{1},\\beta\\sim\\beta_{1}\\Rightarrow \\lim{\\frac{\\alpha}{\\alpha_{1}}}=\\lim{\\frac{\\beta}{\\beta_{1}}}=1 $$ 又 $$ \\lim{\\frac{\\alpha}{\\beta}}=k\\neq 1,\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}}=k\\neq 1 $$ 则 $$ \\lim{\\frac{\\alpha-\\beta}{\\alpha_{1}-\\beta_{1}}}=\\lim{\\frac{\\frac{\\alpha}{\\beta_{1}}-\\frac{\\beta}{\\beta_{1}}}{\\frac{\\alpha_{1}}{\\beta_{1}}-1}}=\\frac{k-1}{k-1}=1 $$ 即 $$ \\alpha -\\beta\\sim \\alpha_{1} - \\beta_{1} $$ $ 2^{\\circ} $ 必要性：$$ \\alpha\\sim\\beta,\\alpha_{1}\\sim\\beta_{1}\\Rightarrow \\lim{\\frac{\\alpha-\\beta}{\\alpha_{1}-\\beta_{1}}}=1 $$ 即 $$ \\lim{\\left(\\frac{\\alpha-\\beta}{\\alpha_{1}-\\beta_{1}}-1 \\right )}=0 $$ 通分得 $$ \\lim{\\frac{\\alpha-\\alpha_{1}}{\\alpha_{1}-\\beta_{1}}}-\\lim{\\frac{\\beta-\\beta_{1}}{\\alpha_{1}-\\beta_{1}}}=0 $$ 所以 $$ \\lim{\\frac{\\frac{\\alpha}{\\alpha_{1}}-1}{1-\\frac{\\beta}{\\alpha_{1}}}}-\\lim{\\frac{1-\\frac{\\beta}{\\beta_{1}}}{\\frac{\\alpha_{1}}{\\beta_{1}}-1}}=0 $$ 又 $$ \\lim{\\frac{\\alpha}{\\alpha_{1}}}=1,\\lim{\\frac{\\beta}{\\beta_{1}}}=1 $$ 所以 $$ \\lim{\\frac{0}{1-\\frac{\\beta}{\\alpha_{1}}}}-\\lim{\\frac{0}{\\frac{\\alpha_{1}}{\\beta_{1}}-1}}=0 $$ 所以 $$ \\lim{\\frac{\\beta_{1}}{\\alpha_{1}}}=k\\neq 1\\Rightarrow \\lim{\\frac{\\alpha_{1}}{\\beta_{1}}}=k\\neq 1 $$ 又 $$ \\lim{\\frac{\\alpha}{\\beta}}=\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}} $$ 所以 $$ \\lim{\\frac{\\alpha}{\\beta}}=k\\neq 1,\\lim{\\frac{\\alpha_{1}}{\\beta_{1}}}=k\\neq 1 $$ 由 $ 1^{\\circ},2^{\\circ} $ 得，原命题成立。证毕。 这样一来，就得到了差形式无穷小量等价代换的充要条件。 例3：$$ \\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}+2\\sin{x}}{\\arcsin{2x}-\\sin{x}}} $$ 解：$$ 1-\\cos{x}\\sim\\frac{x^{2}}{2},-2\\sin{x}\\sim -2x, 2\\arcsin{x}\\sim 2x,\\sin{x}\\sim x\\left ( x\\rightarrow 0 \\right ) $$ 所以 $$ \\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}}{-2\\sin{x}}}=0\\neq 1,\\lim_{x\\rightarrow 0}{\\frac{2\\arcsin{x}}{\\sin{x}}}=2\\neq 1 $$ 由定理 2 得 $$ \\lim_{x\\rightarrow 0}{\\frac{1-\\cos{x}+2\\sin{x}}{\\arcsin{2x}-\\sin{x}}}=\\lim_{x\\rightarrow}{\\frac{\\frac{x^{2}}{2","date":"2014-11-01","objectID":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/:2:0","tags":["等价无穷小量"],"title":"浅谈等价无穷小量代换原理","uri":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["数学之美"],"content":"总结 本文指出，在有加减的情况下不能随便运用等价无穷小代换求极限，并且指出了在有加减的情况下能够使用等价无穷小代换的充分必要条件。对于不满足条件的情况，根据给出的泰勒展开公式，可以求出。 ","date":"2014-11-01","objectID":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/:3:0","tags":["等价无穷小量"],"title":"浅谈等价无穷小量代换原理","uri":"/2014/11/%E6%B5%85%E8%B0%88%E7%AD%89%E4%BB%B7%E6%97%A0%E7%A9%B7%E5%B0%8F%E9%87%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E7%90%86/"},{"categories":["浮生杂记"],"content":"自从上了大学以后，时常想起浅栖的一篇文章《为什么要读大学》。我也一直在思考，我为什么要读大学，前几天看了朱秀林校长的演讲，他也问了同样的问题，为什么要读大学，这是一个基本的问题，想明白了这个问题，可以解决很多问题。利用一节高数课，我仔细的思考了这个问题，并给出了自己的答案——为了成为更完整的人。 还记得高中里，常常听别人说起，现在辛苦一点，到了大学里就会轻松很多。到了大学里才发现，其实大学比高三辛苦多了，说轻松只是相对于那些高中不认真的人来说，想要达到同一高度，是轻松一些。但是如果对自己有更高的要求，那也不见得会和「轻松」这两个字有什么关系。 「想清楚自己想要什么」是一个先决问题，它会影响我们后续的一连串选择，人生就是由不同的选择构成的。要时刻记得自己想要什么，这样才能在大学这个充满诱惑的地方守住自己的方寸之地。 当然，这也就是自己的「目标」，浅栖的班主任给了很好的诠释： 如果要追求绩点，想清楚成绩意味着什么；如果要参加学生会，想清楚学生会职务意味着什么；如果要保研，想清楚保研的实质要求是让导师认为你是一个好学生，并且所有的条件都是由此而出；如果要出国，提前考虑好，或许能多几次 GRE 和托福的机会，可以关注各种交换机会、暑期，甚至大一就可以去招聘会，比较早的时候把规划做好，压力来的时候就可以从容不迫。 有了目标，就要为之奋斗，否则就不能称之为目标，甚至连梦想都谈不上，只能是空想。这时候，就需要我们的「执行力」，在前进的过程中，给自己设下底线：每周早读3次、坚持完成作业、每次考试90分以上，诸如此类。并且朝着目标不断奋斗。 大学是一个较为浮躁的地方，因此，要静下心来，还需要的一件事情便是「专注」。专注的做自己的事情，而不被旁人影响。对于这一点，我觉得深受初中班主任的一次教导——仔细的时候不论发生了什么都不抬头。这也是我初中三年学习习惯上最大的收获。至于有人喜欢边听音边写作业，则会使得自己的心变得散乱。需要不断的自我调整，使得自己的内心变得宁静。这是张兴老师告诉我的，随着时间的推移，我慢慢加深了对于他所讲的「静」的含义。 当然，更需要的是学会懂美，这包括了很多，人性美、文学美等等都包含在里面，从我们的专业中悟出「道」，否则，如果我们只是掌握了一些专业知识，那么和技校生又有什么区别呢。 下面就我自身的情况，谈谈我对于大学生活中的一些基本的问题的看法吧。 我们有早读课，名义上叫做「诚信早读」，有人去签到后也去早读了；有人去签到后继续宿舍睡觉；有人干脆不去签到。从这一点小小的地方就拉出了莫大的差距。早读给我的感觉倒不是真正的目的，而是为了让我们早起，从而能更好地利用早上这段时间。 而对于上课，那就更随性了，玩手机、睡觉应有尽有。我的想法是，要弄清楚，自己哪里需要听，哪里不需要听。可以睡觉，可以做自己的事，但是玩的话就有点说不过去了。睡觉，可能是昨天晚上作业太多，赶夜工，凑巧下面还有自己需要听的课，那么睡觉是无可厚非的；至于做自己的事，可以是看书、做作业或者任何不影响他人的事情。这大概就是我的上课状态吧。 讲到上课，不得不提一提旷课这件事情，我觉得只要理由正当，并且自己恰当的权衡，我觉得是可以的。当然，如果和辅导员关系好，开张假条应付一下就更好了。我上次旷课是为了参加国际唐代文学年会的开幕式，旷了体育课，并且在辅导员那里开了假条。我觉得非常值得，开幕式持续了一个上午，是一场名副其实的文学盛宴。当然，也不是鼓励大家旷课，主要是自己要权衡，也就是之前的一个问题，想清楚自己想要什么。 在说说效率这件事情吧，记得有这么一个公式：投入时间×效率＝实际投入。所以，提高效率远比加大时间投入有效，这也是浅栖的文章给我的一个很大的启发。顺便再讲讲占座的事情，我个人觉得，自己会的课程，不需要占座，做在后面可以自己看看书，在做作业，还不会被老师点名之类的；自己不会的课程，一定要占在前面，实在不行一定要追着老师问，有句话叫做「弄斧必到班门」，我是很赞同的。 至于阅读，大学里有很多的空闲时间，这就给了我们极大的自由度，再辅以一卡通可以借阅十几本书，而图书馆又很大，那么，用这些时间好好阅读一下文史哲方面的书籍是一个非常的选择。至于为什么是这方面的书籍，我想，它们更能启发我们思考，塑造我们的思想，使我们变得更加理性。而对于专业的书籍，在实践中的学习远比书籍重要得多，因此没有太大的必要。当然，读书也不能像读小说一样看过就完。要精读、深度，尤其是流传至今的著作，它们经历是时间的考验与洗礼，是名副其实的人们智慧的结晶。 有了阅读，必有思考，古人云：「一日三省吾身」，我想实在做不到，「一日一省吾身」还是可以的，并且思考一下，今天做了什么，明天该做什么。还有重要的一点就是读书的时候要做勤于做读书笔记，写读后感。然而，这里强调的思考是深度思考，刨根问底式的思考。可以先刨根问底，然后再一步一步演绎出我们的问题，并由此向外延伸，对于问题有新的认识，在这点上，我们高数老师的哲学思想对我有很大的启发。 作为学生，不能没有作业，但是做不做就是问题了。我感觉这完全是个自觉的问题，有人可以完全不要平时分，也不会挂科。但是如果你的目标是刷绩点的话，就要认真了，最好自加压力，找点习题做做。 对于不可避免的问题——游戏，我决定还是说几句，我们这一届也有人玩游戏玩的很厉害，我对于游戏的看法可以引用浅栖的班主任的一段话来阐释： 东方文化强调纪律、律己，即适当的自我约束。8 小时的被迫上课、讲座、做作业之后，人会想要补偿，于是玩游戏，你说玩游戏的害处不只是耽误时间，其最大的害处在于让自己成为欲望的奴隶，变得散懒，无法控制自己。 而对于如何解决这样的问题，我想最好的办法就是在自己很累的时候，做一些自己感兴趣的事情，比如听歌、练书法之类的，慢慢使自己的内心静下来。 社团与社交，我觉得主要看这个岗位是否有利于自身的进一步发展，没有必要为了结识更多的人而去可以的加入某些社团，讨好某些人，一个很现实的问题，他们可能并不把你当朋友。因此，这个问题随性就好，朋友都是在自然之中结交的。 总而言之，上大学就是为了使自己成为更完整的人。 当然，还要牢记一句话：「不要忘记了当初为什么出发。」 ","date":"2014-10-18","objectID":"/2014/10/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AF%BB%E5%A4%A7%E5%AD%A6/:0:0","tags":["大学生活"],"title":"我为什么要读大学","uri":"/2014/10/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AF%BB%E5%A4%A7%E5%AD%A6/"},{"categories":["浮生杂记"],"content":"月\" 月 水调歌头 丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。 明月几时有？把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间？ 转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。 今年，可以说是一个转折点。高考结束了，以前经常以前玩的小伙伴不得不面临分别，各奔东西。有的还没有开学，有的却早已开学，独自在异乡漂泊，在这个理当团聚的日子，承受着难言的乡愁。 「今夜月明人尽望，不知秋思落谁家。」，但无奈正如太白所云「月是故乡明」，因此找了一张故乡的月光图，给远方的小伙伴聊慰乡愁。 且回到苏轼的词上，这首词我记得是小学里就学过的，当时老师要求我们背诵，也就这样背了。到了初中，又学了一遍，又背了一遍。当时觉得苏轼太痴，他对月亮说他思念弟弟，月亮怎么会去理他，这也就更不存在所谓的「千里共婵娟」了。到了现在，方才明白苏轼之心，思之切，故而痴，那么下面的一切也都可以理解了。现在的我也不禁吟出「但愿人长久，千里共婵娟。」的企盼。 这当然不是无用的心灵寄托，我愿意相信，月亮正帮着我们传递着彼此的思念，只是速度没有网络那么快罢了。但我却更倾向于古人的传信方式，「行人临发又开封」多美；「驿寄梅花，鱼传尺素。」多美；「一夜乡心五处同」多美。 匆匆的告别，以为再见一面又有何难。只有真的离别了，才明了再见一面何等之难。告别，似乎是这个暑假的主旋律。告别了高中，告别了小伙伴，过几天又要告别张家港，到别处奔波流浪。还记得零模、一模、二模、三模、高考，查分数、填志愿、录取，短短一年，经历了这么多事情，现在回想起来，却感觉像是很久以前的事情，而它们却实实在在的发生在几个月前。 不管现在如何，未来总是充满希望。 ","date":"2014-09-08","objectID":"/2014/09/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%802014/:0:0","tags":["大学生活"],"title":"中秋望月感怀（2014）","uri":"/2014/09/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%802014/"},{"categories":["浮生杂记"],"content":" 夏虫也为我沉默， 沉默是今晚的康桥。 窗外的夏虫唧唧喳喳的叫着，在 iPad 上打字，以前感觉很慢，去突然间感觉快了起来。 细细想来，自从毕业以后，一直在忙，不是写程序，就是补课，我也不知道自己整天在忙些什么，或许只有让自己忙起来，每天有一大堆的事情等着处理，才不会感觉到无所事事带来的焦躁与不安吧。 现在，补课结束了，程序在分工协作，任务不是很重，所以忙里偷闲，来欣赏夏虫演奏的大自然的交响曲。 一切景语皆情语。回想六年中学生涯，不禁感慨万千。补课时看到那些学生，不论小学、初中、高中，都由衷的羡慕。正如围城一样，我们再也去不到围墙里面，只能在外面看着他们重复着我们的故事，时而为他们感到高兴，时而为他们感到担忧，但到后来才明了，这是他们的生活，需要他们去体验，我们的旁观起不了任何作用，只是徒增自己的感伤罢了。 例如高昕宇，小升初，考上了常青藤，我似乎在他身上看到一点自己的影子，因此总是希望他往后六年的中学生涯好好努力，好好把握，自己当初没有完成的心愿，希望他们能够完成。 有这样的想法，大抵是因为自己六年中学生涯有太多的遗憾吧。六年认识了很多人，从刚开始的点头之交，慢慢接触，大部分人最终回归到点头之交，有些人变的形同陌路，当然，也有极少数人变成了倾心相交。在这个过程中，有人放冷箭，有人争锋相对，到最后才发现，他们竟然是你信任的人。人情冷暖，大抵如斯。 六年，真正认真的是初三、高一、高三。前两次基本如愿，哪料到高考出乎意料。这且不说，这六年来，事事受阻，极少有守得云开见日，且都遭受非议。或许，这该是上天最好的安排吧，且看这出戏该如何演吧，剧本在上帝手里，也在自己手里，却没有最终解释权。世事难料，大抵如斯。 当分别已成习惯，我们已不会记起比尔博姆的告别，剩下的只是互道珍重，或许这便是最后一别，再无相见。回想起来，这六年来，经历了小学毕业，当时大家还小，完全不理解分别的含义，在分别时，还笑嘻嘻的互相打闹；初中毕业，走出教室的那一刻，并没有想到分别，事后才意识到，这一别就是永恒。现下的各奔东西，却变的稀疏平常。大家都相信，还可以继续联系。只是，不知道以后联系上的，是不是今日的你，以后一起玩耍的，是不是今日的你。时间总是那么无情，呼唤着距离一起，将彼此分隔、分割。无能为力，大抵如斯。 岁月褪去了我们的稚气，留下一副看似坚硬的外壳，却不料它一触即破，剩下我们独自哀伤。在这跌爬滚打中，逐渐加厚了外壳，却变的冷漠，失去了本来的纯朴与自然。由此产生的便是深深的距离感。变的复杂无比，却极力追求简单，到头来连自己都没有弄懂自己是谁。所谓宿命，大抵如斯。 不知不觉，已过夜半，窗外仍有小作坊在工作，夏虫依旧唧唧喳喳的叫着。 ","date":"2014-08-22","objectID":"/2014/08/%E5%A4%8F%E5%A4%9C%E5%AF%84%E6%80%9D/:0:0","tags":["高中生活"],"title":"夏夜寄思","uri":"/2014/08/%E5%A4%8F%E5%A4%9C%E5%AF%84%E6%80%9D/"},{"categories":["浮生杂记"],"content":"P2P.edu 是我们学生自发组织、创办，自主管理的一个补课机构，地点租在南门路与南环路的交界处的「圆梦教育」。总的来说，没有满六位数的营业额，或许不能算作是一次非常成功的创业，但是却是一次非常成功的尝试。 从 6 月底持续到现在，很多课程都已经进入尾声，我的课程已正式结束了，写下此个人总结，算是打点计时器，记录一下这个事件吧。 给我的感觉，在创办前期，策划、广告宣传、洽谈生意等，在此期间学到了很多。从设计报价单、学员登记表、签到表，到传单的制作、发放，再到与家长及学生的交流。整个过程，使得我对于自主创业有了一个非常基本的概念和模型，但是这些经历还远远不够。 我个人认为，P2P.edu 在前期最大的败笔是广告宣传的不到位，主要来自于校方的压力，当然，我们也有一种「怕」的不足。怕校方的责怪，但是到了后来，意识到我们并不隶属校方管辖的时候，再去发传单，或许已经有些晚了。现在想想，我们当时确定的传单的受众群体太狭窄，因此 500 张的传单并没有完全发出去。但是却不得不承认，我们经过学生和家长的舆论宣传，还是达到了一定的效果，以至于前几天还有人报名，当然，我们已经没有时间再去办第二期了。 对于需要改进的部分，我想大抵是没有设计一款软件代替签到，财务结算，以至于到后来制作财务报表的时候忙的焦头烂额。在一开始，我的确想到设计一款软件，但是毕竟第一次从事补课行业，对于一些需求并不是特别了解，所以设计的也非常简陋，到后来就直接废弃了。这或许是下次创业需要注意的地方。在与家长的交流中，也学会了很多说话的艺术。 在这段时间内，也接触了很多学生，也有很多让我留下了很深的印象。下面简单的记叙一下。 杨逸涵，小升初，报考常青藤失利。我记得第一次辅导他是他报考常青藤的前一天。给我的总体感觉，聪明是挺聪明的，却不全部用在正道上。以前几乎每天都要被训一顿。可能他的年龄制约了他的性格，有些自负，做出不题目就会哭鼻子，让教他的老师啼笑皆非，总体来说，还是挺有趣的一个小朋友； 高昕宇，小升初，常青藤。我个人认为，这是我们这么多学生中最聪明的一个。但是好玩，不高兴做作业，为此我们想了很多方法来对付他，譬如，下棋，输了两倍的作业量，赢了不做。虽然他每次都输，输了以后还赖皮，到最好还是输了，但是这样一来就心服口服的做了两倍的作业； 这两个学生是小升初的代表，当然，还有一些小升初的学生，但是都非常一般。看着他们，我想起了小升初时期的我，也不知道他们接下来的几年会经历什么，希望他们有个好的未来。 赵张滨，新高三，沙中。这是我的学生，一共补了两期，总共 20 节课，虽然不属于聪明的类型，却还算认真，也值得鼓励，只是他这样的水平去参加高考，真不知道会是个什么样的结果； 朱奔，新高三，梁丰。只是唯一一个补自招的，是我们这边最认真的学生，就算前一天玩的再晚，第二天仍然坚持来上课。 这是新高三的代表，愿他们高考顺利。关于赵张滨，还有个「机智哥」的故事，也是我们在办公室内揣测出来的。当时我们便想到我们上学的时候，办公室里的老师是不是也像我们一样。 还有很多学生，但是给我印象深刻的也就这几个。总的来说，这些学生给我的感觉——眼高手低。所有的人都不愿承认自己弱，但是他们的水平却够不到强。我似乎看到了很久以前的自己，当时也是好高骛远，眼高手低。 当然，这只是一个方面的现象，还有上课不听，作业不做的情况。我处理过一例作业不做的情况，他最终乖乖的把没做的作业补了起来。似乎体会到了老师对待我们不做作业时的焦急与无奈。 有了这段经历，对于老师也肃然起敬。 备课，刚开始每天备课到十点半，第二天一会儿就讲完了，后来白天也开始备课，还是一会儿就讲完了。最麻烦的是出试卷，虽然我看看题目和答案还是可以判断题目的难易程度的，但相当的麻烦，要一个一个字的打下来，排版，打印。至于批作业，我教的是一对一，所以也就轻松一点。帮同学批作业的时候，也感到很无力，可能是他们错的太多，也可能我批作业的速度太慢。 上课，学生做题目的速度太慢了，我只能干等着，这非常的浪费时间，到了后来，便是先把第二天要讲的全部做完了，第二天直接讲题目。 下面讲讲我个人的上课感受吧，说实话，一开始，我也是非常兴奋，每节课都认真备课，虽然每天弄到将近十一点，但是心里还是很高兴的。 第一个学生是赵张滨，上面已经介绍过了，沙中的一位学生。给我的感觉，太内向。但是后来发现，他居然喜欢画漫画，还给我看了一幅他画的漫画，画的还不错，剧情是抄来的。不算聪明，也不算勤奋，有时候偷偷懒，我记得每次让他背的公式——三角函数、求导法则、向量点乘诸如此类，总是偷工减料，到最后我不得不让他默写公式。 我记得有一次他在做一道求函数值域的题目，他绕了个远路，我说道：你这么做是没有必要的，太麻烦了。没想到他一脸委屈的表情，快要哭出来，弄的我非常尴尬，赶紧转移了话题。总是觉得怪怪的，都升高三了，一个男生，还哭鼻子。 我记得前面 10 节课上完了，我给他妈妈打电话，问她要不要续报，跟她分析利弊，她答应续报 10 节。就这样，赵张滨一共报了 20 节课。 最后一节课，我给他考了一份我们的高考数学试卷，两卷加起来 150 多分，比之刚来补课的期末考试 130 分是一个很大的提升，也是对我教学能力的一个肯定。 在此期间，我又接了一个学生——张博涵，第一节课试听。后塍高中，自诩中考英语 90 分背背新概念就行了。第一节课上集合，给我的感觉，虽然概念都不清楚，做起题目来倒也不赖。但是，他试听完以后，就再也没来。和他家长联系，也没有结果。就当是做了一次义工吧。而后来事实证明，他根本不想补课，被抓了过来。 接下来的一个学生——顾誉，梁丰高中的学生，新高二。是我和潘子昊一起教的，而且他教的课时比较多，我的印象不太深刻，只是反映我课上出的题目太难。（其实很简单。） 我训过的学生——杨逸涵、施意涵。前者大声吵闹，扰乱办公室正常工作秩序；后者不做作业。 总的来说，虽然收入不是特别多，总计 2600（现在年终奖金还没有发下来，发下的话，应该会捐给云南鲁甸）。但是却比去年写程序赚钱学到的东西多了很多。 有了这些铺垫，到了大学里，经济独立，这个想法应该比较成熟了。 最后，感谢大家。 ","date":"2014-08-18","objectID":"/2014/08/p2p.edu-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/:0:0","tags":["高中生活"],"title":"P2P.edu - 个人总结","uri":"/2014/08/p2p.edu-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"},{"categories":["浮生杂记"],"content":"上回说到张兴给了我一本初赛的辅导书，让我备战全国初赛。 我记得第一天运动会，我下午去机房，听到高二的说，他们准备明天一天都在机房自习，当时我也很想这样，但是当时的班主任却绝不会同意，所以也就罢了这个念头。当天就准备简单的做做题目。也是那时候第一次接触「Tyvj」——一个在线评测网站（其他竞赛做题目可以刷书，我们做题目必须在电脑上。）。 第一道题目是高二的人给我的一道题目，现在看来只是一道简单的前序和（其实当时的题目数据也用不到这个算法），但是我却不会做。他们认为我什么都不会，于是说，做「A+B Problem」吧，当时我不知道是什么意思，看了题目才知道。（感觉是一股嘲笑味。）当下自觉不解——什么我平时写了那么多程序，却连这种题目都不会做。后来才明白，我平日所涉猎的和当时所做的题目完全是两回事。（但当时的我却未能领会到这一点。）两天的集训（自习）很快就结束了，感觉自己也学到了一点东西，比如问了高三某大神关于图论的一些问题，他非常耐心的给我讲解了图论的基本概念。虽然这样下来，我还是不会做题目，但是理解起来便简单多了。 且说那个十一长假，我在家里只要一有空便会翻开那本书，有时候要去亲戚家吃饭，也带着那本书。一个长假下来，却也看了将近大半。只是对于很多概念，例如「树」、「图」不是很理解。所以在后面很多题目上也是一知半解。 到了初赛的那天，我们中午 12 点在机房集合，再次进行考前辅导。高三的在三楼自己做题目，高二的则和我在二楼做题目。令我感到奇怪的是，辅导员竟然学生。（虽然后来我也成了所谓的「辅导员」。）其间，张春华老师还给我们讲了一下「树」的三种遍历——「前序遍历」、「中序遍历」、「后序遍历」。还好当时即使听懂了，因为果然考到了。出发前半个小时，在三楼做题目的缪叔下来讲了一个「Floyed Alogrithm」，我也听懂了它的原理。（虽然当时还不会写代码。） 讲完便可以出发了，高二、高三的结伴做公交车（因为人比较多），而我和另外一个高一的学生则坐着张兴老师的汽车，前往比赛场地——暨阳高中（三年都是那里。）我记得在出发前大家还在讨论要不要带可编程计算器去。最后有几个高三的带了过去，但是好像没什么用。 来到暨阳高中，高二、高三的人已经到了，我们都穿着校服，感觉不是很自在。这时候张兴老师说，我们凭着校服就可以吓住他们。大家哈哈大笑。 在此期间，看到很多去暨阳高中看运动会的学生，都被拦在了校门外。而我们却在张兴老师的带领下，昂首阔步的踏进了暨阳高中。我记得当时有人冒充进我们的队伍，被门卫揪了出来。进了暨阳高中，我们先找到考场，坐下来以后。便在暨阳高中四处转转。（我们去得比较早。）首先去了田径场，出奇的小，于是便折返去教学楼，出乎意料，看见一座亭子，一座假山，还算有些意趣。 这样四下闲逛，一会儿便到了开考时间。拿到试卷，我做上去感觉有点难度，有几道关于「树」、「图」的题目完全不会，只能硬着头皮乱猜。（但此时却和初一那年大不相同，毕竟也写了一定的程序，猜也有些门道了。）两个小时很快就过去了，考完出来。我有道题目不太确定，马上去问张春华老师，他遮遮掩掩，我便猜到做错了。看到高三的容光焕发，不屑于对答案，也猜到他们考得不错。 回到家中，等到八点半，CCF 公布了标准答案，对完发现，考了 70 分。当下打电话给张兴老师，他听了也非常高兴。后来他又打电话过来，说我这个分数过不了初赛，但是已经不错了，考过了好几个高二的学生。他还说有些后悔，当初没认真辅导我，否则说不定就进复赛了。（后来才知道，我当年是三等奖的第一名） 不管怎么说，这也是我的一次经历，使得我在 OI 的道路上走得更加坚定。 初赛结束，无缘复赛。可以说时间空了很多。 （欲知后事如何，且听下回分解。） ","date":"2014-07-28","objectID":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E5%9B%9B%E5%9B%9E-%E5%B0%8F%E8%AF%95%E8%BA%AB%E6%89%8B/:0:0","tags":["高中生活","NOIP"],"title":"忆昨日·NOIP - 第四回 小试身手","uri":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E5%9B%9B%E5%9B%9E-%E5%B0%8F%E8%AF%95%E8%BA%AB%E6%89%8B/"},{"categories":["浮生杂记"],"content":"上回说到，张兴让我以后每个星期六下午都到他那边去上课。 刚开始，并不要求我周日下午提前到校再去学习，一来为了不让他人察觉（张兴为人比较低调），二来他也有些忙，抽不出太多时间。 我记得第一节课只有我一个人，当时张老师拿了一本破旧的算法书（应该是他以前用过的），让我一个人根据书上的解说，将「快速排序」（竞赛的入门算法）写出来并成功运行。当天下午我就一直在研究这个，差不过用了一个多小时，才把基本框架写了出来。但是运行后的结果却错误百出。静态查错一直没什么效果。 这时候张老师说道「试试调试。」我当时以为自己听错了（这是递归程序，调试下去不得了。），得到确认以后，硬着头皮调试下去。过了十多分钟，但仍是无果。这是不免内心烦躁，当时觉得怎么自己第一节课就连这么一个算法都写不出来。更何况之前看《算法导论》的时候还写出来过。当下不服气，觉得张老师给我的书上的伪代码有些麻烦，于是翻开了自己的《算法导论》，找到那一章节，对着伪代码思索片刻，突然找到了问题所在——递归的参数（下标）传错了。 算法终于写了出来，我非常高兴。抬头一看，只见张老师的妻小都到了，我才明白自己耽误了张老师回家的时间。当下觉得十分抱歉。不料张老师过来检测了一下我的程序，确认完成以后。说道，「嗯，写出来了，时间不早了，回去吧。」又转过去对妻子和女儿说，「我们也回去吧。」我正准备走，不料张老师问道，「你家住哪里？怎么回去？要不要送送你？」我推脱了几句，说家住乐余，自己坐车回去，便走了。 以后每个星期六，我都会去张老师的办公室，他给我上课，有时那位之前跟着张老师学的人也会过来一起听课。但是张老师给他讲的是 C 语言基础，我自然不用听，于是自己在边上的一台电脑上研究算法。 有时候，张老师有事不能来，他便然我去和那些高三的人一起自习，但是他们在那个小机房里每人都有自己的电脑，我却没有，只能站在边上看他们写程序，偶尔和他们聊聊。才知道他们都是实验班和强化班的。 张老师也会来找我谈话，让我多和他们接触接触，学习一些东西，还有一些为人处事的道理，但是也要分辨是非。 当时我只是初来乍到，对这一切都不熟悉，对于那几位高三的学长也充满了尊敬，看着他们写代码的速度飞快，暗自揣测，他们的水平应该胜过我一筹。（毕竟我之前主攻的是应用开发，而不是算法设计。）便经常向他们请教问题，有时候听到我一些比较可笑的理解（比如将有向图的边理解成向量）他们倒也不生气，耐心的给我讲解。 我记得有一次问缪叔（缪晓伟，大家都尊称缪叔）有没有做过应用开发，他说他们合作过一个抢答器。当下我便有了一点底——我的算法设计比不上他们，但是他们的应用开发也不一定比我厉害。当然，现在的缪叔一定比我厉害了。（缪叔现就读于南大软院。） 回到家中，我也只是写一些算法，因为当时还不知道信息学奥林匹克竞赛要考些什么题目，所以做题目根本无从谈起。我以为知道要学一年，到了高二才能参加比赛。 谁知道，就在运动会前夕，张老师将我将了过去，告诉我十一过来就要初赛了，但是报名早在他认识我之前就完成了。他问我想不想参加一次，去试一试。我虽然没有什么底，但还是点了头。但是想到报名早已结束，就算想参加也没办法了。没想到张老师却说，这件事情他来处理。（后来果然报上了名。） 当下给了我一本初赛辅导的书，让我抓紧时间看一遍。他的安排是运动会不要去看比赛，去机房和高二、高三的一起做题目。当时我也很激动，便答应了下来。我拿到了书，随手翻了一翻，便知道内容非同寻常，异常的难。很多没见过的名词、算法、题目。但既然答应了，虽然时间紧迫，但硬着头皮也要看完的。 张老师还是没有改变他低调的风格，让我将书的封面用空白的封皮包住，不要让人家看到。当下我踌躇满志，拿着书回到了教室。 （欲知后事如何，且听下回分解。） ","date":"2014-07-22","objectID":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%B8%89%E5%9B%9E-%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0/:0:0","tags":["高中生活","NOIP"],"title":"忆昨日·NOIP - 第三回 初来乍到","uri":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%B8%89%E5%9B%9E-%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0/"},{"categories":["浮生杂记"],"content":"上回说到，我在初中的时候参加过一次普及组的初赛，后来由于种种原因退出了，开始了自己的自学之路。 到了高中，此时的我已接触了多门编程语言、脚本语言。无意间听说高中还有信息学奥林匹克竞赛，非常欣喜，盼望着能够参加，也想和众位高手一较高下，看看自己多年的自学是否有成效。于是一直深信不疑学校中有许多深藏不露的高手，因此一直非常的低调。直到有一天，得他人引荐，认识了信息组的负责人，也就是后来我的辅导老师，也算是一个朋友——张兴老师。 第一次交谈是在电话中，他粗略的问了一下我的情况，便说，「今天下午一点半到我办公室来一下，信息组三楼，网管室。」我听了一怔，「网管室」，听上去非常的厉害，想必那位张兴老师也不是泛泛之辈。当下欣喜，难以言表。于是匆匆准备，提前十分钟到了「网管室」。 现在想来，当初的欣喜，多半源于自己在编程方面的一点小能耐终于能够有人赏识，大抵如此吧。 在等待的过程中，看见一个人走来，我猜想那人应该是学校的老师，便叫了一声「老师好。」，谁知那人回道，「我不是老师。」。这段插曲算是过去了。又过了几分钟，只见一个男子向我走来，皮肤黝黑，身材枯瘦，再加上之前的插曲，我不敢断定他是老师，便踌躇了一会儿。就在此间，他说道「你就是王凯吧，来的这么早啊。快进来。」边说边从兜里掏出钥匙，熟练的打开门，进去后，他找了一张凳子，放在他的办公桌边上，说道「坐。」从一开始他对我的态度，早已使我受宠若惊，再加上此间，我百般推辞，但奈何不过，只得战战兢兢的坐下。大气都不敢出。（当然，到了后来，我进他办公室，大多都是径直搬了张凳子就坐了下了。所以上文说道，他不仅仅是一位师长。） 他为了缓解气氛，指着一张断了一个角的凳子，说道「你猜这是怎么坏的？」，我不知道他的意图是什么，只是摇头，他笑道「被一个同学坐坏的，他过会儿也会来。」当下我想，那人应该是一位高手。 我们谈论的内容非常的广泛，我记得他听到我说初中学过一些 Pascal，以为我想继续学 Pascal，便准备劝我不要去学那么破旧的东西。但得知我想选报 C++ 并且有一定的基础时，倒是舒坦了不少。于是我们便谈了很多关于桌面应用程序开发的事情，又聊到了网页开发，包括 Javascript、JQuery 等等，最后谈到了算法，对于这方面，我只是略懂，因此聊起来有些吃力，还被当场指出了一个错误——我当时给「归并排序」自创了一个名字「递归排序」，闹了一个笑话。 在这中间，又来了一位同学。他已跟随张兴老师学了几节课，再加上我之前的自我揣测，刚开始对他还是有几分摸不透，毕竟不知道他到底水平如何，所以对于一些自己并没有太大把握的内容，并没有说。但听他的言谈，倒也不似高手，当下才放下了心。 第一次的聊天，大多都是关于计算机方面的内容，随着接触时间的增加，我们也聊很多关于学习、生活方面的事情，在此按下不表，后文会详细记述。 在交谈中，一转眼便将近下午三点，我便去自习了。在临行前，他只是告诉我，以后每周六中午放学后，便到他的办公室来。听了这话，我便知道，他愿意将我当作信息组的一员了。由于这是内部决定的名单，因此比正式竞赛分科早了整整半个学期。 这次谈话对我来说，可谓受益匪浅，自学了三年，终于有一个人可以与我畅谈这些技术。此后，我分别接触了两届信竞大神，虽然他们在年龄上长我一岁，不过倒也相处的来，尤其以缪晓伟、项业成、王意天、胡宇涛四位，交谈最多，他们在学习和生活方面也都给了我很多的经验和指导。这些在后文中会详细记述。 整件事情回想起来也是一场意外，若非那位小伙伴的举荐，恐怕我不一定会是张兴老师辅导，那么我也就不一定会进信息组。 （欲知后事如何，且听下回分解。） ","date":"2014-07-21","objectID":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%BA%8C%E5%9B%9E-%E5%86%8D%E5%85%A5%E4%BF%A1%E7%AB%9E/:0:0","tags":["高中生活","NOIP"],"title":"忆昨日·NOIP - 第二回 再入信竞","uri":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%BA%8C%E5%9B%9E-%E5%86%8D%E5%85%A5%E4%BF%A1%E7%AB%9E/"},{"categories":["浮生杂记"],"content":"时过期年，再次回首起 NOIP 之路，良多感慨。现下忙里偷闲，不妨记录下来。 说起信竞（信息学奥林匹克竞赛），第一次接触是在初一的时候。依稀记得，那是初一的一个中午，王学良拿着一张纸（还是一本本子）走进教室，问道：「你们班谁参加过计算机方面的比赛？」当年的我少不更事，非常得意的举起了手。然后问了姓名，让我某天中午去机房开会。 说来惭愧，当时真是自不量力。小学曾经参加过两次电脑打字比赛，居然恬不知耻的举手了。因此才有了这些事情。 且说那两次虽然都是一等奖，但是都胜之不武。当时比赛用的那一款软件，我发现了一个漏洞：比赛共进行两次（至于如何计算分数我就不太清楚了—），测试内容是一样的。我在第二次测试的时候，将测试的文本全部改成了空格键，这样，只需要按住空格键不放就行了。通过这一非常不正当的手段，忝列一等奖名单，现在想来，实在是羞愧至极。 回到正题，那天开会，去了几个人已无法记清，只依稀记得不满十个人。辅导老师名叫鲁智建，三十岁往上的年纪，皮肤偏黑，戴着一副眼镜，看上去谈不上斯文，却也别有一番气度。再加上他说话的语气，当时对他倒也有几分崇敬。我能回忆起来的会议内容大概就是我们需要学习 Pascal 这门语言。 记得第一次上课，内容是在屏幕上输出“Hello World”字样。当时也只是依葫芦画瓢，什么都不懂。看见屏幕上有几行字，非常欣喜罢了。但是，不知怎么的，我对 Pascal 就是提不上兴趣，现在才明白，因为它的语言太死板，拘泥不通，一点都不优美。下课时，鲁老师让我们自学下一章内容。 看到一章名叫「函数」（此「函数」非彼「函数」），当时吓得不轻，完全看不懂。 第三节课上，鲁老师放出了一段代码，让我们一人解释一句。轮到我的时候，我当时非常忐忑，第一次回答问题，生怕回答错了。现在也已忘记了是什么问题，只记得当时答得一本正经。鲁老师不置可否，继续问下一个人下面一条语句。我也是心中一惊「难道我答得不好？」，但还是看了下一条语句，其中有一个我不懂的单词，谁知道我边上的同学答得十分流利，鲁老师夸赞他很厉害，当时我心中说不出的滋味。 回到家中，问起了何林峻（重庆人氏，因学习易语言相识，此人现从事软件开发。），他只是告诉我「他只是比你多懂几个函数罢了，没什么了不起的。」当时虽然满头雾水，但还是得到了莫大的慰藉。重拾了信心，但还是对坐在我边上的人有几分忌惮，觉得高手真多。 后来的课上，边上的人突然找到一段代码，可以在屏幕上连续的打出变化的字，看上去就像自己定制的屏幕保护一样。当时感觉他非常厉害。鲁老师只是告诉我们，这个东西以后才会学到，现在不要去弄。（后来我才知道，只是极其简单的循环。） 我记得当时只学了一个月，其实也就是十节课不到的样子，便迎来了初赛。拿到参赛证，赫然写着「普及组」字样，当时信誓旦旦，日后我一定要去「提高组」摘金夺银。 匆匆的准备了一番，告知参赛地点在梁丰高中，从常青藤校门出来，走到对面电视大学的站台，坐着公交车，鲁老师带队，连同初二、初三，一行十几人便出发了。 来到梁丰，被那美丽的校园镇住了，我们坐在中央大道的石凳上休息，虽然是十月的时节，却还是异常的闷热。边上的人听着轻松的音乐放松心情，我就带了一个手机，也没有什么放松的办法，好在也不怎么紧张。（因为不知道，所以不害怕，也就不紧张。）考试地点在图书馆（当时并不知道是图书馆）四楼。记得当时做的是电梯，顿时感觉待遇非同一般。等到了考试地点，看见了那么多考生，才发现自己多么的微不足道。 拿到试卷，全是不认识的名词，我已记不太清，顿时气势已输了大半。但还是硬着头皮做了下去。半个小时过去了，有几个人提前交卷出去了，顿时感觉他们太厉害了。（现在才知道他们不会做才提前交卷的。）不禁又捏了一把汗，自然方寸大乱。 所谓「福无双至，祸不单行」，正在此时，突然感到难受难忍（考试那天一直在发烧，来的时候还不要紧，突然难以忍耐。），但还是继续硬磨了十几二十分钟，最终坚持不下，大概是下午 4：20 的样子，提前交卷，回家了。（如果所料不错，考试还有 40 分钟结束。） 在此之前，从未想过提前交卷的念头，现在想想，倒也可以理解。 回到家中，自知不中，却还是盼望着能过初赛，但是消息一直没有等到。后来，由于种种原因，退出了初中的信息组。因此也就无缘了后两次初赛。也不知道他们有没有继续弄下去。 但是这次历练却成为了我系统的自学编程的一个里程碑，也为高中进入信息组打下了坚实的基础。 （欲知后事如何，且听下回分解。） ","date":"2014-07-20","objectID":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%B8%80%E5%9B%9E-%E5%88%9D%E5%85%A5%E4%BF%A1%E7%AB%9E/:0:0","tags":["高中生活","NOIP"],"title":"忆昨日·NOIP - 第一回 初入信竞","uri":"/2014/07/%E5%BF%86%E6%98%A8%E6%97%A5noip-%E7%AC%AC%E4%B8%80%E5%9B%9E-%E5%88%9D%E5%85%A5%E4%BF%A1%E7%AB%9E/"},{"categories":["浮生杂记"],"content":"没想到高考就这么结束了，分数就这样出来了。 还没有缓过来，无法接受，横来的失败，令我不知所措。有句话可以比较准确的形容，失去了信仰。 成绩刚出来，也只是觉得命中注定。中考如斯，高考如斯。但过了一阵子，静下来回忆一下之前的来路，不禁唏嘘。就这样结束了，就以这样的结果结束了？ 当初为了一个目标，开始前行，中途遇到过种种险阻，彷徨、失望、担心，却不曾如现在一般迷惘，不知所措。曾经一度以为自己可以做到，没想到会是这样的结局。值得庆幸的是在这过程中不曾迷失了道路，一直记得当初前行的理由，并一直走了下去，但到今天这样的结果，确是万万没有料到的。这些遗憾与不甘，并不来源于分数本身，而是其后隐藏的，一路前行的过程。 曾经笃定的眼神，充满希望的方向，瞬间全部化作泡影。 仔细回想，如果当初毅然决然去参加数学决赛，或许结果不会这样；如果当初毅然决然的停课复习，备战NOIP，或许结果不会这样；如果当初准备上交自招材料的时候没有那么多负面情绪，以至于到最后胡乱应付，或许结果不会这样；如果…… 但是，这一切都已经发生，一切都是我的选择，没有后悔，只是遗憾。要说对不起，我想是那个曾经的自己，以及三年前信誓旦旦的话语。没想到，到头来，一切成空。是不是人们常说的「命里有时终须有，命里无时莫强求。」 还是谈谈信仰吧，我也不知道，或许付出并不会有什么回报吧。我们都是上帝手中的棋子，演着一部已经定稿的戏剧。所谓「死生有命，富贵在天。」慢慢开始相信「宿命论」。 每当我非常认真的想要做好一件事情，付出了几乎所有的心血，这件事情往往会搞砸。 或许，这就是生活——没有如果。 ","date":"2014-06-25","objectID":"/2014/06/%E6%B2%A1%E6%9C%89%E5%A6%82%E6%9E%9C/:0:0","tags":["高中生活"],"title":"没有如果","uri":"/2014/06/%E6%B2%A1%E6%9C%89%E5%A6%82%E6%9E%9C/"},{"categories":["浮生杂记"],"content":"注：此为一模作文的再创作，之所以取这个题目，是因为当时考试时取的题目实在不堪看。至于将其归于「痴言」分类，大抵可以用曹雪芹的「都云作者痴，谁解其中味。」来解释吧。既然谓之「痴言」，自然是「假语村言」，看官们大可一笑罢之。正文如下： 他躺在宿舍的床上，皎洁的月光安静的洒在地上。他的舍友早已入睡，只是楼上宿舍还时不时传来些许笑声，他知道他们定是在开卧谈会。 这倒也无妨，反正他也睡不着，最近一系列的事情搅得他心绪不宁。刚刚从竞赛的前线败下阵来，回到教室，面对着成堆的作业。本来微弱的保送机会也早已化作了泡影。其实对于参加这次竞赛，他内心是极其矛盾的，本可以去参加数学决赛，说不定还可以弄个省一。不过转念一想，就算有了省一，这又都是他所想要的吗？答案自然是否定的。 对于未来，他有着非常清晰的目标。以至于在高三刚开始填目标时，他毫不犹豫，写下了「上海交大」。当时的他成绩并不理想，他也不知道自己是怎么有勇气在班主任的电脑上打出这几个字来。以至于填完以后根本不敢看班主任一眼，便径直回到自己的座位上。 回到宿舍，他从舍友口中听到其他同学的一些反应，「有人说你考上上海交大他就从楼上跳下去。」他笑笑，淡淡的答了句「那他得先买好保险。」他一直是这么的自信，哪怕是在最黑最暗的时刻。 当然，他知道，那些所谓的闲言碎语都没有丝毫用处，行动才是最切合实际的。他也不会相信，自己会在高一上学期短短一百多天刷完一本《英语5·3》；自己的数学会从这儿算错了，那儿没看清题目到一个比较可观的成绩；虽然语文还是在原地踏步，但是他并不着急，他知道，他能够把它做好，用他的老师的一句话说，叫做「尽善尽美」。 说实话，在一开始，他自己也很迷茫。高二的时候，由于竞赛落下了很多，考试一般都是惨不忍睹。但他找到了支撑他不停奋斗下去的信念。每天背单词，整理错题，刷《英语5·3》，当时的他也不确定，想着，坚持一个月看看结果怎么样吧。第一次月考，他意外的进入了前十的行列，此后基本稳定。但这似乎离他的目标还是相差太远。他总是希望做的更好。 但是，似乎在几次成绩稳定后，他奋斗的热情似乎有所衰退，好在即时反省，并没有太大的影响。 又经历了几次大型考试，他的舍友突然又告诉他，「又有一个人说你考上上海交大他就从楼上跳下去。」甚至不惜调侃一句「我也是。」他依旧是那句玩笑的回答。 这种冷嘲热讽对于他来说已是习以为常，这些年里，他经常和它们打交道，他知道不用去太在意，只要坚定自己的脚步，一直走下去，当阑珊褪去，一切都会柳暗花明。 记得一模第一天考完，他在走廊上看夜景，他的同学在一旁吹着伤感的曲调，他似乎想起了一些什么，却也只是长嘘一声，此时，他的同学说道「听说你数学考得很好啊。」他苦笑，「还行吧。」他的同学继续说道「还行就是很好。」他无奈的摇了摇头，的确，是不错。但却没有考好的感觉，那种所谓的愉悦与轻松。取而代之的是沉重。 不是他不善言谈，只是他实在不知道该如何回答才好。或许，这就是所谓的「快乐都在别人的眼里。」有人说他「装深沉」，他也不知道该怎么去回应。其实他知道自己一点都不「深沉」。譬如大家在晚自习下课后通常会讨论数学题，这题怎么做，那题答案是多少，他觉得这些题目还够不着要讨论的难度，所以很少加入。偶尔插一句话，也会被同学「你这方法谁想得到。」给堵回去。他的数学水平也不是很高，他也经常做错题目，看着满目疮痍的试卷，不知所措。 他也学着别的同学，尝试着阅读英文的小说，却听到「人家英语什么水平，就你，看得懂吗？」当然，他不会就此停下了步伐。 他也有自己的朋友，有自己信任的人。也愿意在某个午后，和几个朋友出去走走逛逛，抑或坐下来喝杯咖啡，聊聊天。 看着高考倒计时牌，他不知道六十多天以后会是什么，但是他感到一天天过的越来越快，他知道自己想要的是什么，也知道自己该怎么去做，更明白两个多月后的结果意味着什么。所以，不论如何，他知道自己不能停下脚步。 「在这人世间有些路是非要单独一个人去面对，单独一个人去跋涉，路再长、再远，夜再黑、再暗也得独自默默地走下去。」他突然想起了席慕容的这句话，在昏昏沉沉中睡去。 「叮···铃···铃······」拿起手表看了一眼，已是早晨六点，他知道，这又是新的一天。 梦想，在远方等着他。 ","date":"2014-04-05","objectID":"/2014/04/%E4%BB%96/:0:0","tags":["高中生活"],"title":"他","uri":"/2014/04/%E4%BB%96/"},{"categories":["浮生杂记"],"content":"最近将自己博客里的 HTML 富文本编辑器换成了 Markdown 编辑器，这样可以更加专注于写文章，而不用去关注排版。它比 Word 轻巧，又不如 Latex 般繁复，用来写博客是再适合不过了。 还记得在放假的时候写的文章中提到希望可以在寒假里再赚一些钱，前几天我们团队（据说已经注册了公司）的队长找到我，让我参与开发一个项目。这个项目据他说是国际项目，分别发布在 Windows、Linux 以及 Mac 三个平台上。他希望我协助开发 Linux 平台，并称会将日后 Linux 平台盈利额的 30% 作为报酬，这是一笔非常可观的收入，要求五月份完工，虽然我非常的欣喜，毕竟这不仅是赚钱的机会，更是对自我能力的提升，但是最后考虑到高考还是没有接。他说我可以只开发 UI，这样可以获得盈利额 12% 作为报酬。思前想后，最终我还是没有接下这个活。 不知不觉已经正月初十，马上就要开学了，下个学期注定是个不同寻常的学期。当然，我相信我们的 OIer 精神一定可以得到更加淋漓尽致的诠释。就在过年的时候，看到我们团队中一个高三学生写的一篇日志，内容是写给自己的一封信，本想摘录一部分，但是无奈他文笔实在是好，所以索性一并摘录过来（有删改，版权所有：Tjz） 亲爱的自己，你好。 当你读到这些文字的时候你已经高三了。我不知道未来的这一百多天的日子里你要经历些什么，不过既然已经跋涉了十一年，最后这一百天里希望你要拼尽全力。 亲爱的自己，只有你自己最清楚，过去的分分秒秒你付出了多少，浪费了多少。最后的一百多天里希望你平静自己的心。即便自己不是绝顶聪明，也要相信勤能补拙。 亲爱的自己，未来的日子里请不要轻言放弃。你难免会有失败的时候，因为不只你一个人在努力。但请你相信付出一定会有回报，你要记得跌跌撞撞才是生活，你要把每一次的失败当成下一次成功的路基，你要坚持。当然你也会取得一些进步，那样的时候请你不要放松，因为你放慢了脚步的时候别人并没有。你进步的原因是你之前落下了很多，所以别人在走的时候你需要跑，别人跑起来的时候你就要加速。你没有资本去骄傲。\u003e 亲爱的自己，你需要一个目标。你已经小小的了解了为目标去奋斗的路上并不觉得疲累，所以请你继续追赶。可以是一个城市，一所学校，一个人，或者是一个梦想。总之你需要它来鞭策你变成更好的人。在逐渐缩小距离的同时，再辛苦也觉得值得不是吗？ 亲爱的自己，未来的日子里请你管住自己。不上网并不会折寿几年，你喜欢的书也不是只卖一年就会绝版，还有你的手机也并不是长在身上的器官，离开这些你一样活的好好的。 还有你那时常泛滥的情绪，请你控制自己的心情。不管你是否经历过，或者还在计较些什么，请你不要继续挣扎，你知道自己曾经输在哪里，所以不可以再摔倒一次。 请你知道不是你现在所承受的伤痛就叫生死劫。以后你还要走很长很长的路，很多事情还不是时候。 你可以有喜欢的人，但请你把Ta放在心里。熬不下去的时候花一分钟去想念，然后记得Ta还在努力，你不坚持、不努力就会离Ta越来越远。所以，你要加油。 亲爱的自己，再动人的情歌、再凄美的故事也不适合高三的你。听英文歌可以练听力，摇滚可以提神，轻音乐能缓解压力。躲在被子里看小说绝对比看报纸看新闻累眼睛。所以当个文青不是不好，是你现在还不够资格。 亲爱的自己，虽然以后的日日夜夜你要早起晚睡，你要改变自己很多的习惯，你要忍受寂寞。但是还是请你记得要对自己好一点。记得每天喝一杯牛奶，喝茶好过喝咖啡。记得经常锻炼身体会慢慢变好。记得不可以暴饮暴食。记得阴天的时候奖励自己一个大大的微笑，并且带上伞不要淋湿。记得濒临崩溃的时候抱紧自己，告诉自己就快结束了，不能放弃。 亲爱的自己，你知道自己没有显赫的背景，没人能为你铺出一条康庄大道，你也没有其他的选择。对你而言通往未来的路只有一座叫高考的独木桥，而这一路只能靠你自己披荆斩棘。你要知道你身上背负的不只是你一个人的命运，还有为了你日夜操劳的家人，都是你必须偿还的债。你没有理由也没有时间不努力了。最后一搏，只许成功，不许失败。 亲爱的自己，请你加油。 不得不佩服 Tjz 神犇的文笔，我所想说的，他都提到了；我没想到的，他也想到了。 不得不说，高考对于我们来说意义重大，每次想到都会有些害怕，我也不知道自己在怕什么，也许就像当初面对中考一样的感觉吧。 说到这，想起上学期只是稍稍在英语方面投入了一些精力，却有了如此结果，倒也出乎意料。或许，这个结果也在我的预料之中。 既然有了这样一个良好的开端，那么就应该坚持下去，一切都会柳暗花明。虽然目标远大到大家都在嘲笑，但奇迹毕竟是由人来创造的，古语有云 海到尽头天是岸，山至高处人为峰。 事在人为！ ","date":"2014-02-09","objectID":"/2014/02/%E6%9D%82%E8%AE%B020140209/:0:0","tags":["高中生活"],"title":"杂记（20140209）","uri":"/2014/02/%E6%9D%82%E8%AE%B020140209/"},{"categories":["浮生杂记"],"content":"本来很早以前就想要写这篇文章了，期间一直在反复思索，于是便一直拖到现在。本文主要是对于生活事件以及个人经历的一些反思，观点可能略有偏激，内容略有冗长，请有选择的阅读。 这篇文章前几天就起笔了，竟一直拖到今天，不论如何，决不能拖到明年。 第一个问题是关于为什么要写博客以及博客该写些什么的问题。 我想还是因为这里比较自由吧。主要还是写一些关于生活的文章，包括一些杂感、竞赛，抑或其他。 这是我创建博客时候写的第一篇文章《Hello World》中的内容，现在想想竞赛，我早已退役，已经不再属于我所需要记录的范畴，取而代之的可能是对于一些数学内容的思考。至于杂感和其他，这是一个非常庞大的概念，虽然我也经常写，但是总感觉言不由衷。在当初创建这个博客的时候，我就希望可以摆脱其他社交平台，但是到后来却发现还是无法摆脱。虽然我不再在各大社交平台上发表文章，但是我会通过博客的一个插件向空间、人人、微博推送这些文章，其实我也不知道为什么要这么做。虽然我不再关心它们在其他地方的排版，但是这样一来似乎还是回到了之前的情形。 再者，写文章也是为了记录生活，但是有时候有些话就是不敢或不愿意写出来，这似乎违背了我搭建博客的初衷。对于这一「囚徒困境」我是极其无奈的，这或许会一直持续影响着我。今天去其他博友的博客上逛逛，看到他们写的文章，似乎也有很多关于日常琐碎的生活，或许这样并没有什么不好，只是需要控制好一个度吧。 第二个问题是关于自己的想法。这个问题还是要面对一下。还记得那次关于萧伯纳和周国平的材料作文，我的观点帮助法被杨英戏称为「怪才」，我当然知道她只是玩笑之言，我也一笑而过。不过时候还是有人说我的想法太「奇怪」，不知那些人是否看过下面这段话： 他们我行我素，桀骜不驯，惹是生非，就像方孔中的圆桩，他们用不同的角度来看待事物，他们既不墨守成规，也不安与现状，你尽可以赞美他们，否定他们，引用他们，质疑他们，颂扬抑或时诋毁他们。不过唯独不能漠视他们。因为他们改变了事物，他们让人类向前跨越了一大步。他们是别人眼里的疯子，却是我们眼中的天才。因为只有疯狂到认为自己能够改变世界的人，才能真正的改变世界。——斯蒂夫·乔布斯 乔帮主的这段话还是非常正确的。至于怎么理解，这就是见仁见智的问题了。 第三个问题是关于人际。这样讲似乎书生气太重了，说白了就是与人相处的事情。有些理论我一直不敢相信它是真的，例如「有的朋友是真的，有的朋友是假的。」不过想想似乎也在理。有的朋友，虽然常年不见，但只要一见面就有说不完的话，就像昨天刚见过一样。而有的朋友，得时刻考虑着为人处事的礼貌。这和心理学上讲人的层进式的防范意识是有一定关系的。或许这才是真正的生活和社会。这也就印证着，所谓的「象牙塔」是并不能真正存在的，我们只能无限接近。 对于友情，我觉得时间是一个非常重要的因素，所谓「试玉要烧三日满」，对于快餐式的友情，我是不敢苟同的，刚认识几天，便称兄道弟，似乎有些过头了。的确，有的时候，我们似乎只要几天，甚至几个小时，便能知道对方曾经的经历，以及意识形态。但是这并不代表着什么，孔夫子早在两千年前便说过「听其言，观其行。」，这才是最恰当的做法。 人是非常复杂的动物，虚虚实实，便如同那难以揣测的兵法，所以兵家有句话「兵不厌诈」，那么简单的类比一下，我想各位读者应该可以得到答案。 第四个问题是关于自身的一些反思。首先摘录一段在别人博客上看到的话： 我是一个学生， ——我的成绩没有多么耀眼。 我是一个子女， ——我的孝行没有多么感人。 我是一个程序员， ——我的程序没有多么成功。 我是一个朋友， ——我的友谊没有多么真挚。 我是一个读者， ——我的见解没有多么深刻。 这段话给我很特别的感觉，似乎非常的切合我。仔细想想，一直以来，我都是非常失败的。 有些久远的中考，挂了；后来的电子技师，挂了；信心满满的 NOIP，挂了；数学夏令营，还是没拿到免试资格；自荐上海交大，直接被刷了下来；想要翻译的英文资料，却迟迟没有完工；写的程序，漏洞百出；做的网页，惨不忍睹；看过的书，一无是处…… 这些已足够说明上面的事实。我和「优秀」完全搭不上边，我离这两个字还差的很多很多。很多很多。 ","date":"2014-01-30","objectID":"/2014/01/%E5%AF%B9%E4%BA%8E%E7%94%9F%E6%B4%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/:0:0","tags":["高中生活"],"title":"对于生活的一些反思","uri":"/2014/01/%E5%AF%B9%E4%BA%8E%E7%94%9F%E6%B4%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/"},{"categories":["浮生杂记"],"content":"很早以前就想写篇日志了。一开始是用来抒发竞赛生涯结束的感慨，后来变成了对复赛成绩的凭吊，现在成了一篇随笔。所以题目叫做「杂」。 期末考试终于结束了，成绩还没出来，至于总结也很难说。且按下不表。 考前网购了一本书《图解：梅花易数》，想起自己之前靠自己看的那点易学知识，实在是太浅了。一直以为占卜算卦是非常难的事情，一定要有什么特殊的条件。昨天稍稍看了几章《梅花易数》，顿时感到易学的博大精深，对于人世间的种种世相都可以用来占卜，或许这样就可以到达真正的「掐指一算」的程度吧。 再且说说自招吧。自荐交大，本以为自己实力足够，材料够硬，结果就好比面试的时候直接被关在了门外。说实话，失落，到没太多，当时看到结果，郭华本想安慰一下我，我却直接说「这没什么。」。不过这倒给了看客们一些话题，省的他们没舌根子嚼，也罢，也罢。 说起这个，似乎还应该感谢两次竞赛的失利，对于打击最大的该是高二的那次，原本斗志昂扬，想着进省队。结果却等来一个二等奖，连省选的资格都没有。再想来，我自认为水平虽然不算特别高，但拿个一等，问题应该不是特别大吧。或许，这就是人生。也多亏有了前几届失败的经历，有了心理准备，也慢慢的有了如今的心理素质，但更大的可能或许是自招并不是我真正看中的吧。既然高考是人生中难得的相对公平的竞争，那么就让它来证明这一切吧。 不过郭华帮我写的材料，说我「正大光明」，这个评价我还是第一次听到。想想也挺对的。再来说说找张兴写材料吧，虽然我已经不再是梁丰 NOIP 的队员了，但他还是一样的热情，或许 NOIP 只是一个桥梁，沟通的是我们师生二人吧。 昨天回到家，发现有个「七牛公司」的市场营销人员找到我，绕圈子绕了半天，结果是让我在博客上发他们公司的广告，在听了我一番说辞之后，他说我的拒绝太成熟了。我实在不知道该如何去回复他。不过不管怎么说，这也意味着我的博客在慢慢的发展吧。 比起空间、人人之类的社交网站，我似乎更倾向于博客，一来博客不会推送信息，不会记录访客，完全是靠读者自己意外搜寻得到，二来比较清静。 临近年关，有些事情也不想提了，不过还是坚信一句「人在做，天在看。」，所谓业因业果。 本想回归原来的题目，谈谈竞赛结束的感想，无奈在我的记忆里，只有没日没夜的刷题，以及无数的 Wrong Answer。不过，我倒是学会了如何为了自己的梦想而奋斗。 至于寒假的规划，首要任务当然是学习，次要人物就是研习《梅花易数》，最好还可以看一点《纳甲筮法》。当然了，如果能够像去年暑假一样，赚点外快就最好了，当然，只是想想罢了。 暂且到这吧，明天就要去学校了，也不知道会面对一个怎样的分数。 ","date":"2014-01-21","objectID":"/2014/01/%E6%9D%82%E8%AE%B020140121/:0:0","tags":["高中生活"],"title":"杂记（20140121）","uri":"/2014/01/%E6%9D%82%E8%AE%B020140121/"},{"categories":["浮生杂记"],"content":"2014\" 2014 恍惚间，一年的光阴又匆匆流过。不知从什么时候开始，每年写一篇文章似乎成了惯例。今年本来并不打算动笔，但是思来想去还是写写罢，也算是对过往的怀念与铭记，对未来的向往与期待。 要不是昨天小伙伴们的跨年短信，我还真不觉得昨天的日子有什么特殊的地方。 不得不说去年发生了很多事情，不得不提的是小高考，考完以后我便写了一篇日志为小高考打个点，也算是对小高考的纪念吧。刚才翻看了一下那篇日志，感觉有很多地方没有记录到，在此补叙几句吧。对于小高考，当时觉得非常神圣，就好像初三时候对中考的感觉一样，但是现在已经考过了，却感觉也没什么，不过如此，或许现在我们既害怕又期待的高考，也会在未来成为茶余饭后的过去吧。 2013年，印象最深刻的是暑假在数学组的经历。包括了在学校上课，讲题；在扬州培训，考试。虽然那段时间我们每天中午都会把时间放在娱乐上。但是却不可否认这段时间给我们数学能力方面带来的突飞猛进。这也为现在高三应付数学难题打下了扎实的基础，或者根本不算难题。 当听到别人在讨论着附加题最后一题，说这题有多难多难，真想说，就这种题目也好意思叫难题。但我知道不能说，别人可不这么认为，他们或许觉得你在吹牛，或许觉得你根本不懂。而当你信笔涂鸦解出这道题时，他们又看不懂了，纷纷说你在炫耀。很多事情就是这么回事。 再说那本英文版的《Steve Jobs》，我自觉看上去没有什么压力，却被人说成炫耀。一如那天文化夜市淘了两本时代周刊时的情况。对此，或许沉默时最恰当的回应，时间是最有力的证明。 不知大家是否记得某个星期五，上午大课间我被周汉东老师叫去应付省里专家的检查。当时还觉得有多大的场面，而实际上不过如此。倒是等他们来的时间太久了。附上一张图片，或许大家都很好奇发生了些什么。 为专家组介绍科技小组\" 为专家组介绍科技小组 事情大抵就是这样，周围围着一圈专家，我在介绍一个单片机作品。旋转时可以显示出字幕，演示的时候大家都非常好奇，纷纷问我这是如何工作的。那天展示的作品虽然不是我自己做的，但是我之前确实自己动手做过一个类似的作品。所以讲起来也头头是道，以至于第二天有反馈说我那天的讲解非常精准到位。 还有值得一提的事情大概就是 NOIP 了，但是却一直不想提，我也猜到了这样的结局，又是一个二等奖。也罢。还在暑假里为派出所开发了一套软件，这样一来也至于觉得自己学的编程毫无用武之地。至少可以用自己赚到的钱做自己想做的事情了。 暑假里加入了 SmartOJ 开发团队，交到了很多朋友，也学到了很多。收获颇丰。 今天是 2014 的第一天，我想可以开始着手之前策划了许久的项目了。 高三刚开始的一个月，还比较静的下心，后来慢慢浮躁起来。其间我曾尝试着参悟佛法，无奈实在没有如此高的悟性，最终无功而返。或许还得靠自己吧。 这些都已经过去了，而过去的这一切证明着我并不差。 对于已经过去的 2013，确实有很多遗憾，也有很多抱歉，更有很多悔恨。 对于已经到来的 2014，说实话，有期待，有惶恐。前方的道路是否坎坷，我也不知道下一步会怎么样，但是我知道只有努力才有可能。 或许现在能做的，只是奋斗。 我相信！ ","date":"2014-01-01","objectID":"/2014/01/%E7%99%B8%E5%B7%B3%E5%BF%972013-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:0","tags":["高中生活"],"title":"癸巳志（2013 年度总结）","uri":"/2014/01/%E7%99%B8%E5%B7%B3%E5%BF%972013-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["数学之美"],"content":"很早就想整理这部分的知识了，迫于时间原因，一直拖到现在。下面就圆、椭圆、双曲线、抛物线的切点弦进行一些研究。主要涉及两个方面，一个是关于曲线上某点的切线方程，另一个是关于曲线的切点弦方程。 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:0:0","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"一、关于曲线上某点的切线方程 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:1:0","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"1、圆 我们都知道，过圆 $ x^{2}+y^{2}=r^{2}\\left ( r \u003e 0 \\right ) $ 上一点 $ P\\left(x_{0},y_{0}\\right) $ 的切线方程是 $ x_{0}x+y_{0}y=r^{2} $ 。下面我们就更为一般的情形进行探究： 定理1.1：给定圆 $ C:\\left ( x-a \\right )^{2}+\\left ( y- b\\right )^{2}=r^{2}\\left ( r \u003e 0 \\right ) $ ，以及圆上一点 $ P\\left(x_{0},y_{0}\\right) $ ，则过该点的切线方程为 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$ 证明：对于圆 $ C:\\left ( x-a \\right )^{2}+\\left ( y- b\\right )^{2}=r^{2} $ ，两边同时对 $ x $ 求导，得 $$ 2\\left ( x-a \\right )+2\\left ( y-b \\right )\\cdot\\frac{dy}{dx}=0 $$ 其中 $ \\frac{dy}{dx})即为(y' $ ，只是导数两种不同的记号，化简整理得 $$ \\frac{dy}{dx}=-\\frac{x-a}{y-b} $$ 那么我们可以写出切线方程为 $$ y-y_{0}=-\\frac{x_{0}-a}{y_{0}-b}\\left ( x-x_{0} \\right ) $$ 进一步化简得 $$ \\left ( x_{0}-a \\right )x+\\left ( y_{0}-b \\right )y-\\left ( x_{0}^{2}+y_{0}^{2} \\right )+ax_{0}+by_{0}=0 $$ 又 $ P\\left(x_{0},y_{0}\\right) $ 在圆 $ C $ 上，则 $ \\left ( x_{0}-a \\right )^{2}+\\left ( y_{0}-b \\right )^{2}=r^{2} $ ，代入上式化简得 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$ 证毕。 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:1:1","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"2、椭圆 有了上面的基础，我们可以猜测到椭圆上某点的切线方程。 定理1.2：给定椭圆 $ C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}+\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u003e b \u003e 0 \\right ) $ ，以及椭圆上一点 $ P\\left(x_{0},y_{0}\\right) $ ，则过该点的切线方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}+\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1. $$ 证明略。 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:1:2","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"3、双曲线 定理1.3：给定双曲线 $ C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}-\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u003e 0, b \u003e 0 \\right ) $ ，以及双曲线上一点 $ P\\left(x_{0},y_{0}\\right) $ ，则过该点的切线方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}-\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1 $$ 证明略。对于焦点在 $ y $ 轴上的情形，读者可以自行推导。 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:1:3","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"4、抛物线 定理1.4：给定抛物线 $ C:y^{2}=2p\\left ( x-a \\right )\\left ( p \u003e 0 \\right ) $ ，以及抛物线上一点 $ P\\left(x_{0},y_{0}\\right) $ ，则过该点的切线方程为 $$ y_{0}y=p(x+x_{0}-2a) $$ 证明略。对于其他三种情形，读者可以自行推导。 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:1:4","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"二、关于曲线外某点的切点弦方程 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:2:0","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"1、圆 类似的，圆 $ x^{2}+y^{2}=r^{2}\\left ( r \u003e 0 \\right ) $ 外一点 $ P\\left(x_{0},y_{0}\\right) $ 的切点弦方程是 $ x_{0}x+y_{0}y=r^{2} $ 。下面我们就更为一般的情形进行探究： 定理2.1：给定圆 $ C:\\left ( x-a \\right )^{2}+\\left ( y- b\\right )^{2}=r^{2}\\left ( r \u003e 0 \\right ) $ ，以及圆外一点 $ P\\left(x_{0},y_{0}\\right) $ ，则该点的切点弦方程为 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$ 证明：设过 $ P $ 的切线与圆 $ C $ 相交于点 $ A\\left ( x_{1},y_{1} \\right ))以及(B\\left ( x_{2},y_{2} \\right ) $ ，首先过点 $ A $ 的切线同时经过点 $ P $ ，切线方程为 $$ \\left ( x_{1}-a \\right )\\left ( x-a \\right )+\\left ( y_{1}-b \\right )\\left ( y-b \\right )=r^{2} $$ 又过点 $ B $ 的切线同时也经过点 $ P $ ，切线方程为 $$ \\left ( x_{2}-a \\right )\\left ( x-a \\right )+\\left ( y_{2}-b \\right )\\left ( y-b \\right )=r^{2} $$ 综合上述两个方程，便可以得到过点 $ A,B $ 的方程，即点(P)的切点弦方程 $$ \\left ( x_{0}-a \\right )\\left ( x-a \\right )+\\left ( y_{0}-b \\right )\\left ( y-b \\right )=r^{2} $$ ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:2:1","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"2、椭圆 定理2.2：给定椭圆 $ C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}+\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u003e b \u003e 0 \\right ) $ ，以及椭圆上一点 $ P\\left(x_{0},y_{0}\\right) $ ，则该点的切点弦方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}+\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1 $$ 证明略。 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:2:2","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"3、双曲线 定理2.3：给定双曲线 $ C:\\frac{\\left ( x-m \\right )^{2}}{a^{2}}-\\frac{\\left ( y-n \\right )^{2}}{b^{2}}=1\\left ( a \u003e 0, b \u003e 0 \\right ) $ ，以及双曲线上一点 $ P\\left(x_{0},y_{0}\\right) $ ，则该点的切点弦方程为 $$ \\frac{\\left ( x_{0}-m \\right )\\left ( x-m \\right )}{a^{2}}-\\frac{\\left ( y_{0}-n \\right )\\left ( y-n \\right )}{b^{2}}=1 $$ 证明略。对于焦点在 $ y $ 轴上的情形，读者可以自行推导。 ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:2:3","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["数学之美"],"content":"4、抛物线 定理2.4：给定抛物线 $ C:y^{2}=2p\\left ( x-a \\right )\\left ( p \u003e 0 \\right ) $ ，以及抛物线上一点 $ P\\left(x_{0},y_{0}\\right) $ ，则该点的切点弦方程为 $$ y_{0}y=p(x+x_{0}-2a) $$ 证明略。对于其他三种情形，读者可以自行推导。 至此，关于二次曲线的两种切线问题已经阐述完毕。从上述过程我们可以看出，过曲线上某点的切线方程和过曲线外某点的切点弦方程的形式是完全一致的，这正是数学的魅力所在！ ","date":"2013-12-31","objectID":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/:2:4","tags":["二次曲线"],"title":"关于二次曲线切线问题的研究","uri":"/2013/12/%E5%85%B3%E4%BA%8E%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF%E5%88%87%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["浮生杂记"],"content":"NOIP 终于还是结束了，本来想写一篇文章好好记录一下这两年奋斗的历程，但自从周一知道成绩以后，便什么想法都没有了。凭心而论，今年题目比去年简单，可是我却考得没有去年高，实在惭愧。 现在想来，当初高二知道成绩以后的踌躇满志，就注定了高三竞赛的没落。 本来写了一篇文章，现在也不想打出来了，一切都过去了。或许，竞赛的成绩并不是最重要的。它所教给我的，是一种精神，正如今年国际金牌得主代表清华大学在ACM开幕式上发言时所说「自己选的路，跪着也要走完。」这种永不言弃的精神将一直伴随着我走下去。 当然，在竞赛的同时还收获了许多意料之外的惊喜。在刷 USACO、Codeforces 的时候，提高了英语的阅读水平。当然，还结交了几个志同道合的网友，虽然大家分布五湖四海，但是却有着相似的经历，同样的目标，虽然现在我们都注定要踏上高考这条路，但却还可以在文化课这一层面进行许多交流。 自主招生正在如火如荼的展开着，但是我却对这一政策兴趣不大。且听我慢慢道来，那些可以拿到一流大学大幅度加分优惠的，有几个正常发挥高考考不上这些学校的。对于备战自主招生，又要耽搁许多文化课的时间，到头来两边都顾不着。想起舍友季文逸跟我说的话「我当初没有报竞赛是明智的，有多少人真正受益了呢。」 当然，这也不代表我不参加自主招生。中国人的一贯想法，大家都报名了，我不报名，岂不落后了。估计自荐上交的可能性大一点。 谨以此文，作为高中 NOIP 生涯的最后一页。 到现在，一切与文化课无关的事情也都已结束，可以真正的捣鼓文化课了。 前方有一个清晰的未来—— 是的，我看见了： 我来了！ ","date":"2013-11-24","objectID":"/2013/11/%E5%91%93%E8%AF%AD%E5%9B%9B%E6%B8%85%E6%99%B0/:0:0","tags":["高中生活"],"title":"呓语（四）：清晰","uri":"/2013/11/%E5%91%93%E8%AF%AD%E5%9B%9B%E6%B8%85%E6%99%B0/"},{"categories":["码志"],"content":"昨天终于把欧拉函数想通了，现在总结一下。 欧拉函数 $ \\varphi \\left ( N \\right ) $ 表示小于或等于 $ N $ 的正整数中与 $ N $ 互质的数的个数。又称 $ \\varphi $ 函数、欧拉商数。 下面介绍欧拉函数的几个性质： $ \\displaystyle\\varphi\\left ( 1 \\right )=1 $； $ \\displaystyle\\varphi \\left( N\\right )=N\\cdot\\prod_{p\\mid N}\\left ( \\frac{p-1}{p} \\right ) $； $ \\displaystyle\\varphi \\left ( p^{k} \\right ) = p^{k}-p^{k-1}=\\left(p-1 \\right )\\cdot p^{k-1} $ ，其中 $ p $ 为质数； $ \\displaystyle\\varphi \\left(mn \\right )=\\varphi \\left(m \\right )\\cdot \\varphi \\left(n \\right ) $ ，其中 $ \\gcd \\left ( m,n \\right )=1 $ 。 我们根据这几个性质就可以求出欧拉函数。 基本思路是首先置 $ \\varphi \\left ( N \\right )=N $ ，然后再枚举素数 $ p $ ，将 $ p $ 的整数倍的欧拉函数 $ \\varphi \\left ( kp \\right ) $ 进行操作 $ \\varphi \\left ( kp \\right )=\\varphi \\left ( kp \\right )\\cdot \\frac{p-1}{p} $ 即可。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 1024; int N; int p[MAX], phi[MAX]; int main() { cin \u003e\u003e N; for(int i = 1; i \u003c= N; i++) // 初始化 { p[i] = 1; phi[i] = i; } p[1] = 0; // 1不是素数 for(int i = 2; i \u003c= N; i++) // 筛素数 { if(p[i]) { for(int j = i * i; j \u003c= N; j += i) { p[j] = 0; } } } for(int i = 2; i \u003c= N; i++) // 求欧拉函数 { if(p[i]) { for(int j = i; j \u003c= N; j += i) // 处理素因子p[i] { phi[j] = phi[j] / i * (i - 1); // 先除后乘，防止中间过程超出范围 } } } cout \u003c\u003c \"Primes: \" \u003c\u003c endl; for(int i = 1; i \u003c= N; i++) { if(p[i]) { cout \u003c\u003c i \u003c\u003c \" \"; } } cout \u003c\u003c endl; cout \u003c\u003c \"Euler Phi Function: \" \u003c\u003c endl; for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c phi[i] \u003c\u003c \" \"; } return 0; } 以上是关于欧拉函数的求法，对于它的应用，这里暂且介绍一个——求解原根的个数。 对于原根的定义，我们可以这样来叙述： 若存在一个实数 $ a $ ，使得 $ a^{i}\\mod{N},a\\in\\left \\{ 1,2,3,\\cdots ,N \\right \\} $ 的结果各不相同，我们就成实数 $ a $ 为 $ N $ 的一个原根。 原根的个数等于 $ \\varphi \\left ( \\varphi \\left ( N \\right ) \\right ) $ 。这样我们就可以很方便的求出原根的个数。 代码如下： #include \u003ciostream\u003e#include \u003cmath.h\u003e using namespace std; typedef unsigned long long ull; ull N; ull phi(ull x); int main() { cin \u003e\u003e N; cout \u003c\u003c phi(phi(N)) \u003c\u003c endl; return 0; } ull phi(ull x) { ull ans = x; ull m = (ull)sqrt(x); for(ull i = 2; i \u003c\u003c= m; i++) { if(x % i == 0) // 求素因子 { ans = ans / i * (i - 1); // 运用通项求解欧拉函数 while(x % i == 0) // 每个素因子只计算一次 { x /= i; } } } if(x \u003e 1) // 防质数 { ans = ans / x * (x - 1); } return ans; } 关于欧拉函数的知识就介绍这么多吧，应付NOIP应该足够了。 ","date":"2013-11-06","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/:0:0","tags":["欧拉函数"],"title":"算法专题：欧拉函数","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"categories":["码志"],"content":"求解线性方程组的有效方法是高斯消元。这个算法我看了半个下午才真正理解并且写了出来。 这个算法的核心思想就是将一个方程组的增广矩阵通过初等行变换转变成上三角矩阵，然后求解各个未知数的解。 我写的高斯消元是将所有系数看成一个矩阵来求解的。 下面来简要讲一下高斯消元的过程： 首先，我们根据方程组写出增广矩阵。每次都找 $ x_{i} $ 系数的绝对值最大的那个方程，将它移到上方，而将下面的方程组的 $ x_{i} $ 的系数全部化成 0。以此类推，到最后再逆序求解每个未知数的解。 我们来看一个例子，求解方程组 $ \\begin{cases}2x+y-z=8\\\\ -3x-y+2z=-11\\\\ -2x+y+2z=-3\\end{cases} $ 首先我们写出它的增广矩阵 $$ \\begin{bmatrix}\\left.\\begin{matrix}2 \u0026 1 \u0026 -1\\\\ -3 \u0026 -1 \u0026 2\\\\ -2 \u0026 1 \u0026 2\\end{matrix}\\right|\\begin{matrix}8\\\\ -11\\\\ -3\\end{matrix}\\end{bmatrix} $$ 接下来我们按照算法步骤来求解这个方程组 $$ \\begin{bmatrix} \\left.\\begin{matrix} 2 \u0026 1 \u0026 -1\\\\ -3 \u0026 -1 \u0026 2\\\\ -2 \u0026 1 \u0026 2 \\end{matrix}\\right| \\begin{matrix} 8\\\\ -11\\\\ -3 \\end{matrix} \\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026 -1 \u0026 2\\\\ 2 \u0026 1 \u0026 -1\\\\ -2 \u0026 1 \u0026 2 \\end{matrix}\\right| \\begin{matrix} -11\\\\ 8\\\\ -3 \\end{matrix}\\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026 -1 \u0026 2\\\\ 0 \u0026 \\frac{1}{3} \u0026 \\frac{1}{3}\\\\ 0 \u0026 \\frac{5}{3} \u0026 \\frac{2}{3} \\end{matrix}\\right| \\begin{matrix}-11\\\\ \\frac{2}{3}\\\\ \\frac{13}{3} \\end{matrix} \\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026 -1 \u0026 2\\\\ 0 \u0026 \\frac{1}{3} \u0026 \\frac{1}{3}\\\\ 0 \u0026 0 \u0026 -1 \\end{matrix}\\right| \\begin{matrix} -11\\\\ \\frac{2}{3}\\\\ 1 \\end{matrix} \\end{bmatrix}\\\\ \\Rightarrow z=-1,y=3\\times\\left ( \\frac{2}{3}-\\frac{1}{3}\\times\\left ( -1 \\right )\\right )=3,x=-\\frac{1}{3}\\times\\left ( -11+3-2*\\left ( -1 \\right ) \\right )=2 $$ 表达能力有限，我也只能解释成这样了。 当时我在网上找资料的时候还抱怨作者为什么不解释清楚点，现在发现，不是作者不愿意解释清楚，这个算法实在难以解释清楚。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 1024; int N; double f[MAX][MAX], ans[MAX]; // f[][]为系数（包括常数），ans[]为结果 double fabs(double x); // double的绝对值 void Gauss(); int main() { cin \u003e\u003e N; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N + 1; j++) // 读取所有系数（包括常数）方程已化为ax+by+…+c=0的形式 { cin \u003e\u003e f[i][j]; } } Gauss(); return 0; } void Gauss() { int nRow = 0; // 保存当前系数绝对值最大的行 double dMax = 0.0f; // 保存当前最大绝对值的系数 for(int i = 1; i \u003c= N; i++) // 对于每一列都处理 { dMax = f[i][i]; nRow = i; // 初始化 for(int j = i + 1; j \u003c= N; j++) // 比较下面所有行的第i列的系数 { if(fabs(f[j][i]) \u003e fabs(dMax)) // 取绝对值最大的系数 { dMax = f[j][i]; nRow = j; } } if(dMax != f[i][i]) // 如果不是当前行最大 { for(int j = i; j \u003c= N + 1; j++) { swap(f[nRow][j], f[i][j]); } // 交换这两个方程组的位置 } for(int j = i + 1; j \u003c= N; j++) // 对于下面的所有方程 { double dTmp = f[j][i] / f[i][i]; // 计算要将第i列的系数消去所需要的倍率 for(int k = i; k \u003c= N + 1; k++) // 对于第j行的方程的每一项的系数都要进行处理 { // 用第nRow行的方程乘以dTmp后去减第j行的方程，这样就可以把第j行的方程的第i列的系数消去 double dMinus = dTmp * f[i][k]; f[j][k] -= dMinus; } } } ans[N + 1] = 1.0f; // 预处理，为了下面的循环方便 for(int i = N; i \u003e= 1; i--) // 逆序求解 { for(int j = i; j \u003c= N + 1; j++) { ans[i] -= f[i][j] * ans[j]; // 减去已求解的未知数乘以其在当前求解的方程中的系数 } ans[i] /= f[i][i]; // 将该未知数的系数化为1，得到结果 } for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c ans[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } double fabs(double x) { if(x \u003c 0) { x = -x; } return x; } 关于高斯消元，这只是一个列主元的算法，还有全主元的，不过个人觉得列主元的就足够用了。 ","date":"2013-11-05","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/:0:0","tags":["线性方程组"],"title":"算法专题：求解线性方程组","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"},{"categories":["码志"],"content":"关于这个算法，主要是参考 NOIP2012 Day2 T1。即这里所讲的是求解这样一个线性模方程： $$ ax\\equiv 1\\mod{p} $$ 的最小正整数解。 去年我是暴搜做的，当时什么都不会。今天在这里介绍两种算法，一种是我国古代数学家秦九韶发明的「大衍求一术」，还一种是著名的「扩展欧几里德算法」。 首先来看一下大衍求一术。这里只介绍它的计算方法，至于证明可以参考扩展欧几里德算法。 例1：求解方程 $ 23x\\equiv 1\\mod{97} $ 。 解：我们只需要列出下面这张表就可以得到求解 $$ \\begin{matrix}23^{1} \u0026 23^{1} \u0026 3^{17} \u0026 3^{17} \u0026 1^{38}\\\\ 97^{0} \u0026 5^{4} \u0026 5^{4} \u0026 2^{21} \u0026 2^{21}\\end{matrix} $$ 结果就是 38。 接下来我们来理论化的表述一下这个算法的过程： 假设输入 $ a,b $ 满足 $ a\u003eb $ 。那么我们用 $ a_{n},A_{n} $ 分别表示第一行的底数和奇数， $ b_{n},B_{n} $ 分别表示第二行的底数和奇数，如果 $ a_{i}\u003eb_{i} $ ，那么 $ a_{i+1}=a_{i}\\mod{b_{i}},A_{i+1}=A_{i}+B_{i}\\cdot \\left [ \\frac{a_{i}}{b_{i}} \\right ],b_{i+1}=b_{i},B_{i+1}=B_{i} $ ；如果 $ a_{i}\u003cb_{i} $ 则上面的结论倒过来即可。 算法结束当且仅当 $ a_{i}=1 $ ，此时 $ A_{i} $ 即为所求的最小正整数解。 例2：求解方程 $ 97x\\equiv 1\\mod{23} $ 。 解：我们只需要列出下面这张表就可以得到求解 $$ \\begin{matrix}97^{1} \u0026 5^{1} \u0026 5^{1} \u0026 2^{5} \u0026 2^{5} \u0026 \\\\ 23^{0} \u0026 23^{0} \u0026 3^{4} \u0026 3^{4} \u0026 1^{9} \u0026 1^{14}\\end{matrix} $$ 结果就是 14。 对于这个结果，如果1最先出现在下面一行，则需要再计算一次，而且这次计算必须使得余数是1。 假设输入 $ a,b $ 满足 $ a\u003cb $ 。中间的步骤和之前一行，在计算过程中必然存在一个 $ i $ 使得 $ b_{i}=1 $ ，此时我们只需计算 $ B_{i+1} $ 即可得到结果。其中 $ B_{i+1}=A_{i}+B_{i}\\cdot \\left(a_{i} - 1\\right) $ 。 代码如下： #include \u003ciostream\u003e using namespace std; struct Num { int nBase, nIndex; // 分别表示底数和奇数 }; Num x, y; int main() { cin \u003e\u003e x.nBase \u003e\u003e y.nBase; x.nIndex = 1; y.nIndex = 0; // 初始化 if(x.nBase \u003c y.nBase) { while(1) { if(x.nBase == 1 || x.nBase == 0) // 循环出口 { cout \u003c\u003c x.nIndex \u003c\u003c endl; break; } if(x.nBase \u003c y.nBase) // 模拟计算过程 { int nDiv = y.nBase / x.nBase; if(y.nBase % x.nBase == 0) { nDiv--; } y.nBase %= x.nBase; y.nIndex += nDiv * x.nIndex; } else { int nDiv = x.nBase / y.nBase; if(x.nBase % y.nBase == 0) { nDiv--; } x.nBase %= y.nBase; x.nIndex += nDiv * y.nIndex; } } } else { while(1) { if(y.nBase == 1) // 出口 { int nDiv = x.nBase - 1; cout \u003c\u003c nDiv * y.nIndex + x.nIndex \u003c\u003c endl; // 求出结果 break; } if(x.nBase \u003c y.nBase) // 模拟计算过程 { int nDiv = y.nBase / x.nBase; if(y.nBase % x.nBase == 0) { nDiv--; } y.nBase %= x.nBase; y.nIndex += nDiv * x.nIndex; } else { int nDiv = x.nBase / y.nBase; if(x.nBase % y.nBase == 0) { nDiv--; } x.nBase %= y.nBase; x.nIndex += nDiv * y.nIndex; } } } return 0; } 可能上面的算法对于某些人来说比较晦涩，我们下面来介绍一下扩展欧几里德算法。首先介绍一个定理： 方程 $ ax+by=\\gcd\\left ( a,b \\right ) $ 一定有解。 这样我们的问题就可以转化为求方程 $ ax+b\\cdot \\left ( -y \\right )=1 $ ，在这里，我们先求出方程 $ ax+b\\cdot \\left ( -y \\right )=\\gcd\\left(a,b\\right) $ 的解，然后只要将结果除以 $ \\gcd\\left(a,b\\right) $ 就行了。 下面来推导一下扩展欧几里德算法。 我们已知 $$ ax+by=\\gcd\\left ( a,b \\right ) $$ 且 $$ \\gcd\\left ( a,b \\right )=\\gcd\\left(b,a\\mod b \\right ) $$ 不妨设 $$ bx{}'+\\left ( a\\mod b \\right )y{}'=\\gcd\\left ( b,a\\mod b \\right ) $$ 此时就有 $$ bx{}'+\\left ( a\\mod b \\right )y{}'=ax+by $$ 展开得到 $$ bx{}'+\\left ( a-\\left [ \\frac{a}{b} \\right ]\\cdot b \\right )y{}'=ax+by $$ 化简得 $$ ay{}'+b\\left (x{}'-\\left [ \\frac{a}{b} \\right ]\\cdot y{}' \\right )=ax+by $$ 因此可以得到 $$ x=y{}',y=x{}'-\\left [ \\frac{a}{b} \\right ]\\cdot y{}' $$ 这样我们就可以用递归来实现扩展欧几里德算法了。 代码如下： #include \u003ciostream\u003e using namespace std; typedef long long LL; LL A, B, C, X = 0, Y = 0; LL gcd(LL a, LL b); void exgcd(LL a, LL b, LL \u0026x, LL \u0026y); int main() { cin \u003e\u003e A \u003e\u003e B; C = gcd(A, B); exgcd(A, -B, X, Y); while(X \u003c 0) { X += B; } // 找最小正整数 cout \u003c\u003c X \u003c\u003c endl; return 0; } void exgcd(LL a, LL b, LL \u0026x, LL \u0026y) { if(a == 0) { x = 0; y = C / b; // 边界 } else { exgcd(b % a, a, x, y); y = x; // 递推公式 x = (C - b * y) / a; } } LL gcd(LL a, LL b) // 求解最大公倍数 { if(b == 0) { return a; } else { return gcd(b, a % b); } } 相比之下扩展欧几里德更容易理解一点，并且没有大衍求一术那么多特殊情况要处理，比较方便。 ","date":"2013-11-04","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/:0:0","tags":["不定方程"],"title":"算法专题：不定方程","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/"},{"categories":["码志"],"content":"强连通分量（Strongly Connected Components），简称 SCC。是指在给定的一张图 $ G=\\left(V,E\\right) $ 的一个子图 $ G{}'=\\left(V,E\\right) $ 这个子图满足对于其中的任意一对点 $ \\left \\langle V_{i},V_{j} \\right \\rangle $ 均存在这样两条路径 $ \\left \\langle V_{i},\\cdots,V_{j} \\right \\rangle,\\left \\langle V_{j},\\cdots,V_{i} \\right \\rangle $ 。 如果我们把强连通分量缩成一个点，这时候，原图 $ G $ 则会变成有向无环图。 图 $ G=\\left(V,E\\right) $ 是有向无环图当且仅当该图中没有点集合元素个数大于1的强连通分量。且任意一个强连通分量都至少包含一个有向环。下面我们通过一张图片来理解一下强连通分量以及缩点： 强连通分量\" 强连通分量 对于统计给定的图 $ G=\\left(V,E\\right) $ 中强连通分量的个数，我们可以应用并查集在 $ O\\left ( \\alpha \\left ( V \\right )\\cdot V \\right ) $ 时间内得到求解。 如果不仅需要统计强连通分量的个数，还要将强连通分量缩点，则需要用到今天介绍的Kosaraju Algorithm。它的具体步骤如下： 对原图 $ G $ 进行DFS并将出栈顺序进行逆序，得到的顺序就是拓扑序列。 将原图的每一条边反向，得到反图 $ G{}' $ 。 按照第一步生成的拓扑序列的顺序再对反图 $ G{}' $ 进行DFS染色，染成同色的就是一个强连通分量。 这个算法比较容易理解，也是最通用的算法。它主要是同时运用了原图 $ G $ 和反图 $ G{}' $ 。 该算法具有一个性质：如果我们把求出来的每个强连通分量缩成一个点，并且用求出每个强连通分量的顺序来标记收缩后的结点，那么这个顺序就是强连通分量缩点后所形成的有向无环图的拓扑序列。 代码如下： #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cstack\u003e using namespace std; const int MAX = 10240; int N, M, nCnt = 0; int pMap[MAX][MAX], pColor[MAX]; stack\u003cint\u003e S; // 储存拓扑序列 void dfs1(int x); // 原图DFS void dfs2(int x); // 反图DFS void Kosaraju(); int main() { cin \u003e\u003e N \u003e\u003e M; memset(pMap, 0, sizeof(pMap)); for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s][e] = 1; // 有向图 } Kosaraju(); return 0; } void Kosaraju() { memset(pColor, 0, sizeof(pColor)); for(int i = 1; i \u003c= N; i++) // DFS原图求出拓扑序列 { if(!pColor[i]) { dfs1(i); } } memset(pColor, 0, sizeof(pColor)); while(!S.empty()) // 按照拓扑序列DFS反图 { int x = S.top(); S.pop(); if(!pColor[x]) { nCnt++; // 找到一个强连通分量 dfs2(x); } } cout \u003c\u003c \"The number of SCC is \" \u003c\u003c nCnt \u003c\u003c endl; } void dfs1(int x) { pColor[x] = 1; // 染色 for(int i = 1; i \u003c= N; i++) { if(pMap[x][i] == 1 \u0026\u0026 !pColor[i]) { dfs1(i); } } S.push(x); // 加入拓扑序列 } void dfs2(int x) { pColor[x] = nCnt; // 属于第几个强连通分量 for(int i = 1; i \u003c= N; i++) { if(pMap[i][x] == 1 \u0026\u0026 !pColor[i]) // 原邻接矩阵的对称矩阵为反图 { dfs2(i); } } } ","date":"2013-11-04","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-kosaraju-algorithm/:0:0","tags":["强连通分量"],"title":"算法专题：强连通分量 - Kosaraju Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-kosaraju-algorithm/"},{"categories":["码志"],"content":"传递闭包（Transitive Closure）主要是研究图上两点之间的连通性。对于这个问题，我们只需要改进一下 Floyd-Warshall Algorithm 就可以很方便的求出它的解。 我们这里主要研究的是有向图的传递闭包问题。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 10240; const int INF = 65536; int N, M; bool f[MAX][MAX], pMap[MAX][MAX]; void Floyd(); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { pMap[i][j] = f[i][j] = (i == j) ? 1 : 0; // 初始化 } } for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s][e] = pMap[e][s] = true; // 无向图 f[s][e] = f[e][s] = true; } Floyd(); return 0; } void Floyd() { for(int k = 1; k \u003c= N; k++) // 最外层必须是k { for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { f[i][j] = f[i][j] || (f[i][k] \u0026\u0026 f[k][j]); // 判断连通性 } } } for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { cout \u003c\u003c f[i][j] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } 这个算法还是比较简单的，只要在 Floyd-Warshall Algorithm 的基础上修改一下就行了。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/:0:0","tags":["传递闭包"],"title":"算法专题：传递闭包","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/"},{"categories":["码志"],"content":"欧拉回路（Euler Circuit）是指：在一个无向图中，一条包含所有边，且其中每一条边只经过一次的路径。欧拉回路最常见的应用是一笔画。 下面介绍几个用于判断给定的图 $ G=\\left(V,E\\right) $ 中是否欧拉通路或欧拉回路： 一个图有欧拉回路当且仅当它是连通的且每个顶点都有偶数度。 一个图有欧拉通路当且经当它是连通的且除两个顶点外，其他顶点都有偶数度。 在第二个定理下，含奇数度的两个节点中，一个必为欧拉通路起点，另一个必为欧拉通路的终点。 这样，我们就可以很容易想出程序的思路： 计算各个顶点的度，如果存在 1 个奇数度，或者奇数度个数大于 2，则不存在欧拉回路。 选择奇数度的一个顶点作为欧拉回路的起点，如果不存在奇数度的顶点，则任意选取一个，在这里我们选取第一个顶点。 每次遍历与该点相连的边，删去该条边，则原图就转化成了一个更小的图，求它的欧拉通路，这样递归即可求解。 代码如下： #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int MAX = 10240; int N, M, pCnt[MAX]; int pMap[MAX][MAX]; vector\u003cint\u003e pVec; void Search(int x); void Euler_Circuit(); int main() { cin \u003e\u003e N \u003e\u003e M; memset(pMap, 0, sizeof(pMap)); for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s][e] = pMap[e][s] = 1; // 无向图 } Euler_Circuit(); return 0; } void Euler_Circuit() { int nStart = 1, nOddNum = 0; // nStart保存起点，nOddNum保存有几个顶点有奇数度 memset(pCnt, 0, sizeof(pCnt)); for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { pCnt[i] += pMap[i][j]; // 计算各个顶点的度 } } for(int i = 1; i \u003c= N; i++) // 统计奇数度顶点的个数 { if(pCnt[i] \u0026 1) { nStart = i; nOddNum++; } } if(nOddNum \u003e 2 || nOddNum == 1) // 不存在欧拉回路 { cout \u003c\u003c \"Not Exsit Euler Circuit\" \u003c\u003c endl; } else { Search(nStart); for(int i = 0; i \u003c pVec.size(); i++) { cout \u003c\u003c pVec[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } void Search(int x) { for(int i = 1; i \u003c= N; i++) { if(pMap[x][i] == 1) { pMap[x][i] = pMap[i][x] = 0; // 删边 Search(i); } } pVec.push_back(x); } 欧拉回路我至今也没有在做题目的时候用到过，不知道是不是这类题目比较少见。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/:0:0","tags":["欧拉回路"],"title":"算法专题：欧拉回路","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"categories":["码志"],"content":"拓扑排序（Topological Sorting）是图论中一个比较重要的概念。它主要用来解决下面这类问题： 给定一个 AOV 网（Activity On Vertex Network）， $ A\\rightarrow B $ 表示活动 $ A $ 必须在活动 $ B $ 之前完成。请给出一个合理的活动顺序。 当然，AOV 网中不可能出现环，因为出现了环就无法拓扑排序。因此可以用拓扑排序来判断图中是否存在环。 关于拓扑排序，我们来看一下下面这张图片： Toplogical Sorting\" Toplogical Sorting 我们可以用队列来实现这个算法，具体改进的过程如下： 记录每个点的入度； 将入度为 0 的顶点加入队列； 依次对入度为 0 的点进行删边操作，同时将新得到的入度为零的点加入队列； 重复上述操作，直至队列为空。 代码如下： #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; int N, M, pDegree[MAX]; queue\u003cint\u003e Q; vector\u003cint\u003e pMap[MAX], pVec; void TopSort(); int main() { cin \u003e\u003e N \u003e\u003e M; memset(pDegree, 0, sizeof(pDegree)); for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s].push_back(e); // 有向图 pDegree[e]++; // 计算入度 } TopSort(); return 0; } void TopSort() { for(int i = 1; i \u003c= N; i++) { if(pDegree[i] == 0) // 入度为0的点入队 { Q.push(i); } } while(!Q.empty()) { int x = Q.front(); Q.pop(); pVec.push_back(x); // 出队顺序即为拓扑序列 for(int i = 0; i \u003c pMap[x].size(); i++) { pDegree[pMap[x][i]]--; // 删边 if(pDegree[pMap[x][i]] == 0) // 新的入度为0的点 { Q.push(pMap[x][i]); } } } for(int i = 1; i \u003c= N; i++) { if(pDegree[i] != 0) // 若存在入度不为0的点，则存在环 { cout \u003c\u003c \"Exsit Loop\" \u003c\u003c endl; return; } } for(int i = 0; i \u003c pVec.size(); i++) // 顺序输出即为拓扑序列 { cout \u003c\u003c pVec[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } {% endhighlight %} 对于这一问题，我们也可以用DFS来解决它，代码如下： {% highlight cpp linenos %} #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int MAX = 10240; int N, M, pVisited[MAX]; // 0-未访问 1-正在访问 2-已访问 vector\u003cint\u003e pMap[MAX], pVec; void TopSort(); bool DFS(int v); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s].push_back(e); // 有向图 } TopSort(); return 0; } void TopSort() { memset(pVisited, 0, sizeof(pVisited)); for(int i = 1; i \u003c= N; i++) // 所有顶点都访问一遍 { if(!pVisited[i]) { if(!DFS(i)) { cout \u003c\u003c \"Exsit Loop\" \u003c\u003c endl; } } } for(int i = pVec.size() - 1; i \u003e= 0; i--) // 倒序输出拓扑序列 { cout \u003c\u003c pVec[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } bool DFS(int v) // false-有环 true-无环 { pVisited[v] = 1; // 正在访问 for(int i = 0; i \u003c pMap[v].size(); i++) // 搜索它的前驱 { if(pVisited[pMap[v][i]] == 1) { return false; } // 该点进入两次则有环 else if(pVisited[pMap[v][i]] == 0) { if(!DFS(pMap[v][i])) { return false; } } } pVisited[v] = 2; // 访问完毕 pVec.push_back(v); // 加入拓扑序列 return true; } 相较这两种算法，我更倾向于用队列来实现，毕竟这种方法符合求解拓扑排序的一般思路。至于这两种算法的复杂度，在这里就不再分析了。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:0:0","tags":["拓扑排序"],"title":"算法专题：拓扑排序","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["码志"],"content":"这次我们来讨论一下关于多源最短路径 APSP（All-Pairs Shortest Paths）。即求出给定的图 $ G=\\left ( V,E \\right ) $ 中任意两对顶点 $ V_{i},V_{j} $ 之间的最短路径。我们根据下面这幅图来理解一下这个概念： 多源最短路径\" 多源最短路径 对于这一问题，比较有效的算法是 Floyd-Warshall Algorithm，简称 Floyd。它是基于动态规划的一种最短路径的算法。 我们用 $ f^{k}\\left ( i,j \\right ) $ 来表示从顶点 $ i $ 到顶点 $ j $ 不经过索引比 $ k $ 大的点的最短路径。这样一来，我们就可以根据 $ f^{k-1}\\left ( i,j \\right ) $ 推出 $ f^{k}\\left ( i,j \\right ) $ 。 假设我们目前已知 $ f^{k-1}\\left ( i,j \\right ) $ ，要推出 $ f^{k}\\left ( i,j \\right ) $ ，无外乎两种情况： 经过顶点 $ k $ ； 不经过顶点 $ k $ 。 对于第一种情况，显然有 $ f^{k}\\left ( i,j \\right )=f^{k-1}\\left ( i,k \\right )+f^{k-1}\\left ( k,j \\right ) $ 。对于第二种情况，我们也很容易得到 $ f^{k}\\left ( i,j \\right )=f^{k-1}\\left ( i,j \\right ) $ 。这样一来，状态转移方程也就确定了： $$ f^{k}\\left ( i,j \\right )=\\min{\\left \\{ f^{k-1}\\left ( i,k \\right )+f^{k-1}\\left ( k,j \\right ),f^{k-1}\\left ( i,j \\right ) \\right \\}} $$ 这样一来，也就解决了为什么 Floyd-Warshall Algorithm 的最外层循环必须是 $ k $ 这一问题。很显然，Floyd-Warshall Algorithm 的时间复杂度为 $ O\\left(V^{3}\\right) $ 。 当然，这个算法还可以用来求最小环，具体求法请参考代码，应该能看懂，就不再多说。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 10240; const int INF = 65536; int N, M; int f[MAX][MAX], pMap[MAX][MAX]; void Floyd(); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { pMap[i][j] = f[i][j] = (i == j) ? 0 : INF; // 初始化 } } for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; pMap[s][e] = v; pMap[e][s] = v; // 无向图 f[s][e] = v; f[e][s] = v; } Floyd(); return 0; } void Floyd() { int nLen = 65536; for(int k = 1; k \u003c= N; k++) // 最外层必须是k { for(int i = 1; i \u003c= k; i++) // 求解最小环 { for(int j = 1; j \u003c= k; j++) { nLen = min(nLen, pMap[i][j] + f[i][k] + f[k][j]); } } for(int i = 1; i \u003c= N; i++) // 求解APSP { for(int j = 1; j \u003c= N; j++) { if(f[i][k] + f[k][j] \u003c f[i][j]) // 是否需要松弛 { f[i][j] = f[i][k] + f[k][j]; } } } } cout \u003c\u003c \"Shortest Loop is \" \u003c\u003c nLen \u003c\u003c endl; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { if(f[i][j] == INF) { cout \u003c\u003c \"-1 \"; } else { cout \u003c\u003c f[i][j] \u003c\u003c \" \"; } } cout \u003c\u003c endl; } } ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-floyd-warshall-algorithm/:0:0","tags":["多源最短路径"],"title":"算法专题：多源最短路径 - Floyd-Warshall Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-floyd-warshall-algorithm/"},{"categories":["码志"],"content":"SPFA 是 Shortest Path Fast Algorithm 的缩写，它是之前介绍的 Bellman-Ford Algorithm 的一种队列实现，减少了不必要的冗余计算。 算法的基本步骤如下： 初始化队列和标记数组，将源点入队。 每次取队首元素，对其发出的所有边进行松弛。并将松弛过的且不在队列中的顶点加入到队列中。 重复第二步直至队列为空。 若要判断负环，则当某个顶点松弛超过V次，即存在负环。 对于SPFA还是比较容易理解的，它的复杂度为 $O\\left(kE\\right)$。 代码如下： #include \u003ciostream\u003e#include \u003cmemory.h\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; bool pQueue[MAX]; int N, M, pDist[MAX], pCnt[MAX]; // pCnt[]记录顶点i松弛的次数 vector\u003cpair\u003cint, int\u003e \u003e pMap[MAX]; queue\u003cint\u003e Q; void SPFA(int s); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; pMap[s].push_back(make_pair(e, v)); // 无向图 pMap[e].push_back(make_pair(s, v)); } SPFA(1); return 0; } void SPFA(int s) { bool bNativeLoop = false; // 判断负环的变量 for(int i = 1; i \u003c= N; i++) // 初始化 { pDist[i] = 2147483647; } memset(pQueue, false, sizeof(pQueue)); pDist[s] = 0; Q.push(s); // 源点入队 pQueue[s] = true; while(!Q.empty()) { int x = Q.front(); Q.pop(); // 取出队首元素 pQueue[x] = false; // 出队 for(int i = 0; i \u003c pMap[x].size(); i++) { if(pDist[pMap[x][i].first] \u003e pDist[x] + pMap[x][i].second) // 松弛 { pDist[pMap[x][i].first] = pDist[x] + pMap[x][i].second; if(!pQueue[pMap[x][i].first]) // 如果未入队 { Q.push(pMap[x][i].first); pQueue[pMap[x][i].first] = true; // 入队 if(++pCnt[pMap[x][i].first] \u003e N) { bNativeLoop = true; // 存在负环 while(!Q.empty()) { Q.pop(); } // 立即退出循环 } } } } } if(bNativeLoop) { cout \u003c\u003c \"Exist Negative Loop\" \u003c\u003c endl; } else { for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c pDist[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } 至此，单源最短路的算法基本复习结束。细究这三种算法，个人觉得 SPFA 的编程复杂度较低。而 Dijkstra Algorithm 也挺实用的。不过在一般情况下我比较倾向于 SPFA。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-spfa/:0:0","tags":["单源最短路径"],"title":"算法专题：单源最短路径 - SPFA","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-spfa/"},{"categories":["码志"],"content":"上一篇文章介绍了一下 Dijkstra Algorithm，但是它仅局限于处理非负权值的图。若图中出现负边，Dijkstra Algorithm 就会出现错误。这时候就需要使用其他的算法来求解单源最短路径。 Ballman-Ford 是一个非常实用的算法，它是由美国数学家 Richard Ballman 和 Lester Ford 发明的。Ballman-Ford 算法的基本流程如下： 初始化 $ pDist\\left [ \\right ] $ 数组。 检查每一条边，如果源点到该条边的起点有通路，则更新原点到该条边的终点的最短路径。循环 $ V $ 次即可得到结果。 如若要检测是否存在负环，则再检查每一条边，若可以松弛，则有负环。 我们来看一张图片具体体会一下 Bellman-Ford Algorithm： Bellman-Ford 算法\" Bellman-Ford 算法 这个算法相对而言比较容易实现，复杂度为 $ O\\left ( VE \\right ) $ 。 代码如下： #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; const int INF = 2147483647; struct Edge { Edge(int _s, int _e, int _v) { s = _s; e = _e; v = _v; } int s, e, v; }; int N, M; int pDist[MAX]; vector\u003cEdge\u003e pEdge; // 边集数组 void Ford(int s); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; pEdge.push_back(Edge(s, e, v)); // 无向图 pEdge.push_back(Edge(e, s, v)); } Ford(1); return 0; } void Ford(int s) { bool bNativeLoop = false; // 记录是否存在负环 for(int i = 1; i \u003c= N; i++) // 初始化 { pDist[i] = INF; } pDist[s] = 0; for(int i = 1; i \u003c= N; i++) // 循环N次 { for(int j = 0; j \u003c pEdge.size(); j++) // 每次检查每一条边 { int s = pEdge[j].s, e = pEdge[j].e, v = pEdge[j].v; if(pDist[s] != INF) // 如果源点可以到达顶点s则进行松弛 { pDist[e] = min(pDist[e], pDist[s] + v); } } } for(int i = 0; i \u003c pEdge.size(); i++) // 检查负环 { int s = pEdge[i].s, e = pEdge[i].e, v = pEdge[i].v; if(pDist[e] \u003e pDist[s] + v) // 若松弛完毕后还能松弛，则存在负环 { bNativeLoop = true; break; } } if(bNativeLoop == true) { cout \u003c\u003c \"Exist Native Loop\" \u003c\u003c endl; } else { for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c pDist[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-bellman-ford-algorithm/:0:0","tags":["单源最短路径"],"title":"算法专题：单源最短路径 – Bellman-Ford Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-bellman-ford-algorithm/"},{"categories":["码志"],"content":"这个星期开始复习最短路的一些算法。 单源最短路径（Single Source Shortest Paths），简称 SSSP。这是图论中非常重要的一类算法。解决这一问题有多种算法，今天先来介绍一下 Dijkstra Algorithm。 首先介绍一下单源最短路径的概念，通俗的讲，就是给定一个源点 $ s $ （即起点），求这个源点到其他各个顶点的最短路径。最短路径，通俗的来讲，我们称使得顶点 $ V_{i} $ 到顶点 $ V_{j} $ 所经过的路径的权值之和最小的一条路径，称为从顶点 $ V_{i} $ 到顶点 $ V_{j} $ 的最短路径。 单源最短路径\" 单源最短路径 上面这幅图标出了从源点 $ s $ 到各个顶点的最短路径，大家可以根据图片自己体会一下最短路径的含义。其中 $ -\\infty $ 表示到该点的最短路径是负无穷，因为我们发现存在负环，所以我们利用负环，使得最短路径达到负无穷，但是这个一般不在我们一般的算法的讨论范围内。 下面来介绍一下 Dijkstra Algorithm。 首先将所有的顶点分成两个集合 $ A $ 、 $ B $ ，其中集合 $ A $ 表示已经求得最短路径的顶点集合，集合 $ B $ 为待求解的顶点集合。初始时有 $ A=\\left { V_{0} \\right } $ 。 将集合 $ A $ 与集合 $ B $ 相连的边按照递增次序排序，取最短的边，将该条边在集合 $ B $ 中所对应的顶点加入到集合 $ A $ 中。 重复第二步，直至集合 $ B $ 为空集。 我们通过下面一幅图来理解一下 Dijkstra Algorithm： Dijkstra 算法\" Dijkstra 算法 下面我们来考虑算法的实现方式，显然，我们需要每次在集合 $ A $ 中发出的所有边中找到最小的一条边，而每次这样找的话，复杂度很高，我们可以考虑用优先队列来优化这个步骤。这样的话复杂度就下降到了 $ O\\left ( \\left ( V+E \\right )\\cdot \\log{E} \\right ) $ 。 代码如下： #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; typedef pair\u003cint,int\u003e pii; int N, M; int pDist[MAX]; vector\u003cpair\u003cint, int\u003e \u003e pMap[MAX]; priority_queue\u003cpii, vector\u003cpii\u003e, greater\u003cpii\u003e \u003e Q; // 优先队列 void Dijkstra(int s); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; // 无向图 pMap[s].push_back(make_pair(e, v)); pMap[e].push_back(make_pair(s, v)); } Dijkstra(1); return 0; } void Dijkstra(int s) { for(int i = 1; i \u003c= N; i++) // 初始化 { pDist[i] = 2147483647; } pDist[s] = 0； Q.push(make_pair(pDist[s], s)); // 将源点加入队列 while(!Q.empty()) { pii x = Q.top(); Q.pop(); // 取最短的边 if(x.first != pDist[x.second]) { continue; } // 防止重复计算 for(int i = 0; i \u003c pMap[x.second].size(); i++) { int v = pMap[x.second][i].first; // 待松弛的顶点 int w = pMap[x.second][i].second; // 从顶点x.second到顶点i的距离 if(pDist[v] \u003e pDist[x.second] + w) { pDist[v] = pDist[x.second] + w; // 松弛 Q.push(make_pair(pDist[v], v)); } } } for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c pDist[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra-algorithm/:0:0","tags":["单源最短路径"],"title":"算法专题：单源最短路径 – Dijkstra Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra-algorithm/"},{"categories":["码志"],"content":"今天来介绍一下最小生成树的另外一种算法：Kruskal Algorithm。这个算法是基于贪心实现的，算法的大体过程如下： 取权值最小的边，如果加入这条边以后，不会出现环，那么就加入这条边。 重复上述操作，直至加入了 $ N-1 $ 条边。 我们还是先来看一张图片来理解一下这个算法： Kruskal 算法\" Kruskal 算法 下面我们来考虑这个算法，最棘手的问题是判断是否构成环，这里我们采用并查集来处理这个问题，它的复杂度是 $ O\\left(V*\\alpha\\left(V\\right)\\right) $ 。对于每次寻找权值最小的边，复杂度是 $ O\\left(E\\right) $ 。这样一来，复杂度将高达 $ O\\left(V*\\alpha\\left(V\\right)+VE\\right) $ ，即 $ O\\left(VE\\right) $ 。 我们考虑优化，每次寻找权值最小的边，可以考虑先将权值从小到大排序。这样复杂度就下降到 $ O\\left(V*\\alpha\\left(V\\right)+E\\log{E}\\right) $ ，即 $ O\\left(E\\log{E}\\right) $ 。 代码如下： #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; const int MAX = 1024; struct Edge { Edge(int _u, int _v, int _w) { u = _u; v = _v; w = _w; } int u, v, w; }; struct Set { int nParent, nCount; }; int cmp(Edge x, Edge y) { return x.w \u003c y.w; } int N, M; vector\u003cEdge\u003e pEdge; Set pSet[MAX]; void Kruskal(); void Init(); int Find(int x); void Union(int x, int y); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int u, v, w; cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; pEdge.push_back(Edge(u, v, w)); } Kruskal(); return 0; } void Kruskal() { int nCost = 0, nPos = 0; vector\u003cEdge\u003e pMST; sort(pEdge.begin(), pEdge.end(), cmp); Init(); while(pMST.size() != N - 1) // 直到MST中有N-1条边 { Edge minEdge = pEdge[nPos++]; if(Find(minEdge.u) != Find(minEdge.v)) // 如果加入后不构成环 { nCost += minEdge.w; pMST.push_back(minEdge); Union(minEdge.u, minEdge.v); } } cout \u003c\u003c \"The MST Cost is \" \u003c\u003c nCost \u003c\u003c endl; } void Init() { for(int i = 1; i \u003c= N; i++) { pSet[i].nParent = i; pSet[i].nCount = 1; } } int Find(int x) { if(pSet[x].nParent != x) { return pSet[x].nParent = Find(pSet[x].nParent); // 路径压缩 } else { return x; } } void Union(int x, int y) { int fx = Find(pSet[x].nParent); int fy = Find(pSet[y].nParent); if(fx != fy) // 启发式合并，减小树的高度 { if(pSet[fx].nCount \u003e pSet[fy].nCount) { pSet[fy].nParent = fx; pSet[fx].nCount += pSet[y].nCount; } else { pSet[fx].nParent = fy; pSet[fy].nCount += pSet[x].nCount; } } } 至此，最小生成树的算法基本复习完毕。 分析两种算法，Prim Algorithm的复杂度是 $ O\\left(V^{2}\\right) $ ，适用于稠密图；而Kruskal Algorithm的复杂度是 $ O\\left(E\\log{E}\\right) $ ，适用于疏密图。各有所长，需要根据不同的情况选择不同的算法。 ","date":"2013-10-20","objectID":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-kruskal-algoritm/:0:0","tags":["最小生成树"],"title":"算法专题：最小生成树 – Kruskal Algoritm","uri":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-kruskal-algoritm/"},{"categories":["码志"],"content":"最近开始准备 NOIP 复赛，发现很多算法已经不会了。只能一个个的捡起来，慢慢复习，顺便做点笔记。 最小生成树（Minimum Spanning Trees），简称 MST。是图论中一个非常重要的概念。解决这个问题有两种算法，今天暂且先来讨论一下 Prim Algorithm。不做特别说明，讨论的都是无向图。 首先介绍一下最小生成树的概念，我们知道，图可以这样定义 $ G=\\left(V,E\\right) $ ，其中 $ G $ 表示图， $ V $ 表示顶点集合， $ E $ 表示边集合。最小生成树是这样一棵树，它满足 $$ w\\left ( T \\right )=\\min {\\left \\{ \\sum_{\\left ( u,v \\right )\\in T}w\\left ( u,v \\right ) \\right \\}} $$ 通俗地讲，就是使得图 $ G $ 连通时，所选取的边的长度的和最小。 最小生成树\" 最小生成树 如上图，加粗的路径就是在最小生成树上的路径。 现在，我们开始讨论Prim Algorithm。这个算法可以分为下面几个步骤： 将顶点集 $ V $ 分成两个集合 $ A $ 和 $ B $ ，其中集合 $ A $ 表示目前已经在MST中的顶点，而集合 $ B $ 则表示目前不在 MST 中的顶点。 寻找与集合 $ A $ 连通的最短的边 $ \\left(u,v\\right) $ ，将这条边加入最小生成树中。（此时，与 $ \\left(u,v\\right) $ 相连的顶点，不妨设为 $ B_{i} $ ，也应加入集合 $ A $ 中） 重复第二步，直至集合 $ B $ 为空集。 算法的大体思想就是这样了。为了方便理解，我们先来看一下下面一张图片： Prim 算法\" Prim 算法 对照上面的图片，想必对于 Prim Algorithm 也有了一定的理解。 下面我们来设计算法，显然，我们需要遍历集合 $ A $ 中所有顶点及与之相连的边，取连接到集合 $ B $ 的权值最小的边，加入最小生成树。这样一来，复杂度将达到 $ O\\left(n^{3}\\right) $ 。 我们可以对这个想法进行优化。我们维护一个 $ pCost\\left [ i \\right ] $ 数组，用来表示从集合 $ A $ 到与之相邻的节点的最小费用。这样，我们只要每次取这个数组中的最小值，把它在集合 $ B $ 中所对应的结点 $ V_{i} $ 加入到集合 $ A $ 中。每次加入结束以后，都要更新 $ pCost\\left [ i \\right ] $ 数组。即枚举所有与结点 $ V_{i} $ 相连的边，判断是否比 $ pCost\\left [ i \\right ] $ 数组中的最小费用小，如果比它小，则更新。这样可以将算法优化到 $ O\\left(n^{2}\\right) $ 。 代码如下： #include \u003ciostream\u003e#include \u003cmemory.h\u003e #include \u003cvector\u003e using namespace std; const int MAX = 1024; const int INF = 2147483647; // 设置最大权值 int N, M; vector\u003cpair\u003cint, int\u003e \u003e pMap[MAX]; // 邻接表 void Prim(); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int u, v, w; cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; pMap[u].push_back(make_pair(v, w)); pMap[v].push_back(make_pair(u, w)); } Prim(); return 0; } void Prim() { int nCost = 0; vector\u003cint\u003e pMST; // 储存MST的结点 int pCost[MAX]; // 储存与集合A相邻的顶点的最小权值，0表示该结点已经在MST中 pMST.push_back(1); // 将结点1加入MST pCost[1] = 0; for(int i = 2; i \u003c= N; i++) // 初始化，切记要将除1以外的都置为INF { pCost[i] = INF; } for(int i = 0; i \u003c pMap[1].size(); i++) // 处理与结点1相连的顶点 { pCost[pMap[1][i].first] = pMap[1][i].second; } for(int i = 1; i \u003c= N - 1; i++) // 剩余N-1个顶点，循环N-1次 { int nVertex = 0, nWeight = INF; // 用于寻找最短的边 for(int j = 1; j \u003c= N; j++) { if(nWeight \u003e pCost[j] \u0026\u0026 pCost[j] != 0) { nVertex = j; nWeight = pCost[j]; } } pCost[nVertex] = 0; pMST.push_back(nVertex); // 将节点nVertex加入MST nCost += nWeight; // 计算MST的费用 for(int j = 0; j \u003c pMap[nVertex].size(); j++) // 更新pCost数组 { if(pCost[pMap[nVertex][j].first] != 0 \u0026\u0026 pCost[pMap[nVertex][j].first] \u003e pMap[nVertex][j].second) { pCost[pMap[nVertex][j].first] = pMap[nVertex][j].second; } } } cout \u003c\u003c \"MST Cost is \" \u003c\u003c nCost \u003c\u003c endl; cout \u003c\u003c \"The vertexs in MST are \"; for(int i = 0; i \u003c pMST.size(); i++) { cout \u003c\u003c pMST[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } ","date":"2013-10-19","objectID":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim-algoritm/:0:0","tags":["最小生成树"],"title":"算法专题：最小生成树 – Prim Algoritm","uri":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim-algoritm/"},{"categories":["浮生杂记"],"content":"随便写写，记录一下最近发生的事情。 高中最后一次运动会居然是在停课中度过的。不过比起化学组去省选的那些人还算幸运的，至少也参与了一点，虽然成绩只有一个引体向上。 29号晚自习，我在机房给高二的上课，讲解初赛的选择题。真正感觉到了「后生可畏」的感觉。本来想冲个省队的，但是我们的国赛在明年7月份，那时候我们已经毕业了，所以不能代表江苏省参赛。信息学竞赛就这点不好，各门竞赛大多高三才到炉火纯青的地步，却不给省队资格。虽然我们全国各地的高三选手联名向CCF抗议，但还是无疾而终。挺可惜的，但至少可以拿个省一回来，给竞赛画上圆满的句号。 我们开发团队的一个初三的学生，把我之前的一篇日志《中秋望月感怀》当做语文作业的作文交了上去，受宠若惊。 前几天和上一届高三的物理竞赛保送大神杨文杰聊了一会儿。咨询了一下高考，自招，交大的相关事宜。总结下来一句话： 踏踏实实做学问。 关于这方面，张兴也给我讲过他静心治学的经历。 今天下午，黄旸洋给我打了个电话，聊了一下他的近况，各种感慨涌上心头。我也不知道该怎么平心静气的把它们记录下来，暂且按下不表。 高考要开始报名了。我也不知道最后会是什么结果，但是我清楚我想要的是什么结果。 我还记得，暑假在数学组的时候，袁秦盟经常喜欢说一句话 是的，我可以的！ 是的，我可以的！ ","date":"2013-09-30","objectID":"/2013/09/%E6%9D%82%E8%AE%B020130930/:0:0","tags":["高中生活"],"title":"杂记（20130930）","uri":"/2013/09/%E6%9D%82%E8%AE%B020130930/"},{"categories":["浮生杂记"],"content":"在我的印象中，从来没有过真正意义上的赏月。小时候虽然每年都会如约赏月，但那时候年纪尚小，即使望月，也不会有什么特别的感触。 自从高二受了周红娟老师的耳濡目染，再者，加上《唐诗之旅》的熏陶，开始对明月产生了一种别样的情怀。自此以后，每当看到明月，想到的不再时冷冰冰的月球，而是嫦娥玉兔，吴刚伐树。有时候甚至会像李白一样「举杯邀明月，对影成三人」。 前几天住宿的时候，便已经感到了中秋的到来。熄灯后，一束月光打在床上，真如太白所记「床前明月光，疑是地上霜」。 今天晚上看新闻，提到瘦西湖是最佳赏月之地，不禁想起徐凝的一句诗「天下三分明月夜，二分无赖是扬州」。好在身处农乡，不像城市中有高大的建筑物遮挡视线，也不用担心刺眼的霓虹灯会干扰赏月的心情。四下只有明亮的月光，别有一番意境。望着皎洁的月亮，一时思绪纷飞。 窗外响起了爆竹声，大家都对一年一度的中秋佳节抱有极大的好感。这么多年没有观赏月色，突然在中秋佳节赏月，心中有种说不出的感觉。为大自然的美妙所折服，人类终究还是渺小的。真希望可以和苏子一样「挟飞仙以遨游，抱明月而长终」。但到最后还是意识到「知不可乎骤得，托遗响于悲风」。 如此一来，不禁想到人事变迁。最先进入脑海的，是周红娟老师，说实话，跟她学到了很多东西。尤其是一种热爱生活、积极生活的态度。或许作为电教员跟她接触的机会多一点吧，感觉周红娟还是挺不错的一个老师，虽然有时候方式方法不太得当，但至少初衷还是好的。或许语文所要教会我们的，便是如何去生活，而不是如何去得分。就像高冰峰老师，一大把年纪了，还如此文艺，不得不说这是一种乐观积极的生活态度。对于周红娟老师的离开，早在她告诉我们她高三只能带一个班的时候，便已料到。后来在暑假里遇到她，得到了确定的消息，当时的确有些不舍，但有些事情总是不可避免的。不过还得谢谢她在大夏天来给我们送清凉。 明月自古便非常的忙碌，我也极少的去麻烦它。至多只是让它捎个信，带个问候罢了。我想今天的月亮一定会非常乐意的将我的思念传递给我的小伙伴们吧。古人是极富浪漫主义色彩的，只要双方都望着明月，明月就会帮他们传递心绪。这远比现代的即时通讯工具高级，靠的是人与自然的融合与共生。相较而言，我更喜欢后者。 高考是个不可避免的话题。虽然已经填完了大学的目标，但现在与之差距着实太大。在高一的时候，我曾幻想着可以拿到计算机一等，然后保送。这个五彩的肥皂泡最终随着竞赛保送制度的取消而破灭。接着，便想着自主招生，这是一条非常好的路径，考的还好可以本一即录，相当于报送。 但是，目睹了几位过来人的事迹，也对它产生了怀疑。就拿去年2013届高三（15）班的胡宇涛来说吧。他和我一起搞竞赛的。去年我们一起去南航参加复赛，第一天下午，2012届高三（15）班的缪晓伟（也是信息组的）带领我们参观南大（仙林校区），当时胡宇涛就表明了要进南大的意愿，他也是这样做的。平时模拟考390左右，有时候还上过400。后来参加了南大自主招生，考的时候差几分面试，只加了10分。到最后，高考却挂了。加来的10分就也形同虚设了。 有一首打油诗，感觉讲的非常在理： 自招毁一生，竞赛穷三代。要考好大学，还得语数外。 当然了，也不是让大家消极的对待自主招生，但是不要花太多精力，这种东西如同竞赛，全靠运气。时也，命也。当然，要考非常好的大学，还是需要自招降降门槛的。所以，这样说来，还是老老实实搞语数外来的实在。 细察为什么大家如此热衷保送，自招，无非就是「逃避」。逃避高考，保送是最好的道路；既然保送取消了，那只好拿自招来当垫背。细想来，这些又是何必呢，高考，终究还是要降临在我们的头上，也会给予我们相对客观公正的评价。 最后一句话，与大家共勉： 说出来被嘲笑的梦想，才有去实现的必要。 月色，还是那样的澄澈明净…… ","date":"2013-09-19","objectID":"/2013/09/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%802013/:0:0","tags":["高中生活"],"title":"中秋望月感怀（2013）","uri":"/2013/09/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%802013/"},{"categories":["数学之美"],"content":"新版高中教材对复数内容进行了极大的删减，使得我们对于复数的认知还停留在最原始的阶段。殊不知，复数的应用非常广泛。现参考《高中数学·甲种本》以及搜集的一些资料，包括做过的例题，整理一下关于复数的内容。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:0:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"一、复数的概念 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"1.1 数的概念的发展 数的概念是从实践中产生和发展起来的。早在原始社会末期，由于记数的需要，人们就建立起自然熟的概念。自然数的全体构成自然数集 $ \\mathbf{N} $ 。 随着生产和科学的发展，熟的概念也得到了发展。 为了表示各种具有相反意义的量以及满足记数法的要求，人们引进了零和负数，把自然数看作正整数，把正整数、零、负整数合并在一起，构成整数集 $ \\mathbf{Z} $ 。 为了解决测量、分配中遇到的将某些量进行等分的问题，人们又引进了有理数，规定他们就是一切形如 $ \\frac{m}{n} $ 的数，其中 $ m\\in \\mathbf{Z},n\\in \\mathbf{N} $ 。这样，就把整数集 $ \\mathbf{Z} $ 扩大为有理数集 $ \\mathbf{Q} $ 。显然， $ \\mathbf{Z}\\subset \\mathbf{Q} $ 。如果把整数看作分母为 $ 1 $ 的分数，那么有理数实际上就是分数集。 每一个有理数都可以表示成整数、有限小数或循环节不为 $ 0 $ 的循环小数；反过来，整数、有限小数或循环节不为 $ 0 $ 的循环小数也都是有理数。如果把整数、有限小数都看作循环节为 $ 0 $ 的循环小数，那么有理数集实际上就是循环小数的集合。 为了解决有些量与量之间的比值（例如用正方形的边长去度量它的对角线所得结果）不能用有理数表示的矛盾，人们又引入了无理数。所谓无理数，就是无限不循环小数。有理数集与无理数集合并在一起，构成实数集 $ \\mathbf{R} $ 。因为有理数都可以看作循环小数（包括整数、有限小数），无理数都是无限不循环小数，所以实数集就是小数集。 从解方程来看，方程 $ x+5=3 $ 在自然数集 $ \\mathbf{N} $ 中无解，在整数集 $ \\mathbf{Z} $ 中就有一个解 $ x=-2 $ ；方程 $ 3x=5 $ 字整数集 $ \\mathbf{Z} $ 中无解，在有理数集 $ \\mathbf{Q} $ 中就有一个解 $ x=\\frac{5}{3} $ ；方程 $ x^{2}=2 $ 在有理数集 $ \\mathbf{Q} $ 中无解，在实数集 $ \\mathbf{R} $ 中就有两个解 $ x=\\pm \\sqrt{2} $ 。但是，熟的范围扩充到实数集 $ \\mathbf{R} $ 以后，象 $ x^{2}=-1 $ 这样的方程还是无解，因为没有一个实数的平方等于 $ -1 $ 。在十六世纪，由于解方程的需要，人们开始引进一个新数 $ i $ ，叫做虚数单位，并规定： 它的平方等于 $ -1 $ ，即 $$ i^{2}=-1 $$ 实数与它进行四则运算时，所有的加、乘运算律仍然成立。 在这种规定下， $ i $ 可以与实数 $ b $ 相乘，再同实数 $ a $ 相加，由于满足乘法交换律及加法交换律，从而可以把结果写成 $ a+bi $ 。人们把它们叫做复数。全体复数所成的集合，一般用字母 $ \\mathbf{C} $ 来表示。1 在这种规定下， $ i $ 就是 $ -1 $ 的一个平方根。因此，方程 $ x^{2}=-1 $ 在复数集 $ \\mathbf{C} $ 中就至少有一个解 $ x=i $ 。 十八世纪以后，复数在数学、力学和电学中得到了应用。从此对它的研究日益展开。现在复数已成为科学技术中普遍使用的一种数学工具。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:1","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"1.2 复数的有关概念 复数 $ a+bi $ （ $ a,b\\in\\mathbf{R} $ 。以后说复数 $ a+bi $ 时，都有 $ a,b\\in\\mathbf{R} $ ），当 $ b=0 $ 时，就是实数；当 $ b\\neq 0 $ 时，叫做虚数，当 $ a=0,b\\neq 0 $ 时，叫做纯虚数； $ a $ 与 $ b $ 分别叫做复数 $ a+bi $ 的实部与虚部。例如， $ 3+4i,-\\frac{1}{2}-\\sqrt{2}i,-0.5i $ 都是虚数，它们的实部分别是 $ 3,-\\frac{1}{2},0 $ ，虚部分别是 $ 4,-\\sqrt{2},-0.5 $ 。 显然，实数集 $ \\mathbf{R} $ 是复数集 $ \\mathbf{C} $ 的真子集，即 $ \\mathbf{R}\\subset \\mathbf{C} $ 。 如果两个复数 $ a+bi $ 与 $ c+di $ 的实部与虚部分别相等，我们就说这两个复数相等，记作 $ a+bi=c+di $ ，这就是说，如果 $ a,b,c,d\\in\\mathbf{R} $ ，那么 $$ a+bi=c+di \\Leftrightarrow a=c,b=d $$ $$ a+bi=0\\Leftrightarrow a=b=0 $$ 例：已知 $ \\left ( 2x-1 \\right )+i=y-\\left ( 3-y \\right )i $ ，其中 $ x,y\\in\\mathbf{R} $ 。求 $ x $ 与 $ y $ 。 解：根据复数相等的定义，得方程组 $ \\begin{cases} 2x-1=y,\\\\ 1=-\\left ( 3-y \\right ) \\end{cases} $ 解得 $ x=\\frac{5}{2},y=4 $ 。 从复数相等的定义，我们知道，任何一个复数 $ z=a+bi $ ，都可以由一个有顺序的实数对 $ \\left ( a,b \\right ) $ 唯一确定。这就使我们能借用平面直角坐标系来表示复数 $ z=a+bi $ 。如图1，点 $ Z $ 的横坐标是 $ a $ ，纵坐标是 $ b $ ，复数 $ z=a+bi $ 可用点 $ Z\\left ( a,b \\right ) $ 来表示。这个建立了直角坐标系表示复数的平面叫做复平面， $ x $ 轴叫做实轴， $ y $ 轴除去原点的部分叫做虚轴（因为原点表示实数 $ 0 $ ，原点不在虚轴上）。表示实数的点都在实轴上，表示纯虚数的点都在轴上。 复数的复平面表示法\" 复数的复平面表示法 很明显，按照这种表示方法，每一个复数，有复平面内唯一的一个点和它对应；反过来，复平面内的每一个点，有唯一的一个复数和它对应。由此可知，复数集 $ \\mathbf{C} $ 和复平面内所有的点所成的集合是一一对应的。这是复数的一个几何意义。 当两个复数实部相等，虚部互为相反数时，这两个复数叫做互为共轭复数（当虚部不等于 $ 0 $ 时也叫做互为共轭虚数）。复数 $ z $ 的共轭复数可以用 $ \\overline{z} $ 来表示，也就是说，复数 $ z=a+bi $ 的共轭复数是 $ \\overline{z}=a-bi $ 。显然，复平面内表示两个互为共轭复数的点 $ Z $ 与 $ \\overline{Z} $ 关于实轴对称（图2），而实数 $ a $ （即虚部为 $ 0 $ 的复数）的共轭复数仍是 $ a $ 本身。 两个实数可以比较大小。但是两个复数，如果不全是实数，就不能比较它们的大小。对于这个命题的证明，将稍后给出。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:2","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"1.3 复数的向量表示 在物理学中，我们经常遇到力、速度、加速度、电场强度等，这些量，除了要考虑它们的绝对值大小以外，还要考虑它们的方向。我们把这种既有绝对值大小又有方向的量叫做向量。向量可以用有向线段来表示，线段的长度就是这个向量的绝对值（叫做这个向量的模），线段的方向（用箭头表示）就是这个向量的方向。模相等且方向相同的向量，不管它们的起点在哪里，都认为是相等的向量。在这一规定下，向量可以根据需要进行平移。模为零的向量（它的方向是任意的）叫做零向量。规定所有零向量相等。 复数的向量表示法\" 复数的向量表示法 复数可以用向量来表示。如图 3，设复平面内的点 $ Z $ 表示复数 $ z=a+bi $ ，连结 $ OZ $ ，如果我们把有向线段 $ OZ $ （方向是从点 $ O $ 指向点 $ Z $ ）看成向量，记作 $ \\overrightarrow{OZ} $ ，就把复数同向量联系起来了。很明显，向量 $ \\overrightarrow{OZ} $ 是由点 $ Z $ 唯一确定的；反过来，点 $ Z $ 也可由向量 $ \\overrightarrow{OZ} $ 唯一确定。因此，复数集 $ C $ 与复平面内所有以原点 $ O $ 为起点的向量所成的集合也是一一对应的。为方便起见，我们常把复数 $ z=a+bi $ 说成点 $ Z $ 或者说成向量 $ \\overrightarrow{OZ} $ 。此外，我们还规定，相等的向量表示同一个复数。 图3中的向量 $ \\overrightarrow{OZ} $ 的模（即有向线段 $ OZ $ 的长度） $ r $ 叫做复数 $ z=a+bi $ 的模（或绝对值）记作 $ \\left | z \\right | $ 或 $ \\left | a+bi \\right | $ 。如果 $ b=0 $ ，那么 $ z=a+bi $ 是一个实数 $ a $ 它的模就等于 $ \\left | a \\right | $ （即 $ a $ 在实数意义上的绝对值）。容易看出， $ \\left | z \\right |=\\left | a+bi \\right |=r=\\sqrt{a^{2}+b^{2}}. $ 例1：求复数 $ z_{1}=3+4i $ 及 $ z_{2}=-\\frac{1}{2}-\\sqrt{2}i $ 的模，并且比较它们的模的大小。 解： $ \\left| z_{1} \\right|=\\sqrt{3^{2}+4^{2}}=5,\\left | z_{2} \\right |=\\sqrt{\\left ( -\\frac{1}{2} \\right )^{2}+\\left ( \\sqrt{2} \\right )^{2}}=\\frac{3}{2}. $ 又 $ 5 \u003e \\frac{3}{2} $ ，故 $ \\left | z_{1} \\right | \u003e \\left | z_{2} \\right | $ 。 例2：设 $ z\\in\\mathbf{C} $ ，满足下列条件的点 $ Z $ 的集合是什么图形？ （1） $ \\left | z \\right |=4 $ ；（2） $ 2 \u003c \\left | z \\right | \u003c 4 $ 。 解： （1）复数 $ z $ 的模等于 $ 4 $ ，就是说，向量 $ \\rightarrow{OZ} $ 的模（即点 $ Z $ 与原点 $ O $ 的距离）等于 $ 4 $ ，所以满足条件 $ \\left | z \\right |=4 $ 的点 $ Z $ 的集合是以原点 $ O $ 为圆心，以 $ 4 $ 为半径的圆。 （2）不等式 $ 2 \u003c \\left | z \\right | \u003c 4 $ 可化为不等式组 $ \\begin{cases}\\left | z \\right | \u003c 4\\\\ \\left | z \\right | \u003e 2\\end{cases} $ 。不等式 $ \\left | z \\right | \u003c 4 $ 的解集是圆 $ \\left | z \\right | = 4 $ 内部所有的点组成的集合，不等式 $ \\left | z \\right | \u003e 2 $ 的解集是圆 $ \\left | z \\right | = 2 $ 外部所有的点组成的集合，这两个集合的交集，就是上述不等式组的解集，也就是满足条件 $ 2 \u003c \\left | z \\right | \u003c 4 $ 的点 $ Z $ 的集合。容易看出，所求的集合是以原点 $ O $ 为圆心，以 $ 2 $ 及 $ 4 $ 为半径的圆所夹的圆环，但不包括圆环的边界（图 4）。 圆\" 圆 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:3","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"二、复数的运算 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:2:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"2.1 复数的加法与减法 复数的加法规定按照以下的法则进行：设 $ z_{1}=a+bi,z_{2}=c+di $ 是任意两个复数，那么它们的和：$$ \\left ( a+bi \\right )+\\left ( c+di \\right )=\\left ( a+c \\right )+\\left ( b+d \\right )i $$ 很明显，两个复数的和仍然是一个复数。 容易验证，复数的加法满足交换律、结合律，即对任意 $ z_{1},z_{2},z_{3}\\in\\mathbf{R} $ ，有 $$ z_{1}+z_{2}=z_{2}+z_{1} $$ $$ \\left ( z_{1}+z_{2} \\right )+z_{3}=z_{1}+\\left ( z_{2}+z_{3} \\right ) $$ 现在我们来看复数加法的几何意义。 从物理学知道，要求出作用于同一点 $ O $ 、但不在同一直线上的两个力 $ \\overrightarrow{F_{1}} $ 与 $ \\overrightarrow{F_{2}} $ 的合力，只要用表示 $ \\overrightarrow{F_{1}} $ 与 $ \\overrightarrow{F_{2}} $ 的向量为相邻的两边画一个平行四边形，那么，平行四边形中，以力的作用点 $ O $ 为起点的那条对角线所表示的向量就是合力 $ \\overrightarrow{F} $ （图5-1）。这个法则通常叫做向量加法的平行四边形法则。 复数加法的几何意义\" 复数加法的几何意义 复数用向量来表示，如果与这些复数对应的向量不在同一直线上，那么这些复数的加法就可以按照向量加法的平行四边形法则来进行。下面我们来证明这一事实。 设 $ \\overrightarrow{OZ_{1}} $ 及 $ \\overrightarrow{OZ_{2}} $ 分别与复数 $ a+bi $ 及 $ c+di $ 对应，且 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 不在同一直线上（图5-2）。以 $ \\overrightarrow{OZ_{1}} $ 及 $ \\overrightarrow{OZ_{2}} $ 为两条邻边画平行四边形 $ OZ_{1}ZZ_{2} $ ，画 $ x $ 轴的垂线 $ PZ_{1},QZ_{2} $ 及 $ RZ $ ，并且画 $ Z_{1}S\\perp RZ $ ，容易证明 $ \\triangle ZZ_{1}S\\cong \\triangle Z_{2}OQ, $ 并且四边形 $ Z_{1}PRS $ 是矩形，因此 $ OR=OP+PR=OP+Z_{1}S=OP+OQ=a+c $ $ RZ=RS+SZ=PZ_{1}+QZ_{2}=b+d. $ 于是点 $ Z $ 的坐标是 $ \\left ( a+c,b+d \\right ) $ ，这说明设 $ \\overrightarrow{OZ} $ 就是于复数 $ \\left ( a+c \\right )+\\left ( b+d \\right )i $ 对应的向量。 由此可知，求两个复数的和，可以先画出这两个复数对应的向量 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ ，如果 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 不在同一直线上，再以这两个向量为两条邻边画平行四边形，那么与这个平行四边的对角线 $ OZ $ 所表示的向量 $ \\overrightarrow{OZ} $ 对应的复数，就是所求两个复数的和。 如果 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 在同一直线上，我们可以画出一个“压扁”了的平行四边形，并据此画出它的对角线来表示 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 的和。 总之，复数的加法可以按照向量的加法法则来进行，这是复数加法的几何意义。 下面再来看复数的减法。 复数的减法规定是加法的逆运算，即把满足 $$ \\left ( c+di \\right )+\\left ( x+yi \\right )=a+bi $$ 的复数 $ x+yi $ ，叫做复数 $ a+bi $ 减去复数 $ c+di $ 的差。记作 $ \\left ( a+bi \\right )-\\left ( c+di \\right ) $ ，根据复数相等的定义，有 $$ c+x=a,d+y=b $$ 由此 $$ x=a-c,y=b-d, $$ 所以 $$ x+yi=\\left ( a-c \\right )+\\left ( b-d \\right )i, $$ 即 $$ \\left ( a+bi \\right )-\\left ( c+di \\right )=\\left ( a-c \\right )+\\left ( b-d \\right )i $$ 这就是复数的减法法则。由此可见，两个复数的差是一个唯一确定的复数。 现设 $ \\overrightarrow{OZ} $ 与复数 $ a+bi $ 对应， $ \\overrightarrow{OZ_{1}} $ 与复数 $ c+di $ 对应（图6）。以 $ \\overrightarrow{OZ} $ 为一条对角线， $ \\overrightarrow{OZ_{1}} $ 为一条边画平行四边形，那么这个平行四边形的另一边， $ \\overrightarrow{OZ_{2}} $ 所表示的向量， $ \\overrightarrow{OZ_{2}} $ 就与复数 $ \\left ( a-c \\right )+\\left ( b-d \\right )i $ 对应。因为 $ Z_{1}Z\\stackrel{;//;}{=}OZ_{2} $ ，所以向量 $ \\overrightarrow{Z_{1}Z} $ 也与这个差对应。 复数减法的几何意义\" 复数减法的几何意义 这就是说，两个复数的差 $ z-z_{1} $ （即 $ \\overrightarrow{OZ}-\\overrightarrow{OZ_{1}} $ ）与连结两个向量终点并指向被减数的向量对应。这就是复数减法的几何意义。 由上所述，我们可以看出，复数的加（减）法与多项式的加（减）法是类似的，就是把复数的实部与实部、虚部与虚部分别相加（减），即 $$ \\left ( a+bi \\right )\\pm \\left ( c+di \\right )=\\left ( a\\pm c \\right )+\\left ( b\\pm d \\right ) $$ 例1：计算 $ \\left ( 5-6i \\right )+\\left ( -2-i \\right )-\\left ( 3+4i \\right ) $ 。 解： $ \\left ( 5-6i \\right )+\\left ( -2-i \\right )-\\left ( 3+4i \\right )=\\left ( 5-2-3 \\right )+\\left ( -6-1-4 \\right )i=-11i $ 。 例2：根据复数的几何意义及向量表示，求复平面内两点间的距离公式。 复平面两点距离\" 复平面两点距离 解：如图 7，设复平面内的任意两点 $ Z_{1},Z_{2} $ 分别表示复数 $ z_{1}=x_{1}+y_{1}i,z_{2}=x_{2}+y_{2}i $ ，那么 $ \\overrightarrow{Z_{1}Z_{1}} $ 就是与复数 $ z_{2}-z_{1} $ 对应的向量。如果用 $ d $ 表示点 $ Z_{1},Z_{1} $ 之间的距离，那么 $ d $ 就是向量 $ \\overrightarrow{Z_{1}Z_{2}} $ 的模，即复数 $ z_{2}-z_{1} $ 的模，所以 $$ d=\\left | z_{2}-z_{1} \\right |=\\left | \\left ( x_{2}+y_{2}i \\right )-\\left ( x_{1}+y_{1}i \\right ) \\right |=\\left | \\left ( x_{2}-x_{1} \\right )+\\left ( y_{2}-y_{1} \\right )i \\right |=\\sqrt{\\left ( x_{2}-x_{1} \\right )^2+\\left ( y_{2}-y_{1} \\right )^2} $$ 这与我们之前导出的两点间的距离公式一致。 例3：根据复数的几何意义及向量表示，求复平面内的圆的方程。 复平面圆\" 复平面圆 解：如图8，设圆心为 $ P $ ，点 $ P $ 与复数 $ p=a+bi $ 对应，圆的半径为 $ r $ ，圆上任意一点 $ Z $ 与复数 $ z=a+bi $ 对应，那么 $$ \\left | z-p \\right |=r $$ 这就是复平面内的圆的方程。特别地，当点 $ P $ 在原点时，圆的方程就成了 $$ \\left | z \\right |=r $$ 请读者利用复数的减法法则，把圆的方程 $$ \\left | z-p \\right |=r $$ 化成用实数表示的一般形式 $$ \\left ( x-a \\right )^{2}+\\left ( y-b \\right )^{2}=r^{2} $$ ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:2:1","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"2.2 复数的乘法与除法 复数的乘法规定按照以下的法则进行：设 $ z_{1}=a+bi,z_{2}=c+di $ 是任意两个复数，那么它们的积 $$ \\left ( a+bi \\right )\\left ( c+di \\right )=ac+bci+cdi+bdi^{2}=\\left ( ac-bd \\right )+\\left ( bc+ad \\right )i $$ 也就是说，复数的乘法与多项式的乘法是类似的，但必须在所得的结果中把 $ i^{2} $ 换成 $ -1 $ ，并且把实部和虚部分别合并。 很显然，两个复数的积仍然是一个复数。 容易验证，复数的乘法满足交换律、结合律以及乘法对加法的分配律，即对任何 $ z_{1},z_{2},z_{3}\\in\\mathbf{C} $ ，有 $$ z_{1}\\cdot z_{2}=z_{2}\\cdot z_{1} $$ $$ \\left ( z_{1}\\cdot z_{2} \\right )\\cdot z_{3}=z_{1}\\cdot\\left ( z_{2}\\cdot z_{3} \\right ) $$ $$ z_{1}\\cdot \\left ( z_{2}+z_{3} \\right )=z_{1}\\cdot z_{2}+z_{1}\\cdot z_{3} $$ 根据复数的乘法法则，对于任何复数 $ z=a+bi $ ，有 $$ \\left ( a+bi \\right )\\left ( a-bi \\right )=a^{2}+b^{2}+\\left ( ab-ab \\right )i=a^{2}+b^{2} $$ 因此，两个共轭复数 $ z,\\overline{z} $ 的积是一个实数，这个实数等于每一个复数的模的平方，即 $$ z\\cdot \\overline{z}=\\left | z \\right |^{2}=\\left | \\overline{z} \\right |^{2} $$ 例1：计算 $ \\left ( 1-2i \\right )\\left ( 3+4i \\right )\\left ( -2+i \\right ) $ 。 解： $ \\left ( 1-2i \\right )\\left ( 3+4i \\right )\\left ( -2+i \\right )=\\left ( 11-2i \\right )\\left ( -2+i \\right )=-20+15i $ 。 计算复数的乘方，要用到虚数单位 $ i $ 的乘方。因为复数的长发满足交换律与结合律，所以实数集 $ \\mathbf{R} $ 中正整数指数幂的运算律，在复数集 $ \\mathbf{C} $ 中仍然成立，即对任何 $ z,z_{1},z_{2}\\in\\mathbf{C} $ 及 $ m,n\\in\\mathbf{N} $ ，有 $$ z^{m}\\cdot z^{n}=z^{m+n} $$ $$ \\left ( z^{m} \\right )^{n}=z^{mn} $$ $$ \\left ( z_{1}\\cdot z_{2} \\right )^{n}=z_{1}^{n}\\cdot z_{1}^{n} $$ 另一方面，我们有 $$ i^{1}=i $$ $$ i^{2}=-1 $$ $$ i^{3}=i^{2}\\cdot i=-i $$ $$ i^{4}=i^{3}\\cdot i=-i\\cdot i=-i^{2}=1 $$ 从而，对于任何 $ n\\in\\mathbf{N} $ ，我们都有 $$ i^{4n+1}=i^{4n}\\cdot i=\\left ( i^4 \\right )^{n}\\cdot i=1^{n}\\cdot i=i $$ 同理可证 $$ i^{4n+2}=-1 $$ $$ i^{4n+3}=-i $$ $$ i^{4n}=1 $$ 这就是说，如果 $ n\\in\\mathbf{N} $ ，那么 $$ i^{4n+1}=i,i^{4n+2}=-1,i^{4n+3}=-i,i^{4n}=1 $$ 例2：计算 $ \\left ( \\frac{1}{2}-\\frac{\\sqrt{3}}{2}i \\right )^{3} $ 。 解： $$ \\begin{align*} \\left ( \\frac{1}{2}-\\frac{\\sqrt{3}}{2}i \\right )^{3}\u0026=\\left ( \\frac{1}{2} \\right )^3-3\\left ( \\frac{1}{2} \\right )^{2}\\left ( \\frac{\\sqrt{3}}{2}i \\right )+3\\left ( \\frac{1}{2} \\right )\\left ( \\frac{\\sqrt{3}}{2}i \\right )^{2}-\\left ( \\frac{\\sqrt{3}}{2} \\right )^{3}\\\\ \u0026=\\frac{1}{8}-\\frac{3\\sqrt{3}}{8}i-\\frac{9}{8}+\\frac{3\\sqrt{3}}{8}i\\\\ \u0026=-1\\end{align*} $$ 复数的除法规定是乘法的逆运算，即把满足 $$ \\left ( c+di \\right )\\left ( x+yi \\right )=a+bi\\left ( c+di\\neq 0 \\right ) $$ 的复数 $ x+yi $ ，叫做复数 $ a+bi $ 除以复数 $ c+di $ 的商，记作 $$ \\left ( a+bi \\right )\\div \\left ( c+di \\right ) $$ 或 $$ \\frac{a+bi}{c+di} $$ 我们知道，两个共轭复数的积是一个实数，因此，两个复数相除，可以先把它们的商写成分式的形式，然后把分子与分母都乘以分母的共轭复数，并且把结果化简，即 $$ \\frac{a+bi}{c+di}=\\frac{\\left ( a+bi \\right )\\left ( c-di \\right )}{\\left ( c+di \\right )\\left ( c-di \\right )}=\\frac{\\left ( ac+bd \\right )+\\left ( bc-ad \\right )i}{c^{2}+d^{2}}=\\frac{ac+bd}{c^{2}+d^{2}}+\\frac{bc-ad}{c^{2}+d^{2}}i\\left ( c+di\\neq 0 \\right ) $$ 因为 $ c+di\\neq 0 $ ，所以 $ c^{2}+d^{2}\\neq 0 $ 。由此可见，商 $ \\frac{a+bi}{c+di} $ 是一个唯一确定的复数。 例3：计算 $ \\left ( 1+2i \\right )\\div \\left ( 3-4i \\right ) $ 。 解： $ \\left ( 1+2i \\right )\\div \\left ( 3-4i \\right )=\\frac{1+2i}{3-4i}=\\frac{\\left ( 1+2i \\right )\\left ( 3+4i \\right )}{\\left ( 3-4i \\right )\\left ( 3+4i \\right )}=\\frac{-5+10i}{25}=-\\frac{1}{5}+\\frac{1}{2}i $ 。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:2:2","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"三、复数的三角形式 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:3:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"3.1 复数的三角形式 我们知道，与复数 $ z=a+bi $ 对应的向量 $ \\overrightarrow{OZ} $ （图9）的模 $ r $ 叫做这个复数的模，并且 $$ r=\\sqrt{a^{2}+b^{2}} $$ 复数的模\" 复数的模 以 $ x $ 轴的正半轴为始边、向量 $ \\overrightarrow{OZ} $ 所在的射线（起点是 $ O $ ）为终边的角 $ \\theta $ ，叫做复数 $ z=a+bi $ 的辐角。 不等于零的复数 $ z=a+bi $ 的辐角有无限多个值，这些值相差 $ 2\\pi $ 的整数倍。例如，复数 $ i $ 的辐角是 $ \\frac{\\pi}{2}+2k\\pi $ ，其中 $ k $ 可以取任何整数。 适合于 $ 0\\leq \\theta \u003c 2\\pi $ 的辐角 $ \\theta $ 的值，叫做辐角的主值。记作 $ \\textrm{arg} z $ ，即 $ 0\\leq \\textrm{arg} z \u003c 2\\pi $ 。 每一个不等于零的复数有唯一的模与辐角的主值，并且可由它的模与辐角的主值唯一确定。因此，两个非零复数相等当且仅当它们的模与辐角的主值分别相等。 很明显，当 $ a\\in\\mathbf{R^{+}} $ 时，$$ \\textrm{arg}\\alpha=0 $$ $$ \\textrm{arg}\\left ( -\\alpha \\right )=\\pi $$ $$ \\textrm{arg}\\left ( ai \\right )=\\frac{\\pi}{2} $$ $$ \\textrm{arg}\\left ( -ai \\right )=\\frac{3\\pi}{2} $$ 如果 $ z=0 $ ，那么与它对应的向量 $ \\overrightarrow{OZ} $ 缩成一个点（零向量），这样的向量的方向是任意的，所以复数 $ 0 $ 的辐角也是任意的。 从图 9 可以看出： $$ \\begin{cases} a=r\\cos{\\theta}\\\\ b=r\\sin{\\theta} \\end{cases} $$ 因此 $$ a+bi=r\\cos{\\theta}+ir\\sin{\\theta}=r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $$ 其中 $$ r=\\sqrt{a^{2}+b^{2}},\\cos{\\theta}=\\frac{a}{r},\\sin{\\theta}=\\frac{b}{r} $$ 当与 $ z $ 对应的点 $ Z $ 不在实轴或虚轴上时， $ z $ 的辐角 $ \\theta $ 的终边所在的象限就是点 $ Z $ 所在的象限；当点 $ Z $ 在实轴或虚轴上时，辐角 $ \\theta $ 的终边就是从原点 $ O $ 出发、经过点 $ Z $ 的板条坐标轴。 因此我们可以说，任何一个复数 $ z=a+bi $ 都可以表示成 $ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $ 的形式。 $$ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $$ 叫做复数 $ a+bi $ 的三角形式。为了同三角形式区别开来， $ a+bi $ 叫做复数的代数形式。 例1：把复数 $ \\sqrt{3}+i $ 表示成三角形式。 解： $ r=\\sqrt{3+1}=2,\\cos{\\theta}=\\frac{\\sqrt{3}}{2}. $ 因为与 $ \\sqrt{3}+i $ 对应的点在第一象限，所以 $ \\textrm{arg}\\left ( \\sqrt{3}+i \\right )=\\frac{\\pi}{6} $ ，于是 $ \\sqrt{3}+i=2\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right ). $ 例2：把复数 $ 1-i $ 表示成三角形式。 解： $ r=\\sqrt{1+1}=\\sqrt{2},\\cos{\\theta}=\\frac{1}{\\sqrt{2}}=\\frac{\\sqrt{2}}{2}. $ 因为与 $ 1-i $ 对应的点在第四象限，所以 $ \\textrm{arg}\\left ( 1-i \\right )=\\frac{7\\pi}{4} $ ，于是 $ 1-i=\\sqrt{2}\\left ( \\cos{\\frac{7\\pi}{4}}+i\\sin{\\frac{7\\pi}{4}} \\right ). $ 例3：把复数 $ -1 $ 表示成三角形式。 解： $ r=\\sqrt{1+0}=1. $ 因为与 $ -1 $ 对应的点在 $ x $ 轴的负半轴上，所以 $ \\textrm{arg}\\left ( -1 \\right )=\\pi $ ，于是 $ -1=\\cos{\\pi}+i\\sin{\\pi}. $ 当然，把一个复数表示成三角形式时，辐角 $ \\theta $ 不一定要取主值。例如， $ \\sqrt{2}\\left [ \\cos{\\left ( -\\frac{\\pi}{4} \\right )}+i\\sin{\\left ( -\\frac{\\pi}{4} \\right )} \\right ] $ 也是复数 $ 1-i $ 的三角形式。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:3:1","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"3.2 复数的三角形式的运算 3.2.1 乘法与乘方 如果把复数 $ z_{1},z_{2} $ 分别写成三角形式 $$ z_{1}=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right ) $$ $$ z_{2}=r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right ) $$ 故有 $$ \\begin{align*} z_{1}\\cdot z_{2} \u0026=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\\\ \u0026=r_{1}r_{2}\\left [ \\left (\\cos{\\theta_{1}}\\cos{\\theta_{2}}-\\sin{\\theta_1}\\sin{\\theta_{2}} \\right ) + i\\left ( \\sin{\\theta_{1}}\\cos{\\theta_{2}}+\\cos{\\theta_{1}}\\sin{\\theta_{2}} \\right ) \\right ]\\\\ \u0026=r_{1}r_{2}\\left [ \\cos{\\left (\\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}+\\theta_{2} \\right )} \\right ] \\end{align*} $$ 即 $$ r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )=r_{1}r_{2}\\left [ \\cos{\\left (\\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}+\\theta_{2} \\right )} \\right ] $$ 这就是说，两个复数相乘，积的模等于各复数的模的积，积的辐角等于各复数的辐角之和。 据此，两个复数 $ z_{1},z_{2} $ 相乘时，可以先画出分别与 $ z_{1},z_{2} $ 对应的向量 $ \\overrightarrow{OP_{1}},\\overrightarrow{OP_{2}} $ ，然后把向量 $ \\overrightarrow{OP_{1}} $ 按逆时针方向旋转一个角度 $ \\theta_{2} $ （如果 $ \\theta \u003c 0 $ ，就要把 $ \\overrightarrow{OP_{1}} $ 按顺时针方向旋转一个角度 $ \\left | \\theta_{2} \\right | $ ），在把它的模变为原来的 $ r_{2} $ 倍，所得的向量 $ \\overrightarrow{OP} $ ，就表示积 $ z_{1}\\cdot z_{2} $ （图 10）。这就是复数乘法的几何意义。 复数乘法的几何意义\" 复数乘法的几何意义 用数学归纳法容易证明（读者自己证明），上面的结论可以推广到 $ n $ 个复数相乘的情况，就是： $$ \\begin{align*} z_{1}\\cdot z_{2}\\cdot\\cdots\\cdot z_{n} \u0026=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\cdot\\cdots\\cdot r_{n}\\left ( \\cos{\\theta_{n}}+i\\sin{\\theta_{n}} \\right )\\\\ \u0026=r_{1}r_{2}\\cdots r_{n}\\left [ \\cos{\\left ( \\theta_{1}+\\theta_{2}+\\cdots +\\theta_{n} \\right )} + i\\sin{\\left ( \\theta_{1}+\\theta_{2}+\\cdots +\\theta_{n} \\right )}\\right ] \\end{align*} $$ 因此，如果 $$ r_{1}=r_{2}=\\cdots=r_{n}=r,\\theta_{1}=\\theta_{2}=\\cdots=\\theta_{n}=\\theta $$ 时，就有 $$ \\left [ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )^n \\right ]=r^{n}\\left ( \\cos{n\\theta}+i\\sin{n\\theta} \\right )\\left ( n\\in\\mathbf{N} \\right ) $$ 这就是说，复数的 $ n\\left(n\\in\\mathbf{N}\\right) $ 次幂的模等于这个复数的模的 $ n $ 次幂，它的辐角等于这个复数的辐角的 $ n $ 倍。这个定理叫做棣莫佛2定理。 例1：计算 $ \\sqrt{2}\\left ( \\cos{\\frac{\\pi}{12}}+i\\sin{\\frac{\\pi}{12}} \\right )\\cdot\\sqrt{3}\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right ) $ 。 解： $ \\sqrt{2}\\left ( \\cos{\\frac{\\pi}{12}}+i\\sin{\\frac{\\pi}{12}} \\right )\\cdot\\sqrt{3}\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right )\\ =\\sqrt{6}\\left [ \\cos\\left ( \\frac{\\pi}{12}+\\frac{\\pi}{6} \\right )+i\\sin\\left ( \\frac{\\pi}{12}+\\frac{\\pi}{6} \\right ) \\right ]\\ =\\sqrt{6}\\left ( \\cos{\\frac{\\pi}{4}}+i\\sin{\\frac{\\pi}{4}} \\right )\\ =\\sqrt{6}\\left ( \\frac{\\sqrt{2}}{2}+\\frac{\\sqrt{2}}{2}i \\right )\\ =\\sqrt{3}+\\sqrt{3}i $ 。 例2：计算 $ \\left ( \\sqrt{3}-i \\right )^{6} $ 。 解：因为 $ \\sqrt{3}-i=2\\left ( \\cos{\\frac{11\\pi}{6}}+i\\sin{\\frac{11\\pi}{6}} \\right ) $ ，所以 $ \\left (\\sqrt{3}-i \\right )^{6}\\ =\\left [2\\left ( \\cos{\\frac{11\\pi}{6}}+i\\sin{\\frac{11\\pi}{6}} \\right ) \\right ]^{6}\\ =2^{6}\\left ( \\cos{11\\pi}+i\\sin{11\\pi} \\right )\\ =64\\left ( \\cos{\\pi}+i\\sin{\\pi} \\right )\\ =64\\cdot\\left ( -1 \\right )=-64 $ 。 例3：如图11，向量 $ \\overrightarrow{OZ} $ 与复数 $ -1+i $ 对应，把 $ \\overrightarrow{OZ} $ 按逆时针方向旋转 $ 120^\\circ $ ，得到 $ \\overrightarrow{OZ‘} $ 。求与向量 $ \\overrightarrow{OZ'} $ 对应的复数（用代数形式表示）。 复数的旋转\" 复数的旋转 解：所求的复数就是 $ -1+i $ 乘以一个复数 $ z_{0} $ 的积，这个复数 $ z_{0} $ 的模是 $ 1 $ ，辐角的主值是 $ 120^\\circ $ 。 所以所求的复数是 $ (-1+i)\\cdot 1\\left ( \\cos{120^\\circ}+i\\sin{120^\\circ} \\right )\\ =(-1+i)\\left ( -\\frac{1}{2}+\\frac{\\sqrt{3}}{2}i \\right )\\ =\\frac{1-\\sqrt{3}}{2}-\\frac{1+\\sqrt{3}}{2}i $ 例4：如图 12，已知平面内并列的三个相等的正方形，利用复数证明 $ \\angle 1+\\angle 2+\\angle 3=\\frac{\\pi}{2}. $ 例 4 图例\" 例 4 图例 证明：如图建立坐标系（确定复平面），由于平行线的内错角相等， $ \\angle 1,\\angle 2,\\angle 3 $ 分别等于复数 $ 1+i,2+i,3+i $ 的辐角的主值，这样 $ \\angle 1+\\angle 2+\\angle 3 $ 就是积 $ \\left ( 1+i \\right )\\left ( 2+i \\right )\\left ( 3+i \\right ) $ 的辐角，而 $$ \\left ( 1+i \\right )\\left ( 2+i \\right )\\left ( 3+i \\right )=10i $$ 其辐角的主值是 $ \\frac{\\pi}","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:3:2","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"*四、复数的指数形式 在科学技术，特别实在电工和无线电计算中，为了方便起见，还采用复数的另一种表示——复数的指数形式。 我们把模为 $ 1 $ ，辐角为 $ \\theta $ （以弧度为单位）的复数 $$ \\cos{\\theta}+i\\sin{\\theta} $$ 用记号 $ e^{i\\theta} $ 来表示，即4 $$ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $$ 例如， $$ e^{i\\frac{\\pi}{2}}=\\cos{\\frac{\\pi}{1}+i\\sin{\\frac{\\pi}{1}}}=i $$ $$ e^{i\\frac{\\pi}{3}}=\\cos{\\frac{\\pi}{3}+i\\sin{\\frac{\\pi}{3}}}=\\frac{1}{2}+\\frac{\\sqrt{3}}{2}i $$ 又如，$$ \\cos{\\frac{5\\pi}{6}}+i\\sin{\\frac{5\\pi}{6}} $$ 可以写成 $$ e^{i\\frac{5\\pi}{6}} $$ $$ \\frac{\\sqrt{2}}{2}+\\frac{\\sqrt{2}}{2}i=\\cos{\\frac{\\pi}{4}}+i\\sin{\\frac{\\pi}{4}} $$ 可以写成 $$ e^{i\\frac{\\theta}{4}} $$ 引入记号 $ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $ 之后，任何一个复数 $$ z=r\\left(\\cos{\\theta}+i\\sin{\\theta}\\right) $$ 就可以表示成 $$ z=re^{i\\theta} $$ 的形式。我们把这一表达式叫做复数的指数形式。 根据复数的指数形式的定义，我们有 $$ e^{i\\theta_{1}}\\cdot e^{i\\theta_{2}}\\ =\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\ =\\cos{\\left ( \\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left ( \\theta_{1}+\\theta_{2} \\right )}\\ =e^{i\\left ( \\theta_{1}+\\theta_{2} \\right )} $$ 即 $$ e^{i\\theta_{1}}\\cdot e^{i\\theta_{2}}=e^{i\\left ( \\theta_{1}+\\theta_{2} \\right )} $$ 同样可证 $$ \\left ( e^{i\\theta} \\right )^{n}=e^{in\\theta}\\left ( n\\in\\mathbf{N} \\right ) $$ $$ \\frac{e^{i\\theta_1}}{e^{i\\theta_{2}}}=e^{i\\left ( \\theta_{1}-\\theta_{2} \\right )} $$ 上述性质与我们过去学过的实数指数幂的性质一致，所以把复数从三角形式改写成指数形式后，可以运用实数集 $ \\mathbf{R} $ 中的幂运算律（注意：乘方的指数限于自然数）来进行运算。这里我们仿照实数集 $ \\mathbf{R} $ 中的说法，把 $ e^{i\\theta} $ 叫做以 $ e $ 为底、 $ i\\theta $ 为指数的幂。 对于开方运算，复数 $ re^{i\\theta} $ 的 $ n\\left(n\\in\\mathbf{N}\\right) $ 次方根是 $$ \\sqrt[n]{r}e^{i\\frac{\\theta+2k\\pi}{n}}\\left ( k=0,1,\\cdots,n-1 \\right ) $$ 例1：把复数 $ z=2i $ 表示成指数形式。 解： $ z=2i=2\\left ( \\cos{\\frac{\\pi}{1}}+i\\sin{\\frac{\\pi}{2}} \\right )=2e^{i\\frac{\\pi}{2}} $ 。 例2：把 $ \\sqrt{2}e^{-i\\frac{\\pi}{4}},\\sqrt{5}e^{i\\frac{2\\pi}{3}} $ 表示成三角形式及代数形式。 解： $$ \\sqrt{2}e^{-i\\frac{\\pi}{4}}=\\sqrt{2}\\left [ \\cos\\left ( -\\frac{\\pi}{4} \\right )+i\\sin{\\frac{\\pi}{4}} \\right ]=1-i $$ $$ \\sqrt{5}e^{i\\frac{2\\pi}{3}}=\\sqrt{5}\\left [ \\cos\\left ( -\\frac{2\\pi}{3} \\right )+i\\sin{\\frac{2\\pi}{3}} \\right ]=-\\frac{\\sqrt{5}}{2}+\\frac{\\sqrt{15}}{2}i $$ 例3：用 $ e^{i\\theta} $ 与 $ e^{-i\\theta} $ 表示 $ \\cos{\\theta} $ 与 $ \\sin{\\theta} $ 。 解：因为 $$ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $$ $$ e^{-i\\theta}=\\cos{\\left ( -\\theta \\right )}+i\\sin\\left ( -\\theta \\right )=\\cos{\\theta}-i\\sin{\\theta} $$ 因此 $$ \\cos{\\theta}=\\frac{e^{i\\theta}+e^{-i\\theta}}{2},\\quad \\sin{\\theta}=\\frac{e^{i\\theta}-e^{-i\\theta}}{2i} $$ $ \\mathbf{C} $ 是英文词组Complex numbers（复数）的第一个字母。 ↩︎ 棣莫佛（Abrabam de Moivre, 1667-1754年），法国数学家。 ↩︎ 采用这个符号时，一定要记住 $ \\sqrt[n]{z} $ 表示 $ n $ 个复数。 ↩︎ 这里的 $ e=2.71828\\cdots $ ，就是自然对数的底数。这个公式叫做欧拉（Leonhard Euler，1707-1783年，瑞士数学家）公式。在“复变函数论”中可以证明这个公式。 ↩︎ ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:4:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["码志"],"content":"忠诚 2 是忠诚的一个提升版本。我们在之前的一篇文章线段树 – 无改动求解区间最值 – 忠诚简单的谈了一下关于无改动求解区间最值的问题。现在我们来研究一下有改动求解区间最值。 首先，我们考虑改动某个值以后，对整棵树重新进行维护。但是很快我们发现，这样的复杂度太大。因为每次只更改一个值，所以只涉及到一条路径，因此我们考虑在递归修改数值的时候，可以标记一下经过的结点，修改完成以后，只对标记过的结点进行维护。这样我们的代码就出来了： int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight || pNode-\u003enMoney != 2147483647) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } void Change(Node *pNode, int x, int nValue) { pNode-\u003enMoney = 2147483647; if(pNode-\u003enLeft == x \u0026\u0026 x == pNode-\u003enRight) { pNode-\u003enMoney = nValue; } else { if(x \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { Change(pNode-\u003epLeft, x, nValue); } else { Change(pNode-\u003epRight, x, nValue); } } } 这样，除了第一次维护外，每次我们只需要维护一条路径，复杂度也大大降低低了。 附上忠诚 2 代码： #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; Node *pRoot; int N, M, nTmp, T, L, R, ans; vector\u003cint\u003e pMoney; Node* Build(int l, int r); int Update(Node *pNode); void Change(Node *pNode, int x, int nValue); int Query(Node *pNode, int l, int r); int main() { ios::sync_with_stdio(false); cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { cin \u003e\u003e nTmp; pMoney.push_back(nTmp); } pRoot = Build(1, N); Update(pRoot); for(int i = 1; i \u003c= M; i++) { cin \u003e\u003e T \u003e\u003e L \u003e\u003e R; if(T == 1) { ans = 2147483647; cout \u003c\u003c Query(pRoot, L, R) \u003c\u003c \" \"; } else { Change(pRoot, L, R); Update(pRoot); } } cout \u003c\u003c endl; return 0; } Node* Build(int l, int r) { Node *pNode = new Node(); if(l == r) { pNode-\u003enMoney = pMoney[l - 1]; } else { pNode-\u003enMoney = 2147483647; } pNode-\u003enLeft = l; pNode-\u003enRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u003epLeft = Build(l, nMid); pNode-\u003epRight = Build(nMid + 1, r); return pNode; } int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight || pNode-\u003enMoney != 2147483647) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } void Change(Node *pNode, int x, int nValue) { pNode-\u003enMoney = 2147483647; if(pNode-\u003enLeft == x \u0026\u0026 x == pNode-\u003enRight) { pNode-\u003enMoney = nValue; } else { if(x \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { Change(pNode-\u003epLeft, x, nValue); } else { Change(pNode-\u003epRight, x, nValue); } } } int Query(Node *pNode, int l, int r) { if(pNode-\u003enLeft == l \u0026\u0026 r == pNode-\u003enRight) { return pNode-\u003enMoney; } else { if(r \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epLeft, l, r); } else if(l \u003e (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epRight, l, r); } else { int nMid = (pNode-\u003enLeft + pNode-\u003enRight) / 2; return min(Query(pNode-\u003epLeft, l, nMid), Query(pNode-\u003epRight, nMid + 1, r)); } } } ","date":"2013-08-27","objectID":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%89%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A-2/:0:0","tags":["线段树"],"title":"线段树 – 有改动求解区间最值 – 忠诚 2","uri":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%89%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A-2/"},{"categories":["码志"],"content":"昨天研究了一下线段树，发现原来线段树有这么多实现方式。当然，对于非递归自底向上线段树，俗称 ZKW 线段树还是不太理解。而且我的实现方式还是用的指针，所以效率不是特别高。首先记录一下自己对于线段树的理解吧。我们用忠诚这道题目来做例子。 线段树可以直观的表示为下面这张图： 线段树示意图\" 线段树示意图 对于一个给定的区间，不断的二分，直到区间变为一个点为止。当然，平时我们所需要的线段树不是这么简陋的，我们需要一些数据域： struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; 有了节点的数据结构，我们需要构建这棵树，我们使用递归的方式生成这棵树，当然，在生成的过程中也可以进行一些初始化操作： Node* Build(int l, int r) { Node *pNode = new Node(); // Init data if(l == r) { pNode-\u003enMoney = pMoney[l - 1]; } else { pNode-\u003enMoney = 0; } pNode-\u003enLeft = l; pNode-\u003enRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u003epLeft = Build(l, nMid); pNode-\u003epRight = Build(nMid + 1, r); return pNode; } 接下来就是线段树最核心的部分了，查找。查找的时候可能有三种情况： 所需要查询的区间全部落在左儿子的区间中，递归左儿子。 所需要查询的区间全部落在右儿子的区间中，递归右儿子。 所需要查询的区间一部分在左儿子的区间中，另一部分在右儿子的区间中，递归左儿子，右儿子，根据需要进行一些操作，例如相加，取最大最小等。 实现部分如下： int Query(Node *pNode, int l, int r) { if(pNode-\u003enLeft == l \u0026\u0026 r == pNode-\u003enRight) { return pNode-\u003enMoney; } else { if(r \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epLeft, l, r); } else if(l \u003e (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epRight, l, r); } else { int nMid = (pNode-\u003enLeft + pNode-\u003enRight) / 2; return min(Query(pNode-\u003epLeft, l, nMid), Query(pNode-\u003epRight, nMid + 1, r)); } } } 但是上面的代码要递归很久才返回数据，有很多的重复运算，这样在数据量很大的情况下非常不理想，所以我们需要进行一些优化。我们可以考虑提前把每个区间的最值求出来，因为原来只有点区间才有数据： int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } 这样，这棵线段树的效率就得到了很大的提高。 附上忠诚代码： #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; Node *pRoot; int N, M, nTmp, L, R, ans; vector\u003cint\u003e pMoney; Node* Build(int l, int r); int Update(Node *pNode); int Query(Node *pNode, int l, int r); int main() { ios::sync_with_stdio(false); cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { cin \u003e\u003e nTmp; pMoney.push_back(nTmp); } pRoot = Build(1, N); Update(pRoot); for(int i = 1; i \u003c= M; i++) { cin \u003e\u003e L \u003e\u003e R; ans = 2147483647; cout \u003c\u003c Query(pRoot, L, R) \u003c\u003c \" \"; } cout \u003c\u003c endl; return 0; } Node* Build(int l, int r) { Node *pNode = new Node(); if(l == r) { pNode-\u003enMoney = pMoney[l - 1]; } else { pNode-\u003enMoney = 0; } pNode-\u003enLeft = l; pNode-\u003enRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u003epLeft = Build(l, nMid); pNode-\u003epRight = Build(nMid + 1, r); return pNode; } int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } int Query(Node *pNode, int l, int r) { if(pNode-\u003enLeft == l \u0026\u0026 r == pNode-\u003enRight) { return pNode-\u003enMoney; } else { if(r \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epLeft, l, r); } else if(l \u003e (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epRight, l, r); } else { int nMid = (pNode-\u003enLeft + pNode-\u003enRight) / 2; return min(Query(pNode-\u003epLeft, l, nMid), Query(pNode-\u003epRight, nMid + 1, r)); } } } ","date":"2013-08-27","objectID":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%97%A0%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A/:0:0","tags":["线段树"],"title":"线段树 – 无改动求解区间最值 – 忠诚","uri":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%97%A0%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A/"},{"categories":["码志"],"content":"题目是经典的采药问题。也是最基础的 0/1 背包问题。 我们约定有 $ N $ 件物品和一个容量为 $ C $ 的背包。第 $ i $ 件物品的重量是 $ w\\left [ i \\right ] $ ，价值是 $ v\\left [ i \\right ] $ 。这样，我们所需要求解将哪些物品装入背包可使价值总和最大。 ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:0:0","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["码志"],"content":"二维数组表示 定义状态： $ f\\left [ i \\right ]\\left [ c \\right ] $ 表示前 $ i $ 件物品恰放入一个容量为 $ c $ 的背包可以获得的最大价值。 状态转移方程： $ f\\left [ i \\right ]\\left [ c \\right ]=\\max\\left \\{ f\\left [ i-1 \\right ]\\left [ c \\right ],f\\left [i-1 \\right ]\\left [ c-w\\left [ i \\right ] \\right ] +v\\left [ i \\right ]\\right \\} $ 代码模版： for(int i = 1; i \u003c= N; i++) { for(int c = 0; c \u003c= C; c++) { f[i][c] = f[i - 1][c]; if(c \u003e= w[i]) { f[i][c] = max(f[i][c], f[i - 1][c - w[i]] + v[i]); } } } 时间复杂度、空间复杂度： $ O\\left ( NC \\right ) $ ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:1:0","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["码志"],"content":"一维数组表示 定义状态：由于 $ i $ 基本没有什么用处，所以我们把它省略。 状态转移方程： $ f\\left [ c \\right ]=\\max\\left \\{ f\\left [ c \\right ],f\\left [ c-w\\left [ i \\right ] \\right ] +v\\left [ i \\right ]\\right \\} $ 需要注意的是，这时候，我们需要将 $ c $ 从 $ C $ 开始，倒着推。 代码模版： for(int i = 1; i \u003c= N; i++) { for(int c = C; C \u003e= 0; C--) { if(c \u003e= w[i]) { f[c] = max(f[c], f[c - w[i]] + v[i]); } } } 时间复杂度： $ O\\left ( NC \\right ) $ 空间复杂度： $ O\\left ( C \\right ) $ ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:2:0","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["码志"],"content":"一维数组表示下的常数优化 内层循环的下限不需要为 0。 代码模版： int bound, sumw = 0; for(int i = 1; i \u003c= N; i++) { sumw += w[i]; bound = max(C - sumw, w[i]); for(int c = C; C \u003e= bound; C--) { if(c \u003e= w[i]) { f[c] = max(f[c], f[c - w[i]] + v[i]); } } } 初始化的细节： 若要求“恰好装满”： $ f\\left [ 0 \\right ]=0 $ ，其他 $ f\\left [ i \\right ]=\\textrm{-INF} $ 。 若不用“恰好装满”： $ f\\left [ 0 \\right ]=0 $ 。 最后附上 NOIP2005P3 的代码： #include \u003ciostream\u003e#include \u003cmemory.h\u003e#include \u003calgorithm\u003e using namespace std; const int MAX = 1024; int C, N; int pC[MAX], pW[MAX], f[MAX]; int main() { cin \u003e\u003e C \u003e\u003e N; for(int i = 0; i \u003c N; i++) { cin \u003e\u003e pC[i] \u003e\u003e pW[i]; } memset(f, 0, sizeof(f)); for(int i = 0; i \u003c N; i++) { for(int j = C; j \u003e= pC[i]; j--) { f[j] = max(f[j], f[j - pC[i]] + pW[i]); } } cout \u003c\u003c f[C] \u003c\u003c endl; return 0; } ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:2:1","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["浮生杂记"],"content":"一个暑假很快就过去了，还有一个多星期就要高三了。回顾这个暑假，总感觉比之前任何一个暑假都要充实，这种感觉就如同大块朵颐后的欣悦。简略的说几类事情吧，希望这次不会沉到草稿箱里。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:0:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"学习 大部分时间都在学校参加数学竞赛辅导。上午自习，下午讲课，最近加入了晚自习。 去扬州进行了为期十天的培训，留下了一篇游记。本来想把课上的讲义发上来的，但是没时间编辑，就一拖再拖。 读完了《博弈论导论》，并初步的学习了一下博弈论。 读完了《看见》，没来得及写下读书笔记。 坚持每天做英语阅读，有来不及的次日补上。 开始刷数学、物理的自主招生题目。 制订了阅读英文书籍的计划。 翻译了一篇论文：Methods of Computing Square Roots。 研究了一大堆闻所未闻的定理。 组织了一次 NOIP 模拟赛，取得了较好的效果。 进一步深入学习了数论，动态规划，树，图论，为 NOIP 2013 奠定基础。 学习使用 LaTeX 编辑文章，制作了一份 2012 年数学初赛试题的集锦，并在扬州坚持每天做一份。 学习使用 git 托管项目。 学习 Qt，并独立写出了第一个 IDE：Light-Cpp。有望参加明年的程序设计比赛。 加入了 Smart Online Judge 开发团队，进行网页的后台开发。 优化了博客的 UI，提高了用户体验质量。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:1:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"娱乐 为了解决我们中午吃何种外卖，哪些人去拿的难题，制作了人员随机系统。 成功在 Ubuntu 系统下实现 GoAgent 翻墙。 学习了通过 PhotoShop 制作移轴摄影的特效。 新增了若干友链。 将博客的文章整理成书，并通过 LaTeX 编辑。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:2:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"资金 通过写程序，赚到了真正意义上的第一桶金。这个暑假收入共计 1800。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:3:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"琐事 有一天在学校上课，正好乘电梯回教室。巧遇周红娟，她兴高采烈的拉住我，和我唠嗑。大概讲了这些事情： 她下学期要去她老家那边支教，不教我们了； 她老公在篮球队当总教练，今天她来看比赛，顺便收拾东西； 不说也罢，影响不好。 对于周红娟，虽然只教了我一年，但是感觉特别亲切，可能由于电教员经常和她接触吧。过一阵子写篇文章，聊表纪念吧。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:4:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"感悟 假作真来真亦假，无为有处有还无。 其实有时候忙碌的生活未必有想象中那么痛苦，反而可以从中找到很多乐趣。发现以前从未发现的风景。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:5:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"高三 一切都会好起来的。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:6:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["码志"],"content":"题目是经典的导弹拦截。第一问很有信心的写下了最长非增序列。第二问就懵了。后来看了题解，有一个“Dilworth 定理”，现在将定理的表述和证明整理如下： 这是一个关于偏序集的定理。偏序集即偏序集合。 偏序的概念：设 $ \\textbf{A} $ 是一个非空集合。 $ P $ 是 $ \\textbf{A} $ 上的一个关系，若关系 $ P $ 是自反的、反对称的、传递的，则称 $ P $ 是集合 $ \\textbf{A} $ 上的偏序关系。 即 $ P $ 满足下列条件： $ \\forall a\\in\\textbf{A},\\left ( a,a \\right )\\in P $ ； 若 $ \\left ( a,b \\right )\\in P,\\left ( b,a \\right )\\in P $ ，则 $ a=b $ ； 若 $ \\left ( a,b \\right )\\in P,\\left ( b,c \\right )\\in P $ ，则 $ \\left ( a,c \\right )\\in P $ 。 我们用 $ a\\leq b $ 表示 $ \\left ( a,b \\right )\\in P $ 。 注：“ $ \\leq $ ”只是符号，不代表不等关系。 例如， $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个偏序集，我们定义 $ A=\\left \\{ 1,2,3 \\right \\} $ ，偏序 $ \\leq $ 在 $ \\textbf{A} $ 上表现为大于等于关系，则有： $ \\leq =\\left \\{ \\left \\langle 3,3 \\right \\rangle,\\left \\langle 3,2 \\right \\rangle,\\left \\langle 3,1 \\right \\rangle\\left \\langle 2,2 \\right \\rangle,\\left \\langle 2,1 \\right \\rangle,\\left \\langle 1,1 \\right \\rangle \\right \\} $ 。 我们再来通过下面几个例子进一步了解偏序集： 实数集上的小于等于关系是一个偏序关系。 设 $ \\textbf{S} $ 是集合， $ P\\left(\\textbf{A}\\right) $ 是 $ \\textbf{S} $ 的所有子集构成的集合，定义 $ P\\left(\\textbf{A}\\right) $ 中两个元素 $ \\textbf{A}\\leq \\textbf{B} $ 当且仅当 $ \\textbf{A} $ 是 $ \\textbf{B} $ 的子集，则 $ P\\left(\\textbf{A}\\right) $ 在这个关系下成为偏序集。 设 $ \\textbf{N} $ 是正整数集，定义 $ m\\leq n $ 当且仅当 $ m $ 能整除 $ n $ ，不难验证这是一个偏序关系。 在偏序集中，有一个非常著名的定理，叫做“Dilworth 定理”。在介绍这个定理之前，我们需要介绍几个术语： 令 $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个偏序集，对于集合中的两个元素 $ a,b $ ，如果有 $ a\\leq b $ 或者 $ b\\leq a $ ，则称 $ a $ 和 $ b $ 是可比的，否则 $ a $ 和 $ b $ 不可比。 例： $ \\left ( \\textbf{A},\\leq \\right ) $ 是偏序集，其中 $ \\textbf{A}=\\left \\{ 1,2,3,4,5 \\right \\} $ ，其中 $ \\leq $ 是整除关系，那么对任意的 $ x\\in P $ 都有 $ 1\\leq x $ ,所以 $ 1 $ 和 $ 1,2,3,4,5 $ 都是可比的，但是 $ 2 $ 不能整除 $ 3 $ ，且 $ 3 $ 不能整除 $ 2 $ ，所以 $ 2 $ 和 $ 3 $ 是不可比的。 在X中，对于元素 $ a $ ，如果任意元素 $ b $ ，由 $ b\\leq a $ 得出 $ b=a $ ，则称 $ a $ 为极小元。 一个反链 $ \\textbf{A} $ 是 $ \\textbf{X} $ 的一个子集，它的任意两个元素都不能进行比较。 一个链 $ \\textbf{C} $ 是 $ \\textbf{X} $ 的一个子集，它的任意两个元素都可比。 定理1：令 $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个有限偏序集，并令 $ r $ 是其最大链的大小。则 $ \\textbf{X} $ 可以被划分成 $ r $ 个但不能再少的反链。 定理2（Dilworth 定理）：令 $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个有限偏序集，并令 $ m $ 是反链的最大的大小。则 $ \\textbf{X} $ 可以被划分成 $ m $ 个但不能再少的链。 证明：这里只对定理1进行证明，定理2的证明留给读者自行证明。 设 $ p $ 为最少反链个数； 先证明 $ \\textbf{X} $ 不能划分成小于 $ r $ 个反链。由于 $ r $ 是最大链 $ \\textbf{C} $ 的大小， $ \\textbf{C} $ 中任两个元素都可比，因此 $ \\textbf{C} $ 中任两个元素都不能属于同一反链。所以 $ p\\geq r $ 。 设 $ \\mathbf{X_{1}}=\\mathbf{X} $ ， $ \\mathbf{A_{1}} $ 是 $ \\mathbf{X_{1}} $ 中的极小元的集合。从 $ \\mathbf{X_{1}} $ 中删除 $ \\mathbf{A_{1}} $ 得到 $ \\mathbf{X_{2}} $ 。注意到对于 $ \\mathbf{X_{2}} $ 中任意元素 $ a_{2} $ ，必存在 $ \\mathbf{X_{1}} $ 中的元素 $ a_{2} $ ，使得 $ a_{1}\\leq a_{1} $ 。令 $ \\mathbf{A_{2}} $ 是 $ \\mathbf{X_{2}} $ 中极小元的集合，从 $ \\mathbf{X_{2}} $ 中删除 $ \\mathbf{A_{2}} $ 得到 $ \\mathbf{X_{3}} $ ……最终，会有一个 $ \\mathbf{X_{k}} $ 非空而 $ \\mathbf{X_{k+1}} $ 为空。于是 $ \\mathbf{A_{1}},\\mathbf{A_{2}},\\cdots ,\\mathbf{A_{k}} $ 就是 $ \\mathbf{x} $ 的反链的划分，同时存在链 $ a_{1}\\leq a_{2}\\leq\\cdots\\leq a_{k} $ ，其中 $ a_{i} $ 在 $ \\mathbf{A_{i}} $ 内。由于 $ r $ 是最长链大小，因此 $ r\\geq k $ 。由于 $ \\mathbf{x} $ 被划分成了 $ k $ 个反链，因此 $ r=k\\geq p $ 。因此 $ r=p $ ，得证。 那么这道题目就化简为求一遍最长非增序列和最长上升序列，DP 即可。 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; const int MAX = 128; int N, f1[MAX], f2[MAX], ans1, ans2; vector\u003cint\u003e pVec; int main() { cin \u003e\u003e N; int nTmp; for(int i = 0; i \u003c N; i++) { cin \u003e\u003e nTmp; pVec.push_back(nTmp); } for(int i = 0; i \u003c pVec.size(); i++) { f1[i] = f2[i] = 1; } for(int i = 1; i \u003c pVec.size(); i++) { for(int j = 0; j \u003c i; j++) { if(pVec[j] \u003e= pVec[i] \u0026\u0026 f1[j] + 1 \u003e f1[i]) { f1[i] = f1[j] + 1; } if(pVec[j] \u003c pVec[i] \u0026\u0026 f2[j] + 1 \u003e f2[i]) { f2[i] = f2[j] + 1; } } } ans1 = 0; ans2 = 0; for(int i = 0; i \u003c pVec.size(); i++) { if(f1[i] \u003e ans1) { ans1 = f1[i]; } if(f2[i] \u003e ans2) { ans2 = f2[i]; } } cout \u003c\u003c ans1 \u003c\u003c \" \" \u003c\u003c ans2 \u003c\u003c endl; return 0; } ","date":"2013-08-22","objectID":"/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/:0:0","tags":["Dilworth 定理"],"title":"Dilworth 定理 - NOIP1999T1","uri":"/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/"},{"categories":["码志"],"content":"题目描述是经典的蛇形填数问题。 以前解决这类问题，通常是通过控制 $ i,j $ 的值来定位数组元素的位置，然后进行赋值。但是这种方法非常的繁琐，且难于理解。容易出错。 今天在做这道题目的时候，通过搜索资料，思索出了一种新解法，相较于原来的解法更以理解，且时间复杂度更低。解法的基本思想是 BFS。下面我们仔细来探讨一下。 首先我们定义一组偏移量数组： const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 };  这个数组的顺序必须和填数的顺序一致。在这里，它被定义为逆时针填数。 然后我们需要设置 BFS 的起点： x = 1; y = N; i = 0; f[x][y] = nNum++; 其中， $ x,y $ 用来保存当前坐标， $ i $ 则是保存当前偏移量的数组下标。 $ f\\left [ x \\right ]\\left [ y \\right ] $ 表示需要填充的矩阵， $ nNum $ 则是所需要填的数。 我们来简单的模拟以下，假设现在坐标为 $ \\left ( 1,n \\right ) $ ，偏移量下标 $ i=0 $ 。首先尝试向右扩展标 $ \\left ( 1,n+1 \\right ) $ ，不合法，于是返回到坐标 $ \\left ( 1,n \\right ) $ 再先下扩展，检测合法后，进行填充，当填充到最下端时，又不合法，这样，返回到坐标 $ \\left ( n,n \\right ) $ 后向左扩展，同理，填充到最左端后又会向上扩展，这里还需要检测当前扩展结点是否已经填数。如果已经填数，则不合法，需要返回上一个坐标。 这样我们模拟一遍 BFS 就可以知道，这种解法是正确的，所以这里略过证明。 基本代码如下： #include \u003ciostream\u003e#include \u003cmemory.h\u003e using namespace std; const int MAX = 16; const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 }; int x, y, i, nNum = 1; int N, f[MAX][MAX]; int main() { memset(f, 0, sizeof(f)); cin \u003e\u003e N; x = 1; y = N; i = 0; f[x][y] = nNum++; while(nNum \u003c= N * N) { x += dx[i]; y += dy[i]; if(x \u003e= 1 \u0026\u0026 x \u003c= N \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= N \u0026\u0026 f[x][y] == 0) { f[x][y] = nNum++; } else { x -= dx[i]; y -= dy[i]; i = (i + 1) % 4; } } for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { if(N * N \u003e 99 \u0026\u0026 f[i][j] \u003c 100) { cout \u003c\u003c \" \"; } if(N * N \u003e 9 \u0026\u0026 f[i][j] \u003c 10) { cout \u003c\u003c \" \"; } cout \u003c\u003c f[i][j] \u003c\u003c \" \"; } cout \u003c\u003c endl; } return 0; } ","date":"2013-08-22","objectID":"/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/:0:0","tags":["广度优先搜索"],"title":"BFS 解决蛇形填数 - NOIP1995P2","uri":"/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/"},{"categories":["浮生杂记"],"content":"今天同学聚会，感慨颇多。彼此分别已有两年，有些人还是像以前一样，有些人却已很难辨认。不禁喟叹「时间」的伟大。还是简单的提一下今天聚会的事情吧。 最令我意外的，是虞永春老师。没想到时隔三四年他还记得那次我踢球撞破眼睑去医院缝了好几针。一见面直接就问，上次缝针的那里还看得出吗。还有就是以前宿舍里的兄弟们，大家还是这么亲近，随意的开玩笑，嬉戏打闹，感觉很好。还有小伙伴们，我想死你们了！有些话无须多言，好兄弟们！ 下面讲讲最近发生的一些事情吧，太零碎，将就着看吧。 有评价说我现在的博客学术味太浓厚，我也不知道该如何回复他，只是报以尴尬的笑。想来放暑假已经有一个月了，却感觉这个暑假充实无比，基本每天都会做做《英语5·3》，刷上一两张数学试卷。说实话，对于这种生活挺期待，也挺喜欢。因为在某些时候我的自制力的确很差。以至于最近不太想写一些文字记录生活，而是写一大堆关于数竞的文章。其实本来写了好几篇，只是大多写了一半就写不下去了，于是只好保存为草稿，最后不了了之。 我记得刚开始申请域名，搭建博客的时候，我的目的仅仅是将这个博客作为生活的一个备份，而不是一大堆关于学术的文章。显然，近阶段我没有做好这一点。不过回过头来想一想，这些学术的内容也是生活的一部分，作为生活的备份也无可厚非。实质原因则是不想写一些回忆性的文字，所以只好发一些学术方面的文章，免得博客变成一潭死水。 足球赛，上午在四十摄氏度的高温下，踢一个多小时，下午我们有时候提早放学，继续踢一会儿，感觉非常舒服。踢完以后整个人什么都不想做。但是后来物理组还是被王惠峰发现了。 每天数学课都是做题目，讲题目，期间接触了许多很有趣的题目，比如海盗船长分金币的题目。 这个暑假终于写出了像样的程序，卖出了像样的价格。还是很兴奋的。 这次就到这吧，有点急事，仓促停笔。 ","date":"2013-08-09","objectID":"/2013/08/%E6%9D%82%E8%AE%B020130809/:0:0","tags":["高中生活"],"title":"杂记（20130221）","uri":"/2013/08/%E6%9D%82%E8%AE%B020130809/"},{"categories":["浮生杂记"],"content":"注：这篇文章在草稿箱里沉睡了许久，现在勉强将其写完，可能有所遗漏。 7月15日至7月24日去扬州参加了数学夏令营。现在将沿途一些所见所闻所感记录于此。这几天的经历可以用一句话来概括「生活单调的像巴甫洛夫的狗，日子凄惨的如薛定谔的猫。」 7月15日中午我们乘坐大巴从学校赶往扬州。当大巴驶在宽阔的长江大桥上，我被长江的宽阔与雄壮所折服。从杨舍到扬州有将近2小时45分钟的车程。去的路上大家都很激动，不断的拍照直播。 我们入住的宾馆叫做辰源宾馆，双人间，自由组合，我便和陈力江住在了一起。刚进入房间，一股恶臭扑面而来，打电话给总台叫人来处理，他却说这里的下水道本来就堵住的，没办法。还说的振振有词。打开电视机，不是看不清就是没声音。在床上躺了一会儿，就去吃晚饭了。晚饭自然是张伟新请客的，就在宾馆的对面——三道菜。那边的菜都有点辣，而且很多菜都长一个样。不得不说他们店里的招牌冷饮——酸梅汤。免费而且无限续杯，口感的确不错。 当天晚上是开班会，我们一个班将近两百多人。班主任自称扬州大学大三学生，自我介绍时说，“我会成为你们既恨又爱的班主任之一”。这句话的前半部分很快就得到了验证，他要核对身份证信息，还要关注一些注意点。但是他只会串行运行，不会并行处理。在他让我们核对身份证期间，居然干巴巴在上面站着，一句话也不说。好不容易核对好了，开始讲一些注意事项。居然重复了五六遍！每次讲完都说“我再强调一遍”，导致最后直接有学生拍桌子起哄。最后处理了一下座位的问题，初步定为抢座位。对了，补充一句，一开始只有我们学校住在外面宾馆，其他学校一律住的宿舍，所以他们有晚自习，我们没有。 班会结束后从大教室走出来，天上早已繁星点点。由于那个老师拖了很久，大家心情本来就不怎么好。又遇到蛮横的门卫，差点起了争执。最后还是打通了张伟新的电话才放我们出校门。相比较而言，其实我们这里的门卫一点都不凶。 对于门卫的做法，或许他是为了学校和学生的安全考虑，但是那天晚上他所表现出来的行为实在是令人大跌眼镜，一副气势汹汹，妄图吓住我们的样子。这种表现让我有种「扬州人都是这种样子。」的感觉。当然，我们学校也有人在趁门卫拦截别人时走了出来，虽然有违规矩，但在这种背景下却也无可厚非。只是觉得门卫实在没有必要到如此地步。 回到宾馆洗漱，整理，大家说明天早点起来去抢位置。我们第一天6点起床，顺利的抢到了第一排。当我们到教室的时候只有7点，8点上课。那个班主任还在睡觉。他就这样被我们吵醒了去开门。结果开了门说，我们以后排座位吧，要考虑到别人的休息。 对于这件事情，班主任为排座位找到了一个非常冠冕堂皇的理由，我们要考虑到住在校外的学生（也就是指我们，但是我们抢到了第一排），这个理由显然是行不通的。感觉这个班主任办事能力太差劲，而且找理由却一点都不让人信服。而不像某些老师，即使你知道他是在找理由，但却心甘情愿跟着他做。 讲函数的老师是个佛教徒。上课讲的一些禅语倒是很值得推敲。 因空见色，由色生情，传情入色，自色悟空。 首先，佛学中的「色」和道家中的「道」有异曲同工之妙，皆是指天地万物。这几句话在《石头记》中也有出现过，是空空道人所说。结合《好了歌》，我们可以这样理解这几句话：从「无」了解表象，接着从表象懂得人间的感情和苦恼，然后从中解脱，懂得此皆因表象而起，最后懂得外物表象终究是「无」。从人情方面理解，这几句话的意思和老子的「超然出世」并无太大区别。从学术上理解，则表示了从无知到理解到运用自如的过程，而最高境界，则是「无招胜又招」。 一个讲排列组合的老师叫刘凯峰。他给我们讲了两个自身的故事。应该算是在警醒我们吧。「我们那时候学习压力几乎没有，初三的时候我们班的男生还在玩水枪。我当时胆子小，所以没和他们一起玩。结果就我考上了高中。」「我在高考前几天还在研究三等分角，结果高考考了个师范。」毕竟，竞赛仅仅是磨练意志和开拓眼界的。真正属于我们的舞台，还是高考。 他还讲了一些他以前出过的一些高考题，还讲了一道数列题，他说是用来准备作为2013年高考附加题最后一题的。但是命题组换了人，所以没叫他去。那道题目相当难，除了第一问可以猜出答案，第二问的证明根本不会。而他也洋洋自得的说，第二问的证明不仅要用到螺旋归纳法，还要如何如何。而且很大气的说，这道题目就没准备让你们拿分，除了第一问有个别人可以猜出答案。 最后一天讲平面几何的老师讲课方式非常奇特。偌大的教室，有投影不用，偏偏用黑板。说话听不清，黑板看不清，而且讲题目喜欢只讲一半。以至于他讲的调和点列似懂非懂，谁知道第二天就考到了调和点列和梅涅劳斯定理综合的平几题。 上课基本就是这样。接下来讲讲课余生活吧，应该算不上太丰富。每天早上7点起床，中午12点休息一会，然后午睡到2点半。晚上6点下课，吃完晚饭买杯奶茶，接着大家串门娱乐。玩到8点左右开始做题目。 某天晚上大家守着信号极差的有线电视，好不容易调到一个清晰的频道，中国好声音，居然还没有声音。 期间大家商量了准备去瘦西湖玩的，可惜有人夜探瘦西湖带回来的消息是：瘦西湖没有夜游，于是只能作罢。本来我们还想像周红娟一样，去瘦西湖上撑一支竹篙，在星辉斑斓里放歌。 比较有印象的应该是那天足球赛，中国队VS日本队。一大群男生在一个房间里看球赛。张伟新来查房，还以为我们在做什么不法勾当。 还有不得不提的一件事情，就是宾馆的隔音效果。中午睡觉，楼上一位大妈在打电话，声音非常大，时不时发出恐怖的大笑声。搞得一个中午没睡觉。晚上，本来快睡着了，隔壁传来一阵电视机的声音。 某天中午，我们准备去大润发逛逛，人生地不熟，遂向一报亭老人问路，他说直走右拐再直走，跑半分钟就到了。结果我们走了十多分钟才看见。回酒店的路上顺便逛了一下酒店后面的所谓步行街，感觉非常的冷清，而且有点邋遢。 最后一天，那个班主任说下午提前40分钟到，要发准考证。谁知我们到了，他还没到。 复赛，有一道题目上课讲过类似的方法，但是考完后还是感觉很虚。但有80%的通过率也放下了心。自己在知识的海洋面前，实在是非常的渺小。 我还像以前一样疯狂的热爱数学！ ","date":"2013-08-01","objectID":"/2013/08/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E9%9B%B6/:0:0","tags":["数学竞赛"],"title":"扬州拾遗（零）","uri":"/2013/08/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E9%9B%B6/"},{"categories":["数学之美"],"content":"一、函数问题基本方法 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:0","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"1. 数型结合法 例1：求方程 $ \\left | x-1\\right |=\\frac{1}{x} $ 的正根的个数。 解：作图像得，正根个数为 $ 1 $ 。 例2：求函数 $ f\\left(x\\right)=\\sqrt{x^{4}-3x^{2}-6x+13}-\\sqrt{x^{4}-x^{2}+1} $ 的最大值。 解： $ f\\left(x\\right)=\\sqrt{\\left(x^{2}-2\\right)^{2}+\\left(x-3\\right)^{2}}-\\sqrt{\\left(x^{2}-1\\right)^{2}+x^{2}} $ 即表示点 $ P\\left(x,x^{2}\\right) $ 到点 $ A\\left(3,2\\right),B\\left(0,1\\right) $ 的距离之差，点 $ P $ 在抛物线 $ y=x^{2} $ 上。 易得点 $ P $ 在直线 $ l_{AB}:x-3y+3=0 $ 上，因此得到 $ P\\left(\\frac{1-\\sqrt{37}}{6},\\frac{19-\\sqrt{37}}{18}\\right) $ ，故 $$ \\begin{align*} f\\left(x\\right)_{max} \u0026=\\sqrt{\\left[\\left(\\frac{1-\\sqrt{37}}{6}-3\\right)^{2}+\\left(\\frac{19-\\sqrt{37}}{18}-2\\right)^{2}\\right]-\\left[\\left(\\frac{1-\\sqrt{37}}{6}\\right)^{2}+\\left(\\frac{19-\\sqrt{37}}{18}-1\\right)^{2}\\right]} \\\\ \u0026=\\frac{2\\sqrt{245+34\\sqrt{37}}}{9} \\end{align*}$$ ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:1","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"2. 函数性质的应用 例3：设 $ x,y\\in\\mathbf{R} $ ，且满足 $ \\begin{cases} \\left ( x-1 \\right )^{3}+1997\\left ( x-1 \\right )=-1\\\\ \\left ( y-1 \\right )^{3}+1997\\left ( y-1 \\right )=1 \\end{cases} $ ，求 $ x+y $ 。 解：考虑函数 $ f\\left(s\\right)=s^{3}+1997s $ ，该函数既是奇函数又是增函数。又 $ f\\left(x-1\\right)=-f\\left(y-1\\right) $ ，得 $ \\left(x-1\\right)+\\left(y-1\\right)=0 $ ，因此 $ x+y=2 $ 。 例4：奇函数 $ f\\left(x\\right) $ 在定义域 $ \\left(-1,1\\right) $ 内是减函数，又 $ f\\left(1-a\\right)+f\\left(1-a^{2}\\right)\u003c0 $ ，求 $ a $ 的取值范围。 解：首先由函数的定义域得 $ \\begin{cases} -1\u003c1-a\u003c1\\\\ -1\u003c1-a^{2}\u003c1 \\end{cases} $ ，解得 $ 0\u003c a\u003c \\sqrt{2} $ 。下面进行分类讨论： $ 1^{\\circ} \\left | 1-a \\right |\u003c 1-a^{2}\\Rightarrow 0\u003c a\u003c 1 $ $ 2^{\\circ}\\left | 1-a^{2} \\right |\u003c 1-a\\Rightarrow -2\u003c a\u003c 0 $ （不符题意）。 综上所述， $ a\\in\\left ( 0,1 \\right ) $ 。 例5：设 $ f\\left(x\\right) $ 是定义在 $ \\left(-\\infty,+\\infty\\right) $ 上以 $ 2 $ 为周期的函数，对 $ k\\in\\mathbf{Z} $ ，用 $ I_{k} $ 表示区间 $ \\left(2k-1,2k+1\\right] $ ，已知当 $ x\\in I_{0} $ 时， $ f\\left(x\\right)=x^{2} $ ，求 $ f\\left(x\\right) $ 在 $ I_{k} $ 上的解析式。 解：根据图像的平移，易得 $ f\\left(x\\right)=\\left(x-2k\\right)^{2} $ 。 例6：解方程 $$ \\left(3x-1\\right)\\left(\\sqrt{9x^{2}-6x+5}+1\\right)+\\left ( 2x-3 \\right )\\left ( \\sqrt{4x^{2}-12x+13}+1 \\right )=0 $$ 解：首先进行因式分解： $$ \\left(3x-1\\right)\\left(\\sqrt{\\left ( 3x-1 \\right )^{2}+4}+1\\right)+\\left ( 2x-3 \\right )\\left ( \\sqrt{\\left ( 2x-3 \\right )^{2}+4}+1 \\right )=0 $$ 考察函数 $$ f\\left ( s \\right )=s\\left ( \\sqrt{s^{2}+4}+1 \\right ) $$ 它既是奇函数又是增函数。因此上述方程转化为 $$ \\left ( 3x-1 \\right )+\\left ( 2x-3 \\right )=0 $$ 解得 $ x=\\frac{4}{5} $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:2","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"3. 配方法 例7：求函数 $ y=x+\\sqrt{2x+1} $ 的值域。 解：首先考虑定义域得 $ D_{y}=\\left [ -\\frac{1}{2},+\\infty \\right ) $ 。又 $$ y=\\left ( \\sqrt{x+\\frac{1}{2}}+\\sqrt{\\frac{1}{2}} \\right )^{2}-1\\geq -\\frac{1}{2} $$ 因此该函数的值域为 $ R_{y}=\\left [ -\\frac{1}{2},+\\infty \\right ) $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:3","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"4. 换元法 例8：求函数 $ y=\\left ( \\sqrt{1+x}+\\sqrt{1-x}+2 \\right )\\left ( \\sqrt{1-x^{2}}+1 \\right ),x\\in\\left [ 0,1 \\right ] $ 的值域。 解：令 $ s=\\sqrt{1+x}+\\sqrt{1-x} $ ，则 $ s^{2}=2\\left ( \\sqrt{1-x^{2}}+1\\right ) $ ，且 $ s\\in\\left [ -\\sqrt{2},\\sqrt{2} \\right ] $ 。代入得 $ y=\\frac{1}{2}\\cdot \\left ( s+2 \\right )\\cdot s^{2}=\\frac{1}{2}s^{3}+s^{2} $ ，易得该函数的值域为 $ R_{y}=\\left [ 2+\\sqrt{2},8 \\right ] $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:4","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"5. 关于反函数 例9：若函数 $ y=f\\left ( x \\right ) $ 定义域、值域均为 $ \\mathbf{R} $ ，且存在反函数。若 $ y=f\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增，求证： $ y=f^{-1}\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增。 解：不妨设 $ x_{1}\u003ex_{2} $ ，则 $ f\\left ( x_{1} \\right )\u003ef\\left ( x_{2} \\right ) $ ，因此 $$ f^{-1}\\left ( f\\left ( x_{1} \\right ) \\right )-f^{-1}\\left ( f\\left ( x_{2} \\right ) \\right )=x_{1}-x_{2}\u003e0 $$ 所以 $ y=f^{-1}\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增。证毕。 例10：设函数 $ f\\left ( x \\right )=\\sqrt[4]{\\frac{4x+1}{3x+2}} $ ，解方程 $ f\\left ( x \\right )=f^{-1}\\left ( x \\right ) $ 。 解：即 $ \\sqrt[4]{\\frac{4x+1}{3x+2}}=x $ ，整理得 $$ \\left ( x-1 \\right )\\left ( 3x^{4}+5x^{3}+5x^{2}+5x+1 \\right )=0 $$ 显然 $ 3x^{4}+5x^{3}+5x^{2}+5x+1\u003e0 $ ，故 $ x=1 $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:5","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"二、典型例题 题1：已知不等式 $ \\sin^{2}x+a\\cos x+a^{2}\\geq 1+\\cos x $ 对一切 $ x\\in\\mathbf{R} $ 恒成立，求 $ a $ 的取值范围。 解： $ \\cos^{2}x+\\left ( 1-a \\right )\\cos x - a^{2}\\leq 0 $ ，其中 $ \\cos x\\in\\left [ -1,1 \\right ] $ 。令 $$ f\\left ( x \\right )=\\cos^{2}x+\\left ( 1-a \\right )\\cos x - a^{2} $$ 则 $$ \\begin{cases} f\\left ( -1 \\right )\\leq 0\\\\ f\\left ( 1 \\right )\\leq 0 \\end{cases} \\Rightarrow \\begin{cases} a^{2}-a\\geq 0\\leq 0\\\\ a^{2}-a-2\\geq 0\\leq 0 \\end{cases} \\Rightarrow a\\in\\left ( -\\infty,-2 \\right ]\\cup\\left [ 1,+\\infty \\right ) $$ 题2：已知函数 $ f\\left ( x \\right ) $ 的定义域是 $ \\left [ -\\frac{1}{2},\\frac{1}{2} \\right ] $ ，求函数 $ g\\left ( x \\right )=f\\left ( ax \\right )+f\\left ( \\frac{x}{a} \\right ) $ 的定义域 $ \\left ( a\u003e 0\\right ) $ 。 解：根据函数函数 $ f\\left ( x \\right ) $ 的定义域很容易得到以下不等式 $ \\begin{cases} -\\frac{1}{2}\\leq ax\\leq \\frac{1}{2}\\\\ -\\frac{1}{2}\\leq \\frac{x}{a}\\leq \\frac{1}{2} \\end{cases} $ 。即 $ \\begin{cases} -\\frac{1}{2a}\\leq x\\leq \\frac{1}{2a}\\\\ -\\frac{a}{2}\\leq x\\leq \\frac{a}{2} \\end{cases} $ 分类讨论得： $ 1^{\\circ}0\u003c a\\leq 1,D_{g}=\\left [ -\\frac{a}{2},\\frac{a}{2} \\right ] $ $ 2^{\\circ}a\u003e 1,D_{g}=\\left [ -\\frac{1}{2a},\\frac{1}{2a} \\right ] $ 题3：已知 $ f\\left(x\\right) $ 是定义在 $ \\mathbf{R} $ 上的函数， $ f\\left(1\\right)=1 $ ，且对任意 $ x\\in\\mathbf{R} $ 都有 $ f\\left(x+5\\right)\\geq f\\left(x\\right) + 5,f\\left(x+1\\right)\\leq f\\left(x\\right)+1 $ ，且 $ g\\left ( x \\right )=f\\left ( x \\right )+1-x $ 求 $ g\\left(2012\\right) $ 。 解： $ f\\left ( x+5 \\right )\\leq f\\left ( x+4 \\right )+1\\leq \\cdots \\leq f\\left ( x \\right )+5 $ ，又 $ f\\left ( x \\right )\\geq f\\left ( x \\right )+5 $ ，故 $ f\\left ( x \\right )= f\\left ( x \\right )+5 $ 。运用数学归纳法，并结合 $ f\\left ( 1 \\right )=1 $ ，不难得到 $ f\\left ( x \\right )=x $ 。因此 $ g\\left ( 2012 \\right )=f\\left ( 2012 \\right )+1-2012=1 $ 。 题4：设函数 $ f:\\mathbf{N^{*}}\\rightarrow \\mathbf{N^{*}} $ ，且严格递增。当 $ m,n $ 互质时， $ f\\left ( m\\cdot n \\right )=f\\left ( m \\right )\\cdot f\\left ( n \\right ) $ 。若 $ f\\left ( 19 \\right )=19 $ ，求 $ f\\left ( f\\left ( 19 \\right ) \\right )\\cdot f\\left ( 98 \\right ) $ 的值。 解：由题意得，当 $ x\\leq 19 $ 时，有 $ f\\left ( x \\right )=x $ 。又 $ f\\left ( 17\\cdot 19 \\right )=f\\left ( 17 \\right )\\cdot f\\left ( 19 \\right )=323 $ ，则当 $ x\\leq 323 $ 时，有 $ f\\left ( x \\right )=x $ 。所以 $$ f\\left ( f\\left ( 19 \\right ) \\right )\\cdot f\\left ( 98 \\right )=f\\left ( 19 \\right )\\cdot f\\left ( 98 \\right )=19*98=1862 $$ 题5：设函数 $ f:\\mathbf{N^{*}}\\rightarrow \\mathbf{N^{*}} $ ，且严格递增。 $ f\\left ( f\\left ( n \\right ) \\right )=3n $ 。求 $ f\\left ( 1 \\right )+f\\left ( 9 \\right )+f\\left ( 36 \\right ) $ 。 解：首先可以得到 $ f\\left ( f\\left ( 1 \\right ) \\right )=3 $ 。不妨假设 $ f\\left ( 1 \\right )=1 $ ，代入得 $ f\\left ( f\\left ( 1 \\right ) \\right )=f\\left ( 1 \\right )=1\\neq 3 $ ，矛盾。因此易证 $ f\\left ( 1 \\right )=2 $ 。于是可以列出： $$ f\\left ( 2 \\right )=f\\left ( f\\left ( 1 \\right ) \\right )=3,f\\left ( 3 \\right )=f\\left ( f\\left ( 2 \\right ) \\right )=6,f\\left ( 6 \\right )=f\\left ( f\\left ( 3 \\right ) \\right )=9,f\\left ( 9 \\right )=f\\left ( f\\left ( 6 \\right ) \\right )=18 $$ 于是得到 $ f\\left ( 9 \\right )=18 $ 。由 $ f\\left ( 3 \\right )=6,f\\left ( 6 \\right )=9 $ 再结合题中所给条件，得 $ f\\left ( 4 \\right )=7 $ 。因此 $$ f\\left ( 7 \\right )=f\\left ( f\\left ( 4 \\right ) \\right )=12,f\\left ( 12 \\right )=f\\left ( f\\left ( 7 \\right ) \\right )=21,f\\left ( 21 \\right )=f\\left ( f\\left ( 12 \\right ) \\right )=36,f\\left ( 36 \\right )=f\\left ( f\\left ( 21 \\right ) \\right )=63 $$ 于是得到 $ f\\left ( 36 \\right )=63 $ ，将以上的结果相加得 $ f\\left ( 1 \\right )+f\\left ( 9 \\right )+f\\left ( 36 \\right )=2+18+63=83 $ 。 题6：已知函数 $ f\\left ( x \\right )=\\log_{x}{\\left ( x+1 \\right )},x\\in\\left ( 1,+\\infty \\right ) $ ，试比较 $ f\\left ( x \\right ),f\\left ( x+1 \\right ) $ 的大小。 解： $ \\frac{f\\left ( x+1 \\right )}{f\\left ( x \\right )}=\\frac{\\log{\\left (x+2 \\right )}}{\\log{\\left (x+1 \\right )}}\\cdot \\frac{\\log{\\left (x+1 \\right )}}{\\log{x}}=\\frac{\\log{\\left ( x+2 \\right )}}{\\log{x}}\u003e 1 $ ，所以 $ f\\left ( x+1 \\right )\u003e f\\left ( x \\right ) $ 。 题7：已知 $ 3^{a}+13^{b}=17^{a},5^{a}+7^{b}=11^{b} $ ，试判断实数 $ a,b $ 的大小关系，并证明之。 解：当 $ a=1 $ 时， $ b\u003e 1 $ ，得 $ b\u003e a $ 。假设 $ b\\leq a $ ，易得 $$ \\begin{cases} 17^","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:2:0","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"三、二次函数 例1：已知 $ f\\left ( x \\right )=ax^{2}+bx $ ，满足 $ 1\\leq f\\left ( -1 \\right )\\leq 2 $ 且 $ 2\\leq f\\left ( 1 \\right )\\leq 4 $ ，求 $ f\\left ( -2 \\right ) $ 的取值范围。 解： 法一：由题设得， $ \\begin{cases} 1\\leq a-b\\leq 2 \u0026 \\left ( \\textrm{i} \\right )\\\\ 2\\leq a+b\\leq 4 \u0026 \\left ( \\textrm{ii} \\right ) \\end{cases} $ ，由 $ 3\\times \\left ( \\textrm{i} \\right )+\\left ( \\textrm{ii} \\right ) $ 得 $ 5\\leq f\\left ( -2 \\right )\\leq 10 $ 。 法二： $ \\begin{cases} f\\left ( -1 \\right )=a-b\\\\ f\\left ( 1 \\right )=a+b \\end{cases} \\Rightarrow \\begin{cases} a=\\frac{1}{2}\\cdot \\left [ f\\left ( 1 \\right ) + f\\left ( -1 \\right ) \\right ]\\\\ b=\\frac{1}{2}\\cdot \\left [ f\\left ( 1 \\right ) - f\\left ( -1 \\right ) \\right ] \\end{cases} $ ，因此 $ f\\left ( -2 \\right )=f\\left ( 1 \\right )+3f\\left ( -1 \\right )\\in\\left [ 5,10 \\right ] $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:3:0","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"鸽巢原理：如果 $k+1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 $2$ 个或更多的物体。 有时候鸽巢原理也被称为抽屉原理，更准确地说应该叫做“狄利克雷抽屉原理”。至于狄利克雷这个名字，还有有趣的函数也是用他的名字命名的。它就是大名鼎鼎的狄利克雷函数 $$f\\left(x\\right)=\\begin{cases}1,\u0026x\\in\\mathbf{Q}\\\\ 0,\u0026x\\not\\in\\mathbf{Q}\\end{cases}$$ 这个函数的有趣之处就在于它没有对应的图像。扯远了。 下面给出鸽巢原理的证明：假定 $k$ 个盒子中没有一个盒子包含的物体多余 $1$ 个，那么物体总数至多是 $k$，这与至少有 $k+1$ 物体矛盾。证毕。 例1：在一组 $367$ 个人中一定至少有 $2$ 个人有相同的生日，这是由于只有 $366$ 个可能的生日。 例2：在 $27$ 个英文单词中一定至少有 $2$ 个单词以同一个字母开始，因为英文字母表中只有 $26$ 个字母。 例3：证明对每个整数 $n$，存在一个数是 $n$ 的倍数，且在它的是进制表示中只出现 $0$ 和 $1$。 证明：令 $n$ 为正整数。考虑 $n$ 个整数 $1,11,111,\\cdots,11\\cdots 1$（在这个数表中，最后一个整数的十进制表示中具有 $n+1$ 个 $1$）。注意到当一个整数被 $n$ 整除时存在 $n$ 个可能的余数。因为这个数表中有 $n+1$ 个整数，由鸽巢原理必有两个整数在除以 $n$ 时有相同的余数。这两个整数之差的十进制表示中只含有 $0$ 和 $1$，且它能被 $n$ 整除。 广义鸽巢原理：如果 $N$ 个物体放入 $k$ 个盒子，那么至少有一个盒子包含了至少 $\\left \\lceil \\frac{N}{k} \\right \\rceil$ 个物体。 证明：假定没有盒子包含了比 $\\left\\lceil \\frac{N}{k} \\right\\rceil-1$ 多的物体，那么物体总数至多是 $$k\\left (\\left\\lceil \\frac{N}{k} \\right \\rceil -1\\right) \u003c k\\left(\\left(\\frac{N}{k}+1\\right)-1\\right)=N$$ 这与存在有总数 $N$ 个物体矛盾。证毕。 例4：在 $100$ 个中至少有 $\\left\\lceil \\frac{100}{12}\\right\\rceil=9$ 个人生在同一个月。 例5：为保证一个州的 $2500$ 万个电话有不同的 $10$ 位电话号码，所需地区代码的最小数是多少？（假定电话号码是 $\\textrm{NXX-NXX-XXXX}$ 形式，其中前 $3$ 位是地区代码，$N$ 表示从 $2$ 到 $9$ 包含的十进制数字，$X$ 表示任何十进制数字）。 解：有 $800$ 万个形如 $\\textrm{NXX-NXX-XXXX}$ 的不同的电话号码。因此，由广义鸽巢原理，在 $2500$ 万个电话号码中，一定至少有 $\\left\\lceil\\frac{25000000}{8000000}\\right\\rceil$ 个同样的电话号码。因而至少需要 $4$ 个地区代码来保证所有的 $10$ 位号码是不同的。 例6：证明在不超过 $2n$ 的任意 $n+1$ 个正整数中一定存在一个正整数被另一个正整数整除。 证明：把 $n+1$ 个整数 $a_{1},a_{2},\\cdots,a_{n}$ 中的每一个都写成 $2$ 的幂与一个奇数的乘积，换句话说，令 $a_{j}=2^{k_{j}}\\cdot q_{j},j=1,2,\\cdots,n+1$，其中 $k_{j}$ 是非负整数，$q_{j}$ 是奇数。整数 $q_{1},q_{2},\\cdots,q_{m+1}$ 都是小于 $2n$ 的正奇数。因为只存在 $n$ 个小于 $2n$ 的正奇数，由鸽巢原理，$q_{1},q_{2},\\cdots,q_{n+1}$ 中必有两个相等。于是，存在整数 $i,j$ 使得 $q_{i}=q_{j}$。令 $q_{i}=q_{j}=q$，那么 $a_{i}=2^{k_{i}}\\cdot q,a_{j}=2^{k_{j}}\\cdot q$。因而，若 $k_{i} \u003c k_{j}$，则 $a_{i}$ 整除 $a_{j}$；反之，则 $a_{j}$ 整除 $a_{i}$。 ","date":"2013-07-13","objectID":"/2013/07/%E6%B5%85%E8%B0%88%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/:0:0","tags":["鸽巢原理"],"title":"浅谈鸽巢原理及其应用","uri":"/2013/07/%E6%B5%85%E8%B0%88%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"翻书复习之时，看到斐波那契数列，于是将一些关于数列递推关系方面的内容整理了一下。 定义1：一个常系数的 $k$ 阶线性齐次递推关系是形如 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}+\\cdots+c_{k}a_{n-k}$ 的递推关系，其中 $c_{1},c_{2},\\cdots,c_{k}$ 是实数，$c_{k}\\neq 0$。 这个定义中递推关系是线性的，因为它的右边是数列前项的倍数之和。这个递推关系是齐次的，因为所出现的各项都是 $a_{j}$ 的倍数。数列各项的系数都是常数而不是依赖于 $n$ 的函数。阶为 $k$ 是因为 $a_{n}$ 由序列前面的 $k$ 项来表示。 例1：递推关系 $p_{n}=2p_{n-1}$ 是 $1$ 阶的线性齐次递推关系。递推关系 $f_{n}=f_{n-1}+f_{n-2}$ 是 $2$ 阶的线性齐次递推关系。 例2：递推关系 $a_{n}=a_{n-1}+a_{n-2}^{2}$ 不是线性的。递推关系 $h_{n}=2h_{n-1}+1$ 不是齐次的。递推关系 $b_{n}=nb_{n-1}$ 不是常系数的。 求解常系数线性齐次递推关系的基本方法是寻找形如 $a_{n}=r^{n}$ 的解，其中 $r$ 是常数。注意 $a_{n}=r^{n}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}+\\cdots+c_{k}a_{n-k}$ 的解，当且仅当 $$r^{n}=c_{1}r^{n-1}+c_{2}r^{n-2}+\\cdots+c_{k}r_{n-k}$$ 当等式两边除以 $r^{n-k}$ 并且从左边减去右边时，我们得到等价的方程 $$r^{k}-c_{1}r^{k-1}-c_{2}r^{k-2}-\\cdots-c_{k-1}r-c_{k}=0$$ 因此，数列 $\\left\\{a_{n}\\right\\}$ 以 $a_{n}=r^{n}$ 作为解，当且仅当 $r$ 使者后一个方程的解。这个方程叫作该递推关系的特征方程。方程的解叫做该递推关系的特征根。 我们首先看一个 $2$ 阶常系数线性齐次递推关系的处理结果。然后，叙述相应的阶可能大于 $2$ 的一般性结果。 定理1：设 $c_{1}$ 和 $c_{2}$ 是实数。假设 $r_{2}-c_{1}r-c_{2}=0$ 有两个不等的根 $r_{1}$ 和 $r_{2}$，那么数 $\\left\\{a_{n}\\right\\}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}$ 的解，当且仅当 $a_{n}=\\alpha_{1}\\cdot r_{1}^{n}+\\alpha_{2}\\cdot r_{2}^{n},n=0,1,2,\\cdots$，其中 $\\alpha_{1}$ 和 $\\alpha_{2}$ 是常数。 例3：求斐波那契数列的通项公式。 解：斐波那契数列满足递推关系 $f_{n}=f_{n-1}+f_{n-2}$ 和初始条件 $f_{1}=f_{2}=1$。特征方程 $r^{2}-r-1=0$ 的两个根是 $r_{1,2}=\\frac{1\\pm\\sqrt{5}}{2}$。因此，由定理 1 的斐波那契数列通项公式为：$$f_{n}=\\alpha_{1}\\cdot \\left(\\frac{1+\\sqrt{5}}{5}\\right)^{n}+\\alpha_{2}\\cdot \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}$$ 其中 $\\alpha_{1},\\alpha_{2}$ 为常数。可由初始条件 $f_{1}=f_{2}=1$ 确定这两个常数，我们有 $$\\begin{cases} f_{1}=\\alpha_{1}\\cdot \\left ( \\frac{1+\\sqrt{5}}{2} \\right )+\\alpha _{2}\\cdot \\left ( \\frac{1-\\sqrt{5}}{2} \\right )=1 \\\\ f_{2}=\\alpha_{1}\\cdot \\left ( \\frac{1+\\sqrt{5}}{2} \\right )^{2}+\\alpha _{2}\\cdot \\left ( \\frac{1-\\sqrt{5}}{2} \\right )^{2}=1 \\end{cases}$$ 从而得到 $\\alpha_{1}=\\frac{\\sqrt{5}}{5},\\alpha_{2}=-\\frac{\\sqrt{5}}{5}$，于是斐波那契数列的通项公式为：$$f_{n}=\\frac{\\sqrt{5}}{5}\\left(\\frac{1+\\sqrt{5}}{5}\\right)^{n}-\\frac{\\sqrt{5}}{5}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}$$ 当存在二重特征根的时候，定理1不再适用。如果遇到这种情况，当 $r_{0}$ 是特征方程的一个二重根时，那么 $a_{n}=nr_{0}^{n}$ 是递推关系的另一个解。 定理2：设 $c_{1}$ 和 $c_{2}$ 是实数。假设 $r_{2}-c_{1}r-c_{2}=0$ 只有一个根 $r_{0}$。数列 $\\left{a_{n}\\right}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}$ 的解，当且仅当 $a_{n}=\\alpha_{1}\\cdot r_{0}^{n}+\\alpha_{2}\\cdot n\\cdot r_{0}^{n},n=0,1,2,\\cdots$，其中 $\\alpha_{1}$ 和 $\\alpha_{2}$ 是常数。 例4：数列 $\\left\\{a_{n}\\right\\}$ 满足 $a_{n}=6a_{n-1}-9a_{n-2}$，且$a_{1}=6，a_{2}=27$，求数列 $\\left\\{a_{n}\\right\\}$ 的通项公式。 解：$r^{2}-6r+9=0$ 唯一的根是 $r=3$。因此这个递推关系的解是 $$a_{n}=\\alpha_{1}\\cdot 3^{n}+\\alpha_{2}\\cdot n\\cdot 3_{n}$$ 其中 $\\alpha_{1},\\alpha_{2}$ 是常数。使用初始条件得 $\\alpha_{1}=\\alpha_{2}=1$，所以 $\\left\\{a_{n}\\right\\}$ 的通项公式为 $$a_{n}=3^{n}+n\\cdot 3^{n}$$ 例5：求满足 $a_{1}=5,a_{2}=15,a_{3}=47$ 的递推关系 $a_{n}=6a_{n-1}-11a_{n-2}+6a_{n-3}$ 的通项公式。 解：有这个递推关系的特征方程 $r^{3}-6r^{2}+11r-6=0$ 得到三个特征根 $r_{1}=1,r_{2}=2,r_{3}=3$，于是递推关系的解的形式为：$$a_{n}=\\alpha_{1}\\cdot 1^{n}+\\alpha_{2}\\cdot 2^{n}+\\alpha_{3}\\cdot 3^{n}$$ 通过初始条件得到 $\\alpha_{1}=1,\\alpha_{2}=-1,\\alpha_{3}=2$。于是通项公式为：$$a_{n}=1-2^{n}+2\\cdot 3^{n}$$ ","date":"2013-07-12","objectID":"/2013/07/%E6%B5%85%E8%B0%88%E6%95%B0%E5%88%97%E4%B8%AD%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B1%82%E8%A7%A3/:0:0","tags":["常系数线性齐次递推关系"],"title":"浅谈数列中常系数线性齐次递推关系的求解","uri":"/2013/07/%E6%B5%85%E8%B0%88%E6%95%B0%E5%88%97%E4%B8%AD%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B1%82%E8%A7%A3/"},{"categories":["余音绕梁"],"content":"歌词如下： 春天的花开秋天的风，以及冬天的落阳 忧郁的青春年少的我，曾经无知的这么想 风车在四季轮回的歌里，它天天的流转 风花雪月的诗句里，我在年年的成长 流水它带走光阴的故事，改变了一个人 就在那多愁善感而初次，等待的青春 发黄的相片古老的信，以及褪色的圣诞卡 年轻时为你写的歌，恐怕你早已忘了吧 过去的誓言，就像那课本里缤纷的书签 刻划着多少美丽的诗，可是终究是一阵烟 流水它带走光阴的故事，改变了三个人 就在那多愁善感而初次，流泪的青春 遥远的路程昨日的梦，以及远去的笑声 再次的见面我们，又历经了多少的路程 不再是旧日熟悉的我，有着旧日狂热的梦 也不是旧日熟悉的你，有着依然的笑容 流水它带走光阴的故事，改变了我们 就在那多愁善感而初次，回忆的青春 流水它带走光阴的故事，改变了我们 就在那多愁善感而初次，回忆的青春 很珍惜这种感觉，和喜欢的歌不期而遇。 这首歌应该算是真正的老歌了，小时候听只是感觉好听，现在却更喜欢这其中一股淡淡的忧伤。 “流水它带走光阴的故事”句一下子化抽象记忆为形象可感的流水，还是可谓妙喻。 ","date":"2013-06-28","objectID":"/2013/06/%E5%85%89%E9%98%B4%E7%9A%84%E6%95%85%E4%BA%8B/:0:0","tags":null,"title":"光阴的故事","uri":"/2013/06/%E5%85%89%E9%98%B4%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["浮生杂记"],"content":"好久没来打理博客了，一直没时间。有时候想要写些文字也就这样耽搁了。比如说《谁是少数幸福的人——读\u003c红与黑\u003e有感》，这篇文章我写在了随笔本上，却一直没时间把它发到博客上来。慢慢发现现在我们自由支配的时间越来越少了，想要安安静静地阅读名家大作也就成了一种奢望。 高考三天在学校上课，我们在图文信息楼四楼最西边的小教室里。根据张伟兴的暗示，隔壁就成了食堂和棋牌室。三天上课，我们一共吃了三顿东池。中午休息的时候看电影，躲在心缘爱心社玩。还差点被周汉东抓到。高一的就没这么幸运了，第一天晚自习就吵得不得了，被王胖子轻而易举地抓了现行，揪去见张新宇了。然后王胖子带着他的战利品笑嘻嘻的来到我们教室说：高二的和高一的就是不一样，到底是有追求的了。 三天做了很多题目，其中最有趣的，被我们改编成课余娱乐项目的便是这道题目： 桌上放有$n$根火柴，甲乙二人轮流从中取走火柴。甲先取，第一次可取走至多$n-1$根火柴，此后没人每次至少取走1根火柴。但是不超过对方刚才取走火柴数目的2倍。取得最后一根火柴者获胜。问：当$n=100$时，甲是否有获胜策略？请详细说明理由。 但是每次玩的时候总是遇到一些小意外，明明处在必胜态，却一不小心走向了必败态。大家有兴趣的可以玩玩。 三天上课，也给了我近距离接触高考的机会。每场考试结束以后，我们可以近距离的接触考生，听他们谈论题目，甚至可以和他们进行一些交流。最激动人心的莫过于听了一次高考英语听力，当时走廊里站满了高二搞竞赛的人，努力的捕捉广播里蹦出的每一个词句。听完听力，我却有些迷惘了。是啊，我们马上就要高三了，要准备自主招生，准备高考。事情越来越多，任务也越来越繁重了。我也不知道高考那天我会是发挥的怎么样，或许命运的神奇之处就在于它的不可捉摸吧。 我最近时常在想一件事情，究竟什么才能够使得一个人获得真正的快乐。曾经在心理学的书中看到过这个问题，它所给出的解答是一种被誉为“自我实现”的马斯洛理论，也就是需求层次理论。以前我对于这一理论是非常认同的，不过现在我的想法开始有了些细微的改变。在我很小的时候，大概是小学吧，我总是喜欢和别人分享自己取得的成绩，获得的荣誉。或许这就是所谓的“自我实现”。但是现在我却更愿意藏巧于拙，将有才能的一方面隐藏起来，而显露出一些比较拙劣的方面。也不知道为什么，陈季伦总是叫我大神，搞得我不知所措。也有人说我是信息学大神，但是我却不是很喜欢这个头衔，所以每次有人问到我关于计算机方面的问题，除非特殊情况，我都会向他推荐李老师。有时候取得了一些小小的成绩，总想和朋友们一起分享，但是却发现大家都很忙，也就只好作罢了。 更多的时候，我在思考这样一件事情，为什么我和同龄的一些人差距这么大呢。为什么我不像他们一样好玩，为什么我不像他们一样喜欢玩游戏，为什么我不像他们一样满脑低俗的思想······相比之下，我却喜欢看各种书籍、资料，有时候甚至对他们的生存状态嗤之以鼻，究竟那种才是真正的，属于我们现在的，符合我们年龄的生存状态呢？并没有谁对谁错，谁是谁非，后来想想，仅仅是个人的选择不一样罢了。但我相信，十年后，二十年后，我不会为我现在所选择的不堕落的向上的生存状态而后悔，而他们，却谁也说不准。 最近发现了自己身上一个很大的毛病，我也不知道如何用语言来描述。或者可以称之为——不成熟。遇人遇事，处理的不够好，就比如说那次和舍管阿姨的争执。完全没必要那么激动。当然，也没惹出什么后果，甚至我开始怀疑那舍管阿姨是想自己讹点钱。因为如果真是学校要求我们赔偿，那么她没有理由不再来向我要钱。但是既然过去了，也就不管它了。但是有的是还是不能太冲动，做事不能不考虑后果。 言归正传，又瞎扯了好多，本来想好好规划一下接下来的极为珍贵的一年时光。 首先是在七月份的数学复赛，前几天和朱宇聊了聊，听他所说，通过这次选拔并不难，只需要做出那道平几。尽人事，听天命。很多事情都是这样的。 接下来当然是自主招生，根据近几年的招生简章，我应该是选择数学、物理这两门考试科目。对于数学学科，现在在数学组上课，接下来又要去扬州培训，这样下来，对于自主招生问题应该不会很大，只要平时在多刷刷题。物理却有点难度，因为物理竞赛的书很难啃啊。也不知道自主招生物理竞赛内容会占多大比例。 目前比较现实的学习方面的计划就是这两个了。 路漫漫其修远兮，吾将上下而求索！ ","date":"2013-06-12","objectID":"/2013/06/%E5%91%93%E8%AF%AD%E4%B8%89%E5%BD%B7%E5%BE%A8/:0:0","tags":["高中生活"],"title":"呓语（三）：彷徨","uri":"/2013/06/%E5%91%93%E8%AF%AD%E4%B8%89%E5%BD%B7%E5%BE%A8/"},{"categories":["数学之美"],"content":"前几天在数学组听课的时候，做平面几何的题目，遇到了塞瓦定理。当时赵诚宇给我讲了一遍，现在再把它整理一下。 塞瓦定理：在 $\\triangle ABC$ 中，若线段 $AD$、$BE$、$CF$ 通过同一点 $O$，则 $\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} =1$。 塞瓦定理逆定理：在 $\\triangle ABC$ 中，若点 $D$、$E$、$F$ 分别在边 $AD$、$BE$、$CF$ 上，且满足 $\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} =1$，则线段 $AD$、$BE$、$CF$ 共点或彼此平行。（我们在此只研究共点的情形） Ceva 定理示意图\" Ceva 定理示意图 证明如下： 首先 $$\\frac {BD} {DC}=\\frac {S_{\\triangle ABD}}{S_{\\triangle ADC}}=\\frac {S_{\\triangle OBD}}{S_{\\triangle ODC}} \\Rightarrow \\frac {BD} {DC}=\\frac {S_{\\triangle ABD}-S_{\\triangle OBD}}{S_{\\triangle ADC}-S_{\\triangle ODC}}=\\frac {S_{\\triangle ABO}}{S_{\\triangle CAO}}$$ 同理 $$\\frac {CE} {EA}=\\frac {S_{\\triangle BCO}}{S_{\\triangle ABO}},\\frac {AF} {FB}=\\frac {S_{\\triangle CAO}}{S_{\\triangle BCO}}$$ 因此 $$\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} = \\frac{S_{\\triangle ABO}}{S_{\\triangle CAO}} \\cdot \\frac{S_{\\triangle BCO}}{S_{\\triangle ABO}} \\cdot \\frac{S_{\\triangle CAO}}{S_{\\triangle BCO}}=1$$ 证毕。 例：在筝形 $ABCD$ 中，$AB=AD$，$BC=CD$，经 $AC$、$BD$ 的交点 $O$ 任做两条直线，分别交 $AD$ 于 $E$，交 $CD$ 于 $H$。$GF$、$EH$ 分别交 $BD$ 于 $I$，$J$。求证：$IO=OJ$。 Ceva 定理例题图\" Ceva 定理例题图 证明如下： 作 $\\triangle ABC$ 的关于 $AC$ 的对称图形，记 $E^{'}H^{'} \\cap BB=M$ 设 $\\angle GOB=\\angle BOH^{'}=\\alpha,\\angle E^{'}OG=\\angle FOH^{'}=\\beta$ 则有：$$\\frac{E^{'}G}{GB} \\cdot \\frac{BH^{'}}{H^{'}F} \\cdot \\frac{FM}{ME^{'}}=\\frac{OE^{'}\\sin \\beta}{OB \\sin \\alpha} \\cdot \\frac{OB \\sin \\alpha}{OF \\sin \\beta} \\cdot \\frac{OF \\sin \\left ( \\alpha + \\beta \\right )}{OE^{'} \\sin \\left ( \\alpha + \\beta \\right )}=1$$ 由塞瓦定理得：$MB$、$E^{'}H^{'}$、$GF$ 共点，因此 $IO=OJ$。证毕。 ","date":"2013-06-01","objectID":"/2013/06/%E6%B5%85%E8%B0%88%E5%A1%9E%E7%93%A6%E5%AE%9A%E7%90%86%E5%9C%A8%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["塞瓦定理"],"title":"浅谈塞瓦定理在平面几何中的应用","uri":"/2013/06/%E6%B5%85%E8%B0%88%E5%A1%9E%E7%93%A6%E5%AE%9A%E7%90%86%E5%9C%A8%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["浮生杂记"],"content":"NOIP 2012 获奖证书\" NOIP 2012 获奖证书 上面这张证书是星期四下午拿到的，至此 NOIP 2012 画上了一个不完美但却圆满的句号。 由于最近的一系列事件，加之以徐丹的高压政策下，我们被迫交出了机房的钥匙。一开始当然不会同意，但最后还是交出了钥匙。因为想明白了一些事情。首先，钥匙交给我们保管，是为了让我们在老师不在的时候可以进入机房得到联系。信息学不像数理化，只要一本题典，一堆草稿纸就可以应付的。但是，如果我们在机房，并不能干很多事情，并不能把时间全部高效利用，并不能 AC 更多的题目，而更多的时候是在磨洋工。那么这把钥匙给了我们，又有什么积极用处呢？在上交钥匙的时候，便决定以后周六、周日不再踏入机房。而周四，本来还想去联合电子看看的。不过徐丹非要把我们押在那里，看来计划又要有变化了。对于徐丹，并不是不尊重，而是她有时候说话的气焰太嚣张了。一个连 C++ 语法都讲不连贯的人，居然妄想着辅导我们算法，简直是可笑不自量。 本来打算彻底退出竞赛编制，自己在家里有空的时候刷题，毕竟距离初赛还有很长一段时间。但一时不知道怎么开口。至于原因，请允许我使用历史学科教导我的方法来简要分析一下：直接原因是徐丹索要钥匙事件；根本原因是对于竞赛时间不能得到合理利用的难以容忍，在此不一一例证。这样一来，便可心如不系之舟了。至于高三的竞赛，张兴老师希望我可以继续努力，争取拿到国一。只是担心那时候是否有足够的精力和时间，或者有没有别的优惠政策。毕竟取消报送，不论自己是否热爱这门竞赛，在高考这座大山的压迫下，还是会或多或少的丧失一点积极性的。 对于高一到高二复赛结束，这段竞赛经历将成为我永久的记忆。从中学到的领悟到的，远比寒窗十年所得要多得多。这一点，或许同样搞竞赛的人会有同感吧。接下来的内容是对于那段过往的一些回忆。 说起信息学竞赛，不得不提一提冯璞。我记得那时在高一上学期刚开学的时候，有一天中午和她聊天，说到赵之赫在跟一个老师（张兴）学编程，问我要不要一起去。说实话，我并不需要学，因为那些早就会了，只是对于这个话题比较感兴趣，所以就答应了。于是她把赵之赫妈妈的电话给了我。于是我便和赵之赫妈妈取得了联系，她又给了我张兴老师的电话，就这样，辗转多方，终于和张兴老师取得了联系。他和我说让我第二天下午早点去和他谈谈。 第一次，跑到信息楼三楼，等候在网管室门口。由于紧张，甚至误将一名学生认做了老师，搞得好尴尬。终于，张兴老师到了，给我第一印象是高级知识分子，技术宅，再后来的接触过程中也印证了我的想法。那天他和我谈了好多，关于编程，设计，美学…… 就这样，我通过非正当途径，成为了信息组的一员。那时候的信息组还是非常强大的，例如缪晓伟、张宇辰、周弋渊、王俊涛（《坐在生活的前排》范文的作者之一），这是我印象中高三神犇。在当时，高二的选手还欠火候，例如项业成、王意天、胡宇涛。不过有一点让我非常钦佩，他们在没有老师的情况下，都在认真刷题，也是由于受到他们的影响，为了竞赛，我戒了游戏。自此以后，再也没有碰过任何游戏。 第一次初赛，说实话，大家都没重视。毕竟只有高一嘛，还有机会。于是乎，差了 7 分出线，两道选择题。不过对我来说已经是一个非常好的成绩了。因为我是在十一长假七天内飞快的看完一本初赛书，就这样去裸考的。再加上一些自己曾经写代码的经验。几个辅导竞赛的老师大吃一惊，甚至说后悔当初没有考前专门辅导一下我。 初赛结束以后，距离信息组正式报名还有一段时间，这段时间内，我便在张兴老师的办公室内，有时候和他聊聊天，有时候他教我一些基本的算法。下学期，开始了正式的上课。内容分为三大块：C++、数据结构、算法。C++ 部分还是很轻松的，我还上了几节课。数据结构就不好说了，深似海啊。在讲到树、图的时候，已经缴械投降了。而且带着侥幸的想法，认为这就是最难的内容了。不过当时老师安慰我们说我们暑假要去常州培训，那个时候他们会给你们讲清楚的。 就这样，我们一直上课到暑假。期间我还去数学组客串了几节课，本想去听数论的，结果张伟兴就是不讲。到了暑假里，八月份的时候，我们又集中起来上课，每天晚上在机房里对着电脑调试代码到九点半。期间自称蒟蒻的神犇缪晓伟来给我们上了半天课。项业成给我们讲了并查集。后来又把我叫到准备室，给我讲了 DFS。 接下来就是振奋人心的常州之行。本以为可以疯玩了，结果除了第一天下午张春华老师带着我们参观了一个公园，以后就每天六点半起，十二点半睡，其余时间都在写代码，持续了一个星期。到最后整个人都瘫掉了。不过还是觉得很开心，因为学到了很多，见到了很多神犇。 就这样，迎来了初赛。在初赛前，抽了几节晚自习复习。初赛前一天本来是放假，但我还是留了下来，和项业成、王意天、胡宇涛一起复习，就这样看书看到第二天一点。初赛启程。2 个小时一会儿就过去了。我记得的玉米是第一个交卷的，不过出来的成绩并不理想。玉米和项业成都挺可惜的。我和胡宇涛过了初赛，接下来就是暗无天日的复赛刷题了。 停课刷题，我记得在短短的十几天里，我们一共刷了上百道题目。把前几年的复赛都做过了，并且立志要拿一等。在出征前，张春华老师还请我们吃了一顿饭，虽然是在学校食堂吃的，不过这份心意还是领了。 南航，淅淅沥沥的小雨。我们两个学生，加上张兴，三个人走在大道上，显得尤为渺小。复赛很快就结束了，唯一留下印象的，是南航极其优越的伙食。 等待结果是一个非常揪心的过程，因为有所期待。最后出来是二等，失落是肯定的，不过那个时候已经完全看透了。 随着高三神犇的离开，现在的信息组毫无生机，都是一些像我这样的蒟蒻。不堪回首。 ","date":"2013-05-18","objectID":"/2013/05/to-noip/:0:0","tags":["NOIP"],"title":"To NOIP","uri":"/2013/05/to-noip/"},{"categories":["数学之美"],"content":"我记得在计算机复赛前一天晚上本想看看同余方程的解法，结果第二天就考到了。明天是数学竞赛初赛，简略的复习一下线性同余及中国剩余定理，顺便记下一些笔记。 定理1：令 $m$ 为正整数。若 $\\begin{cases} a \\equiv b \\pmod m \\\\ c \\equiv d \\pmod m \\end{cases}$，那么 $\\begin{cases} a+c \\equiv b+d \\pmod m \\\\ ac \\equiv bd \\pmod m\\end{cases}$。 证明：因为 $\\begin{cases} a \\equiv b \\pmod m \\\\ c \\equiv d \\pmod m\\end{cases}$，所以有整数 $s$ 和 $t$ 使 $\\begin{cases} b=a+sm \\\\ d=c+tm\\end{cases}$。于是 $$ \\begin{cases} b+d=(a+sm)+(c+tm)=(a+c)+m(s+t)\\\\ bd=(a+sm)(c+tm)=ac+m(at+cs+stm) \\end{cases} \\Rightarrow \\begin{cases} a+c \\equiv b+d \\pmod m \\\\ ac \\equiv bd \\pmod m \\end{cases}$$ 例：由于 $\\begin{cases} 7 \\equiv 2 \\pmod 5 \\\\ 11 \\equiv 1 \\pmod 5\\end{cases}$，从定理1知 $\\begin{cases} 18 = 7+11 \\equiv 2+1=3 \\pmod 5 \\\\ 77 = 7 \\cdot 11 \\equiv 2 \\cdot 1=2 \\pmod 5\\end{cases}$。 定理2：如果 $a$ 和 $m$ 为互素的整数，$m \u003e 1$，则存在 $a$ 的模 $m$ 的逆。而且这个逆模 $m$ 是唯一的。（即有小于 $m$ 的唯一正整数 $\\overline{a}$，如果这样的 $\\overline{a}$ 存在的话。这样的 $\\overline{a}$ 称为 $a$ 模 $m$ 逆，且 $a$ 的任何别的模 $m$ 逆均和 $\\overline{a}$ 模 $m$ 同余。） 证明：由定理 1 及 $\\gcd \\left ( a,m \\right )=1$ 知，有整数 $s$ 和 $t$ 使 $$sa+tm=1$$ 于是 $$sa+tm \\equiv 1 \\pmod m$$ 由于 $tm \\equiv 0 \\pmod m$，所以 $$sa \\equiv 1 \\pmod m$$ 结论是 $s$ 为 $a$ 的模 $m$ 逆。 例：求 $3$ 的模 $7$ 逆。 解：由于 $\\gcd \\left ( 3,7 \\right )=1$，定理 3 说明存在 $3$ 模 $7$ 的逆。若用欧几里得算法求 $3$ 和 $7$ 的最大公约数，算法很快结束：$$7=2 \\cdot 3 + 1$$ 从这一等式看到 $$-2 \\cdot 3 + 1 \\cdot 7=1$$ 这说明 -2 是 3 模 7 的一个逆。（注意，模 $7$ 同余于 $-2$ 的每个整数也是 $3$ 的逆，例如 $5,-9,12$ 等。） 例：求线性同余 $3x \\equiv 4 \\pmod 7$ 的解。 解：易知 $-2$ 是 $3$ 模 $7$ 的逆。在同余式的两边同乘以 $-2$ 得 $$-2 \\cdot 3x \\equiv -2 \\cdot 4 \\pmod 7$$ 因为 $\\begin{cases} -6 \\equiv 1 \\pmod 7 \\\\ -8 \\equiv 6 \\pmod 7\\end{cases}$，所以若 $x$ 是解，必有 $$x \\equiv -8 \\equiv 6 \\pmod 7$$ 于是由定理 1，有 $$3x \\equiv 3 \\cdot 6 \\equiv 18 \\equiv 4 \\pmod 7 $$ 这说明所有这种 $x$ 满足问题中的同余式。结论是，同余方程的解是使 $x \\equiv 6 \\pmod 7$ 的整数。 从有关线性同余系统的中国古典问题而得名的中国剩余定理，可以这样叙述：只要线性同余系统的模数两两互素，则该系统有解，而且以所有模数之乘积取模，解是唯一的。 定理3（中国剩余定理）：令 $m_{1},m_{2},\\cdots,m_{n}$ 为两两互素的正整数，则同余方程组 $$ \\begin{cases} x \\equiv a_{1} \\pmod {m_{1}}\\\\ x \\equiv a_{2} \\pmod {m_{2}}\\\\ \\vdots \\\\ x \\equiv a_{1} \\pmod {m_{n}} \\end{cases}$$ 唯一的模 $m=m_{1}m_{2} \\cdots m_{n}$ 解。（即有一个解 $x$，使 $0 \\leq x \\leq m$，且所有其他的解均与此解模 $m$ 同余。） 证明：要建立这一定理，需要证明有一个解存在，而且是模 $m$ 唯一的。下面将给出构造这样一个解的方法以证明解的存在。 要构造一个适合各方程的解，首先对 $k=1,2, \\cdots ,n$，令 $M_{k}=\\frac{m}{m_{k}}$，即 $M_{k}$ 是除 $m_{k}$ 以外所有模数的乘积。由于 $i \\neq k$ 时，$m_{i}$ 和 $m_{k}$ 没有大于 1 的公因子，所以 $\\gcd \\left ( m_{k},M_{k} \\right )=1$。从而由定理 2 知有整数 $y_{k}$，即 $M_{k}$ 模 $m_{k}$ 的逆，使得 $$M_{k}y_{k} \\equiv 1 \\pmod {m_{k}}$$ 要得到适合所有方程的解，令 $$x=a_{1}M_{1}y_{1}+a_{2}M_{2}y_{2}+\\cdots+a_{n}M_{n}y_{n}$$ 现要证明 $x$ 就是这样一个解。 首先注意，由于只要 $j \\neq k$，就有 $M_{j} \\equiv 0 \\pmod {m_{k}}$，在 $x$ 的求和表达式中除第 $k$ 项以外的各项模 $m_{k}$ 均同余于 $0$。由于 $M_{k}y_{k} \\equiv 1 \\pmod {m_{k}}$，可以看出对 $k=1,2, \\cdots ,n$，均有 $$x \\equiv a_{n}M_{n}y_{n} \\equiv a_{k} \\pmod {m_{k}}$$。这就证明了 $x$ 是这 $n$ 个同余方程的公共解。 例：求同余方程组 $\\begin{cases} x \\equiv 2 \\pmod 3\\\\ x \\equiv 3 \\pmod 5\\\\ x \\equiv 2 \\pmod 7 \\end{cases}$ 的解。 解：首先令 $m=3 \\cdot 5 \\cdot 7=105$，$M_{1}=\\frac {m} {3}=35$，$M_{2}=\\frac {m} {5}=21$，$M_{3}=\\frac {m} {7}=15$。可看到 $2$ 是 $M_{1}=35$ 的模 $3$ 逆，因为 $35 \\equiv 2 \\pmod 3$；$1$ 是 $M_{2}=21$ 的模 $5$ 逆，因为 $21 \\equiv 1 \\pmod 5$；$1$ 也是 $M_{3}=15$ 的模 $7$ 逆，因为 $15 \\equiv -1 \\pmod 4$。于是这一方程组的解是满足下列式子的那些 $x$： $$ x \\equiv a_{1}M_{1}y_{1}+a_{2}M_{2}y_{2}+a_{3}M_{3}y_{3}=2 \\cdot 35 \\cdot 2 + 3 \\cdot 21 \\cdot 1 + 2 \\cdot 15 \\cdot 1=233 \\equiv 23 \\pmod {105} $$ 可以见 $23$ 是所有解当中最小的正整数。结论是 $23$ 是最小的正整数，除以 $3$ 时余 $2$，除以 $5$ 时余 $3$，除以 $7$ 时余 $2$。 ","date":"2013-05-04","objectID":"/2013/05/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E5%8F%8A%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/:0:0","tags":["线性同余"],"title":"浅谈线性同余及中国剩余定理","uri":"/2013/05/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E5%8F%8A%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"categories":["浮生杂记"],"content":"向生命的来处张望，不禁唏嘘，时光竟如此匆匆流过。 现在的我已是一名高二的学生，想想明年就要高考，却和理想的大学相差一些距离。前一阵子看了一本书，讲的是一个英语成绩班级倒数的人通过三年的努力成为全省第五的故事。当时感到了一股强大的正能量，过了几天，我根据自己的情况，也制定了一份计划，把刷英语由原来的自发变成了自觉。最近各门科目，尤其是理科上课教的非常快。似乎老师们都认为，把知识讲完了，通过做题就可以把那些没弄懂的都巩固了。这种思维固然不错，但是却显露着填压式教育的影子。 最近慢慢的，真的懂得了学习。以前就好比是在黑暗的泥泞中摸着石头过河，却总是失足落水。我们的学习并不是为了老师，并不是为了父母，抑或其他。不认真便是对自己的不负责任。但是尽力的，却另当别论。但是科学研究表明，人类的潜力是非常巨大的，所以对于这五门学科，只要肯下工夫，并不存在任何问题。但是如果把所有的经历都放在了这上面，生活就未免有些单调。对我来说，也是不现实的。 喜欢在闲暇的午后，泡上一杯茶，预约一本好书。对于这个信息爆炸的时代，基本上任何人都可以写上一本书。但是那些所谓所谓的作家也仅仅是徒有其表。我对于书籍一直有一种纯净的观念，认为那些毫无思考力的言情玄幻等根本无法称作是书籍。否则，为什么历史上没有流传下来任何类似的书籍呢。个人比较倾向于文学，哲学，历史。这里不得不提一提历史方面的书籍，自从当年明月的《明朝那些事》出版以后，各种类似的书就层出不穷，质量也是良莠不齐。我觉得对于这种现代人改写的历史小说，一定程度上加入了作者自己的观点和看法，并不能很好的还原事情的真实面貌。由于吃过几次这样的亏。所以对于历史方面，我便倾向于看二十四史。虽然是拗口难懂的文言文，但是读上去比那些白话文的改编版清爽多了。 最近很喜欢品茶。一来它可以提神醒脑，而且不像咖啡一样对神经系统具有副作用；二来它可以是一个人静下来，更可以洗净一个人内心的浮躁与污垢。感觉灵魂更加纯洁，高尚。周红娟戏称为养生，或许这也是一个原因吧。但对于我来说，最重要的是第二点。最近总有些莫名其妙的浮躁，可能是气温升高了，功课也比较繁重，这主观与客观的交汇导致的吧。 最近在看《红与黑》，目前为止看完了上卷，却给了我很深的思考。让我联想到了当初学习《周易》时候的一句话： 看到的都是表象。 我们在这个世界，看到的是不是也都是表象？我来创造一个词，暂且叫作“快餐式友情”。我想大家身边都不缺乏朋友，而且我们也可以很快的和陌生人聊得很好，成为朋友。但是，你们之间有足够的信任吗？不要急着给出答案，仔细思考。 最近自己变得不怎么喜欢说话了，追根溯源，竟是张兴曾经和我说过的一句话： 不要和那些人一样，整天谈那些无聊没用的东西。说话要一针见血。 要忍住寂寞，才能成功。 这两句话给我的影响的确很大，本来我就感觉自己和他们在讨论一些无聊的话题时很不自在。不讨论反倒好多了。这样也就有更多的精力去考虑别的我感兴趣的事情了。对于第二句话，应该是放之四海皆准的真理吧，纵观古今之外，哪一个成功的人不是如此？如果有例外，那一定是他不够成功。 本来有很多想写的，写到这突然没了思绪了，那就到这吧。 ","date":"2013-04-29","objectID":"/2013/04/%E5%91%93%E8%AF%AD%E4%BA%8C%E6%84%9F%E6%82%9F/:0:0","tags":["高中生活"],"title":"呓语（二）：感悟","uri":"/2013/04/%E5%91%93%E8%AF%AD%E4%BA%8C%E6%84%9F%E6%82%9F/"},{"categories":["数学之美"],"content":"最近数学课上讲了矩阵，很久以前便对矩阵很有兴趣，但由于一些原因没有深入学习。正好趁这个机会，有思考了一下关于矩阵的内容。目前应用较广的应该是运用逆矩阵求解线性方程组，尤其对于三元一次方程组，运用逆矩阵求解会非常方便。 一个方形矩阵的伴随矩阵是一个类似于逆矩阵的概念。如果矩阵可逆，那么它的逆矩阵和它的伴随矩阵之间只差一个系数。然而，伴随矩阵对不可逆的矩阵也有定义，并且不需要用到除法。我们对这种情况不做深入讨论。 引理1：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，以及两个整数 $i,j$，其中 $1\\leq i,j\\leq n$。去掉 $\\mathbf{A}$ 的第 $i$ 行以及第 $j$ 列，得到一个 $n-1$ 阶子矩阵。记这个子矩阵的行列式为 $\\mathbf{M}_{ij}$。称为余子式。 引理2：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，代数余子式是余子式 $\\mathbf{M}_{ij}$ 与 $\\left ( -1 \\right )^{i+j}$ 的乘积，记作 $\\mathbf{C}_{ij}$。 例：对于矩阵 $\\begin{bmatrix} 1 \u0026 4 \u0026 7\\\\ 3 \u0026 0 \u0026 5\\\\ -1 \u0026 9 \u0026 11 \\end{bmatrix} $，计算它的代数余子式 $\\mathbf{C}_{23}$。 解：首先计算余子式 $\\mathbf{M}_{23}$，即原矩阵去掉第二行以及第三行所得的矩阵的行列式：$ \\begin{bmatrix} 1 \u0026 4 \u0026 \\bigcirc \\\\ \\bigcirc \u0026 \\bigcirc \u0026 \\bigcirc \\\\ -1 \u0026 9 \u0026 \\bigcirc \\end{bmatrix} $，即 $ \\begin{vmatrix} 1 \u0026 4\\\\ -1 \u0026 9 \\end{vmatrix} = \\left ( 9-\\left ( -4 \\right ) \\right )=13 $。因此 $ \\mathbf{C}_{23}=\\left ( -1 \\right )^{2+3}\\cdot M_{23}=-13$。 引理3：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，由代数余子式组成的新的矩阵，称为该矩阵的余子矩阵。记作 $\\mathbf{C}$。 引理4：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，定义它的转置矩阵 $\\mathbf{A^{T}}$。转置矩阵 $\\mathbf{A^{T}}$ 可以通过下列操作得到：把 $\\mathbf{A}$ 的横行写为 $\\mathbf{A^{T}}$ 的纵行，把 $\\mathbf{A}$ 的纵行写为 $\\mathbf{A^{T}}$ 的横行。 例：$ \\begin{bmatrix} 1 \u0026 2\\\\ 3 \u0026 4 \\end{bmatrix}^{T}=\\begin{bmatrix} 1 \u0026 3\\\\ 2 \u0026 4 \\end{bmatrix} $。 引理5：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，它的余子矩阵 $\\mathbf{C}$ 的转置矩阵称为矩阵 $\\mathbf{A}$ 的伴随矩阵。记作 $\\mathbf{A^{*}}=\\mathbf{C^{T}}$。 例：对于矩阵 $ \\mathbf{A}=\\begin{bmatrix} a \u0026 b\\\\ c \u0026 d \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。 解：$ \\mathbf{A^{*}}=\\begin{bmatrix} \\mathbf{C}_{11} \u0026 \\mathbf{C}_{12}\\\\ \\mathbf{C}_{21} \u0026 \\mathbf{C}_{22} \\end{bmatrix}^{T}=\\begin{bmatrix} \\mathbf{M}_{11} \u0026 -\\mathbf{M}_{12}\\\\ -\\mathbf{M}_{21} \u0026 \\mathbf{M}_{22} \\end{bmatrix}^{T}=\\begin{bmatrix} d \u0026 -c\\\\ -b \u0026 a \\end{bmatrix}^{T}=\\begin{bmatrix} d \u0026 -b\\\\ -c \u0026 a \\end{bmatrix}$。 例：对于矩阵$ \\mathbf{A}=\\begin{bmatrix} a_{11} \u0026 a_{12} \u0026 a_{13}\\\\ a_{21} \u0026 a_{22} \u0026 a_{23}\\\\ a_{31} \u0026 a_{32} \u0026 a_{33} \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。 解：$$\\begin{align*} \\mathbf{A^{*}} \u0026=\\begin{bmatrix} \\mathbf{C}_{11} \u0026 \\mathbf{C}_{12} \u0026 \\mathbf{C}_{13}\\\\ \\mathbf{C}_{21} \u0026 \\mathbf{C}_{22} \u0026 \\mathbf{C}_{23}\\\\ \\mathbf{C}_{31} \u0026 \\mathbf{C}_{32} \u0026 \\mathbf{C}_{33} \\end{bmatrix}^{T}\\\\ \u0026=\\begin{bmatrix} \\mathbf{M}_{11} \u0026 -\\mathbf{M}_{12} \u0026 \\mathbf{M}_{13}\\\\ -\\mathbf{M}_{21} \u0026 \\mathbf{M}_{22} \u0026 -\\mathbf{M}_{23}\\\\ \\mathbf{M}_{31} \u0026 -\\mathbf{M}_{32} \u0026 \\mathbf{M}_{33} \\end{bmatrix}^{T} \\\\ \u0026= \\begin{bmatrix} \\begin{vmatrix} a_{22} \u0026 a_{23}\\\\ a_{32} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{21} \u0026 a_{23}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{21} \u0026 a_{22}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix}\\\\ -\\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{32} \u0026 a_{33} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix}\\\\ \\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{22} \u0026 a_{23} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{21} \u0026 a_{23} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{21} \u0026 a_{22} \\end{vmatrix} \\end{bmatrix}^{T}\\\\ \u0026=\\begin{bmatrix} \\begin{vmatrix} a_{22} \u0026 a_{23}\\\\ a_{32} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{32} \u0026 a_{33}\\end{vmatrix} \u0026 \\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{22} \u0026 a_{23} \\end{vmatrix}\\\\ -\\begin{vmatrix} a_{21} \u0026 a_{23}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{21} \u0026 a_{23} \\end{vmatrix}\\\\ \\begin{vmatrix} a_{21} \u0026 a_{22}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{21} \u0026 a_{22} \\end{vmatrix} \\end{bmatrix} \\end{align*} $$ 其中 $\\begin{vmatrix} a_{im} \u0026 a_{in}\\\\ a_{jm} \u0026 a_{jn} \\end{vmatrix}=a_{im}\\cdot a_{jn}-a_{in}\\cdot a_{jm}$。 例：对于矩阵 $\\mathbf{A}=\\begin{bmatrix}-3 \u0026 2 \u0026 -5\\\\ -1 \u0026 0 \u0026 -2\\\\ 3 \u0026 -4 \u0026 1 \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。 解：通过计算不难得出 $\\mathbf{A^{*}}=\\begin{bmatrix} -8 \u0026 18 \u0026 -4\\\\ -5 \u0026 12 \u0026 -1\\\\ 4 \u0026 -6 \u0026 2 \\end{bmatrix}$。 引理6：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，它的逆矩阵 $","date":"2013-04-29","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5%E5%9C%A8%E9%80%86%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["伴随矩阵"],"title":"浅谈伴随矩阵在逆矩阵求解中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5%E5%9C%A8%E9%80%86%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"前几天在做化学竞赛初赛试题时遇到一道关于富勒烯衍生物的习题。大意是求 $\\mathrm{C_{50}Cl_{10}}$ 中单键的个数。但是去问浦建芳，她把施锦元叫了上来，大师兄便给我讲了欧拉公式。当天晚上没有完全弄清楚，回家谷歌以后，现在将内容整理如下。（以 $\\mathrm{C_{50}Cl_{10}}$ 为例） ","date":"2013-04-21","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["富勒烯"],"title":"浅谈欧拉公式在富勒烯及其衍生物中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"1、求 $\\mathrm{C_{50}Cl_{10}}$ 中五边形以及六边形的个数 这类题目可以应用欧拉公式，设 $\\mathrm{C_{50}Cl_{10}}$ 中存在 $x$ 个五边形及 $y$ 个六边形。由欧拉公式可以得到结果： $$ \\begin{cases} 50+x+y=\\frac{5x+6y}{2}+2 \\\\ 50\\times \\frac{3}{2}=\\frac{5x+6y}{2} \\end{cases}\\Rightarrow \\begin{cases}x=12 \\\\ y=15\\end{cases} $$ ","date":"2013-04-21","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:1:0","tags":["富勒烯"],"title":"浅谈欧拉公式在富勒烯及其衍生物中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"2、求 $\\mathrm{C_{50}Cl_{10}}$ 中单键的个数 对于这类题目，可以考虑这样的一个加成反应：$\\mathrm{C_{50}+5Cl_{2}} \\rightarrow \\mathrm{C_{50}Cl_{10}}$。这样的话，我们可以首先考虑 $\\mathrm{C_{50}}$，根据（1）中方法求出其中五边形以及六边形的个数。从而得到一共有 75 根碳碳键。 考虑到 $\\mathrm{C_{50}}$ 中每个碳原子边上有两个碳碳单键一根碳碳双键，即可得到碳碳单键数目是碳碳双键数目的两倍。这样可以确定 $\\mathrm{C_{50}}$ 中有 50 根碳碳单键，25 根碳碳双键。 接着考虑加成的过程，在上述加成反应的过程中，断开了 5 根碳碳双键，这样就新形成了 5 根碳碳单键，从而得到 $\\mathrm{C_{50}Cl_{10}}$ 中共有碳碳单键 55 根。 ","date":"2013-04-21","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:2:0","tags":["富勒烯"],"title":"浅谈欧拉公式在富勒烯及其衍生物中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["浮生杂记"],"content":"好久没更新博客了。英语课上把博客地址写在了黑板上，不知道郭华老师和周红娟老师会不会光临这么一个小角落。第一反应是博客的访问量可能会增加，接着就想到：如果周红娟老师看到我写的这些文章，岂不是贻笑大方。 先来说说卖泡面的事情吧。经过一个寒假的考虑和筹划。准备这个学期搞得稍微正规点。所以在开学的时候准备发行债券，无奈去年出现一例质量问题，所以没人敢买债券。既然这条融资途径无效，那么只能自己先垫出一部分。于是乎，昨天又去进货了，而且列了进货清单。还得感谢 Microsoft OneNote——这款平时用来记笔记的软件，在这种情况下也可以用来记录销售情况。 前段时间给自己的小卖部起了个名字——斯凯泰。开发了一个网上订购系统，主要解决有的时候同学来买泡面，却发现水不够了，或者卖完了。通过网上订购系统，可以提前预订，这样就可以预留出订购者所需要的数目。网站做的很简单，只是实现了基本功能。 对于卖泡面，完全没有什么资本家的意思。只是为了娱乐一番，同时积累积累经验。所以这学期价格会有所下调。 时间过得好快，转眼一年又过去了。昨天晚上黄旸洋打来电话，聊了好久。彼此好久没联系了，但还是感觉那么亲近，或许这就是王勃所说的“海内存知己，天涯若比邻。”吧。聊的内容自然无外乎那几样，只是感觉大家似乎变了，似乎又没变。他还提起了很久以前的一个项目，重新做一下初中的毕业视频。他说，为了这个，他在学 PS, PR, AE。一直有这么一个想法，只是心有余而力不足。现在总算空下来了，也该把这个未完成的项目继续下去。 通知： 烦请张家港市常青藤实验中学 2011 级初三（3）班的同学将你们对于接下来我和黄旸洋合作的这一毕业视频提供可行性建议以及必要的素材。建议包括整体构思，画面效果等；素材包括图片，声音，文字，视频等。一切内容请发到邮箱：admin@ivy-end.com，发送时请注明姓名。 小高考结束以后，的确像玉米他们所说，很空。数学，化学，生物三门竞赛的轮番轰炸让人喘不过气来。对于生物竞赛，没有资料，也未曾深入了解，所以只能作罢。对于数学和化学，倒是有希望出线。但是一节晚自习只能做两道不等式或者 15 道化学选择题。这的确让人感到无奈。 化学很多内容没教过，工艺流程完全不会。而且化学反应平衡和离子反应都没讲，很多以前学过的都忘记了。不过想想也对，如果这么简单就让我们过了初赛，那岂不是太看不起化学竞赛了。只是一点想不通，为什么数理化生初赛学校都会派出分母，而我们信息学却完全没有。而且我们的试卷费只要 10 元。 这段比较空闲的时间应该规划一下，好好利用。语文上的古诗，的确挺诗情画意的，但是我们却始终无法达到唐人的那种境界，只能以一种仰望的姿态去欣赏。首先当然是数学竞赛，好好准备一下吧。其次，最近冒出一个很奇怪的想法，想系统的看一下关于中医方面的书。或许只是想法吧。 宿舍又扣分了，作为室长的我免不了背黑锅。权利和义务是相统一的嘛。 古人云：一日三省吾身。最近又冒出一个想法，还是关于理性和感性的问题。或许大多数在不涉及原则问题的情况下还是感性比理性更为好吧。很多事情没必要寻根问底。以前可能太过于理性了吧。有个称呼叫死理性派。这样不好。 我也不知道自己写了些什么，感觉最近一段时间，想说的内容很多，却发现写不下来什么了。 好吧，先到这。 ","date":"2013-04-04","objectID":"/2013/04/%E6%9D%82%E8%AE%B020130404/:0:0","tags":["高中生活"],"title":"杂记（20130404）","uri":"/2013/04/%E6%9D%82%E8%AE%B020130404/"},{"categories":["浮生杂记"],"content":"高中的一个重要的转折点——小高考，就这样过去了。写下一篇日志来记录一下小高考复习期间的一些感受和想法。打点计时器真可谓是人类一项伟大的发明。 这段时间，思考了很多，体会了很多，感悟了很多。且听我慢慢道来。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年只相似。 短短的四句诗，却透出了人生渺小宇宙无限的感慨。我们终究是很渺小的，微不足道，试问千万年后，我们又在哪里呢？生命是那么渺小，于己，对于这个世界，我们有多大的意义呢？或许最大的意义就是不要让生命留下遗憾吧。于他，我们又为何要让俗世凡尘的喧杂打搅了平静的内心呢。或许庄子是正确的，我们的确应该逍遥游。感觉很多事情是没有结果的，很多事情是徒劳无功的。是我超脱了，还是我才是真正蒙在鼓里的人。或许我们都只是上帝的玩偶，不幸的是，上帝喜欢掷骰子。突然想起一首诗： 虞美人·听雨 —宋·蒋捷 少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低断雁叫西风。 而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前点滴到天明。 人生无常，总有许多美好的事物，在你还没来得及珍惜的时候悄然逝去，不论是亲人，信念，抑或其他。而对于我们，所能做的，也唯有好好珍惜每一天吧。一直很欣赏乔布斯的一句话“记住你即将死去。”，但是我始终无法做到。或许是因为他的经历使然吧。 对于人生的思考大概就是这样了，接下里就是对马克思主义哲学的怀疑了。 首先，根据“矛盾是普遍的。我们要用一分为二的观点看问题。”那么，马克思主义哲学是否具有另一面呢。这不禁引起了我的思考。后来，对这一原理越来越感到不可信，事事有矛盾，时时有矛盾。而且还要求我们用联系，发展，全面的观点看问题，试问，这样一来，岂不是陷入了相对主义的泥潭？再者，马克思主义哲学中的辩证法是从黑格尔那里继承下来的。大家都知道，黑格尔是近代西方唯心主义的集大成者。而对于这一继承，居然只是简简单单的说“马克思主义哲学剔除了黑格尔辩证法中唯心主义的成分”，这显然是不现实的。所以说辩证法有唯心主义的漏洞，这也就很容易解释为什么它会陷入相对主义了。 对于世界观这一方面，我比较倾向于老子。对于庄子也有些可借鉴之处。 以上便是我最近思想方面的记录了。下面主要来谈谈生活和学习方面的吧。 最让我感到吃惊的是历史成绩吧，从一模 53 到二模 77 再到三模 85 。该怎么评价这件事情呢，该说我有潜力呢，还是该说我以前根本不认真呢。刚开始觉得半个月背书一定很无趣，没想到还真挺充实的。因为一根弦紧绷着，就没时间去管别的了。 考试前一天，感冒了，到了晚上发烧。幸好及时吃了退烧药。虽然考试的时候没有头痛，但还是感到很困。不过到了下午考生物的时候已经基本清醒了，至于政治，其实没什么区别，因为用不着动脑子，只要把背的搬上去。总之，小高考已经考完了，对于过程，无怨无悔。至于结果怎么样，还是得看运气。 越来越有种感觉，考试结果，和水平没有太大的关系，最主要的是运气。就好比上次有一场比赛，一位神犇辛辛苦苦花了一个多小时写了几百行代码，0 分；一位蒟蒻，几分钟写了个随机数，100 分。这就是运气。我们无法把握，因为是上帝在掷骰子。人生的戏剧性就在于，你可以努力的很多很多，虽然它占据了 99% 的比例，但取决定作用的 1% 却在上帝手中。就好比爱迪生的名言“成功是 99% 的勤奋加上 1% 的天才，但往往那 1% 是最重要的”。 以后我再也不用知道如何促进我国国民经济又好又快发展了 以后我再也不用知道如何正确看待反经济全球化了 以后我再也不用知道如何防治我国西北荒漠化了 以后我再也不用知道生一个即患白化又患色盲的孩子的概率了 这究竟是福是祸，以后我们就再也见不到小四门老师了。马静华，翟玉明，盛费兵，张书玉。学了那么多仅仅是为了一场考试？突然想起中考，是淡淡的忧伤吗？ 不管怎么说吧，既然考完了，也就过去了。感觉一个人突然松了下来。又发现还有很多事情等着我去处理，不管是生活，学习，竞赛。是该好好缕缕了。接下来应该要开始准备自招吧。也不知道玉米考的咋样，到现在也不透个风声。为了吸取了玉米来不及准备的经验，所以过一段时间就开始吧。至于竞赛，张兴让我给高一竞赛的上课。所以还要做课件。讲课对于自己巩固所学，的确很有帮助。主要讲数据结构。 好了，就这样吧。 接下来的道路会更崎岖。 ","date":"2013-03-17","objectID":"/2013/03/%E4%B8%BA%E5%B0%8F%E9%AB%98%E8%80%83%E6%89%93%E4%B8%AA%E7%82%B9/:0:0","tags":["高中生活"],"title":"为小高考打个点","uri":"/2013/03/%E4%B8%BA%E5%B0%8F%E9%AB%98%E8%80%83%E6%89%93%E4%B8%AA%E7%82%B9/"},{"categories":["浮生杂记"],"content":"先来谈谈最近很火的《新笑傲江湖》吧。抱着对金庸小说《笑傲江湖》的喜爱，尝试得看了第一集，细细的看了第二集，忍耐的看了第三集，然后，就没有然后了。 首先引用一些外界评论吧： 看于正才知张纪中厚道 大家都知道，张纪中拍摄的《新西游记》对原著改变有点大，所以放映出来大家反应很强烈。当时也尝试性得看了几集《新西游记》，还可以接受一部分。但是《新笑傲江湖》简直无法直视。没看到几个原著中的剧情。还有人物塑造方面，就拿令狐冲来说吧，毫无洒脱、侠义之气，说文明些，完全就是一个嬉皮士。当然这是由于我们和编剧的世界观差异导致的。最主要的问题是色彩绚丽，华而不实，毫无一点武侠的痕迹。而且很多台词不符合客观规律。不论是改编的内容还是剧中传递出来的一种精神，都与原著差距甚远。可能编剧只是考虑到了部分受众的喜好以及经济利益吧。 再来看看很久以前金庸接受南方周末采访的记录，虽然是家比较早，但却可以看出金老先生对改编电视剧的态度： 南方周末：您的作品大部分被改成了电视剧和电影，早期的香港版追求娱乐性，台湾版追求煽情，大陆版看重的是小说的道德意识和精神高度，正剧色彩比较浓，您喜欢哪一种风格的改编？ 金庸：小说是当文学作品来看的，人家都说文学作品有真、善、美的追求，在作品里我只追求美的范畴，跟真、善没有关系，把我所喜好的所见的美好融到作品里面去。两岸三地拍电视剧我不关心，他们追求什么样的风格，和他们的市场有关，跟我没有关系，人家喜欢拍就拍，我只关注电视剧是否忠实于小说原著，这一点我比较在乎。 再引用金庸以前接受采访时说过的一句话： 那些作品都好比是我的儿子，而改编就好比他要出远门，把儿子托付给别人照顾，结果回家时发现儿子被打得面目全非。 对于一部电视剧的看法与个人世界观以及以往接触的人、事、物都有关系，所以对于《新笑傲江湖》，虽然不喜欢看，但它总有存在的意义，或积极，或消极。如若想真正品味《笑傲江湖》，还是推荐看原著。至于这本书，我的感想很多，有很多细枝末节的感触，大体就像《笑傲江湖李亚鹏版》的插曲《天地作合》所描述的那样吧——凌万物而超脱。 扯远了。最近在思考一些问题，好像有点宽泛而且不切实际，却着实让自己感到迷茫。算是哲学范畴的吧——我们如何才能在这个世界上活得更有意义？ 只有献身社会，才能找出那实际上最短暂而有风险的生命的意义。——爱因斯坦 人的意义在于为社会创造出价值，从而以人类的进步推动社会的进步。——马克思 生命是有限的，但为人民服务是无限的，我要把有限的生命投入到无限的为人民服务之中去。——雷锋 类似的话语还有很多，那么当时间以万亿年为尺度向前行进，那么现在的人类社会又会在哪里呢？我们对社会的贡献、付出有在哪里呢？难道我们就应该享受生活，放任自流？整日这样的生活未免像一潭死水，太无趣。那我们到底在追求什么呢？或许这就是短暂生命和永恒宇宙的矛盾吧。我们该怎么做呢，思前想后，还是感到活在当下，不留遗憾最为实际。至于怎么活，Steven Jobs 的观点十分值得借鉴： Follow your heart. Stay hungry, stay foolish. 或许思考这些没有太多的现实意义，但的确可以让自己找到一点方向。每天，太阳还是依旧升起，一切还是依旧，所以也就没必要想那么多了。接着再来说一些感悟吧。假期不知不觉就过去了，曾经在《呓语（一）：无题》中引用过一句话： 而放假绝不是最终的出路，因为我们并没有假期，所谓的假期也只是自我欺骗。 当时仅仅觉得这句话很有意味，这几天却突然领悟了。人生就像一场旅行，我们需要不断拼搏，所谓的假期，只是另外一种形式的奋斗罢了。这些动力，并不仅仅是为了 4A。 再说说前几天修改的网站副标题——“上善若水，大道至简。”。第二句很容易理解，主要谈谈第一句： 上善若水。水善利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，政善治，事善能，动善时。夫唯不争，故无尤。——老子《道德经》 翻译想必是没有必要了。其中几句值得斟酌，“处众人之所恶，故几于道”。是因为“处众人之所恶”导致了“故几于道”还是“故几于道”引起了“处众人之所恶”？个人认为可能是后者，在当代社会中，毕竟糊涂人远多于明白人，而明白人中又有糊涂人。所以说真正的明白人才可以达到“故几于道”的境界。但这样又产生了一个问题，我们首先参考一下马克思主义哲学的相关内容： 物质决定意识，意识对物质具有反作用。 价值观作为一种社会意识，对社会存在具有重大的反作用，对人们的行为具有重要的驱动、制约和导向作用。 价值观对人们认识世界和改造世界的活动具有重要的导向作用。 价值观对人生道路的选择具有重要的导向作用。 有了这些内容作为指导，我们不难得出，当那些真正的明白人到达一定境界时，所作所为就会与常人不同。而这时候人们却常常鄙夷的称他们清高。岂不冤哉？（排除某些故意装作清高之人，此类人无法称之为明白人）这类问题在生活中经常出现，两个世界观不同的人争论问题是毫无意义的。世界观在不违背到的前提下本没有对错。面对这些，还是那句老话： 穷则独善其身，达则兼济天下。 有个比较远的话题吧——人生漫漫长路，会遇到很多人，很多事，我们怎么面对现在呢？欢迎来这里讨论。 扯了好多，这也许就是我目前的思想状态吧。 最后推荐几个网站吧： 果壳网·科技真有意思 SegmentFault Stack Overflow ","date":"2013-02-21","objectID":"/2013/02/%E6%9D%82%E8%AE%B020130221/:0:0","tags":["高中生活"],"title":"杂记（20130221）","uri":"/2013/02/%E6%9D%82%E8%AE%B020130221/"},{"categories":["码志"],"content":"由于各种各样的原因，之前很多次向 Linux 迁移的计划未能实现。主要是因为有些程序只能在 Windows 上运行，比如我们最常用的 QQ。此次迁移的主要原因和以往大致相同： Windows 系列的系统臃肿而且不实用，很多东西华而不实。 Windows 系列的系统及其程序属于商业行为，为了追求自由、共享和开源。 我选择的是 Ubuntu 12.04 LTS，主要还是看中了 LTS（Long Term Support），这样可以获取更长时间的技术支持。 安装过程就略过不提了。我采用的是 USB 安装，毕竟刻录光盘很奢侈。将移动硬盘分出一个 4GB 的分区，然后用 Universal USB Installer 写了启动引导，接下去的过程就很简单了，因为都是 GUI 界面，相对容易些。 装完系统就是折腾了，Linux 就是用来折腾的。下面慢慢介绍。 ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:0:0","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"换上 Gnome3 由于 Ubuntu 自带的 Unity 界面非常不稳定，主要是个人不喜欢那种风格。所以毅然决然的换了 Gnome3。由于 Ubuntu 早已将其加入到了软件源中，所以直接 apt-get 就可以了。 sudo apt-get install gnome-shell 安装结束以后就可以使用了。可能是个人癖好吧，我还是把 Unity 删了，命令如下： sudo apt-get --auto-remove purge unity sudo apt-get --auto-remove purge unity-commonp sudo apt-get --auto-remove purge unity-lens* sudo apt-get --auto-remove purge unity-services sudo apt-get --auto-remove purge unity-asset-pool 切记不可使用这条命令： sudo apt-get --auto-remove purge unity* 因为把所有关于 Unity 的东西都删除以后会无法进入系统。这样就基本完成了桌面的更换，为了操作方便，我们还需安装一个软件来配置 Gnome3 桌面： sudo apt-get install gnome-tweak-tool ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:1:0","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"软件整理 这个方面主要包括卸载一些不必要的软件以及安装一些必要的软件。卸载就不多说了，这是个智者见智，仁者见仁的事情。主要将一下软件安装。 浏览器使用谷歌的 Chromium，输入法也使用了谷歌的 googlepinyin。个人很喜欢谷歌，简洁而且功能强大。 接下去主要讲解一下在 Ubuntu 上使用 QQ 的方法——不用整天网页挂 WebQQ，不用 Wine。 众所周知，在 Linux 下有一款支持多种即时通讯账户的软件叫做——Pidgin，默认不支持 QQ，我们只需要安装一个插件就行了。 ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:0","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"Step 1：安装 Pidgin sudo apt-get install pidgin ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:1","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"Step 2：安装插件 pidgin-lwqq sudo add-apt-repository ppa:lainme/pidgin-lwqq sudo apt-get update sudo apt-get install libpurple0 pidgin-lwqq ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:2","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"Step 3：Enjoy it! 不得不说，Pidgin 真是解决了一个大难题，因为很多同学都在用 QQ，所以不用 QQ 也很难取得联系。有了这款软件就方便多了。接下来是下载软件，我选择了 aria2。一来是终端模式的，看起来舒服；二来支持断点续传；这两样加起来也足够了。而且速度也很快。安装方法： sudo apt-get aria2 使用方法： #一般使用 aria2c #分段下载 为分段数目，取值介于1~5之间 aria2c -s #断点续传 aria2c -c #下载BitTorrent文件 aria2c -o 至于编程，已经做好放弃 VS 之类的准备了，转战 QT。主要方面应该是跨平台应用和网页开发吧。 ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:3","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["余音绕梁"],"content":"歌词如下： 莽莽苍苍兮群山巍峨 日月光照兮纷纭错落 丝竹共振兮执节者歌 行云流水兮用心无多 求大道以弭兵兮凌万物而超脱 觅知音固难得兮唯天地与作合 求大道以弭兵兮凌万物而超脱 觅知音固难得兮唯天地与作合 这首歌是《笑傲江湖》的一首插曲，它与令狐冲的一系列行为都非常的映衬，真实而准确地传递出了这部书的灵魂。 ","date":"2013-02-11","objectID":"/2013/02/%E5%A4%A9%E5%9C%B0%E4%BD%9C%E5%90%88/:0:0","tags":null,"title":"天地作合","uri":"/2013/02/%E5%A4%A9%E5%9C%B0%E4%BD%9C%E5%90%88/"},{"categories":["浮生杂记"],"content":"其实这应该是很早以前写的，但是一直没时间静下来。 NOIP 2012 复赛备战期间，让我体会到了什么是真正的刷题，这远比期末每天好几张的试卷来的恐怖。刷题，不仅仅是整日做题目，这只是基础。重要的是对于每道做过的题目做完后探寻更简便的方法来解决它。而且刷题注重的是效率，一道题刷过就必须 Accepted。任何不起眼的错误导致的 Wrong Answer 都必须避免。回想起那段刷题时光，现在的状态与那时相比，恐怕相差甚远。 对于作业，还有些话要讲，首先引用一位神犇的分析： 做作业的悲剧性在于，我们用有限的生命，去完成无限的作业。更可悲的是，速度或快或慢都无济于事——或因一日的拖延便往后日日无法完成当日作业，抑或是日日赶超但仍需要完成作业。悲剧的根源在于，以我们的微薄之力，一日完成的作业量不变，但所发作业却以亘古不变的步伐一日一日向前迈进。我们终究无法完成所有作业，终究会明白，最好不过是今日完成今日的作业，而所谓「急功近利」地积极完成明日作业，在作业们眼中看来，不过是可笑的雕虫小技。 而放假绝不是最终的出路，因为我们并没有假期，所谓的假期也只是自我欺骗。 但终有一日，什么都不会有意义，这也正是我们所恐惧地期盼之日。 因此，每次发完作业，总是没日没夜做作业的，不能称之为刷题，而只能说是在运行程序罢了，因为他们沿着作业预算好的轨迹低头拉车，却从未抬头看天。仔细想来，低头拉车，抬头看天，本是一对客观矛盾。根据马克思主义哲学的科学指导，不难的出，在不同条件下，矛盾主次双方可以相互转化。我们不能一味低头拉车，这样只能成为程序，也不能一味抬头看天，这样只是好高骛远。由此得出，在适当的条件下，做适当的转化是非常有必要的。所谓“独阴不生，独阳不长”大概也可以从这个角度来理解吧。 所谓假期，只是不受学校朝六晚十的时间约束，可以自由安排时间罢了。除去此项，或许放假与不放假也没头太大区别吧。但是，这项确是非常重要的。当然，自由安排也是“仁者见仁，智者见智”。自从两年前和游戏断绝以来，唯一可以打发时间的事情便成了阅读。这两年也发现，阅读，确实给了我们一片非常广阔的天地。一个午后，一本书，一杯水，就可以打发一个下午。在诸多类别的书籍中，个人尤爱哲学、历史。哲学的书总是给人对生命的思索，不停的回答着同样的问题：人生的意义何在？史书则可以不断给人以思索，唐太宗说到“以史为镜可以知兴替”。在 21 世纪的今天，我们虽然不用经历古代的战火纷飞，但是历史仍然给我们以启发，教给我们以做人的道理和是非的标准。文学类的文本个人觉得更多的是呼唤我们对于周围生活的关注。这些不能也不该成为炫耀的资本，而应该作为一种个人内在的修养积淀下来。看着别人大谈《孙子兵法》，批判老庄，笑而不语。一来他们在意的不是你说的道理，而是你不同意他们的观点，二来既然他们得出这种观点，那么以他们目前的阅读积累应该无法理解你的看法。 在《苏东坡传》上看到林语堂老先生的一个观点，这里只能大致叙述一下了。世界上有两种人，一种市侩小人，整日说结论性话语；一种正人君子，会先分析问题，再给出参考性方案。但是现在社会太“急”，人们只在乎结果，而完全不注意过程，也就导致了小人横行，君子遭贬。这也是一件好事，因为小人，君子自此各司其职，都不违背各自的心愿。小人喜欢势利，居庙堂之高；君子独善其身，处江湖之远。结果只可能是朝政败坏，改朝换代。把这个观点运用到当代社会，或许大家也就明白一二了。无奈的是国民就是喜欢结果，就是喜欢听结论性话语。 再来说说“友谊”吧。关于这个话题，仅仅是个人看法，不全面，因为无法将各个方面详尽表述出来。 以前还是挺相信友情的，当然，也不是说现在不相信了。也交了很多朋友。当时大家都挺聊得来的，一些小事也可以相信的。但是，似乎忽视了中国古代劳动人民的思想成果“路遥知马力，日久见人心”、“患难见真情”。很多很多所谓的朋友，到后来，在你最关键的时刻，过河拆桥算是留情面了，有时会突然在背后捅你一刀。这又可以分为两种，一种是十分明显的，真刀实干。第二种是放冷箭，所谓“明枪易躲，暗箭难防”。这个从很多武侠小说中也可以得到证明，就比如《笑傲江湖》吧，定逸师太被岳不群杀死时，说的是“是你？”，显然，她也是被暗算了。如果她不认识凶手，应该说的是“你是？”。这样也就造成了许许多多的逢场作戏。对于此类问题，还是玉米的方法比较有效“你若对我报以真诚的微笑，我也回应你真诚的微笑；你若对我报以虚假的微笑，我也回应你真诚的微笑。”，有时候，心胸还是应该开阔，所谓“退一步海阔天空”，这些事情只不过给了我们一个看清事实真相的途径罢了。“害人之心不可有，防人之心不可无”。 很多所谓“朋友”都只是逢场作戏罢了。冲突就发生在做戏的一方被看穿且毫不留情面的揭露出来，此人一定暴跳如雷，而且到处宣扬你的种种恶迹，毕竟“欲加之罪，何患无辞”。对于这些，笑笑罢了，“笑世间可笑之人，笑世间可笑之事”。因为任何一个人的评价，都必须由后世之人来评定，所有的当代人都只是当局者迷，当然也不排除自身个体。 友情，还有一种同化功能，所谓“近朱者赤，近墨者黑”。一个个原本优秀的人因为善恶不分，交友不善，荒废了一生，这种事例实在多见。所以，择友时有一点很重要：慎重！ 好吧，到这里，呓语显现出来了，其实我也没看懂自己到底写了些什么。 最后，还是想提一下张贤明，这个已经远离我们一年多的名字。 以前想起他，想到的是他教育我们的各种阴损招数，以及他惩罚我们的种种办法。后来想起他，想到的是和他在一起的快乐时光，每节语文课，班会课。如今想起他，想到的是他说的那些话，突然感觉很有道理，很值得揣摩，推敲。 印象最深的，莫过于“输不丢人，怕才丢人。”这句话，每每想到，都会想起 Steven Jobs 的名言“听从你内心的声音”，或许很多事情前思后想，只会是顾此失彼。看似不明智的奋力一搏，可能收获意想不到的结果。 就到这吧。 ","date":"2013-02-04","objectID":"/2013/02/%E5%91%93%E8%AF%AD%E4%B8%80%E6%97%A0%E9%A2%98/:0:0","tags":["计划"],"title":"呓语（一）：无题","uri":"/2013/02/%E5%91%93%E8%AF%AD%E4%B8%80%E6%97%A0%E9%A2%98/"},{"categories":["浮生杂记"],"content":"迷迷糊糊，期末复习，小高考补课就这么过去了。不得不提一下数学，没想到啊。就这样，迎来了这一不寻常的寒假。最后一天突然下起了雨，似乎把一切繁杂和浮躁都冲洗而去。 仔细算来，从今天到开学前一共还有 23 天。时间不容我们挥霍。像以往一样制定一个计划吧（当然不是学校里那种按天数来划的），以前总是写在纸上，这次就直接发到博客上吧。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:0:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"寒假作业 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"语文 练字（黑色钢笔）。 专题摘抄 3000 字，并写一篇书评。 预习《唐诗宋词选读》，背诵 14 篇，熟读 2 篇。 关注时事，写一篇社会评论。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:1","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"数学 复习必修 2、选修 2-1、选修 2-2。 寒假作业（好像只要做几张综合卷）。 综合练习。 附加题练习。 自选一本与本学期有关试题。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:2","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"英语 暂无。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:3","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"物理 暂无。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:4","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"化学 复习《有机化学基础》、《物质结构与性质》。 预习《化学反应原理》。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:5","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"小四门（政、史、地、生） 背诵。 完成考点等练习。 由于开学后离学业水平测试只有十多天，所以小四门成为了寒假的主要矛盾。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:6","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"学习计划 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"语文 按要求完成作业。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:1","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"数学 按要求完成作业。 加强运算能力。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:2","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"英语 作业日：一篇阅读、一篇完形、若干单选。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:3","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"物理 无。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:4","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"化学 预习《化学反应原理》。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:5","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"小四门（政、史、地、生） 作业日：认真背诵，完成练习。 争取小四门 4A 吧。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:6","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"阅读计划 史记（中华书局 1959 年版） 数学（甲种本） 代数 第一册 电子技术基础 准备开始看二十四史，不知道能不能坚持下去。《史记》作为二十四史之首，而且和上学期教学内容相近，所以先看。甲种本的数学，纯粹是兴趣，也算是为了自招吧。电子技术基础，总是在电脑上写程序也挺没意思的，所以要和单片机结合起来。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:3:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"OI 计划 怎么说了，没什么动力了。没保送，去年拿了个全国复赛二等奖，自招资格是有了。所以 OI 也就放下来了。高三的话，看运气吧。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:4:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"EE 计划 制作 AM/FM 调频收音机。 DIY 太阳能便携式充电器。 制作摄像小车。 第三项可能来不及。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:5:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"杂项 坚持每周更新 blog。 其他的想到再说吧。 寒假就这么开始了…… ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:6:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["鉴于往事"],"content":"本文主要整理了《中国通史：诸葛亮治蜀》的解说稿。 东汉末年，各个地方势力，各据一方，天下大乱。公元 208 年，在曹操百万大军的高压下，刘备派诸葛亮出使山东，与孙权结盟。孙刘联军在赤壁大破曹军，魏、蜀、吴三分天下之势初步形成。公元 219 年，刘备北伐，孙权偷袭荆州，杀死关羽，刘备北伐失败。公元 221 年，刘备亲率数万大军讨伐孙权，双方在夷陵相持。第二年，刘备被孙权的军队连连击败。夷陵之战惨败，刘备忧愤成疾。弥留之际，刘备将儿子刘禅，托付给诸葛亮，随即病逝。后主刘禅，封诸葛亮为武乡侯，领益州牧1，总理朝政。自此，举国重任，落在诸葛亮一人肩上。 这是一条使命之船，船上的主人名叫邓芝2，在蜀汉政权中担任尚书。蜀汉建兴元年十月，也就是夷陵之战的第二年，邓芝受诸葛亮的委派，前往东吴。孙权背盟，偷袭荆州，按照一般的情理，蜀汉与东吴从此应该结下不共戴天的深仇大恨。然而，这时的诸葛亮，却做出了一个惊人的决策——再次与东吴结盟。 赞曰：国家利益是国际关系的决定因素，只有永远的利益。面对强大的曹魏政权，蜀汉也只有和东吴结盟才得存活下去。 这个时候的东吴政权，跟曹魏政权仍旧藕断丝连，是否接见邓芝，孙权心中犹豫不决。邓芝便给孙权写了封信，信中说道，自己今天来到这里，不仅是为了蜀汉的利益，也是为了东吴的利益。孙权读到这句话受到触动，决定接见邓芝。见面后，邓芝依照诸葛亮的嘱托，详细分析了当前的形势，阐明了吴与蜀唇亡齿寒的道理。很快，孙权跟曹魏断绝了藩属3关系，转而与蜀汉结为盟友。 沈伯俊：蜀汉的开国君主，刘备去世以后，诸葛亮就面临着如何治理蜀汉的艰巨任务。经过荆州之失，夷陵之败，蜀汉的疆域，只剩下了一个益州。精兵良将折损过半，开国元勋逐步凋零，吴蜀同盟不复存在，就像诸葛亮后来在《出师表》里边讲的，天下三分，益州疲弊，此诚危急存亡之秋也。 然而，就在所有人以为，蜀汉和东吴从此将和平相处，再无战事的时候，一个震惊天下的消息突然从东吴传来。这一次，诸葛亮的外交策略即将遭到前所未有的挑战。公元 229 年，孙权经过多年的犹豫后决定称帝。为了让自己这个皇帝能够得到蜀汉的认可，孙权决定先将此事通报蜀汉。消息传到蜀汉，一石激起千层浪，朝中群臣一片愤慨。自古天无二日，国无二主，只有蜀汉才是天下正统。曹贼窃国，必须诛而伐之。现在，孙权也要称帝，更是大逆不道，蜀汉应与之绝交，并且立即出兵讨伐。 赞曰：孙权这一招妙极。此这个时候提出称帝，对于蜀汉来说从原则上是绝对不能接受的，但是又不得不接受。毕竟在这种时刻，生存才是蜀汉的主要矛盾。而孙权正好抓住了这一点。 孙权称帝，到底应该如何应对，对于诸葛亮来说，这是一个两难的决定。如果要承认孙权这个皇帝，等于损害了蜀汉自身的正统性与合法性。如果不接受，那么两国将重新回到敌对状态，之前的努力将付之东流。然而，对于现在的蜀汉来说，根本无力承受任何一场大规模的军事行动。这是诸葛亮总理朝政以来，面临的最大的一次考验。 楼劲：在一个通达的政治家看起来，你的意识形态立场，是要服从于你的现实利益的立场。这个时候他是为自我的生存着想。你要生存下去，你必须跟孙权、必须跟东吴政权保持一种联手的关系。否则你无法抗住北方的压力，因为北方现在越来越强大。 愤怒的群臣终于被诸葛亮说服了。随后诸葛亮派出使臣，祝贺孙权称帝。孙权闻讯大喜，随即决定于蜀汉升坛歃盟，对天发誓，戮力同心，同讨魏贼。这样的结果，是蜀汉和东吴都很渴求的，而对于蜀汉来说，却显得更加重要。因为，当外部环境基本平稳之后，诸葛亮终于可以腾出手来，去解决一个令蜀汉头疼多年的问题，那就是，南中叛乱。 这里是云南省西盟佤族自治县。这里居住着一支中国西南最古老的少数民族之一——佤族。每逢重大的民族节日，佤族人都会敲起木鼓，挥舞着战刀，跳着世代传承下来的舞蹈，以此纪念祖先的勇敢和不屈不挠的战斗精神。三国时期，整个云南、贵州和四川西南部都隶属于蜀汉政权，统称南中。南中地区世代居住着众多少数民族。东汉末年，腐败政权对南中地区搜刮无度，很多民众不断反抗，一些豪强趁机煽动叛乱，企图割据称雄。刘备当政时形势本有所好转，但在他病逝之后，一些豪强再次趁机叛乱。 赞曰：典型的官逼民反。而且中国民众普遍思想意识落后，很容易被一些有非分之想的人利用，造反也就自然了。 北有曹魏政权重压，南有豪强叛乱，南中之乱不平，蜀汉将两面受敌。诸葛亮决定亲自征讨南方。蜀汉建兴三年春三月，几万蜀兵，在诸葛亮的亲自率领下，浩浩荡荡地向南中地区进发。然而，要想征服这片广袤的荒蛮之地绝非易事。广大南中地区山高林密，危险重重，瘴疠之乡，到处都有充满敌意的眼睛。佤族人历来骁勇善战，每一次战胜敌人，他们都会用特别的仪式进行庆祝。然而，当诸葛亮进入南中之后，向来以凶悍著称的叛乱部队，却没有得到庆祝胜利的机会。他们在训练有素的蜀汉正规军面前，一触即溃，蜀汉大军很快向叛军首领孟获展开攻击，并最终将孟获擒住。让孟获想不到的是，诸葛亮虽然擒住了他，却并没有伤害他的意思，而是请他观看汉军阵营，孟获不以为然，对诸葛亮说，如果能放他回去再决一战，他一定可以打败诸葛亮。诸葛亮哈哈一笑，将孟获放走，约他择日再战。其实，在诸葛亮的心中，平定叛乱，绝不是依靠武力杀伐这么简单。对于南中，诸葛亮有着一个更为长远的打算。史书记载，诸葛亮七擒孟获，七纵孟获，最后，孟获输得心服口服，诸葛亮还要放他，孟获再也不肯回去了，说：公，天威也，南人不复反矣。 赞曰：得民心者得天下。 沈伯俊：诸葛亮在军事上发展非常顺利，因为他赢得了民心。得到了少数（民）族民众的欢迎，史书记载，建兴三年春南征，其秋悉平。到了秋天就全部平定了。 收服孟获之后，南中各个部族纷纷归附。佤族人说，他们的祖先还与诸葛亮结下誓盟，生生世世镇守边关，永不叛乱。不过，结束叛乱只是平定南中的第一步。接下来，诸葛亮要真正开始实施自己对于南中的计划了。 这里是云南省西盟佤族自治县爬街村。 1970 年代，尼桑老人，作为西盟民族工作队队长，被派到这里，帮助村民们发展农业生产。老人至今还记得，比他更老的老人们给他讲的关于诸葛亮的故事。 尼桑：我主要是跟一个名字叫艾初（音）的一个老人，死了可能是十多年吧，还有一个叫艾桑（音）的，死了可能五六年了。按照他们说那些，佤族（语）说，也就是两千年以前，就在这个时候呢，因为（粮食）产量很低，他（诸葛亮）就教（我们）如何耕种，如何选种，如何把这个种子管好。 约一千八百年前，一些蜀汉的官员被诸葛亮派到这里。他们带来了当时最先进的农耕技术，教会了南中人民盖房子，种水稻，使用耕牛，植桑养蚕，纺纱织布，改变了这里刀耕火种的原始生产方式。 这里是云南省普洱市，是闻名中外的普洱茶的最主要的产地之一。相传，当年正是诸葛亮在这里大规模的推广茶叶种植，才有了后来的普洱茶。今天，普洱茶已经是中国人最日常的生活茶饮之一。为了纪念诸葛亮，与其他地区不同，这里的人们奉诸葛亮为茶祖。像这样的关于诸葛亮的故事，在广大的西南地区有很多，这些美丽的故事，宛若普洱茶的茶香，越是经历久远的年代，越是厚重，香醇。 赞曰：至此，诸葛亮对与南中的改革也就差不多了，农业是立根之本。而茶叶又可以带来一定的经济利益，使人民安居乐业。 沈伯俊：早在《隆中对》中，诸葛亮就提出了他的治理南中的原则，南抚夷越。既然是南抚夷越，那他的原则就是，但欲服其心，不欲灭其类也。 七擒孟获，南抚夷越，最终让这里的人们过上真正稳定的生活。这才是诸葛亮心中真正的队南中的平定。经过几年的努力，蜀汉政权终于拥有了一个相对和平安稳的环境。而此时，诸葛亮所推行的内政改革\u003e ，也已经全面展开。 内政，第一位重要的因素，就是人才。诸葛亮选拔人才，不拘资历，不拘地域，尤其注重德才兼备。张裔，益州太守，在南中叛乱时期，被反叛首领抓获献给了孙权。在这之后的数年里，诸葛亮的心里一直牵挂着这个才识过人的张裔，后来，在邓芝出使东吴期间，邓芝遵照诸葛亮的嘱托，向孙权提出，希望能够放张裔回蜀。适逢两国重新修好，孙权痛快答应了邓芝的要求，然而，事后孙权很快发现，张裔是一位博学多才之士。十分后悔放虎归山，于是立即派人去追，而张裔早已连夜返回蜀地去了。张裔归来，诸葛亮立即委以重任，蜀汉又有了一位得力的官员。蒋琬，费祎，董允，王连，陈震，张裔，费诗，秦宓等等，像这样被诸葛亮发现并任用的官员数不胜数。一时间，人尽其才，才尽其用，巴蜀地区有才能的人才争相为国家效劳。 沈伯俊：他善于发现人才，诸葛亮本人就是刘备慧眼识才才走上政治舞台的。诸葛亮怎么识才？怎么衡量一个才？他始终坚持德才兼备。 内政建设，除了需要得力的人才，更需要建立一套完善的法律体系。诸葛亮亲自主持制定了蜀汉的国家法典《蜀科》。以法治蜀，从严治国。公元 228 年，这一天，蜀汉的刑场周围挤满了文武群臣和围观的百姓。行刑时间将至，只见一个人缓缓来到刑场，这个人正是诸葛亮最疼爱的谋士，马谡。马谡，因为违反军令，导致战略要地街亭失守，兵败失守后，马谡又临阵逃脱，论罪当斩。临刑前，马谡给诸葛亮写信，信中，他视诸葛亮为自己的父亲，并将一家老小托付给诸葛亮，围观的百姓无不动容流泪，群臣纷纷向诸葛亮求情，然而，此时的马谡却十分清楚，自己罪无可赦，丞相绝不会姑息。马谡被斩首后，诸葛亮伤心欲绝，久久难以平复。 法律面前，人人平等。在诸葛亮所惩处的人里面，既有亲贵，也有功臣，无论是什么人，一旦触犯刑律，诸葛亮一律严办，绝不偏袒。然而，诸葛亮的以法治蜀，绝不是依靠简单的严刑酷法，而是建立在教化的基础上，并充满了人性关怀。同为先帝托孤大臣的李严4，因为弄权而贻误军机，被诸葛亮弹劾流放。之后，诸葛亮给李严的儿子李丰写了一封信，信中，诸葛亮诚恳地说明了流放的理由，并希望李丰能够说服他的父亲，充分认识到自己的错误","date":"2013-01-26","objectID":"/2013/01/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E7%BA%AA%E5%BD%95%E7%89%87031-%E8%AF%B8%E8%91%9B%E4%BA%AE%E6%B2%BB%E8%9C%80/:0:0","tags":["《中国通史》纪录片"],"title":"《中国通史》纪录片：031 诸葛亮治蜀","uri":"/2013/01/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E7%BA%AA%E5%BD%95%E7%89%87031-%E8%AF%B8%E8%91%9B%E4%BA%AE%E6%B2%BB%E8%9C%80/"},{"categories":["浮生杂记"],"content":"2013\" 2013 充满传奇色彩的 2012 年就这样过去了。自从上了高中以后，总觉得时间好快，有种跟不上节奏的感觉。 先简单总结一下过去的一年。高一下学期，为了一个信念努力拼搏，虽然如愿以偿，但总是觉得怪怪的。高二，一直被一种莫名的情绪笼罩。 可能是因为生活节奏太快的缘故，对于很多事情都没有什么记忆了。以至于周五回想周一的事情都感觉过了好久。推究这种感觉的原因，可能是被迫习惯了这些不习惯的事实吧。这一年也对我的思想转变起了很大的影响。下面主要讲几件事例吧，也不可能面面俱到。 申明：本人对下述事件所涉及的个人或集体不带任何恶意。 一开始来到新班级，有点诧异。没过几天，就感觉很不习惯。对于自己以前所在班级的留恋无可非议，每天在走廊里搞聚会，利用优势地理位置也无可厚非，但是大声喧哗，影响公共秩序好像不太好吧。 课间我们在走廊里乘凉，看着一群男男女女大吵大叫，玩一些不上大雅之堂的游戏或者说些带着痞子气的话语，只能说，他们没事干吧。或许我们根本不了解他们才下的这个结论吧。不过这样的印象谁又敢去了解呢。 对于一些人，尤其是男生，都高二了，遇到事情推卸责任，耍脾气，真是不可理喻，在此也不想指出，毕竟，他们早晚会为自己的行为付出代价。也许只有这样他们才会明白吧。 还有个不得不提的话题，为什么现在的女生会如此随意呢，对此，只能是敬而远之了。 上评论可能是从我个人想法出发吧。当初建立世界观的时候受老子、周易的影响较大，所以有些思想比较传统吧，对于这些过于现代的元素感到无法接受吧。有了上述的事例，自然就造成了现在自己宁可一个人看看课外书，刷刷作业，也不想去接触外界那些令人无法接受的事情。就好像文化夜市我和张程晔、子敬兄、昊阳兄一起在教室刷作业，然后去小店解决了晚饭。 对于日后，我想我还是会坚持我的世界观不动摇吧，毕竟现在看到的事情不会也不可能会是社会的走向。所以，必须坚定信念。 另外一件对于我影响比较大的事情是一个人的一句话，大意是，不一定朋友就一定会是非常好的，也可能是没办法的。这也就好比戴着面具生活，只是要记得对谁带着面具，对谁毫无掩饰。虽然说这样做可以建立和谐的人际关系，但是总觉得有点违背个人内心道德，但是有时候还不得不这样。 思想上的转变大致如上所述，经历了很大的斗争，最终结果是，坚持自己以往的根本思想，对于一些新思想，取精去糟的吸收。 再讲讲 NOIP 吧，这是个不得不提的话题，虽然竞赛过去几个月了，成绩也已经尘埃落定，但是这次比赛却给我很大的启发。做人做事就好比代码。有时候一步走错，满盘皆输；有时候贪心的选择了自己不熟练的算法，可能直接导致了 0 分；有时候把问题复杂化，结果只能是 0 分。虽然过程非常艰辛，但是拿到了全国复赛二等奖的通知还是挺开心的。不知道能不能获得 Winter Camp 的资格。 对于新班主任，郭华。宿舍扣分扣得我都不好意思见她了。进入高二，总感觉数学不对劲，明明都是会的内容，却不是算错，就是没过程。 最近在宿舍里做起了泡面生意，到目前一共卖出了 12 箱，也有了些盈利。主要还是为了积累经验。做生意的确很苦，每天要去泡开水，风雨无阻。 2013，新年快乐。 ","date":"2012-12-31","objectID":"/2012/12/%E5%A3%AC%E8%BE%B0%E5%BF%972012-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:0","tags":["年度总结"],"title":"壬辰志（2012 年度总结）","uri":"/2012/12/%E5%A3%AC%E8%BE%B0%E5%BF%972012-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["浮生杂记"],"content":"网站终于好了，在 2012 年的最后一天写下第一篇文章。 搭建网站的想法很早就有了，由于一些事情耽搁了，主要是经济来源问题。由于前段时间在宿舍中卖泡面赚了些钱，所以才搭起了这个网站。搭建这个网站也不容易，从申请域名，设置 A 记录，配置 DNS 服务器，域名解析到空间的选择等，可以说又是一次历练吧。现在的网站还非常简陋，以后会慢慢完善。 有人问我，什么不用 QQ 空间。我想还是因为这里比较自由吧。主要还是写一些关于生活的文章，包括一些杂感、竞赛，抑或其他。 关于 Ivy - End，前者是我的母校，后者是我的 QQ 昵称。但现在有了更多的意义。将来也是。 附上一段代码： #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello World\" \u003c\u003c endl; return 0; } ","date":"2012-12-31","objectID":"/2012/12/hello-world/:0:0","tags":["建站"],"title":"Hello World","uri":"/2012/12/hello-world/"}]