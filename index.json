[{"categories":["浮生杂记"],"content":"NOIP 终于还是结束了，本来想写一篇文章好好记录一下这两年奋斗的历程，但自从周一知道成绩以后，便什么想法都没有了。凭心而论，今年题目比去年简单，可是我却考得没有去年高，实在惭愧。 现在想来，当初高二知道成绩以后的踌躇满志，就注定了高三竞赛的没落。 本来写了一篇文章，现在也不想打出来了，一切都过去了。或许，竞赛的成绩并不是最重要的。它所教给我的，是一种精神，正如今年国际金牌得主代表清华大学在ACM开幕式上发言时所说「自己选的路，跪着也要走完。」这种永不言弃的精神将一直伴随着我走下去。 当然，在竞赛的同时还收获了许多意料之外的惊喜。在刷 USACO、Codeforces 的时候，提高了英语的阅读水平。当然，还结交了几个志同道合的网友，虽然大家分布五湖四海，但是却有着相似的经历，同样的目标，虽然现在我们都注定要踏上高考这条路，但却还可以在文化课这一层面进行许多交流。 自主招生正在如火如荼的展开着，但是我却对这一政策兴趣不大。且听我慢慢道来，那些可以拿到一流大学大幅度加分优惠的，有几个正常发挥高考考不上这些学校的。对于备战自主招生，又要耽搁许多文化课的时间，到头来两边都顾不着。想起舍友季文逸跟我说的话「我当初没有报竞赛是明智的，有多少人真正受益了呢。」 当然，这也不代表我不参加自主招生。中国人的一贯想法，大家都报名了，我不报名，岂不落后了。估计自荐上交的可能性大一点。 谨以此文，作为高中 NOIP 生涯的最后一页。 到现在，一切与文化课无关的事情也都已结束，可以真正的捣鼓文化课了。 前方有一个清晰的未来—— 是的，我看见了： 我来了！ ","date":"2013-11-24","objectID":"/2013/11/%E5%91%93%E8%AF%AD%E5%9B%9B%E6%B8%85%E6%99%B0/:0:0","tags":["高中生活"],"title":"呓语（四）：清晰","uri":"/2013/11/%E5%91%93%E8%AF%AD%E5%9B%9B%E6%B8%85%E6%99%B0/"},{"categories":["码志"],"content":"昨天终于把欧拉函数想通了，现在总结一下。 欧拉函数 $ \\varphi \\left ( N \\right ) $ 表示小于或等于 $ N $ 的正整数中与 $ N $ 互质的数的个数。又称 $ \\varphi $ 函数、欧拉商数。 下面介绍欧拉函数的几个性质： $ \\displaystyle\\varphi\\left ( 1 \\right )=1 $； $ \\displaystyle\\varphi \\left( N\\right )=N\\cdot\\prod_{p\\mid N}\\left ( \\frac{p-1}{p} \\right ) $； $ \\displaystyle\\varphi \\left ( p^{k} \\right ) = p^{k}-p^{k-1}=\\left(p-1 \\right )\\cdot p^{k-1} $ ，其中 $ p $ 为质数； $ \\displaystyle\\varphi \\left(mn \\right )=\\varphi \\left(m \\right )\\cdot \\varphi \\left(n \\right ) $ ，其中 $ \\gcd \\left ( m,n \\right )=1 $ 。 我们根据这几个性质就可以求出欧拉函数。 基本思路是首先置 $ \\varphi \\left ( N \\right )=N $ ，然后再枚举素数 $ p $ ，将 $ p $ 的整数倍的欧拉函数 $ \\varphi \\left ( kp \\right ) $ 进行操作 $ \\varphi \\left ( kp \\right )=\\varphi \\left ( kp \\right )\\cdot \\frac{p-1}{p} $ 即可。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 1024; int N; int p[MAX], phi[MAX]; int main() { cin \u003e\u003e N; for(int i = 1; i \u003c= N; i++) // 初始化 { p[i] = 1; phi[i] = i; } p[1] = 0; // 1不是素数 for(int i = 2; i \u003c= N; i++) // 筛素数 { if(p[i]) { for(int j = i * i; j \u003c= N; j += i) { p[j] = 0; } } } for(int i = 2; i \u003c= N; i++) // 求欧拉函数 { if(p[i]) { for(int j = i; j \u003c= N; j += i) // 处理素因子p[i] { phi[j] = phi[j] / i * (i - 1); // 先除后乘，防止中间过程超出范围 } } } cout \u003c\u003c \"Primes: \" \u003c\u003c endl; for(int i = 1; i \u003c= N; i++) { if(p[i]) { cout \u003c\u003c i \u003c\u003c \" \"; } } cout \u003c\u003c endl; cout \u003c\u003c \"Euler Phi Function: \" \u003c\u003c endl; for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c phi[i] \u003c\u003c \" \"; } return 0; } 以上是关于欧拉函数的求法，对于它的应用，这里暂且介绍一个——求解原根的个数。 对于原根的定义，我们可以这样来叙述： 若存在一个实数 $ a $ ，使得 $ a^{i}\\mod{N},a\\in\\left \\{ 1,2,3,\\cdots ,N \\right \\} $ 的结果各不相同，我们就成实数 $ a $ 为 $ N $ 的一个原根。 原根的个数等于 $ \\varphi \\left ( \\varphi \\left ( N \\right ) \\right ) $ 。这样我们就可以很方便的求出原根的个数。 代码如下： #include \u003ciostream\u003e#include \u003cmath.h\u003e using namespace std; typedef unsigned long long ull; ull N; ull phi(ull x); int main() { cin \u003e\u003e N; cout \u003c\u003c phi(phi(N)) \u003c\u003c endl; return 0; } ull phi(ull x) { ull ans = x; ull m = (ull)sqrt(x); for(ull i = 2; i \u003c\u003c= m; i++) { if(x % i == 0) // 求素因子 { ans = ans / i * (i - 1); // 运用通项求解欧拉函数 while(x % i == 0) // 每个素因子只计算一次 { x /= i; } } } if(x \u003e 1) // 防质数 { ans = ans / x * (x - 1); } return ans; } 关于欧拉函数的知识就介绍这么多吧，应付NOIP应该足够了。 ","date":"2013-11-06","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/:0:0","tags":["欧拉函数"],"title":"算法专题：欧拉函数","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"categories":["码志"],"content":"求解线性方程组的有效方法是高斯消元。这个算法我看了半个下午才真正理解并且写了出来。 这个算法的核心思想就是将一个方程组的增广矩阵通过初等行变换转变成上三角矩阵，然后求解各个未知数的解。 我写的高斯消元是将所有系数看成一个矩阵来求解的。 下面来简要讲一下高斯消元的过程： 首先，我们根据方程组写出增广矩阵。每次都找 $ x_{i} $ 系数的绝对值最大的那个方程，将它移到上方，而将下面的方程组的 $ x_{i} $ 的系数全部化成 0。以此类推，到最后再逆序求解每个未知数的解。 我们来看一个例子，求解方程组 $ \\begin{cases}2x+y-z=8\\\\ -3x-y+2z=-11\\\\ -2x+y+2z=-3\\end{cases} $ 首先我们写出它的增广矩阵 $$ \\begin{bmatrix}\\left.\\begin{matrix}2 \u0026 1 \u0026 -1\\\\ -3 \u0026 -1 \u0026 2\\\\ -2 \u0026 1 \u0026 2\\end{matrix}\\right|\\begin{matrix}8\\\\ -11\\\\ -3\\end{matrix}\\end{bmatrix} $$ 接下来我们按照算法步骤来求解这个方程组 $$ \\begin{bmatrix} \\left.\\begin{matrix} 2 \u0026 1 \u0026 -1\\\\ -3 \u0026 -1 \u0026 2\\\\ -2 \u0026 1 \u0026 2 \\end{matrix}\\right| \\begin{matrix} 8\\\\ -11\\\\ -3 \\end{matrix} \\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026 -1 \u0026 2\\\\ 2 \u0026 1 \u0026 -1\\\\ -2 \u0026 1 \u0026 2 \\end{matrix}\\right| \\begin{matrix} -11\\\\ 8\\\\ -3 \\end{matrix}\\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026 -1 \u0026 2\\\\ 0 \u0026 \\frac{1}{3} \u0026 \\frac{1}{3}\\\\ 0 \u0026 \\frac{5}{3} \u0026 \\frac{2}{3} \\end{matrix}\\right| \\begin{matrix}-11\\\\ \\frac{2}{3}\\\\ \\frac{13}{3} \\end{matrix} \\end{bmatrix}\\Rightarrow \\begin{bmatrix} \\left.\\begin{matrix} -3 \u0026 -1 \u0026 2\\\\ 0 \u0026 \\frac{1}{3} \u0026 \\frac{1}{3}\\\\ 0 \u0026 0 \u0026 -1 \\end{matrix}\\right| \\begin{matrix} -11\\\\ \\frac{2}{3}\\\\ 1 \\end{matrix} \\end{bmatrix}\\\\ \\Rightarrow z=-1,y=3\\times\\left ( \\frac{2}{3}-\\frac{1}{3}\\times\\left ( -1 \\right )\\right )=3,x=-\\frac{1}{3}\\times\\left ( -11+3-2*\\left ( -1 \\right ) \\right )=2 $$ 表达能力有限，我也只能解释成这样了。 当时我在网上找资料的时候还抱怨作者为什么不解释清楚点，现在发现，不是作者不愿意解释清楚，这个算法实在难以解释清楚。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 1024; int N; double f[MAX][MAX], ans[MAX]; // f[][]为系数（包括常数），ans[]为结果 double fabs(double x); // double的绝对值 void Gauss(); int main() { cin \u003e\u003e N; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N + 1; j++) // 读取所有系数（包括常数）方程已化为ax+by+…+c=0的形式 { cin \u003e\u003e f[i][j]; } } Gauss(); return 0; } void Gauss() { int nRow = 0; // 保存当前系数绝对值最大的行 double dMax = 0.0f; // 保存当前最大绝对值的系数 for(int i = 1; i \u003c= N; i++) // 对于每一列都处理 { dMax = f[i][i]; nRow = i; // 初始化 for(int j = i + 1; j \u003c= N; j++) // 比较下面所有行的第i列的系数 { if(fabs(f[j][i]) \u003e fabs(dMax)) // 取绝对值最大的系数 { dMax = f[j][i]; nRow = j; } } if(dMax != f[i][i]) // 如果不是当前行最大 { for(int j = i; j \u003c= N + 1; j++) { swap(f[nRow][j], f[i][j]); } // 交换这两个方程组的位置 } for(int j = i + 1; j \u003c= N; j++) // 对于下面的所有方程 { double dTmp = f[j][i] / f[i][i]; // 计算要将第i列的系数消去所需要的倍率 for(int k = i; k \u003c= N + 1; k++) // 对于第j行的方程的每一项的系数都要进行处理 { // 用第nRow行的方程乘以dTmp后去减第j行的方程，这样就可以把第j行的方程的第i列的系数消去 double dMinus = dTmp * f[i][k]; f[j][k] -= dMinus; } } } ans[N + 1] = 1.0f; // 预处理，为了下面的循环方便 for(int i = N; i \u003e= 1; i--) // 逆序求解 { for(int j = i; j \u003c= N + 1; j++) { ans[i] -= f[i][j] * ans[j]; // 减去已求解的未知数乘以其在当前求解的方程中的系数 } ans[i] /= f[i][i]; // 将该未知数的系数化为1，得到结果 } for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c ans[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } double fabs(double x) { if(x \u003c 0) { x = -x; } return x; } 关于高斯消元，这只是一个列主元的算法，还有全主元的，不过个人觉得列主元的就足够用了。 ","date":"2013-11-05","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/:0:0","tags":["线性方程组"],"title":"算法专题：求解线性方程组","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"},{"categories":["码志"],"content":"关于这个算法，主要是参考 NOIP2012 Day2 T1。即这里所讲的是求解这样一个线性模方程： $$ ax\\equiv 1\\mod{p} $$ 的最小正整数解。 去年我是暴搜做的，当时什么都不会。今天在这里介绍两种算法，一种是我国古代数学家秦九韶发明的「大衍求一术」，还一种是著名的「扩展欧几里德算法」。 首先来看一下大衍求一术。这里只介绍它的计算方法，至于证明可以参考扩展欧几里德算法。 例1：求解方程 $ 23x\\equiv 1\\mod{97} $ 。 解：我们只需要列出下面这张表就可以得到求解 $$ \\begin{matrix}23^{1} \u0026 23^{1} \u0026 3^{17} \u0026 3^{17} \u0026 1^{38}\\\\ 97^{0} \u0026 5^{4} \u0026 5^{4} \u0026 2^{21} \u0026 2^{21}\\end{matrix} $$ 结果就是 38。 接下来我们来理论化的表述一下这个算法的过程： 假设输入 $ a,b $ 满足 $ a\u003eb $ 。那么我们用 $ a_{n},A_{n} $ 分别表示第一行的底数和奇数， $ b_{n},B_{n} $ 分别表示第二行的底数和奇数，如果 $ a_{i}\u003eb_{i} $ ，那么 $ a_{i+1}=a_{i}\\mod{b_{i}},A_{i+1}=A_{i}+B_{i}\\cdot \\left [ \\frac{a_{i}}{b_{i}} \\right ],b_{i+1}=b_{i},B_{i+1}=B_{i} $ ；如果 $ a_{i}\u003cb_{i} $ 则上面的结论倒过来即可。 算法结束当且仅当 $ a_{i}=1 $ ，此时 $ A_{i} $ 即为所求的最小正整数解。 例2：求解方程 $ 97x\\equiv 1\\mod{23} $ 。 解：我们只需要列出下面这张表就可以得到求解 $$ \\begin{matrix}97^{1} \u0026 5^{1} \u0026 5^{1} \u0026 2^{5} \u0026 2^{5} \u0026 \\\\ 23^{0} \u0026 23^{0} \u0026 3^{4} \u0026 3^{4} \u0026 1^{9} \u0026 1^{14}\\end{matrix} $$ 结果就是 14。 对于这个结果，如果1最先出现在下面一行，则需要再计算一次，而且这次计算必须使得余数是1。 假设输入 $ a,b $ 满足 $ a\u003cb $ 。中间的步骤和之前一行，在计算过程中必然存在一个 $ i $ 使得 $ b_{i}=1 $ ，此时我们只需计算 $ B_{i+1} $ 即可得到结果。其中 $ B_{i+1}=A_{i}+B_{i}\\cdot \\left(a_{i} - 1\\right) $ 。 代码如下： #include \u003ciostream\u003e using namespace std; struct Num { int nBase, nIndex; // 分别表示底数和奇数 }; Num x, y; int main() { cin \u003e\u003e x.nBase \u003e\u003e y.nBase; x.nIndex = 1; y.nIndex = 0; // 初始化 if(x.nBase \u003c y.nBase) { while(1) { if(x.nBase == 1 || x.nBase == 0) // 循环出口 { cout \u003c\u003c x.nIndex \u003c\u003c endl; break; } if(x.nBase \u003c y.nBase) // 模拟计算过程 { int nDiv = y.nBase / x.nBase; if(y.nBase % x.nBase == 0) { nDiv--; } y.nBase %= x.nBase; y.nIndex += nDiv * x.nIndex; } else { int nDiv = x.nBase / y.nBase; if(x.nBase % y.nBase == 0) { nDiv--; } x.nBase %= y.nBase; x.nIndex += nDiv * y.nIndex; } } } else { while(1) { if(y.nBase == 1) // 出口 { int nDiv = x.nBase - 1; cout \u003c\u003c nDiv * y.nIndex + x.nIndex \u003c\u003c endl; // 求出结果 break; } if(x.nBase \u003c y.nBase) // 模拟计算过程 { int nDiv = y.nBase / x.nBase; if(y.nBase % x.nBase == 0) { nDiv--; } y.nBase %= x.nBase; y.nIndex += nDiv * x.nIndex; } else { int nDiv = x.nBase / y.nBase; if(x.nBase % y.nBase == 0) { nDiv--; } x.nBase %= y.nBase; x.nIndex += nDiv * y.nIndex; } } } return 0; } 可能上面的算法对于某些人来说比较晦涩，我们下面来介绍一下扩展欧几里德算法。首先介绍一个定理： 方程 $ ax+by=\\gcd\\left ( a,b \\right ) $ 一定有解。 这样我们的问题就可以转化为求方程 $ ax+b\\cdot \\left ( -y \\right )=1 $ ，在这里，我们先求出方程 $ ax+b\\cdot \\left ( -y \\right )=\\gcd\\left(a,b\\right) $ 的解，然后只要将结果除以 $ \\gcd\\left(a,b\\right) $ 就行了。 下面来推导一下扩展欧几里德算法。 我们已知 $$ ax+by=\\gcd\\left ( a,b \\right ) $$ 且 $$ \\gcd\\left ( a,b \\right )=\\gcd\\left(b,a\\mod b \\right ) $$ 不妨设 $$ bx{}'+\\left ( a\\mod b \\right )y{}'=\\gcd\\left ( b,a\\mod b \\right ) $$ 此时就有 $$ bx{}'+\\left ( a\\mod b \\right )y{}'=ax+by $$ 展开得到 $$ bx{}'+\\left ( a-\\left [ \\frac{a}{b} \\right ]\\cdot b \\right )y{}'=ax+by $$ 化简得 $$ ay{}'+b\\left (x{}'-\\left [ \\frac{a}{b} \\right ]\\cdot y{}' \\right )=ax+by $$ 因此可以得到 $$ x=y{}',y=x{}'-\\left [ \\frac{a}{b} \\right ]\\cdot y{}' $$ 这样我们就可以用递归来实现扩展欧几里德算法了。 代码如下： #include \u003ciostream\u003e using namespace std; typedef long long LL; LL A, B, C, X = 0, Y = 0; LL gcd(LL a, LL b); void exgcd(LL a, LL b, LL \u0026x, LL \u0026y); int main() { cin \u003e\u003e A \u003e\u003e B; C = gcd(A, B); exgcd(A, -B, X, Y); while(X \u003c 0) { X += B; } // 找最小正整数 cout \u003c\u003c X \u003c\u003c endl; return 0; } void exgcd(LL a, LL b, LL \u0026x, LL \u0026y) { if(a == 0) { x = 0; y = C / b; // 边界 } else { exgcd(b % a, a, x, y); y = x; // 递推公式 x = (C - b * y) / a; } } LL gcd(LL a, LL b) // 求解最大公倍数 { if(b == 0) { return a; } else { return gcd(b, a % b); } } 相比之下扩展欧几里德更容易理解一点，并且没有大衍求一术那么多特殊情况要处理，比较方便。 ","date":"2013-11-04","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/:0:0","tags":["不定方程"],"title":"算法专题：不定方程","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/"},{"categories":["码志"],"content":"强连通分量（Strongly Connected Components），简称 SCC。是指在给定的一张图 $ G=\\left(V,E\\right) $ 的一个子图 $ G{}'=\\left(V,E\\right) $ 这个子图满足对于其中的任意一对点 $ \\left \\langle V_{i},V_{j} \\right \\rangle $ 均存在这样两条路径 $ \\left \\langle V_{i},\\cdots,V_{j} \\right \\rangle,\\left \\langle V_{j},\\cdots,V_{i} \\right \\rangle $ 。 如果我们把强连通分量缩成一个点，这时候，原图 $ G $ 则会变成有向无环图。 图 $ G=\\left(V,E\\right) $ 是有向无环图当且仅当该图中没有点集合元素个数大于1的强连通分量。且任意一个强连通分量都至少包含一个有向环。下面我们通过一张图片来理解一下强连通分量以及缩点： 强连通分量\" 强连通分量 对于统计给定的图 $ G=\\left(V,E\\right) $ 中强连通分量的个数，我们可以应用并查集在 $ O\\left ( \\alpha \\left ( V \\right )\\cdot V \\right ) $ 时间内得到求解。 如果不仅需要统计强连通分量的个数，还要将强连通分量缩点，则需要用到今天介绍的Kosaraju Algorithm。它的具体步骤如下： 对原图 $ G $ 进行DFS并将出栈顺序进行逆序，得到的顺序就是拓扑序列。 将原图的每一条边反向，得到反图 $ G{}' $ 。 按照第一步生成的拓扑序列的顺序再对反图 $ G{}' $ 进行DFS染色，染成同色的就是一个强连通分量。 这个算法比较容易理解，也是最通用的算法。它主要是同时运用了原图 $ G $ 和反图 $ G{}' $ 。 该算法具有一个性质：如果我们把求出来的每个强连通分量缩成一个点，并且用求出每个强连通分量的顺序来标记收缩后的结点，那么这个顺序就是强连通分量缩点后所形成的有向无环图的拓扑序列。 代码如下： #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cstack\u003e using namespace std; const int MAX = 10240; int N, M, nCnt = 0; int pMap[MAX][MAX], pColor[MAX]; stack\u003cint\u003e S; // 储存拓扑序列 void dfs1(int x); // 原图DFS void dfs2(int x); // 反图DFS void Kosaraju(); int main() { cin \u003e\u003e N \u003e\u003e M; memset(pMap, 0, sizeof(pMap)); for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s][e] = 1; // 有向图 } Kosaraju(); return 0; } void Kosaraju() { memset(pColor, 0, sizeof(pColor)); for(int i = 1; i \u003c= N; i++) // DFS原图求出拓扑序列 { if(!pColor[i]) { dfs1(i); } } memset(pColor, 0, sizeof(pColor)); while(!S.empty()) // 按照拓扑序列DFS反图 { int x = S.top(); S.pop(); if(!pColor[x]) { nCnt++; // 找到一个强连通分量 dfs2(x); } } cout \u003c\u003c \"The number of SCC is \" \u003c\u003c nCnt \u003c\u003c endl; } void dfs1(int x) { pColor[x] = 1; // 染色 for(int i = 1; i \u003c= N; i++) { if(pMap[x][i] == 1 \u0026\u0026 !pColor[i]) { dfs1(i); } } S.push(x); // 加入拓扑序列 } void dfs2(int x) { pColor[x] = nCnt; // 属于第几个强连通分量 for(int i = 1; i \u003c= N; i++) { if(pMap[i][x] == 1 \u0026\u0026 !pColor[i]) // 原邻接矩阵的对称矩阵为反图 { dfs2(i); } } } ","date":"2013-11-04","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-kosaraju-algorithm/:0:0","tags":["强连通分量"],"title":"算法专题：强连通分量 - Kosaraju Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-kosaraju-algorithm/"},{"categories":["码志"],"content":"传递闭包（Transitive Closure）主要是研究图上两点之间的连通性。对于这个问题，我们只需要改进一下 Floyd-Warshall Algorithm 就可以很方便的求出它的解。 我们这里主要研究的是有向图的传递闭包问题。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 10240; const int INF = 65536; int N, M; bool f[MAX][MAX], pMap[MAX][MAX]; void Floyd(); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { pMap[i][j] = f[i][j] = (i == j) ? 1 : 0; // 初始化 } } for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s][e] = pMap[e][s] = true; // 无向图 f[s][e] = f[e][s] = true; } Floyd(); return 0; } void Floyd() { for(int k = 1; k \u003c= N; k++) // 最外层必须是k { for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { f[i][j] = f[i][j] || (f[i][k] \u0026\u0026 f[k][j]); // 判断连通性 } } } for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { cout \u003c\u003c f[i][j] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } 这个算法还是比较简单的，只要在 Floyd-Warshall Algorithm 的基础上修改一下就行了。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/:0:0","tags":["传递闭包"],"title":"算法专题：传递闭包","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85/"},{"categories":["码志"],"content":"欧拉回路（Euler Circuit）是指：在一个无向图中，一条包含所有边，且其中每一条边只经过一次的路径。欧拉回路最常见的应用是一笔画。 下面介绍几个用于判断给定的图 $ G=\\left(V,E\\right) $ 中是否欧拉通路或欧拉回路： 一个图有欧拉回路当且仅当它是连通的且每个顶点都有偶数度。 一个图有欧拉通路当且经当它是连通的且除两个顶点外，其他顶点都有偶数度。 在第二个定理下，含奇数度的两个节点中，一个必为欧拉通路起点，另一个必为欧拉通路的终点。 这样，我们就可以很容易想出程序的思路： 计算各个顶点的度，如果存在 1 个奇数度，或者奇数度个数大于 2，则不存在欧拉回路。 选择奇数度的一个顶点作为欧拉回路的起点，如果不存在奇数度的顶点，则任意选取一个，在这里我们选取第一个顶点。 每次遍历与该点相连的边，删去该条边，则原图就转化成了一个更小的图，求它的欧拉通路，这样递归即可求解。 代码如下： #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int MAX = 10240; int N, M, pCnt[MAX]; int pMap[MAX][MAX]; vector\u003cint\u003e pVec; void Search(int x); void Euler_Circuit(); int main() { cin \u003e\u003e N \u003e\u003e M; memset(pMap, 0, sizeof(pMap)); for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s][e] = pMap[e][s] = 1; // 无向图 } Euler_Circuit(); return 0; } void Euler_Circuit() { int nStart = 1, nOddNum = 0; // nStart保存起点，nOddNum保存有几个顶点有奇数度 memset(pCnt, 0, sizeof(pCnt)); for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { pCnt[i] += pMap[i][j]; // 计算各个顶点的度 } } for(int i = 1; i \u003c= N; i++) // 统计奇数度顶点的个数 { if(pCnt[i] \u0026 1) { nStart = i; nOddNum++; } } if(nOddNum \u003e 2 || nOddNum == 1) // 不存在欧拉回路 { cout \u003c\u003c \"Not Exsit Euler Circuit\" \u003c\u003c endl; } else { Search(nStart); for(int i = 0; i \u003c pVec.size(); i++) { cout \u003c\u003c pVec[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } void Search(int x) { for(int i = 1; i \u003c= N; i++) { if(pMap[x][i] == 1) { pMap[x][i] = pMap[i][x] = 0; // 删边 Search(i); } } pVec.push_back(x); } 欧拉回路我至今也没有在做题目的时候用到过，不知道是不是这类题目比较少见。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/:0:0","tags":["欧拉回路"],"title":"算法专题：欧拉回路","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"categories":["码志"],"content":"拓扑排序（Topological Sorting）是图论中一个比较重要的概念。它主要用来解决下面这类问题： 给定一个 AOV 网（Activity On Vertex Network）， $ A\\rightarrow B $ 表示活动 $ A $ 必须在活动 $ B $ 之前完成。请给出一个合理的活动顺序。 当然，AOV 网中不可能出现环，因为出现了环就无法拓扑排序。因此可以用拓扑排序来判断图中是否存在环。 关于拓扑排序，我们来看一下下面这张图片： Toplogical Sorting\" Toplogical Sorting 我们可以用队列来实现这个算法，具体改进的过程如下： 记录每个点的入度； 将入度为 0 的顶点加入队列； 依次对入度为 0 的点进行删边操作，同时将新得到的入度为零的点加入队列； 重复上述操作，直至队列为空。 代码如下： #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; int N, M, pDegree[MAX]; queue\u003cint\u003e Q; vector\u003cint\u003e pMap[MAX], pVec; void TopSort(); int main() { cin \u003e\u003e N \u003e\u003e M; memset(pDegree, 0, sizeof(pDegree)); for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s].push_back(e); // 有向图 pDegree[e]++; // 计算入度 } TopSort(); return 0; } void TopSort() { for(int i = 1; i \u003c= N; i++) { if(pDegree[i] == 0) // 入度为0的点入队 { Q.push(i); } } while(!Q.empty()) { int x = Q.front(); Q.pop(); pVec.push_back(x); // 出队顺序即为拓扑序列 for(int i = 0; i \u003c pMap[x].size(); i++) { pDegree[pMap[x][i]]--; // 删边 if(pDegree[pMap[x][i]] == 0) // 新的入度为0的点 { Q.push(pMap[x][i]); } } } for(int i = 1; i \u003c= N; i++) { if(pDegree[i] != 0) // 若存在入度不为0的点，则存在环 { cout \u003c\u003c \"Exsit Loop\" \u003c\u003c endl; return; } } for(int i = 0; i \u003c pVec.size(); i++) // 顺序输出即为拓扑序列 { cout \u003c\u003c pVec[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } {% endhighlight %} 对于这一问题，我们也可以用DFS来解决它，代码如下： {% highlight cpp linenos %} #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; const int MAX = 10240; int N, M, pVisited[MAX]; // 0-未访问 1-正在访问 2-已访问 vector\u003cint\u003e pMap[MAX], pVec; void TopSort(); bool DFS(int v); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e; cin \u003e\u003e s \u003e\u003e e; pMap[s].push_back(e); // 有向图 } TopSort(); return 0; } void TopSort() { memset(pVisited, 0, sizeof(pVisited)); for(int i = 1; i \u003c= N; i++) // 所有顶点都访问一遍 { if(!pVisited[i]) { if(!DFS(i)) { cout \u003c\u003c \"Exsit Loop\" \u003c\u003c endl; } } } for(int i = pVec.size() - 1; i \u003e= 0; i--) // 倒序输出拓扑序列 { cout \u003c\u003c pVec[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } bool DFS(int v) // false-有环 true-无环 { pVisited[v] = 1; // 正在访问 for(int i = 0; i \u003c pMap[v].size(); i++) // 搜索它的前驱 { if(pVisited[pMap[v][i]] == 1) { return false; } // 该点进入两次则有环 else if(pVisited[pMap[v][i]] == 0) { if(!DFS(pMap[v][i])) { return false; } } } pVisited[v] = 2; // 访问完毕 pVec.push_back(v); // 加入拓扑序列 return true; } 相较这两种算法，我更倾向于用队列来实现，毕竟这种方法符合求解拓扑排序的一般思路。至于这两种算法的复杂度，在这里就不再分析了。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:0:0","tags":["拓扑排序"],"title":"算法专题：拓扑排序","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["码志"],"content":"这次我们来讨论一下关于多源最短路径 APSP（All-Pairs Shortest Paths）。即求出给定的图 $ G=\\left ( V,E \\right ) $ 中任意两对顶点 $ V_{i},V_{j} $ 之间的最短路径。我们根据下面这幅图来理解一下这个概念： 多源最短路径\" 多源最短路径 对于这一问题，比较有效的算法是 Floyd-Warshall Algorithm，简称 Floyd。它是基于动态规划的一种最短路径的算法。 我们用 $ f^{k}\\left ( i,j \\right ) $ 来表示从顶点 $ i $ 到顶点 $ j $ 不经过索引比 $ k $ 大的点的最短路径。这样一来，我们就可以根据 $ f^{k-1}\\left ( i,j \\right ) $ 推出 $ f^{k}\\left ( i,j \\right ) $ 。 假设我们目前已知 $ f^{k-1}\\left ( i,j \\right ) $ ，要推出 $ f^{k}\\left ( i,j \\right ) $ ，无外乎两种情况： 经过顶点 $ k $ ； 不经过顶点 $ k $ 。 对于第一种情况，显然有 $ f^{k}\\left ( i,j \\right )=f^{k-1}\\left ( i,k \\right )+f^{k-1}\\left ( k,j \\right ) $ 。对于第二种情况，我们也很容易得到 $ f^{k}\\left ( i,j \\right )=f^{k-1}\\left ( i,j \\right ) $ 。这样一来，状态转移方程也就确定了： $$ f^{k}\\left ( i,j \\right )=\\min{\\left \\{ f^{k-1}\\left ( i,k \\right )+f^{k-1}\\left ( k,j \\right ),f^{k-1}\\left ( i,j \\right ) \\right \\}} $$ 这样一来，也就解决了为什么 Floyd-Warshall Algorithm 的最外层循环必须是 $ k $ 这一问题。很显然，Floyd-Warshall Algorithm 的时间复杂度为 $ O\\left(V^{3}\\right) $ 。 当然，这个算法还可以用来求最小环，具体求法请参考代码，应该能看懂，就不再多说。 代码如下： #include \u003ciostream\u003e using namespace std; const int MAX = 10240; const int INF = 65536; int N, M; int f[MAX][MAX], pMap[MAX][MAX]; void Floyd(); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { pMap[i][j] = f[i][j] = (i == j) ? 0 : INF; // 初始化 } } for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; pMap[s][e] = v; pMap[e][s] = v; // 无向图 f[s][e] = v; f[e][s] = v; } Floyd(); return 0; } void Floyd() { int nLen = 65536; for(int k = 1; k \u003c= N; k++) // 最外层必须是k { for(int i = 1; i \u003c= k; i++) // 求解最小环 { for(int j = 1; j \u003c= k; j++) { nLen = min(nLen, pMap[i][j] + f[i][k] + f[k][j]); } } for(int i = 1; i \u003c= N; i++) // 求解APSP { for(int j = 1; j \u003c= N; j++) { if(f[i][k] + f[k][j] \u003c f[i][j]) // 是否需要松弛 { f[i][j] = f[i][k] + f[k][j]; } } } } cout \u003c\u003c \"Shortest Loop is \" \u003c\u003c nLen \u003c\u003c endl; for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { if(f[i][j] == INF) { cout \u003c\u003c \"-1 \"; } else { cout \u003c\u003c f[i][j] \u003c\u003c \" \"; } } cout \u003c\u003c endl; } } ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-floyd-warshall-algorithm/:0:0","tags":["多源最短路径"],"title":"算法专题：多源最短路径 - Floyd-Warshall Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-floyd-warshall-algorithm/"},{"categories":["码志"],"content":"SPFA 是 Shortest Path Fast Algorithm 的缩写，它是之前介绍的 Bellman-Ford Algorithm 的一种队列实现，减少了不必要的冗余计算。 算法的基本步骤如下： 初始化队列和标记数组，将源点入队。 每次取队首元素，对其发出的所有边进行松弛。并将松弛过的且不在队列中的顶点加入到队列中。 重复第二步直至队列为空。 若要判断负环，则当某个顶点松弛超过V次，即存在负环。 对于SPFA还是比较容易理解的，它的复杂度为 $O\\left(kE\\right)$。 代码如下： #include \u003ciostream\u003e#include \u003cmemory.h\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; bool pQueue[MAX]; int N, M, pDist[MAX], pCnt[MAX]; // pCnt[]记录顶点i松弛的次数 vector\u003cpair\u003cint, int\u003e \u003e pMap[MAX]; queue\u003cint\u003e Q; void SPFA(int s); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; pMap[s].push_back(make_pair(e, v)); // 无向图 pMap[e].push_back(make_pair(s, v)); } SPFA(1); return 0; } void SPFA(int s) { bool bNativeLoop = false; // 判断负环的变量 for(int i = 1; i \u003c= N; i++) // 初始化 { pDist[i] = 2147483647; } memset(pQueue, false, sizeof(pQueue)); pDist[s] = 0; Q.push(s); // 源点入队 pQueue[s] = true; while(!Q.empty()) { int x = Q.front(); Q.pop(); // 取出队首元素 pQueue[x] = false; // 出队 for(int i = 0; i \u003c pMap[x].size(); i++) { if(pDist[pMap[x][i].first] \u003e pDist[x] + pMap[x][i].second) // 松弛 { pDist[pMap[x][i].first] = pDist[x] + pMap[x][i].second; if(!pQueue[pMap[x][i].first]) // 如果未入队 { Q.push(pMap[x][i].first); pQueue[pMap[x][i].first] = true; // 入队 if(++pCnt[pMap[x][i].first] \u003e N) { bNativeLoop = true; // 存在负环 while(!Q.empty()) { Q.pop(); } // 立即退出循环 } } } } } if(bNativeLoop) { cout \u003c\u003c \"Exist Negative Loop\" \u003c\u003c endl; } else { for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c pDist[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } 至此，单源最短路的算法基本复习结束。细究这三种算法，个人觉得 SPFA 的编程复杂度较低。而 Dijkstra Algorithm 也挺实用的。不过在一般情况下我比较倾向于 SPFA。 ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-spfa/:0:0","tags":["单源最短路径"],"title":"算法专题：单源最短路径 - SPFA","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-spfa/"},{"categories":["码志"],"content":"上一篇文章介绍了一下 Dijkstra Algorithm，但是它仅局限于处理非负权值的图。若图中出现负边，Dijkstra Algorithm 就会出现错误。这时候就需要使用其他的算法来求解单源最短路径。 Ballman-Ford 是一个非常实用的算法，它是由美国数学家 Richard Ballman 和 Lester Ford 发明的。Ballman-Ford 算法的基本流程如下： 初始化 $ pDist\\left [ \\right ] $ 数组。 检查每一条边，如果源点到该条边的起点有通路，则更新原点到该条边的终点的最短路径。循环 $ V $ 次即可得到结果。 如若要检测是否存在负环，则再检查每一条边，若可以松弛，则有负环。 我们来看一张图片具体体会一下 Bellman-Ford Algorithm： Bellman-Ford 算法\" Bellman-Ford 算法 这个算法相对而言比较容易实现，复杂度为 $ O\\left ( VE \\right ) $ 。 代码如下： #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; const int INF = 2147483647; struct Edge { Edge(int _s, int _e, int _v) { s = _s; e = _e; v = _v; } int s, e, v; }; int N, M; int pDist[MAX]; vector\u003cEdge\u003e pEdge; // 边集数组 void Ford(int s); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; pEdge.push_back(Edge(s, e, v)); // 无向图 pEdge.push_back(Edge(e, s, v)); } Ford(1); return 0; } void Ford(int s) { bool bNativeLoop = false; // 记录是否存在负环 for(int i = 1; i \u003c= N; i++) // 初始化 { pDist[i] = INF; } pDist[s] = 0; for(int i = 1; i \u003c= N; i++) // 循环N次 { for(int j = 0; j \u003c pEdge.size(); j++) // 每次检查每一条边 { int s = pEdge[j].s, e = pEdge[j].e, v = pEdge[j].v; if(pDist[s] != INF) // 如果源点可以到达顶点s则进行松弛 { pDist[e] = min(pDist[e], pDist[s] + v); } } } for(int i = 0; i \u003c pEdge.size(); i++) // 检查负环 { int s = pEdge[i].s, e = pEdge[i].e, v = pEdge[i].v; if(pDist[e] \u003e pDist[s] + v) // 若松弛完毕后还能松弛，则存在负环 { bNativeLoop = true; break; } } if(bNativeLoop == true) { cout \u003c\u003c \"Exist Native Loop\" \u003c\u003c endl; } else { for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c pDist[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-bellman-ford-algorithm/:0:0","tags":["单源最短路径"],"title":"算法专题：单源最短路径 – Bellman-Ford Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-bellman-ford-algorithm/"},{"categories":["码志"],"content":"这个星期开始复习最短路的一些算法。 单源最短路径（Single Source Shortest Paths），简称 SSSP。这是图论中非常重要的一类算法。解决这一问题有多种算法，今天先来介绍一下 Dijkstra Algorithm。 首先介绍一下单源最短路径的概念，通俗的讲，就是给定一个源点 $ s $ （即起点），求这个源点到其他各个顶点的最短路径。最短路径，通俗的来讲，我们称使得顶点 $ V_{i} $ 到顶点 $ V_{j} $ 所经过的路径的权值之和最小的一条路径，称为从顶点 $ V_{i} $ 到顶点 $ V_{j} $ 的最短路径。 单源最短路径\" 单源最短路径 上面这幅图标出了从源点 $ s $ 到各个顶点的最短路径，大家可以根据图片自己体会一下最短路径的含义。其中 $ -\\infty $ 表示到该点的最短路径是负无穷，因为我们发现存在负环，所以我们利用负环，使得最短路径达到负无穷，但是这个一般不在我们一般的算法的讨论范围内。 下面来介绍一下 Dijkstra Algorithm。 首先将所有的顶点分成两个集合 $ A $ 、 $ B $ ，其中集合 $ A $ 表示已经求得最短路径的顶点集合，集合 $ B $ 为待求解的顶点集合。初始时有 $ A=\\left { V_{0} \\right } $ 。 将集合 $ A $ 与集合 $ B $ 相连的边按照递增次序排序，取最短的边，将该条边在集合 $ B $ 中所对应的顶点加入到集合 $ A $ 中。 重复第二步，直至集合 $ B $ 为空集。 我们通过下面一幅图来理解一下 Dijkstra Algorithm： Dijkstra 算法\" Dijkstra 算法 下面我们来考虑算法的实现方式，显然，我们需要每次在集合 $ A $ 中发出的所有边中找到最小的一条边，而每次这样找的话，复杂度很高，我们可以考虑用优先队列来优化这个步骤。这样的话复杂度就下降到了 $ O\\left ( \\left ( V+E \\right )\\cdot \\log{E} \\right ) $ 。 代码如下： #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cqueue\u003e using namespace std; const int MAX = 10240; typedef pair\u003cint,int\u003e pii; int N, M; int pDist[MAX]; vector\u003cpair\u003cint, int\u003e \u003e pMap[MAX]; priority_queue\u003cpii, vector\u003cpii\u003e, greater\u003cpii\u003e \u003e Q; // 优先队列 void Dijkstra(int s); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int s, e, v; cin \u003e\u003e s \u003e\u003e e \u003e\u003e v; // 无向图 pMap[s].push_back(make_pair(e, v)); pMap[e].push_back(make_pair(s, v)); } Dijkstra(1); return 0; } void Dijkstra(int s) { for(int i = 1; i \u003c= N; i++) // 初始化 { pDist[i] = 2147483647; } pDist[s] = 0； Q.push(make_pair(pDist[s], s)); // 将源点加入队列 while(!Q.empty()) { pii x = Q.top(); Q.pop(); // 取最短的边 if(x.first != pDist[x.second]) { continue; } // 防止重复计算 for(int i = 0; i \u003c pMap[x.second].size(); i++) { int v = pMap[x.second][i].first; // 待松弛的顶点 int w = pMap[x.second][i].second; // 从顶点x.second到顶点i的距离 if(pDist[v] \u003e pDist[x.second] + w) { pDist[v] = pDist[x.second] + w; // 松弛 Q.push(make_pair(pDist[v], v)); } } } for(int i = 1; i \u003c= N; i++) { cout \u003c\u003c pDist[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } ","date":"2013-11-03","objectID":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra-algorithm/:0:0","tags":["单源最短路径"],"title":"算法专题：单源最短路径 – Dijkstra Algorithm","uri":"/2013/11/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra-algorithm/"},{"categories":["码志"],"content":"今天来介绍一下最小生成树的另外一种算法：Kruskal Algorithm。这个算法是基于贪心实现的，算法的大体过程如下： 取权值最小的边，如果加入这条边以后，不会出现环，那么就加入这条边。 重复上述操作，直至加入了 $ N-1 $ 条边。 我们还是先来看一张图片来理解一下这个算法： Kruskal 算法\" Kruskal 算法 下面我们来考虑这个算法，最棘手的问题是判断是否构成环，这里我们采用并查集来处理这个问题，它的复杂度是 $ O\\left(V*\\alpha\\left(V\\right)\\right) $ 。对于每次寻找权值最小的边，复杂度是 $ O\\left(E\\right) $ 。这样一来，复杂度将高达 $ O\\left(V*\\alpha\\left(V\\right)+VE\\right) $ ，即 $ O\\left(VE\\right) $ 。 我们考虑优化，每次寻找权值最小的边，可以考虑先将权值从小到大排序。这样复杂度就下降到 $ O\\left(V*\\alpha\\left(V\\right)+E\\log{E}\\right) $ ，即 $ O\\left(E\\log{E}\\right) $ 。 代码如下： #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e using namespace std; const int MAX = 1024; struct Edge { Edge(int _u, int _v, int _w) { u = _u; v = _v; w = _w; } int u, v, w; }; struct Set { int nParent, nCount; }; int cmp(Edge x, Edge y) { return x.w \u003c y.w; } int N, M; vector\u003cEdge\u003e pEdge; Set pSet[MAX]; void Kruskal(); void Init(); int Find(int x); void Union(int x, int y); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int u, v, w; cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; pEdge.push_back(Edge(u, v, w)); } Kruskal(); return 0; } void Kruskal() { int nCost = 0, nPos = 0; vector\u003cEdge\u003e pMST; sort(pEdge.begin(), pEdge.end(), cmp); Init(); while(pMST.size() != N - 1) // 直到MST中有N-1条边 { Edge minEdge = pEdge[nPos++]; if(Find(minEdge.u) != Find(minEdge.v)) // 如果加入后不构成环 { nCost += minEdge.w; pMST.push_back(minEdge); Union(minEdge.u, minEdge.v); } } cout \u003c\u003c \"The MST Cost is \" \u003c\u003c nCost \u003c\u003c endl; } void Init() { for(int i = 1; i \u003c= N; i++) { pSet[i].nParent = i; pSet[i].nCount = 1; } } int Find(int x) { if(pSet[x].nParent != x) { return pSet[x].nParent = Find(pSet[x].nParent); // 路径压缩 } else { return x; } } void Union(int x, int y) { int fx = Find(pSet[x].nParent); int fy = Find(pSet[y].nParent); if(fx != fy) // 启发式合并，减小树的高度 { if(pSet[fx].nCount \u003e pSet[fy].nCount) { pSet[fy].nParent = fx; pSet[fx].nCount += pSet[y].nCount; } else { pSet[fx].nParent = fy; pSet[fy].nCount += pSet[x].nCount; } } } 至此，最小生成树的算法基本复习完毕。 分析两种算法，Prim Algorithm的复杂度是 $ O\\left(V^{2}\\right) $ ，适用于稠密图；而Kruskal Algorithm的复杂度是 $ O\\left(E\\log{E}\\right) $ ，适用于疏密图。各有所长，需要根据不同的情况选择不同的算法。 ","date":"2013-10-20","objectID":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-kruskal-algoritm/:0:0","tags":["最小生成树"],"title":"算法专题：最小生成树 – Kruskal Algoritm","uri":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-kruskal-algoritm/"},{"categories":["码志"],"content":"最近开始准备 NOIP 复赛，发现很多算法已经不会了。只能一个个的捡起来，慢慢复习，顺便做点笔记。 最小生成树（Minimum Spanning Trees），简称 MST。是图论中一个非常重要的概念。解决这个问题有两种算法，今天暂且先来讨论一下 Prim Algorithm。不做特别说明，讨论的都是无向图。 首先介绍一下最小生成树的概念，我们知道，图可以这样定义 $ G=\\left(V,E\\right) $ ，其中 $ G $ 表示图， $ V $ 表示顶点集合， $ E $ 表示边集合。最小生成树是这样一棵树，它满足 $$ w\\left ( T \\right )=\\min {\\left \\{ \\sum_{\\left ( u,v \\right )\\in T}w\\left ( u,v \\right ) \\right \\}} $$ 通俗地讲，就是使得图 $ G $ 连通时，所选取的边的长度的和最小。 最小生成树\" 最小生成树 如上图，加粗的路径就是在最小生成树上的路径。 现在，我们开始讨论Prim Algorithm。这个算法可以分为下面几个步骤： 将顶点集 $ V $ 分成两个集合 $ A $ 和 $ B $ ，其中集合 $ A $ 表示目前已经在MST中的顶点，而集合 $ B $ 则表示目前不在 MST 中的顶点。 寻找与集合 $ A $ 连通的最短的边 $ \\left(u,v\\right) $ ，将这条边加入最小生成树中。（此时，与 $ \\left(u,v\\right) $ 相连的顶点，不妨设为 $ B_{i} $ ，也应加入集合 $ A $ 中） 重复第二步，直至集合 $ B $ 为空集。 算法的大体思想就是这样了。为了方便理解，我们先来看一下下面一张图片： Prim 算法\" Prim 算法 对照上面的图片，想必对于 Prim Algorithm 也有了一定的理解。 下面我们来设计算法，显然，我们需要遍历集合 $ A $ 中所有顶点及与之相连的边，取连接到集合 $ B $ 的权值最小的边，加入最小生成树。这样一来，复杂度将达到 $ O\\left(n^{3}\\right) $ 。 我们可以对这个想法进行优化。我们维护一个 $ pCost\\left [ i \\right ] $ 数组，用来表示从集合 $ A $ 到与之相邻的节点的最小费用。这样，我们只要每次取这个数组中的最小值，把它在集合 $ B $ 中所对应的结点 $ V_{i} $ 加入到集合 $ A $ 中。每次加入结束以后，都要更新 $ pCost\\left [ i \\right ] $ 数组。即枚举所有与结点 $ V_{i} $ 相连的边，判断是否比 $ pCost\\left [ i \\right ] $ 数组中的最小费用小，如果比它小，则更新。这样可以将算法优化到 $ O\\left(n^{2}\\right) $ 。 代码如下： #include \u003ciostream\u003e#include \u003cmemory.h\u003e #include \u003cvector\u003e using namespace std; const int MAX = 1024; const int INF = 2147483647; // 设置最大权值 int N, M; vector\u003cpair\u003cint, int\u003e \u003e pMap[MAX]; // 邻接表 void Prim(); int main() { cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= M; i++) { int u, v, w; cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; pMap[u].push_back(make_pair(v, w)); pMap[v].push_back(make_pair(u, w)); } Prim(); return 0; } void Prim() { int nCost = 0; vector\u003cint\u003e pMST; // 储存MST的结点 int pCost[MAX]; // 储存与集合A相邻的顶点的最小权值，0表示该结点已经在MST中 pMST.push_back(1); // 将结点1加入MST pCost[1] = 0; for(int i = 2; i \u003c= N; i++) // 初始化，切记要将除1以外的都置为INF { pCost[i] = INF; } for(int i = 0; i \u003c pMap[1].size(); i++) // 处理与结点1相连的顶点 { pCost[pMap[1][i].first] = pMap[1][i].second; } for(int i = 1; i \u003c= N - 1; i++) // 剩余N-1个顶点，循环N-1次 { int nVertex = 0, nWeight = INF; // 用于寻找最短的边 for(int j = 1; j \u003c= N; j++) { if(nWeight \u003e pCost[j] \u0026\u0026 pCost[j] != 0) { nVertex = j; nWeight = pCost[j]; } } pCost[nVertex] = 0; pMST.push_back(nVertex); // 将节点nVertex加入MST nCost += nWeight; // 计算MST的费用 for(int j = 0; j \u003c pMap[nVertex].size(); j++) // 更新pCost数组 { if(pCost[pMap[nVertex][j].first] != 0 \u0026\u0026 pCost[pMap[nVertex][j].first] \u003e pMap[nVertex][j].second) { pCost[pMap[nVertex][j].first] = pMap[nVertex][j].second; } } } cout \u003c\u003c \"MST Cost is \" \u003c\u003c nCost \u003c\u003c endl; cout \u003c\u003c \"The vertexs in MST are \"; for(int i = 0; i \u003c pMST.size(); i++) { cout \u003c\u003c pMST[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; } ","date":"2013-10-19","objectID":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim-algoritm/:0:0","tags":["最小生成树"],"title":"算法专题：最小生成树 – Prim Algoritm","uri":"/2013/10/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim-algoritm/"},{"categories":["浮生杂记"],"content":"随便写写，记录一下最近发生的事情。 高中最后一次运动会居然是在停课中度过的。不过比起化学组去省选的那些人还算幸运的，至少也参与了一点，虽然成绩只有一个引体向上。 29号晚自习，我在机房给高二的上课，讲解初赛的选择题。真正感觉到了「后生可畏」的感觉。本来想冲个省队的，但是我们的国赛在明年7月份，那时候我们已经毕业了，所以不能代表江苏省参赛。信息学竞赛就这点不好，各门竞赛大多高三才到炉火纯青的地步，却不给省队资格。虽然我们全国各地的高三选手联名向CCF抗议，但还是无疾而终。挺可惜的，但至少可以拿个省一回来，给竞赛画上圆满的句号。 我们开发团队的一个初三的学生，把我之前的一篇日志《中秋望月感怀》当做语文作业的作文交了上去，受宠若惊。 前几天和上一届高三的物理竞赛保送大神杨文杰聊了一会儿。咨询了一下高考，自招，交大的相关事宜。总结下来一句话： 踏踏实实做学问。 关于这方面，张兴也给我讲过他静心治学的经历。 今天下午，黄旸洋给我打了个电话，聊了一下他的近况，各种感慨涌上心头。我也不知道该怎么平心静气的把它们记录下来，暂且按下不表。 高考要开始报名了。我也不知道最后会是什么结果，但是我清楚我想要的是什么结果。 我还记得，暑假在数学组的时候，袁秦盟经常喜欢说一句话 是的，我可以的！ 是的，我可以的！ ","date":"2013-09-30","objectID":"/2013/09/%E6%9D%82%E8%AE%B020130930/:0:0","tags":["高中生活"],"title":"杂记（20130930）","uri":"/2013/09/%E6%9D%82%E8%AE%B020130930/"},{"categories":["浮生杂记"],"content":"在我的印象中，从来没有过真正意义上的赏月。小时候虽然每年都会如约赏月，但那时候年纪尚小，即使望月，也不会有什么特别的感触。 自从高二受了周红娟老师的耳濡目染，再者，加上《唐诗之旅》的熏陶，开始对明月产生了一种别样的情怀。自此以后，每当看到明月，想到的不再时冷冰冰的月球，而是嫦娥玉兔，吴刚伐树。有时候甚至会像李白一样「举杯邀明月，对影成三人」。 前几天住宿的时候，便已经感到了中秋的到来。熄灯后，一束月光打在床上，真如太白所记「床前明月光，疑是地上霜」。 今天晚上看新闻，提到瘦西湖是最佳赏月之地，不禁想起徐凝的一句诗「天下三分明月夜，二分无赖是扬州」。好在身处农乡，不像城市中有高大的建筑物遮挡视线，也不用担心刺眼的霓虹灯会干扰赏月的心情。四下只有明亮的月光，别有一番意境。望着皎洁的月亮，一时思绪纷飞。 窗外响起了爆竹声，大家都对一年一度的中秋佳节抱有极大的好感。这么多年没有观赏月色，突然在中秋佳节赏月，心中有种说不出的感觉。为大自然的美妙所折服，人类终究还是渺小的。真希望可以和苏子一样「挟飞仙以遨游，抱明月而长终」。但到最后还是意识到「知不可乎骤得，托遗响于悲风」。 如此一来，不禁想到人事变迁。最先进入脑海的，是周红娟老师，说实话，跟她学到了很多东西。尤其是一种热爱生活、积极生活的态度。或许作为电教员跟她接触的机会多一点吧，感觉周红娟还是挺不错的一个老师，虽然有时候方式方法不太得当，但至少初衷还是好的。或许语文所要教会我们的，便是如何去生活，而不是如何去得分。就像高冰峰老师，一大把年纪了，还如此文艺，不得不说这是一种乐观积极的生活态度。对于周红娟老师的离开，早在她告诉我们她高三只能带一个班的时候，便已料到。后来在暑假里遇到她，得到了确定的消息，当时的确有些不舍，但有些事情总是不可避免的。不过还得谢谢她在大夏天来给我们送清凉。 明月自古便非常的忙碌，我也极少的去麻烦它。至多只是让它捎个信，带个问候罢了。我想今天的月亮一定会非常乐意的将我的思念传递给我的小伙伴们吧。古人是极富浪漫主义色彩的，只要双方都望着明月，明月就会帮他们传递心绪。这远比现代的即时通讯工具高级，靠的是人与自然的融合与共生。相较而言，我更喜欢后者。 高考是个不可避免的话题。虽然已经填完了大学的目标，但现在与之差距着实太大。在高一的时候，我曾幻想着可以拿到计算机一等，然后保送。这个五彩的肥皂泡最终随着竞赛保送制度的取消而破灭。接着，便想着自主招生，这是一条非常好的路径，考的还好可以本一即录，相当于报送。 但是，目睹了几位过来人的事迹，也对它产生了怀疑。就拿去年2013届高三（15）班的胡宇涛来说吧。他和我一起搞竞赛的。去年我们一起去南航参加复赛，第一天下午，2012届高三（15）班的缪晓伟（也是信息组的）带领我们参观南大（仙林校区），当时胡宇涛就表明了要进南大的意愿，他也是这样做的。平时模拟考390左右，有时候还上过400。后来参加了南大自主招生，考的时候差几分面试，只加了10分。到最后，高考却挂了。加来的10分就也形同虚设了。 有一首打油诗，感觉讲的非常在理： 自招毁一生，竞赛穷三代。要考好大学，还得语数外。 当然了，也不是让大家消极的对待自主招生，但是不要花太多精力，这种东西如同竞赛，全靠运气。时也，命也。当然，要考非常好的大学，还是需要自招降降门槛的。所以，这样说来，还是老老实实搞语数外来的实在。 细察为什么大家如此热衷保送，自招，无非就是「逃避」。逃避高考，保送是最好的道路；既然保送取消了，那只好拿自招来当垫背。细想来，这些又是何必呢，高考，终究还是要降临在我们的头上，也会给予我们相对客观公正的评价。 最后一句话，与大家共勉： 说出来被嘲笑的梦想，才有去实现的必要。 月色，还是那样的澄澈明净…… ","date":"2013-09-19","objectID":"/2013/09/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%80/:0:0","tags":["高中生活"],"title":"中秋望月感怀","uri":"/2013/09/%E4%B8%AD%E7%A7%8B%E6%9C%9B%E6%9C%88%E6%84%9F%E6%80%80/"},{"categories":["数学之美"],"content":"新版高中教材对复数内容进行了极大的删减，使得我们对于复数的认知还停留在最原始的阶段。殊不知，复数的应用非常广泛。现参考《高中数学·甲种本》以及搜集的一些资料，包括做过的例题，整理一下关于复数的内容。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:0:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"一、复数的概念 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"1.1 数的概念的发展 数的概念是从实践中产生和发展起来的。早在原始社会末期，由于记数的需要，人们就建立起自然熟的概念。自然数的全体构成自然数集 $ \\mathbf{N} $ 。 随着生产和科学的发展，熟的概念也得到了发展。 为了表示各种具有相反意义的量以及满足记数法的要求，人们引进了零和负数，把自然数看作正整数，把正整数、零、负整数合并在一起，构成整数集 $ \\mathbf{Z} $ 。 为了解决测量、分配中遇到的将某些量进行等分的问题，人们又引进了有理数，规定他们就是一切形如 $ \\frac{m}{n} $ 的数，其中 $ m\\in \\mathbf{Z},n\\in \\mathbf{N} $ 。这样，就把整数集 $ \\mathbf{Z} $ 扩大为有理数集 $ \\mathbf{Q} $ 。显然， $ \\mathbf{Z}\\subset \\mathbf{Q} $ 。如果把整数看作分母为 $ 1 $ 的分数，那么有理数实际上就是分数集。 每一个有理数都可以表示成整数、有限小数或循环节不为 $ 0 $ 的循环小数；反过来，整数、有限小数或循环节不为 $ 0 $ 的循环小数也都是有理数。如果把整数、有限小数都看作循环节为 $ 0 $ 的循环小数，那么有理数集实际上就是循环小数的集合。 为了解决有些量与量之间的比值（例如用正方形的边长去度量它的对角线所得结果）不能用有理数表示的矛盾，人们又引入了无理数。所谓无理数，就是无限不循环小数。有理数集与无理数集合并在一起，构成实数集 $ \\mathbf{R} $ 。因为有理数都可以看作循环小数（包括整数、有限小数），无理数都是无限不循环小数，所以实数集就是小数集。 从解方程来看，方程 $ x+5=3 $ 在自然数集 $ \\mathbf{N} $ 中无解，在整数集 $ \\mathbf{Z} $ 中就有一个解 $ x=-2 $ ；方程 $ 3x=5 $ 字整数集 $ \\mathbf{Z} $ 中无解，在有理数集 $ \\mathbf{Q} $ 中就有一个解 $ x=\\frac{5}{3} $ ；方程 $ x^{2}=2 $ 在有理数集 $ \\mathbf{Q} $ 中无解，在实数集 $ \\mathbf{R} $ 中就有两个解 $ x=\\pm \\sqrt{2} $ 。但是，熟的范围扩充到实数集 $ \\mathbf{R} $ 以后，象 $ x^{2}=-1 $ 这样的方程还是无解，因为没有一个实数的平方等于 $ -1 $ 。在十六世纪，由于解方程的需要，人们开始引进一个新数 $ i $ ，叫做虚数单位，并规定： 它的平方等于 $ -1 $ ，即 $$ i^{2}=-1 $$ 实数与它进行四则运算时，所有的加、乘运算律仍然成立。 在这种规定下， $ i $ 可以与实数 $ b $ 相乘，再同实数 $ a $ 相加，由于满足乘法交换律及加法交换律，从而可以把结果写成 $ a+bi $ 。人们把它们叫做复数。全体复数所成的集合，一般用字母 $ \\mathbf{C} $ 来表示。1 在这种规定下， $ i $ 就是 $ -1 $ 的一个平方根。因此，方程 $ x^{2}=-1 $ 在复数集 $ \\mathbf{C} $ 中就至少有一个解 $ x=i $ 。 十八世纪以后，复数在数学、力学和电学中得到了应用。从此对它的研究日益展开。现在复数已成为科学技术中普遍使用的一种数学工具。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:1","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"1.2 复数的有关概念 复数 $ a+bi $ （ $ a,b\\in\\mathbf{R} $ 。以后说复数 $ a+bi $ 时，都有 $ a,b\\in\\mathbf{R} $ ），当 $ b=0 $ 时，就是实数；当 $ b\\neq 0 $ 时，叫做虚数，当 $ a=0,b\\neq 0 $ 时，叫做纯虚数； $ a $ 与 $ b $ 分别叫做复数 $ a+bi $ 的实部与虚部。例如， $ 3+4i,-\\frac{1}{2}-\\sqrt{2}i,-0.5i $ 都是虚数，它们的实部分别是 $ 3,-\\frac{1}{2},0 $ ，虚部分别是 $ 4,-\\sqrt{2},-0.5 $ 。 显然，实数集 $ \\mathbf{R} $ 是复数集 $ \\mathbf{C} $ 的真子集，即 $ \\mathbf{R}\\subset \\mathbf{C} $ 。 如果两个复数 $ a+bi $ 与 $ c+di $ 的实部与虚部分别相等，我们就说这两个复数相等，记作 $ a+bi=c+di $ ，这就是说，如果 $ a,b,c,d\\in\\mathbf{R} $ ，那么 $$ a+bi=c+di \\Leftrightarrow a=c,b=d $$ $$ a+bi=0\\Leftrightarrow a=b=0 $$ 例：已知 $ \\left ( 2x-1 \\right )+i=y-\\left ( 3-y \\right )i $ ，其中 $ x,y\\in\\mathbf{R} $ 。求 $ x $ 与 $ y $ 。 解：根据复数相等的定义，得方程组 $ \\begin{cases} 2x-1=y,\\\\ 1=-\\left ( 3-y \\right ) \\end{cases} $ 解得 $ x=\\frac{5}{2},y=4 $ 。 从复数相等的定义，我们知道，任何一个复数 $ z=a+bi $ ，都可以由一个有顺序的实数对 $ \\left ( a,b \\right ) $ 唯一确定。这就使我们能借用平面直角坐标系来表示复数 $ z=a+bi $ 。如图1，点 $ Z $ 的横坐标是 $ a $ ，纵坐标是 $ b $ ，复数 $ z=a+bi $ 可用点 $ Z\\left ( a,b \\right ) $ 来表示。这个建立了直角坐标系表示复数的平面叫做复平面， $ x $ 轴叫做实轴， $ y $ 轴除去原点的部分叫做虚轴（因为原点表示实数 $ 0 $ ，原点不在虚轴上）。表示实数的点都在实轴上，表示纯虚数的点都在轴上。 复数的复平面表示法\" 复数的复平面表示法 很明显，按照这种表示方法，每一个复数，有复平面内唯一的一个点和它对应；反过来，复平面内的每一个点，有唯一的一个复数和它对应。由此可知，复数集 $ \\mathbf{C} $ 和复平面内所有的点所成的集合是一一对应的。这是复数的一个几何意义。 当两个复数实部相等，虚部互为相反数时，这两个复数叫做互为共轭复数（当虚部不等于 $ 0 $ 时也叫做互为共轭虚数）。复数 $ z $ 的共轭复数可以用 $ \\overline{z} $ 来表示，也就是说，复数 $ z=a+bi $ 的共轭复数是 $ \\overline{z}=a-bi $ 。显然，复平面内表示两个互为共轭复数的点 $ Z $ 与 $ \\overline{Z} $ 关于实轴对称（图2），而实数 $ a $ （即虚部为 $ 0 $ 的复数）的共轭复数仍是 $ a $ 本身。 两个实数可以比较大小。但是两个复数，如果不全是实数，就不能比较它们的大小。对于这个命题的证明，将稍后给出。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:2","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"1.3 复数的向量表示 在物理学中，我们经常遇到力、速度、加速度、电场强度等，这些量，除了要考虑它们的绝对值大小以外，还要考虑它们的方向。我们把这种既有绝对值大小又有方向的量叫做向量。向量可以用有向线段来表示，线段的长度就是这个向量的绝对值（叫做这个向量的模），线段的方向（用箭头表示）就是这个向量的方向。模相等且方向相同的向量，不管它们的起点在哪里，都认为是相等的向量。在这一规定下，向量可以根据需要进行平移。模为零的向量（它的方向是任意的）叫做零向量。规定所有零向量相等。 复数的向量表示法\" 复数的向量表示法 复数可以用向量来表示。如图 3，设复平面内的点 $ Z $ 表示复数 $ z=a+bi $ ，连结 $ OZ $ ，如果我们把有向线段 $ OZ $ （方向是从点 $ O $ 指向点 $ Z $ ）看成向量，记作 $ \\overrightarrow{OZ} $ ，就把复数同向量联系起来了。很明显，向量 $ \\overrightarrow{OZ} $ 是由点 $ Z $ 唯一确定的；反过来，点 $ Z $ 也可由向量 $ \\overrightarrow{OZ} $ 唯一确定。因此，复数集 $ C $ 与复平面内所有以原点 $ O $ 为起点的向量所成的集合也是一一对应的。为方便起见，我们常把复数 $ z=a+bi $ 说成点 $ Z $ 或者说成向量 $ \\overrightarrow{OZ} $ 。此外，我们还规定，相等的向量表示同一个复数。 图3中的向量 $ \\overrightarrow{OZ} $ 的模（即有向线段 $ OZ $ 的长度） $ r $ 叫做复数 $ z=a+bi $ 的模（或绝对值）记作 $ \\left | z \\right | $ 或 $ \\left | a+bi \\right | $ 。如果 $ b=0 $ ，那么 $ z=a+bi $ 是一个实数 $ a $ 它的模就等于 $ \\left | a \\right | $ （即 $ a $ 在实数意义上的绝对值）。容易看出， $ \\left | z \\right |=\\left | a+bi \\right |=r=\\sqrt{a^{2}+b^{2}}. $ 例1：求复数 $ z_{1}=3+4i $ 及 $ z_{2}=-\\frac{1}{2}-\\sqrt{2}i $ 的模，并且比较它们的模的大小。 解： $ \\left| z_{1} \\right|=\\sqrt{3^{2}+4^{2}}=5,\\left | z_{2} \\right |=\\sqrt{\\left ( -\\frac{1}{2} \\right )^{2}+\\left ( \\sqrt{2} \\right )^{2}}=\\frac{3}{2}. $ 又 $ 5 \u003e \\frac{3}{2} $ ，故 $ \\left | z_{1} \\right | \u003e \\left | z_{2} \\right | $ 。 例2：设 $ z\\in\\mathbf{C} $ ，满足下列条件的点 $ Z $ 的集合是什么图形？ （1） $ \\left | z \\right |=4 $ ；（2） $ 2 \u003c \\left | z \\right | \u003c 4 $ 。 解： （1）复数 $ z $ 的模等于 $ 4 $ ，就是说，向量 $ \\rightarrow{OZ} $ 的模（即点 $ Z $ 与原点 $ O $ 的距离）等于 $ 4 $ ，所以满足条件 $ \\left | z \\right |=4 $ 的点 $ Z $ 的集合是以原点 $ O $ 为圆心，以 $ 4 $ 为半径的圆。 （2）不等式 $ 2 \u003c \\left | z \\right | \u003c 4 $ 可化为不等式组 $ \\begin{cases}\\left | z \\right | \u003c 4\\\\ \\left | z \\right | \u003e 2\\end{cases} $ 。不等式 $ \\left | z \\right | \u003c 4 $ 的解集是圆 $ \\left | z \\right | = 4 $ 内部所有的点组成的集合，不等式 $ \\left | z \\right | \u003e 2 $ 的解集是圆 $ \\left | z \\right | = 2 $ 外部所有的点组成的集合，这两个集合的交集，就是上述不等式组的解集，也就是满足条件 $ 2 \u003c \\left | z \\right | \u003c 4 $ 的点 $ Z $ 的集合。容易看出，所求的集合是以原点 $ O $ 为圆心，以 $ 2 $ 及 $ 4 $ 为半径的圆所夹的圆环，但不包括圆环的边界（图 4）。 圆\" 圆 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:1:3","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"二、复数的运算 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:2:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"2.1 复数的加法与减法 复数的加法规定按照以下的法则进行：设 $ z_{1}=a+bi,z_{2}=c+di $ 是任意两个复数，那么它们的和：$$ \\left ( a+bi \\right )+\\left ( c+di \\right )=\\left ( a+c \\right )+\\left ( b+d \\right )i $$ 很明显，两个复数的和仍然是一个复数。 容易验证，复数的加法满足交换律、结合律，即对任意 $ z_{1},z_{2},z_{3}\\in\\mathbf{R} $ ，有 $$ z_{1}+z_{2}=z_{2}+z_{1} $$ $$ \\left ( z_{1}+z_{2} \\right )+z_{3}=z_{1}+\\left ( z_{2}+z_{3} \\right ) $$ 现在我们来看复数加法的几何意义。 从物理学知道，要求出作用于同一点 $ O $ 、但不在同一直线上的两个力 $ \\overrightarrow{F_{1}} $ 与 $ \\overrightarrow{F_{2}} $ 的合力，只要用表示 $ \\overrightarrow{F_{1}} $ 与 $ \\overrightarrow{F_{2}} $ 的向量为相邻的两边画一个平行四边形，那么，平行四边形中，以力的作用点 $ O $ 为起点的那条对角线所表示的向量就是合力 $ \\overrightarrow{F} $ （图5-1）。这个法则通常叫做向量加法的平行四边形法则。 复数加法的几何意义\" 复数加法的几何意义 复数用向量来表示，如果与这些复数对应的向量不在同一直线上，那么这些复数的加法就可以按照向量加法的平行四边形法则来进行。下面我们来证明这一事实。 设 $ \\overrightarrow{OZ_{1}} $ 及 $ \\overrightarrow{OZ_{2}} $ 分别与复数 $ a+bi $ 及 $ c+di $ 对应，且 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 不在同一直线上（图5-2）。以 $ \\overrightarrow{OZ_{1}} $ 及 $ \\overrightarrow{OZ_{2}} $ 为两条邻边画平行四边形 $ OZ_{1}ZZ_{2} $ ，画 $ x $ 轴的垂线 $ PZ_{1},QZ_{2} $ 及 $ RZ $ ，并且画 $ Z_{1}S\\perp RZ $ ，容易证明 $ \\triangle ZZ_{1}S\\cong \\triangle Z_{2}OQ, $ 并且四边形 $ Z_{1}PRS $ 是矩形，因此 $ OR=OP+PR=OP+Z_{1}S=OP+OQ=a+c $ $ RZ=RS+SZ=PZ_{1}+QZ_{2}=b+d. $ 于是点 $ Z $ 的坐标是 $ \\left ( a+c,b+d \\right ) $ ，这说明设 $ \\overrightarrow{OZ} $ 就是于复数 $ \\left ( a+c \\right )+\\left ( b+d \\right )i $ 对应的向量。 由此可知，求两个复数的和，可以先画出这两个复数对应的向量 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ ，如果 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 不在同一直线上，再以这两个向量为两条邻边画平行四边形，那么与这个平行四边的对角线 $ OZ $ 所表示的向量 $ \\overrightarrow{OZ} $ 对应的复数，就是所求两个复数的和。 如果 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 在同一直线上，我们可以画出一个“压扁”了的平行四边形，并据此画出它的对角线来表示 $ \\overrightarrow{OZ_{1}},\\overrightarrow{OZ_{2}} $ 的和。 总之，复数的加法可以按照向量的加法法则来进行，这是复数加法的几何意义。 下面再来看复数的减法。 复数的减法规定是加法的逆运算，即把满足 $$ \\left ( c+di \\right )+\\left ( x+yi \\right )=a+bi $$ 的复数 $ x+yi $ ，叫做复数 $ a+bi $ 减去复数 $ c+di $ 的差。记作 $ \\left ( a+bi \\right )-\\left ( c+di \\right ) $ ，根据复数相等的定义，有 $$ c+x=a,d+y=b $$ 由此 $$ x=a-c,y=b-d, $$ 所以 $$ x+yi=\\left ( a-c \\right )+\\left ( b-d \\right )i, $$ 即 $$ \\left ( a+bi \\right )-\\left ( c+di \\right )=\\left ( a-c \\right )+\\left ( b-d \\right )i $$ 这就是复数的减法法则。由此可见，两个复数的差是一个唯一确定的复数。 现设 $ \\overrightarrow{OZ} $ 与复数 $ a+bi $ 对应， $ \\overrightarrow{OZ_{1}} $ 与复数 $ c+di $ 对应（图6）。以 $ \\overrightarrow{OZ} $ 为一条对角线， $ \\overrightarrow{OZ_{1}} $ 为一条边画平行四边形，那么这个平行四边形的另一边， $ \\overrightarrow{OZ_{2}} $ 所表示的向量， $ \\overrightarrow{OZ_{2}} $ 就与复数 $ \\left ( a-c \\right )+\\left ( b-d \\right )i $ 对应。因为 $ Z_{1}Z\\stackrel{;//;}{=}OZ_{2} $ ，所以向量 $ \\overrightarrow{Z_{1}Z} $ 也与这个差对应。 复数减法的几何意义\" 复数减法的几何意义 这就是说，两个复数的差 $ z-z_{1} $ （即 $ \\overrightarrow{OZ}-\\overrightarrow{OZ_{1}} $ ）与连结两个向量终点并指向被减数的向量对应。这就是复数减法的几何意义。 由上所述，我们可以看出，复数的加（减）法与多项式的加（减）法是类似的，就是把复数的实部与实部、虚部与虚部分别相加（减），即 $$ \\left ( a+bi \\right )\\pm \\left ( c+di \\right )=\\left ( a\\pm c \\right )+\\left ( b\\pm d \\right ) $$ 例1：计算 $ \\left ( 5-6i \\right )+\\left ( -2-i \\right )-\\left ( 3+4i \\right ) $ 。 解： $ \\left ( 5-6i \\right )+\\left ( -2-i \\right )-\\left ( 3+4i \\right )=\\left ( 5-2-3 \\right )+\\left ( -6-1-4 \\right )i=-11i $ 。 例2：根据复数的几何意义及向量表示，求复平面内两点间的距离公式。 复平面两点距离\" 复平面两点距离 解：如图 7，设复平面内的任意两点 $ Z_{1},Z_{2} $ 分别表示复数 $ z_{1}=x_{1}+y_{1}i,z_{2}=x_{2}+y_{2}i $ ，那么 $ \\overrightarrow{Z_{1}Z_{1}} $ 就是与复数 $ z_{2}-z_{1} $ 对应的向量。如果用 $ d $ 表示点 $ Z_{1},Z_{1} $ 之间的距离，那么 $ d $ 就是向量 $ \\overrightarrow{Z_{1}Z_{2}} $ 的模，即复数 $ z_{2}-z_{1} $ 的模，所以 $$ d=\\left | z_{2}-z_{1} \\right |=\\left | \\left ( x_{2}+y_{2}i \\right )-\\left ( x_{1}+y_{1}i \\right ) \\right |=\\left | \\left ( x_{2}-x_{1} \\right )+\\left ( y_{2}-y_{1} \\right )i \\right |=\\sqrt{\\left ( x_{2}-x_{1} \\right )^2+\\left ( y_{2}-y_{1} \\right )^2} $$ 这与我们之前导出的两点间的距离公式一致。 例3：根据复数的几何意义及向量表示，求复平面内的圆的方程。 复平面圆\" 复平面圆 解：如图8，设圆心为 $ P $ ，点 $ P $ 与复数 $ p=a+bi $ 对应，圆的半径为 $ r $ ，圆上任意一点 $ Z $ 与复数 $ z=a+bi $ 对应，那么 $$ \\left | z-p \\right |=r $$ 这就是复平面内的圆的方程。特别地，当点 $ P $ 在原点时，圆的方程就成了 $$ \\left | z \\right |=r $$ 请读者利用复数的减法法则，把圆的方程 $$ \\left | z-p \\right |=r $$ 化成用实数表示的一般形式 $$ \\left ( x-a \\right )^{2}+\\left ( y-b \\right )^{2}=r^{2} $$ ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:2:1","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"2.2 复数的乘法与除法 复数的乘法规定按照以下的法则进行：设 $ z_{1}=a+bi,z_{2}=c+di $ 是任意两个复数，那么它们的积 $$ \\left ( a+bi \\right )\\left ( c+di \\right )=ac+bci+cdi+bdi^{2}=\\left ( ac-bd \\right )+\\left ( bc+ad \\right )i $$ 也就是说，复数的乘法与多项式的乘法是类似的，但必须在所得的结果中把 $ i^{2} $ 换成 $ -1 $ ，并且把实部和虚部分别合并。 很显然，两个复数的积仍然是一个复数。 容易验证，复数的乘法满足交换律、结合律以及乘法对加法的分配律，即对任何 $ z_{1},z_{2},z_{3}\\in\\mathbf{C} $ ，有 $$ z_{1}\\cdot z_{2}=z_{2}\\cdot z_{1} $$ $$ \\left ( z_{1}\\cdot z_{2} \\right )\\cdot z_{3}=z_{1}\\cdot\\left ( z_{2}\\cdot z_{3} \\right ) $$ $$ z_{1}\\cdot \\left ( z_{2}+z_{3} \\right )=z_{1}\\cdot z_{2}+z_{1}\\cdot z_{3} $$ 根据复数的乘法法则，对于任何复数 $ z=a+bi $ ，有 $$ \\left ( a+bi \\right )\\left ( a-bi \\right )=a^{2}+b^{2}+\\left ( ab-ab \\right )i=a^{2}+b^{2} $$ 因此，两个共轭复数 $ z,\\overline{z} $ 的积是一个实数，这个实数等于每一个复数的模的平方，即 $$ z\\cdot \\overline{z}=\\left | z \\right |^{2}=\\left | \\overline{z} \\right |^{2} $$ 例1：计算 $ \\left ( 1-2i \\right )\\left ( 3+4i \\right )\\left ( -2+i \\right ) $ 。 解： $ \\left ( 1-2i \\right )\\left ( 3+4i \\right )\\left ( -2+i \\right )=\\left ( 11-2i \\right )\\left ( -2+i \\right )=-20+15i $ 。 计算复数的乘方，要用到虚数单位 $ i $ 的乘方。因为复数的长发满足交换律与结合律，所以实数集 $ \\mathbf{R} $ 中正整数指数幂的运算律，在复数集 $ \\mathbf{C} $ 中仍然成立，即对任何 $ z,z_{1},z_{2}\\in\\mathbf{C} $ 及 $ m,n\\in\\mathbf{N} $ ，有 $$ z^{m}\\cdot z^{n}=z^{m+n} $$ $$ \\left ( z^{m} \\right )^{n}=z^{mn} $$ $$ \\left ( z_{1}\\cdot z_{2} \\right )^{n}=z_{1}^{n}\\cdot z_{1}^{n} $$ 另一方面，我们有 $$ i^{1}=i $$ $$ i^{2}=-1 $$ $$ i^{3}=i^{2}\\cdot i=-i $$ $$ i^{4}=i^{3}\\cdot i=-i\\cdot i=-i^{2}=1 $$ 从而，对于任何 $ n\\in\\mathbf{N} $ ，我们都有 $$ i^{4n+1}=i^{4n}\\cdot i=\\left ( i^4 \\right )^{n}\\cdot i=1^{n}\\cdot i=i $$ 同理可证 $$ i^{4n+2}=-1 $$ $$ i^{4n+3}=-i $$ $$ i^{4n}=1 $$ 这就是说，如果 $ n\\in\\mathbf{N} $ ，那么 $$ i^{4n+1}=i,i^{4n+2}=-1,i^{4n+3}=-i,i^{4n}=1 $$ 例2：计算 $ \\left ( \\frac{1}{2}-\\frac{\\sqrt{3}}{2}i \\right )^{3} $ 。 解： $$ \\begin{align*} \\left ( \\frac{1}{2}-\\frac{\\sqrt{3}}{2}i \\right )^{3}\u0026=\\left ( \\frac{1}{2} \\right )^3-3\\left ( \\frac{1}{2} \\right )^{2}\\left ( \\frac{\\sqrt{3}}{2}i \\right )+3\\left ( \\frac{1}{2} \\right )\\left ( \\frac{\\sqrt{3}}{2}i \\right )^{2}-\\left ( \\frac{\\sqrt{3}}{2} \\right )^{3}\\\\ \u0026=\\frac{1}{8}-\\frac{3\\sqrt{3}}{8}i-\\frac{9}{8}+\\frac{3\\sqrt{3}}{8}i\\\\ \u0026=-1\\end{align*} $$ 复数的除法规定是乘法的逆运算，即把满足 $$ \\left ( c+di \\right )\\left ( x+yi \\right )=a+bi\\left ( c+di\\neq 0 \\right ) $$ 的复数 $ x+yi $ ，叫做复数 $ a+bi $ 除以复数 $ c+di $ 的商，记作 $$ \\left ( a+bi \\right )\\div \\left ( c+di \\right ) $$ 或 $$ \\frac{a+bi}{c+di} $$ 我们知道，两个共轭复数的积是一个实数，因此，两个复数相除，可以先把它们的商写成分式的形式，然后把分子与分母都乘以分母的共轭复数，并且把结果化简，即 $$ \\frac{a+bi}{c+di}=\\frac{\\left ( a+bi \\right )\\left ( c-di \\right )}{\\left ( c+di \\right )\\left ( c-di \\right )}=\\frac{\\left ( ac+bd \\right )+\\left ( bc-ad \\right )i}{c^{2}+d^{2}}=\\frac{ac+bd}{c^{2}+d^{2}}+\\frac{bc-ad}{c^{2}+d^{2}}i\\left ( c+di\\neq 0 \\right ) $$ 因为 $ c+di\\neq 0 $ ，所以 $ c^{2}+d^{2}\\neq 0 $ 。由此可见，商 $ \\frac{a+bi}{c+di} $ 是一个唯一确定的复数。 例3：计算 $ \\left ( 1+2i \\right )\\div \\left ( 3-4i \\right ) $ 。 解： $ \\left ( 1+2i \\right )\\div \\left ( 3-4i \\right )=\\frac{1+2i}{3-4i}=\\frac{\\left ( 1+2i \\right )\\left ( 3+4i \\right )}{\\left ( 3-4i \\right )\\left ( 3+4i \\right )}=\\frac{-5+10i}{25}=-\\frac{1}{5}+\\frac{1}{2}i $ 。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:2:2","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"三、复数的三角形式 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:3:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"3.1 复数的三角形式 我们知道，与复数 $ z=a+bi $ 对应的向量 $ \\overrightarrow{OZ} $ （图9）的模 $ r $ 叫做这个复数的模，并且 $$ r=\\sqrt{a^{2}+b^{2}} $$ 复数的模\" 复数的模 以 $ x $ 轴的正半轴为始边、向量 $ \\overrightarrow{OZ} $ 所在的射线（起点是 $ O $ ）为终边的角 $ \\theta $ ，叫做复数 $ z=a+bi $ 的辐角。 不等于零的复数 $ z=a+bi $ 的辐角有无限多个值，这些值相差 $ 2\\pi $ 的整数倍。例如，复数 $ i $ 的辐角是 $ \\frac{\\pi}{2}+2k\\pi $ ，其中 $ k $ 可以取任何整数。 适合于 $ 0\\leq \\theta \u003c 2\\pi $ 的辐角 $ \\theta $ 的值，叫做辐角的主值。记作 $ \\textrm{arg} z $ ，即 $ 0\\leq \\textrm{arg} z \u003c 2\\pi $ 。 每一个不等于零的复数有唯一的模与辐角的主值，并且可由它的模与辐角的主值唯一确定。因此，两个非零复数相等当且仅当它们的模与辐角的主值分别相等。 很明显，当 $ a\\in\\mathbf{R^{+}} $ 时，$$ \\textrm{arg}\\alpha=0 $$ $$ \\textrm{arg}\\left ( -\\alpha \\right )=\\pi $$ $$ \\textrm{arg}\\left ( ai \\right )=\\frac{\\pi}{2} $$ $$ \\textrm{arg}\\left ( -ai \\right )=\\frac{3\\pi}{2} $$ 如果 $ z=0 $ ，那么与它对应的向量 $ \\overrightarrow{OZ} $ 缩成一个点（零向量），这样的向量的方向是任意的，所以复数 $ 0 $ 的辐角也是任意的。 从图 9 可以看出： $$ \\begin{cases} a=r\\cos{\\theta}\\\\ b=r\\sin{\\theta} \\end{cases} $$ 因此 $$ a+bi=r\\cos{\\theta}+ir\\sin{\\theta}=r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $$ 其中 $$ r=\\sqrt{a^{2}+b^{2}},\\cos{\\theta}=\\frac{a}{r},\\sin{\\theta}=\\frac{b}{r} $$ 当与 $ z $ 对应的点 $ Z $ 不在实轴或虚轴上时， $ z $ 的辐角 $ \\theta $ 的终边所在的象限就是点 $ Z $ 所在的象限；当点 $ Z $ 在实轴或虚轴上时，辐角 $ \\theta $ 的终边就是从原点 $ O $ 出发、经过点 $ Z $ 的板条坐标轴。 因此我们可以说，任何一个复数 $ z=a+bi $ 都可以表示成 $ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $ 的形式。 $$ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right ) $$ 叫做复数 $ a+bi $ 的三角形式。为了同三角形式区别开来， $ a+bi $ 叫做复数的代数形式。 例1：把复数 $ \\sqrt{3}+i $ 表示成三角形式。 解： $ r=\\sqrt{3+1}=2,\\cos{\\theta}=\\frac{\\sqrt{3}}{2}. $ 因为与 $ \\sqrt{3}+i $ 对应的点在第一象限，所以 $ \\textrm{arg}\\left ( \\sqrt{3}+i \\right )=\\frac{\\pi}{6} $ ，于是 $ \\sqrt{3}+i=2\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right ). $ 例2：把复数 $ 1-i $ 表示成三角形式。 解： $ r=\\sqrt{1+1}=\\sqrt{2},\\cos{\\theta}=\\frac{1}{\\sqrt{2}}=\\frac{\\sqrt{2}}{2}. $ 因为与 $ 1-i $ 对应的点在第四象限，所以 $ \\textrm{arg}\\left ( 1-i \\right )=\\frac{7\\pi}{4} $ ，于是 $ 1-i=\\sqrt{2}\\left ( \\cos{\\frac{7\\pi}{4}}+i\\sin{\\frac{7\\pi}{4}} \\right ). $ 例3：把复数 $ -1 $ 表示成三角形式。 解： $ r=\\sqrt{1+0}=1. $ 因为与 $ -1 $ 对应的点在 $ x $ 轴的负半轴上，所以 $ \\textrm{arg}\\left ( -1 \\right )=\\pi $ ，于是 $ -1=\\cos{\\pi}+i\\sin{\\pi}. $ 当然，把一个复数表示成三角形式时，辐角 $ \\theta $ 不一定要取主值。例如， $ \\sqrt{2}\\left [ \\cos{\\left ( -\\frac{\\pi}{4} \\right )}+i\\sin{\\left ( -\\frac{\\pi}{4} \\right )} \\right ] $ 也是复数 $ 1-i $ 的三角形式。 ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:3:1","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"3.2 复数的三角形式的运算 3.2.1 乘法与乘方 如果把复数 $ z_{1},z_{2} $ 分别写成三角形式 $$ z_{1}=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right ) $$ $$ z_{2}=r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right ) $$ 故有 $$ \\begin{align*} z_{1}\\cdot z_{2} \u0026=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\\\ \u0026=r_{1}r_{2}\\left [ \\left (\\cos{\\theta_{1}}\\cos{\\theta_{2}}-\\sin{\\theta_1}\\sin{\\theta_{2}} \\right ) + i\\left ( \\sin{\\theta_{1}}\\cos{\\theta_{2}}+\\cos{\\theta_{1}}\\sin{\\theta_{2}} \\right ) \\right ]\\\\ \u0026=r_{1}r_{2}\\left [ \\cos{\\left (\\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}+\\theta_{2} \\right )} \\right ] \\end{align*} $$ 即 $$ r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )=r_{1}r_{2}\\left [ \\cos{\\left (\\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left (\\theta_{1}+\\theta_{2} \\right )} \\right ] $$ 这就是说，两个复数相乘，积的模等于各复数的模的积，积的辐角等于各复数的辐角之和。 据此，两个复数 $ z_{1},z_{2} $ 相乘时，可以先画出分别与 $ z_{1},z_{2} $ 对应的向量 $ \\overrightarrow{OP_{1}},\\overrightarrow{OP_{2}} $ ，然后把向量 $ \\overrightarrow{OP_{1}} $ 按逆时针方向旋转一个角度 $ \\theta_{2} $ （如果 $ \\theta \u003c 0 $ ，就要把 $ \\overrightarrow{OP_{1}} $ 按顺时针方向旋转一个角度 $ \\left | \\theta_{2} \\right | $ ），在把它的模变为原来的 $ r_{2} $ 倍，所得的向量 $ \\overrightarrow{OP} $ ，就表示积 $ z_{1}\\cdot z_{2} $ （图 10）。这就是复数乘法的几何意义。 复数乘法的几何意义\" 复数乘法的几何意义 用数学归纳法容易证明（读者自己证明），上面的结论可以推广到 $ n $ 个复数相乘的情况，就是： $$ \\begin{align*} z_{1}\\cdot z_{2}\\cdot\\cdots\\cdot z_{n} \u0026=r_{1}\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\cdot r_{2}\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\cdot\\cdots\\cdot r_{n}\\left ( \\cos{\\theta_{n}}+i\\sin{\\theta_{n}} \\right )\\\\ \u0026=r_{1}r_{2}\\cdots r_{n}\\left [ \\cos{\\left ( \\theta_{1}+\\theta_{2}+\\cdots +\\theta_{n} \\right )} + i\\sin{\\left ( \\theta_{1}+\\theta_{2}+\\cdots +\\theta_{n} \\right )}\\right ] \\end{align*} $$ 因此，如果 $$ r_{1}=r_{2}=\\cdots=r_{n}=r,\\theta_{1}=\\theta_{2}=\\cdots=\\theta_{n}=\\theta $$ 时，就有 $$ \\left [ r\\left ( \\cos{\\theta}+i\\sin{\\theta} \\right )^n \\right ]=r^{n}\\left ( \\cos{n\\theta}+i\\sin{n\\theta} \\right )\\left ( n\\in\\mathbf{N} \\right ) $$ 这就是说，复数的 $ n\\left(n\\in\\mathbf{N}\\right) $ 次幂的模等于这个复数的模的 $ n $ 次幂，它的辐角等于这个复数的辐角的 $ n $ 倍。这个定理叫做棣莫佛2定理。 例1：计算 $ \\sqrt{2}\\left ( \\cos{\\frac{\\pi}{12}}+i\\sin{\\frac{\\pi}{12}} \\right )\\cdot\\sqrt{3}\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right ) $ 。 解： $ \\sqrt{2}\\left ( \\cos{\\frac{\\pi}{12}}+i\\sin{\\frac{\\pi}{12}} \\right )\\cdot\\sqrt{3}\\left ( \\cos{\\frac{\\pi}{6}}+i\\sin{\\frac{\\pi}{6}} \\right )\\ =\\sqrt{6}\\left [ \\cos\\left ( \\frac{\\pi}{12}+\\frac{\\pi}{6} \\right )+i\\sin\\left ( \\frac{\\pi}{12}+\\frac{\\pi}{6} \\right ) \\right ]\\ =\\sqrt{6}\\left ( \\cos{\\frac{\\pi}{4}}+i\\sin{\\frac{\\pi}{4}} \\right )\\ =\\sqrt{6}\\left ( \\frac{\\sqrt{2}}{2}+\\frac{\\sqrt{2}}{2}i \\right )\\ =\\sqrt{3}+\\sqrt{3}i $ 。 例2：计算 $ \\left ( \\sqrt{3}-i \\right )^{6} $ 。 解：因为 $ \\sqrt{3}-i=2\\left ( \\cos{\\frac{11\\pi}{6}}+i\\sin{\\frac{11\\pi}{6}} \\right ) $ ，所以 $ \\left (\\sqrt{3}-i \\right )^{6}\\ =\\left [2\\left ( \\cos{\\frac{11\\pi}{6}}+i\\sin{\\frac{11\\pi}{6}} \\right ) \\right ]^{6}\\ =2^{6}\\left ( \\cos{11\\pi}+i\\sin{11\\pi} \\right )\\ =64\\left ( \\cos{\\pi}+i\\sin{\\pi} \\right )\\ =64\\cdot\\left ( -1 \\right )=-64 $ 。 例3：如图11，向量 $ \\overrightarrow{OZ} $ 与复数 $ -1+i $ 对应，把 $ \\overrightarrow{OZ} $ 按逆时针方向旋转 $ 120^\\circ $ ，得到 $ \\overrightarrow{OZ‘} $ 。求与向量 $ \\overrightarrow{OZ'} $ 对应的复数（用代数形式表示）。 复数的旋转\" 复数的旋转 解：所求的复数就是 $ -1+i $ 乘以一个复数 $ z_{0} $ 的积，这个复数 $ z_{0} $ 的模是 $ 1 $ ，辐角的主值是 $ 120^\\circ $ 。 所以所求的复数是 $ (-1+i)\\cdot 1\\left ( \\cos{120^\\circ}+i\\sin{120^\\circ} \\right )\\ =(-1+i)\\left ( -\\frac{1}{2}+\\frac{\\sqrt{3}}{2}i \\right )\\ =\\frac{1-\\sqrt{3}}{2}-\\frac{1+\\sqrt{3}}{2}i $ 例4：如图 12，已知平面内并列的三个相等的正方形，利用复数证明 $ \\angle 1+\\angle 2+\\angle 3=\\frac{\\pi}{2}. $ 例 4 图例\" 例 4 图例 证明：如图建立坐标系（确定复平面），由于平行线的内错角相等， $ \\angle 1,\\angle 2,\\angle 3 $ 分别等于复数 $ 1+i,2+i,3+i $ 的辐角的主值，这样 $ \\angle 1+\\angle 2+\\angle 3 $ 就是积 $ \\left ( 1+i \\right )\\left ( 2+i \\right )\\left ( 3+i \\right ) $ 的辐角，而 $$ \\left ( 1+i \\right )\\left ( 2+i \\right )\\left ( 3+i \\right )=10i $$ 其辐角的主值是 $ \\frac{\\pi}","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:3:2","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["数学之美"],"content":"*四、复数的指数形式 在科学技术，特别实在电工和无线电计算中，为了方便起见，还采用复数的另一种表示——复数的指数形式。 我们把模为 $ 1 $ ，辐角为 $ \\theta $ （以弧度为单位）的复数 $$ \\cos{\\theta}+i\\sin{\\theta} $$ 用记号 $ e^{i\\theta} $ 来表示，即4 $$ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $$ 例如， $$ e^{i\\frac{\\pi}{2}}=\\cos{\\frac{\\pi}{1}+i\\sin{\\frac{\\pi}{1}}}=i $$ $$ e^{i\\frac{\\pi}{3}}=\\cos{\\frac{\\pi}{3}+i\\sin{\\frac{\\pi}{3}}}=\\frac{1}{2}+\\frac{\\sqrt{3}}{2}i $$ 又如，$$ \\cos{\\frac{5\\pi}{6}}+i\\sin{\\frac{5\\pi}{6}} $$ 可以写成 $$ e^{i\\frac{5\\pi}{6}} $$ $$ \\frac{\\sqrt{2}}{2}+\\frac{\\sqrt{2}}{2}i=\\cos{\\frac{\\pi}{4}}+i\\sin{\\frac{\\pi}{4}} $$ 可以写成 $$ e^{i\\frac{\\theta}{4}} $$ 引入记号 $ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $ 之后，任何一个复数 $$ z=r\\left(\\cos{\\theta}+i\\sin{\\theta}\\right) $$ 就可以表示成 $$ z=re^{i\\theta} $$ 的形式。我们把这一表达式叫做复数的指数形式。 根据复数的指数形式的定义，我们有 $$ e^{i\\theta_{1}}\\cdot e^{i\\theta_{2}}\\ =\\left ( \\cos{\\theta_{1}}+i\\sin{\\theta_{1}} \\right )\\left ( \\cos{\\theta_{2}}+i\\sin{\\theta_{2}} \\right )\\ =\\cos{\\left ( \\theta_{1}+\\theta_{2} \\right )}+i\\sin{\\left ( \\theta_{1}+\\theta_{2} \\right )}\\ =e^{i\\left ( \\theta_{1}+\\theta_{2} \\right )} $$ 即 $$ e^{i\\theta_{1}}\\cdot e^{i\\theta_{2}}=e^{i\\left ( \\theta_{1}+\\theta_{2} \\right )} $$ 同样可证 $$ \\left ( e^{i\\theta} \\right )^{n}=e^{in\\theta}\\left ( n\\in\\mathbf{N} \\right ) $$ $$ \\frac{e^{i\\theta_1}}{e^{i\\theta_{2}}}=e^{i\\left ( \\theta_{1}-\\theta_{2} \\right )} $$ 上述性质与我们过去学过的实数指数幂的性质一致，所以把复数从三角形式改写成指数形式后，可以运用实数集 $ \\mathbf{R} $ 中的幂运算律（注意：乘方的指数限于自然数）来进行运算。这里我们仿照实数集 $ \\mathbf{R} $ 中的说法，把 $ e^{i\\theta} $ 叫做以 $ e $ 为底、 $ i\\theta $ 为指数的幂。 对于开方运算，复数 $ re^{i\\theta} $ 的 $ n\\left(n\\in\\mathbf{N}\\right) $ 次方根是 $$ \\sqrt[n]{r}e^{i\\frac{\\theta+2k\\pi}{n}}\\left ( k=0,1,\\cdots,n-1 \\right ) $$ 例1：把复数 $ z=2i $ 表示成指数形式。 解： $ z=2i=2\\left ( \\cos{\\frac{\\pi}{1}}+i\\sin{\\frac{\\pi}{2}} \\right )=2e^{i\\frac{\\pi}{2}} $ 。 例2：把 $ \\sqrt{2}e^{-i\\frac{\\pi}{4}},\\sqrt{5}e^{i\\frac{2\\pi}{3}} $ 表示成三角形式及代数形式。 解： $$ \\sqrt{2}e^{-i\\frac{\\pi}{4}}=\\sqrt{2}\\left [ \\cos\\left ( -\\frac{\\pi}{4} \\right )+i\\sin{\\frac{\\pi}{4}} \\right ]=1-i $$ $$ \\sqrt{5}e^{i\\frac{2\\pi}{3}}=\\sqrt{5}\\left [ \\cos\\left ( -\\frac{2\\pi}{3} \\right )+i\\sin{\\frac{2\\pi}{3}} \\right ]=-\\frac{\\sqrt{5}}{2}+\\frac{\\sqrt{15}}{2}i $$ 例3：用 $ e^{i\\theta} $ 与 $ e^{-i\\theta} $ 表示 $ \\cos{\\theta} $ 与 $ \\sin{\\theta} $ 。 解：因为 $$ e^{i\\theta}=\\cos{\\theta}+i\\sin{\\theta} $$ $$ e^{-i\\theta}=\\cos{\\left ( -\\theta \\right )}+i\\sin\\left ( -\\theta \\right )=\\cos{\\theta}-i\\sin{\\theta} $$ 因此 $$ \\cos{\\theta}=\\frac{e^{i\\theta}+e^{-i\\theta}}{2},\\quad \\sin{\\theta}=\\frac{e^{i\\theta}-e^{-i\\theta}}{2i} $$ $ \\mathbf{C} $ 是英文词组Complex numbers（复数）的第一个字母。 ↩︎ 棣莫佛（Abrabam de Moivre, 1667-1754年），法国数学家。 ↩︎ 采用这个符号时，一定要记住 $ \\sqrt[n]{z} $ 表示 $ n $ 个复数。 ↩︎ 这里的 $ e=2.71828\\cdots $ ，就是自然对数的底数。这个公式叫做欧拉（Leonhard Euler，1707-1783年，瑞士数学家）公式。在“复变函数论”中可以证明这个公式。 ↩︎ ","date":"2013-08-30","objectID":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/:4:0","tags":["复数"],"title":"关于复数的一些补充","uri":"/2013/08/%E5%85%B3%E4%BA%8E%E5%A4%8D%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"},{"categories":["码志"],"content":"忠诚 2 是忠诚的一个提升版本。我们在之前的一篇文章线段树 – 无改动求解区间最值 – 忠诚简单的谈了一下关于无改动求解区间最值的问题。现在我们来研究一下有改动求解区间最值。 首先，我们考虑改动某个值以后，对整棵树重新进行维护。但是很快我们发现，这样的复杂度太大。因为每次只更改一个值，所以只涉及到一条路径，因此我们考虑在递归修改数值的时候，可以标记一下经过的结点，修改完成以后，只对标记过的结点进行维护。这样我们的代码就出来了： int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight || pNode-\u003enMoney != 2147483647) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } void Change(Node *pNode, int x, int nValue) { pNode-\u003enMoney = 2147483647; if(pNode-\u003enLeft == x \u0026\u0026 x == pNode-\u003enRight) { pNode-\u003enMoney = nValue; } else { if(x \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { Change(pNode-\u003epLeft, x, nValue); } else { Change(pNode-\u003epRight, x, nValue); } } } 这样，除了第一次维护外，每次我们只需要维护一条路径，复杂度也大大降低低了。 附上忠诚 2 代码： #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; Node *pRoot; int N, M, nTmp, T, L, R, ans; vector\u003cint\u003e pMoney; Node* Build(int l, int r); int Update(Node *pNode); void Change(Node *pNode, int x, int nValue); int Query(Node *pNode, int l, int r); int main() { ios::sync_with_stdio(false); cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { cin \u003e\u003e nTmp; pMoney.push_back(nTmp); } pRoot = Build(1, N); Update(pRoot); for(int i = 1; i \u003c= M; i++) { cin \u003e\u003e T \u003e\u003e L \u003e\u003e R; if(T == 1) { ans = 2147483647; cout \u003c\u003c Query(pRoot, L, R) \u003c\u003c \" \"; } else { Change(pRoot, L, R); Update(pRoot); } } cout \u003c\u003c endl; return 0; } Node* Build(int l, int r) { Node *pNode = new Node(); if(l == r) { pNode-\u003enMoney = pMoney[l - 1]; } else { pNode-\u003enMoney = 2147483647; } pNode-\u003enLeft = l; pNode-\u003enRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u003epLeft = Build(l, nMid); pNode-\u003epRight = Build(nMid + 1, r); return pNode; } int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight || pNode-\u003enMoney != 2147483647) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } void Change(Node *pNode, int x, int nValue) { pNode-\u003enMoney = 2147483647; if(pNode-\u003enLeft == x \u0026\u0026 x == pNode-\u003enRight) { pNode-\u003enMoney = nValue; } else { if(x \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { Change(pNode-\u003epLeft, x, nValue); } else { Change(pNode-\u003epRight, x, nValue); } } } int Query(Node *pNode, int l, int r) { if(pNode-\u003enLeft == l \u0026\u0026 r == pNode-\u003enRight) { return pNode-\u003enMoney; } else { if(r \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epLeft, l, r); } else if(l \u003e (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epRight, l, r); } else { int nMid = (pNode-\u003enLeft + pNode-\u003enRight) / 2; return min(Query(pNode-\u003epLeft, l, nMid), Query(pNode-\u003epRight, nMid + 1, r)); } } } ","date":"2013-08-27","objectID":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%89%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A-2/:0:0","tags":["线段树"],"title":"线段树 – 有改动求解区间最值 – 忠诚 2","uri":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%9C%89%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A-2/"},{"categories":["码志"],"content":"昨天研究了一下线段树，发现原来线段树有这么多实现方式。当然，对于非递归自底向上线段树，俗称 ZKW 线段树还是不太理解。而且我的实现方式还是用的指针，所以效率不是特别高。首先记录一下自己对于线段树的理解吧。我们用忠诚这道题目来做例子。 线段树可以直观的表示为下面这张图： 线段树示意图\" 线段树示意图 对于一个给定的区间，不断的二分，直到区间变为一个点为止。当然，平时我们所需要的线段树不是这么简陋的，我们需要一些数据域： struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; 有了节点的数据结构，我们需要构建这棵树，我们使用递归的方式生成这棵树，当然，在生成的过程中也可以进行一些初始化操作： Node* Build(int l, int r) { Node *pNode = new Node(); // Init data if(l == r) { pNode-\u003enMoney = pMoney[l - 1]; } else { pNode-\u003enMoney = 0; } pNode-\u003enLeft = l; pNode-\u003enRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u003epLeft = Build(l, nMid); pNode-\u003epRight = Build(nMid + 1, r); return pNode; } 接下来就是线段树最核心的部分了，查找。查找的时候可能有三种情况： 所需要查询的区间全部落在左儿子的区间中，递归左儿子。 所需要查询的区间全部落在右儿子的区间中，递归右儿子。 所需要查询的区间一部分在左儿子的区间中，另一部分在右儿子的区间中，递归左儿子，右儿子，根据需要进行一些操作，例如相加，取最大最小等。 实现部分如下： int Query(Node *pNode, int l, int r) { if(pNode-\u003enLeft == l \u0026\u0026 r == pNode-\u003enRight) { return pNode-\u003enMoney; } else { if(r \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epLeft, l, r); } else if(l \u003e (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epRight, l, r); } else { int nMid = (pNode-\u003enLeft + pNode-\u003enRight) / 2; return min(Query(pNode-\u003epLeft, l, nMid), Query(pNode-\u003epRight, nMid + 1, r)); } } } 但是上面的代码要递归很久才返回数据，有很多的重复运算，这样在数据量很大的情况下非常不理想，所以我们需要进行一些优化。我们可以考虑提前把每个区间的最值求出来，因为原来只有点区间才有数据： int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } 这样，这棵线段树的效率就得到了很大的提高。 附上忠诚代码： #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; struct Node { int nLeft, nRight; unsigned long long nMoney; Node *pLeft, *pRight; }; Node *pRoot; int N, M, nTmp, L, R, ans; vector\u003cint\u003e pMoney; Node* Build(int l, int r); int Update(Node *pNode); int Query(Node *pNode, int l, int r); int main() { ios::sync_with_stdio(false); cin \u003e\u003e N \u003e\u003e M; for(int i = 1; i \u003c= N; i++) { cin \u003e\u003e nTmp; pMoney.push_back(nTmp); } pRoot = Build(1, N); Update(pRoot); for(int i = 1; i \u003c= M; i++) { cin \u003e\u003e L \u003e\u003e R; ans = 2147483647; cout \u003c\u003c Query(pRoot, L, R) \u003c\u003c \" \"; } cout \u003c\u003c endl; return 0; } Node* Build(int l, int r) { Node *pNode = new Node(); if(l == r) { pNode-\u003enMoney = pMoney[l - 1]; } else { pNode-\u003enMoney = 0; } pNode-\u003enLeft = l; pNode-\u003enRight = r; if(l == r) { return pNode; } int nMid = (l + r) / 2; pNode-\u003epLeft = Build(l, nMid); pNode-\u003epRight = Build(nMid + 1, r); return pNode; } int Update(Node *pNode) { if(pNode-\u003enLeft == pNode-\u003enRight) { return pNode-\u003enMoney; } else { return pNode-\u003enMoney = min(Update(pNode-\u003epLeft), Update(pNode-\u003epRight)); } } int Query(Node *pNode, int l, int r) { if(pNode-\u003enLeft == l \u0026\u0026 r == pNode-\u003enRight) { return pNode-\u003enMoney; } else { if(r \u003c= (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epLeft, l, r); } else if(l \u003e (pNode-\u003enLeft + pNode-\u003enRight) / 2) { return Query(pNode-\u003epRight, l, r); } else { int nMid = (pNode-\u003enLeft + pNode-\u003enRight) / 2; return min(Query(pNode-\u003epLeft, l, nMid), Query(pNode-\u003epRight, nMid + 1, r)); } } } ","date":"2013-08-27","objectID":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%97%A0%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A/:0:0","tags":["线段树"],"title":"线段树 – 无改动求解区间最值 – 忠诚","uri":"/2013/08/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E6%97%A0%E6%94%B9%E5%8A%A8%E6%B1%82%E8%A7%A3%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC-%E5%BF%A0%E8%AF%9A/"},{"categories":["码志"],"content":"题目是经典的采药问题。也是最基础的 0/1 背包问题。 我们约定有 $ N $ 件物品和一个容量为 $ C $ 的背包。第 $ i $ 件物品的重量是 $ w\\left [ i \\right ] $ ，价值是 $ v\\left [ i \\right ] $ 。这样，我们所需要求解将哪些物品装入背包可使价值总和最大。 ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:0:0","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["码志"],"content":"二维数组表示 定义状态： $ f\\left [ i \\right ]\\left [ c \\right ] $ 表示前 $ i $ 件物品恰放入一个容量为 $ c $ 的背包可以获得的最大价值。 状态转移方程： $ f\\left [ i \\right ]\\left [ c \\right ]=\\max\\left \\{ f\\left [ i-1 \\right ]\\left [ c \\right ],f\\left [i-1 \\right ]\\left [ c-w\\left [ i \\right ] \\right ] +v\\left [ i \\right ]\\right \\} $ 代码模版： for(int i = 1; i \u003c= N; i++) { for(int c = 0; c \u003c= C; c++) { f[i][c] = f[i - 1][c]; if(c \u003e= w[i]) { f[i][c] = max(f[i][c], f[i - 1][c - w[i]] + v[i]); } } } 时间复杂度、空间复杂度： $ O\\left ( NC \\right ) $ ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:1:0","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["码志"],"content":"一维数组表示 定义状态：由于 $ i $ 基本没有什么用处，所以我们把它省略。 状态转移方程： $ f\\left [ c \\right ]=\\max\\left \\{ f\\left [ c \\right ],f\\left [ c-w\\left [ i \\right ] \\right ] +v\\left [ i \\right ]\\right \\} $ 需要注意的是，这时候，我们需要将 $ c $ 从 $ C $ 开始，倒着推。 代码模版： for(int i = 1; i \u003c= N; i++) { for(int c = C; C \u003e= 0; C--) { if(c \u003e= w[i]) { f[c] = max(f[c], f[c - w[i]] + v[i]); } } } 时间复杂度： $ O\\left ( NC \\right ) $ 空间复杂度： $ O\\left ( C \\right ) $ ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:2:0","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["码志"],"content":"一维数组表示下的常数优化 内层循环的下限不需要为 0。 代码模版： int bound, sumw = 0; for(int i = 1; i \u003c= N; i++) { sumw += w[i]; bound = max(C - sumw, w[i]); for(int c = C; C \u003e= bound; C--) { if(c \u003e= w[i]) { f[c] = max(f[c], f[c - w[i]] + v[i]); } } } 初始化的细节： 若要求“恰好装满”： $ f\\left [ 0 \\right ]=0 $ ，其他 $ f\\left [ i \\right ]=\\textrm{-INF} $ 。 若不用“恰好装满”： $ f\\left [ 0 \\right ]=0 $ 。 最后附上 NOIP2005P3 的代码： #include \u003ciostream\u003e#include \u003cmemory.h\u003e#include \u003calgorithm\u003e using namespace std; const int MAX = 1024; int C, N; int pC[MAX], pW[MAX], f[MAX]; int main() { cin \u003e\u003e C \u003e\u003e N; for(int i = 0; i \u003c N; i++) { cin \u003e\u003e pC[i] \u003e\u003e pW[i]; } memset(f, 0, sizeof(f)); for(int i = 0; i \u003c N; i++) { for(int j = C; j \u003e= pC[i]; j--) { f[j] = max(f[j], f[j - pC[i]] + pW[i]); } } cout \u003c\u003c f[C] \u003c\u003c endl; return 0; } ","date":"2013-08-23","objectID":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/:2:1","tags":["0/1 背包"],"title":"0/1 背包 - NOIP2005P3","uri":"/2013/08/01-%E8%83%8C%E5%8C%85-noip2005p3/"},{"categories":["浮生杂记"],"content":"一个暑假很快就过去了，还有一个多星期就要高三了。回顾这个暑假，总感觉比之前任何一个暑假都要充实，这种感觉就如同大块朵颐后的欣悦。简略的说几类事情吧，希望这次不会沉到草稿箱里。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:0:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"学习 大部分时间都在学校参加数学竞赛辅导。上午自习，下午讲课，最近加入了晚自习。 去扬州进行了为期十天的培训，留下了一篇游记。本来想把课上的讲义发上来的，但是没时间编辑，就一拖再拖。 读完了《博弈论导论》，并初步的学习了一下博弈论。 读完了《看见》，没来得及写下读书笔记。 坚持每天做英语阅读，有来不及的次日补上。 开始刷数学、物理的自主招生题目。 制订了阅读英文书籍的计划。 翻译了一篇论文：Methods of Computing Square Roots。 研究了一大堆闻所未闻的定理。 组织了一次 NOIP 模拟赛，取得了较好的效果。 进一步深入学习了数论，动态规划，树，图论，为 NOIP 2013 奠定基础。 学习使用 LaTeX 编辑文章，制作了一份 2012 年数学初赛试题的集锦，并在扬州坚持每天做一份。 学习使用 git 托管项目。 学习 Qt，并独立写出了第一个 IDE：Light-Cpp。有望参加明年的程序设计比赛。 加入了 Smart Online Judge 开发团队，进行网页的后台开发。 优化了博客的 UI，提高了用户体验质量。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:1:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"娱乐 为了解决我们中午吃何种外卖，哪些人去拿的难题，制作了人员随机系统。 成功在 Ubuntu 系统下实现 GoAgent 翻墙。 学习了通过 PhotoShop 制作移轴摄影的特效。 新增了若干友链。 将博客的文章整理成书，并通过 LaTeX 编辑。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:2:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"资金 通过写程序，赚到了真正意义上的第一桶金。这个暑假收入共计 1800。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:3:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"琐事 有一天在学校上课，正好乘电梯回教室。巧遇周红娟，她兴高采烈的拉住我，和我唠嗑。大概讲了这些事情： 她下学期要去她老家那边支教，不教我们了； 她老公在篮球队当总教练，今天她来看比赛，顺便收拾东西； 不说也罢，影响不好。 对于周红娟，虽然只教了我一年，但是感觉特别亲切，可能由于电教员经常和她接触吧。过一阵子写篇文章，聊表纪念吧。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:4:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"感悟 假作真来真亦假，无为有处有还无。 其实有时候忙碌的生活未必有想象中那么痛苦，反而可以从中找到很多乐趣。发现以前从未发现的风景。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:5:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["浮生杂记"],"content":"高三 一切都会好起来的。 ","date":"2013-08-22","objectID":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/:6:0","tags":["高中生活"],"title":"暑假小结","uri":"/2013/08/%E6%9A%91%E5%81%87%E5%B0%8F%E7%BB%93/"},{"categories":["码志"],"content":"题目是经典的导弹拦截。第一问很有信心的写下了最长非增序列。第二问就懵了。后来看了题解，有一个“Dilworth 定理”，现在将定理的表述和证明整理如下： 这是一个关于偏序集的定理。偏序集即偏序集合。 偏序的概念：设 $ \\textbf{A} $ 是一个非空集合。 $ P $ 是 $ \\textbf{A} $ 上的一个关系，若关系 $ P $ 是自反的、反对称的、传递的，则称 $ P $ 是集合 $ \\textbf{A} $ 上的偏序关系。 即 $ P $ 满足下列条件： $ \\forall a\\in\\textbf{A},\\left ( a,a \\right )\\in P $ ； 若 $ \\left ( a,b \\right )\\in P,\\left ( b,a \\right )\\in P $ ，则 $ a=b $ ； 若 $ \\left ( a,b \\right )\\in P,\\left ( b,c \\right )\\in P $ ，则 $ \\left ( a,c \\right )\\in P $ 。 我们用 $ a\\leq b $ 表示 $ \\left ( a,b \\right )\\in P $ 。 注：“ $ \\leq $ ”只是符号，不代表不等关系。 例如， $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个偏序集，我们定义 $ A=\\left \\{ 1,2,3 \\right \\} $ ，偏序 $ \\leq $ 在 $ \\textbf{A} $ 上表现为大于等于关系，则有： $ \\leq =\\left \\{ \\left \\langle 3,3 \\right \\rangle,\\left \\langle 3,2 \\right \\rangle,\\left \\langle 3,1 \\right \\rangle\\left \\langle 2,2 \\right \\rangle,\\left \\langle 2,1 \\right \\rangle,\\left \\langle 1,1 \\right \\rangle \\right \\} $ 。 我们再来通过下面几个例子进一步了解偏序集： 实数集上的小于等于关系是一个偏序关系。 设 $ \\textbf{S} $ 是集合， $ P\\left(\\textbf{A}\\right) $ 是 $ \\textbf{S} $ 的所有子集构成的集合，定义 $ P\\left(\\textbf{A}\\right) $ 中两个元素 $ \\textbf{A}\\leq \\textbf{B} $ 当且仅当 $ \\textbf{A} $ 是 $ \\textbf{B} $ 的子集，则 $ P\\left(\\textbf{A}\\right) $ 在这个关系下成为偏序集。 设 $ \\textbf{N} $ 是正整数集，定义 $ m\\leq n $ 当且仅当 $ m $ 能整除 $ n $ ，不难验证这是一个偏序关系。 在偏序集中，有一个非常著名的定理，叫做“Dilworth 定理”。在介绍这个定理之前，我们需要介绍几个术语： 令 $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个偏序集，对于集合中的两个元素 $ a,b $ ，如果有 $ a\\leq b $ 或者 $ b\\leq a $ ，则称 $ a $ 和 $ b $ 是可比的，否则 $ a $ 和 $ b $ 不可比。 例： $ \\left ( \\textbf{A},\\leq \\right ) $ 是偏序集，其中 $ \\textbf{A}=\\left \\{ 1,2,3,4,5 \\right \\} $ ，其中 $ \\leq $ 是整除关系，那么对任意的 $ x\\in P $ 都有 $ 1\\leq x $ ,所以 $ 1 $ 和 $ 1,2,3,4,5 $ 都是可比的，但是 $ 2 $ 不能整除 $ 3 $ ，且 $ 3 $ 不能整除 $ 2 $ ，所以 $ 2 $ 和 $ 3 $ 是不可比的。 在X中，对于元素 $ a $ ，如果任意元素 $ b $ ，由 $ b\\leq a $ 得出 $ b=a $ ，则称 $ a $ 为极小元。 一个反链 $ \\textbf{A} $ 是 $ \\textbf{X} $ 的一个子集，它的任意两个元素都不能进行比较。 一个链 $ \\textbf{C} $ 是 $ \\textbf{X} $ 的一个子集，它的任意两个元素都可比。 定理1：令 $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个有限偏序集，并令 $ r $ 是其最大链的大小。则 $ \\textbf{X} $ 可以被划分成 $ r $ 个但不能再少的反链。 定理2（Dilworth 定理）：令 $ \\left ( \\textbf{A},\\leq \\right ) $ 是一个有限偏序集，并令 $ m $ 是反链的最大的大小。则 $ \\textbf{X} $ 可以被划分成 $ m $ 个但不能再少的链。 证明：这里只对定理1进行证明，定理2的证明留给读者自行证明。 设 $ p $ 为最少反链个数； 先证明 $ \\textbf{X} $ 不能划分成小于 $ r $ 个反链。由于 $ r $ 是最大链 $ \\textbf{C} $ 的大小， $ \\textbf{C} $ 中任两个元素都可比，因此 $ \\textbf{C} $ 中任两个元素都不能属于同一反链。所以 $ p\\geq r $ 。 设 $ \\mathbf{X_{1}}=\\mathbf{X} $ ， $ \\mathbf{A_{1}} $ 是 $ \\mathbf{X_{1}} $ 中的极小元的集合。从 $ \\mathbf{X_{1}} $ 中删除 $ \\mathbf{A_{1}} $ 得到 $ \\mathbf{X_{2}} $ 。注意到对于 $ \\mathbf{X_{2}} $ 中任意元素 $ a_{2} $ ，必存在 $ \\mathbf{X_{1}} $ 中的元素 $ a_{2} $ ，使得 $ a_{1}\\leq a_{1} $ 。令 $ \\mathbf{A_{2}} $ 是 $ \\mathbf{X_{2}} $ 中极小元的集合，从 $ \\mathbf{X_{2}} $ 中删除 $ \\mathbf{A_{2}} $ 得到 $ \\mathbf{X_{3}} $ ……最终，会有一个 $ \\mathbf{X_{k}} $ 非空而 $ \\mathbf{X_{k+1}} $ 为空。于是 $ \\mathbf{A_{1}},\\mathbf{A_{2}},\\cdots ,\\mathbf{A_{k}} $ 就是 $ \\mathbf{x} $ 的反链的划分，同时存在链 $ a_{1}\\leq a_{2}\\leq\\cdots\\leq a_{k} $ ，其中 $ a_{i} $ 在 $ \\mathbf{A_{i}} $ 内。由于 $ r $ 是最长链大小，因此 $ r\\geq k $ 。由于 $ \\mathbf{x} $ 被划分成了 $ k $ 个反链，因此 $ r=k\\geq p $ 。因此 $ r=p $ ，得证。 那么这道题目就化简为求一遍最长非增序列和最长上升序列，DP 即可。 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; const int MAX = 128; int N, f1[MAX], f2[MAX], ans1, ans2; vector\u003cint\u003e pVec; int main() { cin \u003e\u003e N; int nTmp; for(int i = 0; i \u003c N; i++) { cin \u003e\u003e nTmp; pVec.push_back(nTmp); } for(int i = 0; i \u003c pVec.size(); i++) { f1[i] = f2[i] = 1; } for(int i = 1; i \u003c pVec.size(); i++) { for(int j = 0; j \u003c i; j++) { if(pVec[j] \u003e= pVec[i] \u0026\u0026 f1[j] + 1 \u003e f1[i]) { f1[i] = f1[j] + 1; } if(pVec[j] \u003c pVec[i] \u0026\u0026 f2[j] + 1 \u003e f2[i]) { f2[i] = f2[j] + 1; } } } ans1 = 0; ans2 = 0; for(int i = 0; i \u003c pVec.size(); i++) { if(f1[i] \u003e ans1) { ans1 = f1[i]; } if(f2[i] \u003e ans2) { ans2 = f2[i]; } } cout \u003c\u003c ans1 \u003c\u003c \" \" \u003c\u003c ans2 \u003c\u003c endl; return 0; } ","date":"2013-08-22","objectID":"/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/:0:0","tags":["Dilworth 定理"],"title":"Dilworth 定理 - NOIP1999T1","uri":"/2013/08/dilworth-%E5%AE%9A%E7%90%86-noip1999t1/"},{"categories":["码志"],"content":"题目描述是经典的蛇形填数问题。 以前解决这类问题，通常是通过控制 $ i,j $ 的值来定位数组元素的位置，然后进行赋值。但是这种方法非常的繁琐，且难于理解。容易出错。 今天在做这道题目的时候，通过搜索资料，思索出了一种新解法，相较于原来的解法更以理解，且时间复杂度更低。解法的基本思想是 BFS。下面我们仔细来探讨一下。 首先我们定义一组偏移量数组： const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 };  这个数组的顺序必须和填数的顺序一致。在这里，它被定义为逆时针填数。 然后我们需要设置 BFS 的起点： x = 1; y = N; i = 0; f[x][y] = nNum++; 其中， $ x,y $ 用来保存当前坐标， $ i $ 则是保存当前偏移量的数组下标。 $ f\\left [ x \\right ]\\left [ y \\right ] $ 表示需要填充的矩阵， $ nNum $ 则是所需要填的数。 我们来简单的模拟以下，假设现在坐标为 $ \\left ( 1,n \\right ) $ ，偏移量下标 $ i=0 $ 。首先尝试向右扩展标 $ \\left ( 1,n+1 \\right ) $ ，不合法，于是返回到坐标 $ \\left ( 1,n \\right ) $ 再先下扩展，检测合法后，进行填充，当填充到最下端时，又不合法，这样，返回到坐标 $ \\left ( n,n \\right ) $ 后向左扩展，同理，填充到最左端后又会向上扩展，这里还需要检测当前扩展结点是否已经填数。如果已经填数，则不合法，需要返回上一个坐标。 这样我们模拟一遍 BFS 就可以知道，这种解法是正确的，所以这里略过证明。 基本代码如下： #include \u003ciostream\u003e#include \u003cmemory.h\u003e using namespace std; const int MAX = 16; const int dx[] = { 1, 0, -1, 0 }; const int dy[] = { 0, -1, 0, 1 }; int x, y, i, nNum = 1; int N, f[MAX][MAX]; int main() { memset(f, 0, sizeof(f)); cin \u003e\u003e N; x = 1; y = N; i = 0; f[x][y] = nNum++; while(nNum \u003c= N * N) { x += dx[i]; y += dy[i]; if(x \u003e= 1 \u0026\u0026 x \u003c= N \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= N \u0026\u0026 f[x][y] == 0) { f[x][y] = nNum++; } else { x -= dx[i]; y -= dy[i]; i = (i + 1) % 4; } } for(int i = 1; i \u003c= N; i++) { for(int j = 1; j \u003c= N; j++) { if(N * N \u003e 99 \u0026\u0026 f[i][j] \u003c 100) { cout \u003c\u003c \" \"; } if(N * N \u003e 9 \u0026\u0026 f[i][j] \u003c 10) { cout \u003c\u003c \" \"; } cout \u003c\u003c f[i][j] \u003c\u003c \" \"; } cout \u003c\u003c endl; } return 0; } ","date":"2013-08-22","objectID":"/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/:0:0","tags":["广度优先搜索"],"title":"BFS 解决蛇形填数 - NOIP1995P2","uri":"/2013/08/bfs-%E8%A7%A3%E5%86%B3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0-noip1995p2/"},{"categories":["浮生杂记"],"content":"今天同学聚会，感慨颇多。彼此分别已有两年，有些人还是像以前一样，有些人却已很难辨认。不禁喟叹「时间」的伟大。还是简单的提一下今天聚会的事情吧。 最令我意外的，是虞永春老师。没想到时隔三四年他还记得那次我踢球撞破眼睑去医院缝了好几针。一见面直接就问，上次缝针的那里还看得出吗。还有就是以前宿舍里的兄弟们，大家还是这么亲近，随意的开玩笑，嬉戏打闹，感觉很好。还有小伙伴们，我想死你们了！有些话无须多言，好兄弟们！ 下面讲讲最近发生的一些事情吧，太零碎，将就着看吧。 有评价说我现在的博客学术味太浓厚，我也不知道该如何回复他，只是报以尴尬的笑。想来放暑假已经有一个月了，却感觉这个暑假充实无比，基本每天都会做做《英语5·3》，刷上一两张数学试卷。说实话，对于这种生活挺期待，也挺喜欢。因为在某些时候我的自制力的确很差。以至于最近不太想写一些文字记录生活，而是写一大堆关于数竞的文章。其实本来写了好几篇，只是大多写了一半就写不下去了，于是只好保存为草稿，最后不了了之。 我记得刚开始申请域名，搭建博客的时候，我的目的仅仅是将这个博客作为生活的一个备份，而不是一大堆关于学术的文章。显然，近阶段我没有做好这一点。不过回过头来想一想，这些学术的内容也是生活的一部分，作为生活的备份也无可厚非。实质原因则是不想写一些回忆性的文字，所以只好发一些学术方面的文章，免得博客变成一潭死水。 足球赛，上午在四十摄氏度的高温下，踢一个多小时，下午我们有时候提早放学，继续踢一会儿，感觉非常舒服。踢完以后整个人什么都不想做。但是后来物理组还是被王惠峰发现了。 每天数学课都是做题目，讲题目，期间接触了许多很有趣的题目，比如海盗船长分金币的题目。 这个暑假终于写出了像样的程序，卖出了像样的价格。还是很兴奋的。 这次就到这吧，有点急事，仓促停笔。 ","date":"2013-08-09","objectID":"/2013/08/%E6%9D%82%E8%AE%B020130809/:0:0","tags":["高中生活"],"title":"杂记（20130221）","uri":"/2013/08/%E6%9D%82%E8%AE%B020130809/"},{"categories":["浮生杂记"],"content":"注：这篇文章在草稿箱里沉睡了许久，现在勉强将其写完，可能有所遗漏。 7月15日至7月24日去扬州参加了数学夏令营。现在将沿途一些所见所闻所感记录于此。这几天的经历可以用一句话来概括「生活单调的像巴甫洛夫的狗，日子凄惨的如薛定谔的猫。」 7月15日中午我们乘坐大巴从学校赶往扬州。当大巴驶在宽阔的长江大桥上，我被长江的宽阔与雄壮所折服。从杨舍到扬州有将近2小时45分钟的车程。去的路上大家都很激动，不断的拍照直播。 我们入住的宾馆叫做辰源宾馆，双人间，自由组合，我便和陈力江住在了一起。刚进入房间，一股恶臭扑面而来，打电话给总台叫人来处理，他却说这里的下水道本来就堵住的，没办法。还说的振振有词。打开电视机，不是看不清就是没声音。在床上躺了一会儿，就去吃晚饭了。晚饭自然是张伟新请客的，就在宾馆的对面——三道菜。那边的菜都有点辣，而且很多菜都长一个样。不得不说他们店里的招牌冷饮——酸梅汤。免费而且无限续杯，口感的确不错。 当天晚上是开班会，我们一个班将近两百多人。班主任自称扬州大学大三学生，自我介绍时说，“我会成为你们既恨又爱的班主任之一”。这句话的前半部分很快就得到了验证，他要核对身份证信息，还要关注一些注意点。但是他只会串行运行，不会并行处理。在他让我们核对身份证期间，居然干巴巴在上面站着，一句话也不说。好不容易核对好了，开始讲一些注意事项。居然重复了五六遍！每次讲完都说“我再强调一遍”，导致最后直接有学生拍桌子起哄。最后处理了一下座位的问题，初步定为抢座位。对了，补充一句，一开始只有我们学校住在外面宾馆，其他学校一律住的宿舍，所以他们有晚自习，我们没有。 班会结束后从大教室走出来，天上早已繁星点点。由于那个老师拖了很久，大家心情本来就不怎么好。又遇到蛮横的门卫，差点起了争执。最后还是打通了张伟新的电话才放我们出校门。相比较而言，其实我们这里的门卫一点都不凶。 对于门卫的做法，或许他是为了学校和学生的安全考虑，但是那天晚上他所表现出来的行为实在是令人大跌眼镜，一副气势汹汹，妄图吓住我们的样子。这种表现让我有种「扬州人都是这种样子。」的感觉。当然，我们学校也有人在趁门卫拦截别人时走了出来，虽然有违规矩，但在这种背景下却也无可厚非。只是觉得门卫实在没有必要到如此地步。 回到宾馆洗漱，整理，大家说明天早点起来去抢位置。我们第一天6点起床，顺利的抢到了第一排。当我们到教室的时候只有7点，8点上课。那个班主任还在睡觉。他就这样被我们吵醒了去开门。结果开了门说，我们以后排座位吧，要考虑到别人的休息。 对于这件事情，班主任为排座位找到了一个非常冠冕堂皇的理由，我们要考虑到住在校外的学生（也就是指我们，但是我们抢到了第一排），这个理由显然是行不通的。感觉这个班主任办事能力太差劲，而且找理由却一点都不让人信服。而不像某些老师，即使你知道他是在找理由，但却心甘情愿跟着他做。 讲函数的老师是个佛教徒。上课讲的一些禅语倒是很值得推敲。 因空见色，由色生情，传情入色，自色悟空。 首先，佛学中的「色」和道家中的「道」有异曲同工之妙，皆是指天地万物。这几句话在《石头记》中也有出现过，是空空道人所说。结合《好了歌》，我们可以这样理解这几句话：从「无」了解表象，接着从表象懂得人间的感情和苦恼，然后从中解脱，懂得此皆因表象而起，最后懂得外物表象终究是「无」。从人情方面理解，这几句话的意思和老子的「超然出世」并无太大区别。从学术上理解，则表示了从无知到理解到运用自如的过程，而最高境界，则是「无招胜又招」。 一个讲排列组合的老师叫刘凯峰。他给我们讲了两个自身的故事。应该算是在警醒我们吧。「我们那时候学习压力几乎没有，初三的时候我们班的男生还在玩水枪。我当时胆子小，所以没和他们一起玩。结果就我考上了高中。」「我在高考前几天还在研究三等分角，结果高考考了个师范。」毕竟，竞赛仅仅是磨练意志和开拓眼界的。真正属于我们的舞台，还是高考。 他还讲了一些他以前出过的一些高考题，还讲了一道数列题，他说是用来准备作为2013年高考附加题最后一题的。但是命题组换了人，所以没叫他去。那道题目相当难，除了第一问可以猜出答案，第二问的证明根本不会。而他也洋洋自得的说，第二问的证明不仅要用到螺旋归纳法，还要如何如何。而且很大气的说，这道题目就没准备让你们拿分，除了第一问有个别人可以猜出答案。 最后一天讲平面几何的老师讲课方式非常奇特。偌大的教室，有投影不用，偏偏用黑板。说话听不清，黑板看不清，而且讲题目喜欢只讲一半。以至于他讲的调和点列似懂非懂，谁知道第二天就考到了调和点列和梅涅劳斯定理综合的平几题。 上课基本就是这样。接下来讲讲课余生活吧，应该算不上太丰富。每天早上7点起床，中午12点休息一会，然后午睡到2点半。晚上6点下课，吃完晚饭买杯奶茶，接着大家串门娱乐。玩到8点左右开始做题目。 某天晚上大家守着信号极差的有线电视，好不容易调到一个清晰的频道，中国好声音，居然还没有声音。 期间大家商量了准备去瘦西湖玩的，可惜有人夜探瘦西湖带回来的消息是：瘦西湖没有夜游，于是只能作罢。本来我们还想像周红娟一样，去瘦西湖上撑一支竹篙，在星辉斑斓里放歌。 比较有印象的应该是那天足球赛，中国队VS日本队。一大群男生在一个房间里看球赛。张伟新来查房，还以为我们在做什么不法勾当。 还有不得不提的一件事情，就是宾馆的隔音效果。中午睡觉，楼上一位大妈在打电话，声音非常大，时不时发出恐怖的大笑声。搞得一个中午没睡觉。晚上，本来快睡着了，隔壁传来一阵电视机的声音。 某天中午，我们准备去大润发逛逛，人生地不熟，遂向一报亭老人问路，他说直走右拐再直走，跑半分钟就到了。结果我们走了十多分钟才看见。回酒店的路上顺便逛了一下酒店后面的所谓步行街，感觉非常的冷清，而且有点邋遢。 最后一天，那个班主任说下午提前40分钟到，要发准考证。谁知我们到了，他还没到。 复赛，有一道题目上课讲过类似的方法，但是考完后还是感觉很虚。但有80%的通过率也放下了心。自己在知识的海洋面前，实在是非常的渺小。 我还像以前一样疯狂的热爱数学！ ","date":"2013-08-01","objectID":"/2013/08/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E9%9B%B6/:0:0","tags":["数学竞赛"],"title":"扬州拾遗（零）","uri":"/2013/08/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E9%9B%B6/"},{"categories":["数学之美"],"content":"一、函数问题基本方法 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:0","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"1. 数型结合法 例1：求方程 $ \\left | x-1\\right |=\\frac{1}{x} $ 的正根的个数。 解：作图像得，正根个数为 $ 1 $ 。 例2：求函数 $ f\\left(x\\right)=\\sqrt{x^{4}-3x^{2}-6x+13}-\\sqrt{x^{4}-x^{2}+1} $ 的最大值。 解： $ f\\left(x\\right)=\\sqrt{\\left(x^{2}-2\\right)^{2}+\\left(x-3\\right)^{2}}-\\sqrt{\\left(x^{2}-1\\right)^{2}+x^{2}} $ 即表示点 $ P\\left(x,x^{2}\\right) $ 到点 $ A\\left(3,2\\right),B\\left(0,1\\right) $ 的距离之差，点 $ P $ 在抛物线 $ y=x^{2} $ 上。 易得点 $ P $ 在直线 $ l_{AB}:x-3y+3=0 $ 上，因此得到 $ P\\left(\\frac{1-\\sqrt{37}}{6},\\frac{19-\\sqrt{37}}{18}\\right) $ ，故 $$ \\begin{align*} f\\left(x\\right)_{max} \u0026=\\sqrt{\\left[\\left(\\frac{1-\\sqrt{37}}{6}-3\\right)^{2}+\\left(\\frac{19-\\sqrt{37}}{18}-2\\right)^{2}\\right]-\\left[\\left(\\frac{1-\\sqrt{37}}{6}\\right)^{2}+\\left(\\frac{19-\\sqrt{37}}{18}-1\\right)^{2}\\right]} \\\\ \u0026=\\frac{2\\sqrt{245+34\\sqrt{37}}}{9} \\end{align*}$$ ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:1","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"2. 函数性质的应用 例3：设 $ x,y\\in\\mathbf{R} $ ，且满足 $ \\begin{cases} \\left ( x-1 \\right )^{3}+1997\\left ( x-1 \\right )=-1\\\\ \\left ( y-1 \\right )^{3}+1997\\left ( y-1 \\right )=1 \\end{cases} $ ，求 $ x+y $ 。 解：考虑函数 $ f\\left(s\\right)=s^{3}+1997s $ ，该函数既是奇函数又是增函数。又 $ f\\left(x-1\\right)=-f\\left(y-1\\right) $ ，得 $ \\left(x-1\\right)+\\left(y-1\\right)=0 $ ，因此 $ x+y=2 $ 。 例4：奇函数 $ f\\left(x\\right) $ 在定义域 $ \\left(-1,1\\right) $ 内是减函数，又 $ f\\left(1-a\\right)+f\\left(1-a^{2}\\right)\u003c0 $ ，求 $ a $ 的取值范围。 解：首先由函数的定义域得 $ \\begin{cases} -1\u003c1-a\u003c1\\\\ -1\u003c1-a^{2}\u003c1 \\end{cases} $ ，解得 $ 0\u003c a\u003c \\sqrt{2} $ 。下面进行分类讨论： $ 1^{\\circ} \\left | 1-a \\right |\u003c 1-a^{2}\\Rightarrow 0\u003c a\u003c 1 $ $ 2^{\\circ}\\left | 1-a^{2} \\right |\u003c 1-a\\Rightarrow -2\u003c a\u003c 0 $ （不符题意）。 综上所述， $ a\\in\\left ( 0,1 \\right ) $ 。 例5：设 $ f\\left(x\\right) $ 是定义在 $ \\left(-\\infty,+\\infty\\right) $ 上以 $ 2 $ 为周期的函数，对 $ k\\in\\mathbf{Z} $ ，用 $ I_{k} $ 表示区间 $ \\left(2k-1,2k+1\\right] $ ，已知当 $ x\\in I_{0} $ 时， $ f\\left(x\\right)=x^{2} $ ，求 $ f\\left(x\\right) $ 在 $ I_{k} $ 上的解析式。 解：根据图像的平移，易得 $ f\\left(x\\right)=\\left(x-2k\\right)^{2} $ 。 例6：解方程 $$ \\left(3x-1\\right)\\left(\\sqrt{9x^{2}-6x+5}+1\\right)+\\left ( 2x-3 \\right )\\left ( \\sqrt{4x^{2}-12x+13}+1 \\right )=0 $$ 解：首先进行因式分解： $$ \\left(3x-1\\right)\\left(\\sqrt{\\left ( 3x-1 \\right )^{2}+4}+1\\right)+\\left ( 2x-3 \\right )\\left ( \\sqrt{\\left ( 2x-3 \\right )^{2}+4}+1 \\right )=0 $$ 考察函数 $$ f\\left ( s \\right )=s\\left ( \\sqrt{s^{2}+4}+1 \\right ) $$ 它既是奇函数又是增函数。因此上述方程转化为 $$ \\left ( 3x-1 \\right )+\\left ( 2x-3 \\right )=0 $$ 解得 $ x=\\frac{4}{5} $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:2","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"3. 配方法 例7：求函数 $ y=x+\\sqrt{2x+1} $ 的值域。 解：首先考虑定义域得 $ D_{y}=\\left [ -\\frac{1}{2},+\\infty \\right ) $ 。又 $$ y=\\left ( \\sqrt{x+\\frac{1}{2}}+\\sqrt{\\frac{1}{2}} \\right )^{2}-1\\geq -\\frac{1}{2} $$ 因此该函数的值域为 $ R_{y}=\\left [ -\\frac{1}{2},+\\infty \\right ) $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:3","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"4. 换元法 例8：求函数 $ y=\\left ( \\sqrt{1+x}+\\sqrt{1-x}+2 \\right )\\left ( \\sqrt{1-x^{2}}+1 \\right ),x\\in\\left [ 0,1 \\right ] $ 的值域。 解：令 $ s=\\sqrt{1+x}+\\sqrt{1-x} $ ，则 $ s^{2}=2\\left ( \\sqrt{1-x^{2}}+1\\right ) $ ，且 $ s\\in\\left [ -\\sqrt{2},\\sqrt{2} \\right ] $ 。代入得 $ y=\\frac{1}{2}\\cdot \\left ( s+2 \\right )\\cdot s^{2}=\\frac{1}{2}s^{3}+s^{2} $ ，易得该函数的值域为 $ R_{y}=\\left [ 2+\\sqrt{2},8 \\right ] $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:4","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"5. 关于反函数 例9：若函数 $ y=f\\left ( x \\right ) $ 定义域、值域均为 $ \\mathbf{R} $ ，且存在反函数。若 $ y=f\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增，求证： $ y=f^{-1}\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增。 解：不妨设 $ x_{1}\u003ex_{2} $ ，则 $ f\\left ( x_{1} \\right )\u003ef\\left ( x_{2} \\right ) $ ，因此 $$ f^{-1}\\left ( f\\left ( x_{1} \\right ) \\right )-f^{-1}\\left ( f\\left ( x_{2} \\right ) \\right )=x_{1}-x_{2}\u003e0 $$ 所以 $ y=f^{-1}\\left ( x \\right ) $ 在 $ \\left(-\\infty,+\\infty\\right) $ 上递增。证毕。 例10：设函数 $ f\\left ( x \\right )=\\sqrt[4]{\\frac{4x+1}{3x+2}} $ ，解方程 $ f\\left ( x \\right )=f^{-1}\\left ( x \\right ) $ 。 解：即 $ \\sqrt[4]{\\frac{4x+1}{3x+2}}=x $ ，整理得 $$ \\left ( x-1 \\right )\\left ( 3x^{4}+5x^{3}+5x^{2}+5x+1 \\right )=0 $$ 显然 $ 3x^{4}+5x^{3}+5x^{2}+5x+1\u003e0 $ ，故 $ x=1 $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:1:5","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"二、典型例题 题1：已知不等式 $ \\sin^{2}x+a\\cos x+a^{2}\\geq 1+\\cos x $ 对一切 $ x\\in\\mathbf{R} $ 恒成立，求 $ a $ 的取值范围。 解： $ \\cos^{2}x+\\left ( 1-a \\right )\\cos x - a^{2}\\leq 0 $ ，其中 $ \\cos x\\in\\left [ -1,1 \\right ] $ 。令 $$ f\\left ( x \\right )=\\cos^{2}x+\\left ( 1-a \\right )\\cos x - a^{2} $$ 则 $$ \\begin{cases} f\\left ( -1 \\right )\\leq 0\\\\ f\\left ( 1 \\right )\\leq 0 \\end{cases} \\Rightarrow \\begin{cases} a^{2}-a\\geq 0\\leq 0\\\\ a^{2}-a-2\\geq 0\\leq 0 \\end{cases} \\Rightarrow a\\in\\left ( -\\infty,-2 \\right ]\\cup\\left [ 1,+\\infty \\right ) $$ 题2：已知函数 $ f\\left ( x \\right ) $ 的定义域是 $ \\left [ -\\frac{1}{2},\\frac{1}{2} \\right ] $ ，求函数 $ g\\left ( x \\right )=f\\left ( ax \\right )+f\\left ( \\frac{x}{a} \\right ) $ 的定义域 $ \\left ( a\u003e 0\\right ) $ 。 解：根据函数函数 $ f\\left ( x \\right ) $ 的定义域很容易得到以下不等式 $ \\begin{cases} -\\frac{1}{2}\\leq ax\\leq \\frac{1}{2}\\\\ -\\frac{1}{2}\\leq \\frac{x}{a}\\leq \\frac{1}{2} \\end{cases} $ 。即 $ \\begin{cases} -\\frac{1}{2a}\\leq x\\leq \\frac{1}{2a}\\\\ -\\frac{a}{2}\\leq x\\leq \\frac{a}{2} \\end{cases} $ 分类讨论得： $ 1^{\\circ}0\u003c a\\leq 1,D_{g}=\\left [ -\\frac{a}{2},\\frac{a}{2} \\right ] $ $ 2^{\\circ}a\u003e 1,D_{g}=\\left [ -\\frac{1}{2a},\\frac{1}{2a} \\right ] $ 题3：已知 $ f\\left(x\\right) $ 是定义在 $ \\mathbf{R} $ 上的函数， $ f\\left(1\\right)=1 $ ，且对任意 $ x\\in\\mathbf{R} $ 都有 $ f\\left(x+5\\right)\\geq f\\left(x\\right) + 5,f\\left(x+1\\right)\\leq f\\left(x\\right)+1 $ ，且 $ g\\left ( x \\right )=f\\left ( x \\right )+1-x $ 求 $ g\\left(2012\\right) $ 。 解： $ f\\left ( x+5 \\right )\\leq f\\left ( x+4 \\right )+1\\leq \\cdots \\leq f\\left ( x \\right )+5 $ ，又 $ f\\left ( x \\right )\\geq f\\left ( x \\right )+5 $ ，故 $ f\\left ( x \\right )= f\\left ( x \\right )+5 $ 。运用数学归纳法，并结合 $ f\\left ( 1 \\right )=1 $ ，不难得到 $ f\\left ( x \\right )=x $ 。因此 $ g\\left ( 2012 \\right )=f\\left ( 2012 \\right )+1-2012=1 $ 。 题4：设函数 $ f:\\mathbf{N^{*}}\\rightarrow \\mathbf{N^{*}} $ ，且严格递增。当 $ m,n $ 互质时， $ f\\left ( m\\cdot n \\right )=f\\left ( m \\right )\\cdot f\\left ( n \\right ) $ 。若 $ f\\left ( 19 \\right )=19 $ ，求 $ f\\left ( f\\left ( 19 \\right ) \\right )\\cdot f\\left ( 98 \\right ) $ 的值。 解：由题意得，当 $ x\\leq 19 $ 时，有 $ f\\left ( x \\right )=x $ 。又 $ f\\left ( 17\\cdot 19 \\right )=f\\left ( 17 \\right )\\cdot f\\left ( 19 \\right )=323 $ ，则当 $ x\\leq 323 $ 时，有 $ f\\left ( x \\right )=x $ 。所以 $$ f\\left ( f\\left ( 19 \\right ) \\right )\\cdot f\\left ( 98 \\right )=f\\left ( 19 \\right )\\cdot f\\left ( 98 \\right )=19*98=1862 $$ 题5：设函数 $ f:\\mathbf{N^{*}}\\rightarrow \\mathbf{N^{*}} $ ，且严格递增。 $ f\\left ( f\\left ( n \\right ) \\right )=3n $ 。求 $ f\\left ( 1 \\right )+f\\left ( 9 \\right )+f\\left ( 36 \\right ) $ 。 解：首先可以得到 $ f\\left ( f\\left ( 1 \\right ) \\right )=3 $ 。不妨假设 $ f\\left ( 1 \\right )=1 $ ，代入得 $ f\\left ( f\\left ( 1 \\right ) \\right )=f\\left ( 1 \\right )=1\\neq 3 $ ，矛盾。因此易证 $ f\\left ( 1 \\right )=2 $ 。于是可以列出： $$ f\\left ( 2 \\right )=f\\left ( f\\left ( 1 \\right ) \\right )=3,f\\left ( 3 \\right )=f\\left ( f\\left ( 2 \\right ) \\right )=6,f\\left ( 6 \\right )=f\\left ( f\\left ( 3 \\right ) \\right )=9,f\\left ( 9 \\right )=f\\left ( f\\left ( 6 \\right ) \\right )=18 $$ 于是得到 $ f\\left ( 9 \\right )=18 $ 。由 $ f\\left ( 3 \\right )=6,f\\left ( 6 \\right )=9 $ 再结合题中所给条件，得 $ f\\left ( 4 \\right )=7 $ 。因此 $$ f\\left ( 7 \\right )=f\\left ( f\\left ( 4 \\right ) \\right )=12,f\\left ( 12 \\right )=f\\left ( f\\left ( 7 \\right ) \\right )=21,f\\left ( 21 \\right )=f\\left ( f\\left ( 12 \\right ) \\right )=36,f\\left ( 36 \\right )=f\\left ( f\\left ( 21 \\right ) \\right )=63 $$ 于是得到 $ f\\left ( 36 \\right )=63 $ ，将以上的结果相加得 $ f\\left ( 1 \\right )+f\\left ( 9 \\right )+f\\left ( 36 \\right )=2+18+63=83 $ 。 题6：已知函数 $ f\\left ( x \\right )=\\log_{x}{\\left ( x+1 \\right )},x\\in\\left ( 1,+\\infty \\right ) $ ，试比较 $ f\\left ( x \\right ),f\\left ( x+1 \\right ) $ 的大小。 解： $ \\frac{f\\left ( x+1 \\right )}{f\\left ( x \\right )}=\\frac{\\log{\\left (x+2 \\right )}}{\\log{\\left (x+1 \\right )}}\\cdot \\frac{\\log{\\left (x+1 \\right )}}{\\log{x}}=\\frac{\\log{\\left ( x+2 \\right )}}{\\log{x}}\u003e 1 $ ，所以 $ f\\left ( x+1 \\right )\u003e f\\left ( x \\right ) $ 。 题7：已知 $ 3^{a}+13^{b}=17^{a},5^{a}+7^{b}=11^{b} $ ，试判断实数 $ a,b $ 的大小关系，并证明之。 解：当 $ a=1 $ 时， $ b\u003e 1 $ ，得 $ b\u003e a $ 。假设 $ b\\leq a $ ，易得 $$ \\begin{cases} 17^","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:2:0","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"三、二次函数 例1：已知 $ f\\left ( x \\right )=ax^{2}+bx $ ，满足 $ 1\\leq f\\left ( -1 \\right )\\leq 2 $ 且 $ 2\\leq f\\left ( 1 \\right )\\leq 4 $ ，求 $ f\\left ( -2 \\right ) $ 的取值范围。 解： 法一：由题设得， $ \\begin{cases} 1\\leq a-b\\leq 2 \u0026 \\left ( \\textrm{i} \\right )\\\\ 2\\leq a+b\\leq 4 \u0026 \\left ( \\textrm{ii} \\right ) \\end{cases} $ ，由 $ 3\\times \\left ( \\textrm{i} \\right )+\\left ( \\textrm{ii} \\right ) $ 得 $ 5\\leq f\\left ( -2 \\right )\\leq 10 $ 。 法二： $ \\begin{cases} f\\left ( -1 \\right )=a-b\\\\ f\\left ( 1 \\right )=a+b \\end{cases} \\Rightarrow \\begin{cases} a=\\frac{1}{2}\\cdot \\left [ f\\left ( 1 \\right ) + f\\left ( -1 \\right ) \\right ]\\\\ b=\\frac{1}{2}\\cdot \\left [ f\\left ( 1 \\right ) - f\\left ( -1 \\right ) \\right ] \\end{cases} $ ，因此 $ f\\left ( -2 \\right )=f\\left ( 1 \\right )+3f\\left ( -1 \\right )\\in\\left [ 5,10 \\right ] $ 。 ","date":"2013-07-25","objectID":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/:3:0","tags":["函数","数学竞赛"],"title":"扬州拾遗（一）：竞赛中的函数","uri":"/2013/07/%E6%89%AC%E5%B7%9E%E6%8B%BE%E9%81%97%E4%B8%80%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"categories":["数学之美"],"content":"鸽巢原理：如果 $k+1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 $2$ 个或更多的物体。 有时候鸽巢原理也被称为抽屉原理，更准确地说应该叫做“狄利克雷抽屉原理”。至于狄利克雷这个名字，还有有趣的函数也是用他的名字命名的。它就是大名鼎鼎的狄利克雷函数 $$f\\left(x\\right)=\\begin{cases}1,\u0026x\\in\\mathbf{Q}\\\\ 0,\u0026x\\not\\in\\mathbf{Q}\\end{cases}$$ 这个函数的有趣之处就在于它没有对应的图像。扯远了。 下面给出鸽巢原理的证明：假定 $k$ 个盒子中没有一个盒子包含的物体多余 $1$ 个，那么物体总数至多是 $k$，这与至少有 $k+1$ 物体矛盾。证毕。 例1：在一组 $367$ 个人中一定至少有 $2$ 个人有相同的生日，这是由于只有 $366$ 个可能的生日。 例2：在 $27$ 个英文单词中一定至少有 $2$ 个单词以同一个字母开始，因为英文字母表中只有 $26$ 个字母。 例3：证明对每个整数 $n$，存在一个数是 $n$ 的倍数，且在它的是进制表示中只出现 $0$ 和 $1$。 证明：令 $n$ 为正整数。考虑 $n$ 个整数 $1,11,111,\\cdots,11\\cdots 1$（在这个数表中，最后一个整数的十进制表示中具有 $n+1$ 个 $1$）。注意到当一个整数被 $n$ 整除时存在 $n$ 个可能的余数。因为这个数表中有 $n+1$ 个整数，由鸽巢原理必有两个整数在除以 $n$ 时有相同的余数。这两个整数之差的十进制表示中只含有 $0$ 和 $1$，且它能被 $n$ 整除。 广义鸽巢原理：如果 $N$ 个物体放入 $k$ 个盒子，那么至少有一个盒子包含了至少 $\\left \\lceil \\frac{N}{k} \\right \\rceil$ 个物体。 证明：假定没有盒子包含了比 $\\left\\lceil \\frac{N}{k} \\right\\rceil-1$ 多的物体，那么物体总数至多是 $$k\\left (\\left\\lceil \\frac{N}{k} \\right \\rceil -1\\right) \u003c k\\left(\\left(\\frac{N}{k}+1\\right)-1\\right)=N$$ 这与存在有总数 $N$ 个物体矛盾。证毕。 例4：在 $100$ 个中至少有 $\\left\\lceil \\frac{100}{12}\\right\\rceil=9$ 个人生在同一个月。 例5：为保证一个州的 $2500$ 万个电话有不同的 $10$ 位电话号码，所需地区代码的最小数是多少？（假定电话号码是 $\\textrm{NXX-NXX-XXXX}$ 形式，其中前 $3$ 位是地区代码，$N$ 表示从 $2$ 到 $9$ 包含的十进制数字，$X$ 表示任何十进制数字）。 解：有 $800$ 万个形如 $\\textrm{NXX-NXX-XXXX}$ 的不同的电话号码。因此，由广义鸽巢原理，在 $2500$ 万个电话号码中，一定至少有 $\\left\\lceil\\frac{25000000}{8000000}\\right\\rceil$ 个同样的电话号码。因而至少需要 $4$ 个地区代码来保证所有的 $10$ 位号码是不同的。 例6：证明在不超过 $2n$ 的任意 $n+1$ 个正整数中一定存在一个正整数被另一个正整数整除。 证明：把 $n+1$ 个整数 $a_{1},a_{2},\\cdots,a_{n}$ 中的每一个都写成 $2$ 的幂与一个奇数的乘积，换句话说，令 $a_{j}=2^{k_{j}}\\cdot q_{j},j=1,2,\\cdots,n+1$，其中 $k_{j}$ 是非负整数，$q_{j}$ 是奇数。整数 $q_{1},q_{2},\\cdots,q_{m+1}$ 都是小于 $2n$ 的正奇数。因为只存在 $n$ 个小于 $2n$ 的正奇数，由鸽巢原理，$q_{1},q_{2},\\cdots,q_{n+1}$ 中必有两个相等。于是，存在整数 $i,j$ 使得 $q_{i}=q_{j}$。令 $q_{i}=q_{j}=q$，那么 $a_{i}=2^{k_{i}}\\cdot q,a_{j}=2^{k_{j}}\\cdot q$。因而，若 $k_{i} \u003c k_{j}$，则 $a_{i}$ 整除 $a_{j}$；反之，则 $a_{j}$ 整除 $a_{i}$。 ","date":"2013-07-13","objectID":"/2013/07/%E6%B5%85%E8%B0%88%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/:0:0","tags":["鸽巢原理"],"title":"浅谈鸽巢原理及其应用","uri":"/2013/07/%E6%B5%85%E8%B0%88%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"翻书复习之时，看到斐波那契数列，于是将一些关于数列递推关系方面的内容整理了一下。 定义1：一个常系数的 $k$ 阶线性齐次递推关系是形如 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}+\\cdots+c_{k}a_{n-k}$ 的递推关系，其中 $c_{1},c_{2},\\cdots,c_{k}$ 是实数，$c_{k}\\neq 0$。 这个定义中递推关系是线性的，因为它的右边是数列前项的倍数之和。这个递推关系是齐次的，因为所出现的各项都是 $a_{j}$ 的倍数。数列各项的系数都是常数而不是依赖于 $n$ 的函数。阶为 $k$ 是因为 $a_{n}$ 由序列前面的 $k$ 项来表示。 例1：递推关系 $p_{n}=2p_{n-1}$ 是 $1$ 阶的线性齐次递推关系。递推关系 $f_{n}=f_{n-1}+f_{n-2}$ 是 $2$ 阶的线性齐次递推关系。 例2：递推关系 $a_{n}=a_{n-1}+a_{n-2}^{2}$ 不是线性的。递推关系 $h_{n}=2h_{n-1}+1$ 不是齐次的。递推关系 $b_{n}=nb_{n-1}$ 不是常系数的。 求解常系数线性齐次递推关系的基本方法是寻找形如 $a_{n}=r^{n}$ 的解，其中 $r$ 是常数。注意 $a_{n}=r^{n}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}+\\cdots+c_{k}a_{n-k}$ 的解，当且仅当 $$r^{n}=c_{1}r^{n-1}+c_{2}r^{n-2}+\\cdots+c_{k}r_{n-k}$$ 当等式两边除以 $r^{n-k}$ 并且从左边减去右边时，我们得到等价的方程 $$r^{k}-c_{1}r^{k-1}-c_{2}r^{k-2}-\\cdots-c_{k-1}r-c_{k}=0$$ 因此，数列 $\\left\\{a_{n}\\right\\}$ 以 $a_{n}=r^{n}$ 作为解，当且仅当 $r$ 使者后一个方程的解。这个方程叫作该递推关系的特征方程。方程的解叫做该递推关系的特征根。 我们首先看一个 $2$ 阶常系数线性齐次递推关系的处理结果。然后，叙述相应的阶可能大于 $2$ 的一般性结果。 定理1：设 $c_{1}$ 和 $c_{2}$ 是实数。假设 $r_{2}-c_{1}r-c_{2}=0$ 有两个不等的根 $r_{1}$ 和 $r_{2}$，那么数 $\\left\\{a_{n}\\right\\}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}$ 的解，当且仅当 $a_{n}=\\alpha_{1}\\cdot r_{1}^{n}+\\alpha_{2}\\cdot r_{2}^{n},n=0,1,2,\\cdots$，其中 $\\alpha_{1}$ 和 $\\alpha_{2}$ 是常数。 例3：求斐波那契数列的通项公式。 解：斐波那契数列满足递推关系 $f_{n}=f_{n-1}+f_{n-2}$ 和初始条件 $f_{1}=f_{2}=1$。特征方程 $r^{2}-r-1=0$ 的两个根是 $r_{1,2}=\\frac{1\\pm\\sqrt{5}}{2}$。因此，由定理 1 的斐波那契数列通项公式为：$$f_{n}=\\alpha_{1}\\cdot \\left(\\frac{1+\\sqrt{5}}{5}\\right)^{n}+\\alpha_{2}\\cdot \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}$$ 其中 $\\alpha_{1},\\alpha_{2}$ 为常数。可由初始条件 $f_{1}=f_{2}=1$ 确定这两个常数，我们有 $$\\begin{cases} f_{1}=\\alpha_{1}\\cdot \\left ( \\frac{1+\\sqrt{5}}{2} \\right )+\\alpha _{2}\\cdot \\left ( \\frac{1-\\sqrt{5}}{2} \\right )=1 \\\\ f_{2}=\\alpha_{1}\\cdot \\left ( \\frac{1+\\sqrt{5}}{2} \\right )^{2}+\\alpha _{2}\\cdot \\left ( \\frac{1-\\sqrt{5}}{2} \\right )^{2}=1 \\end{cases}$$ 从而得到 $\\alpha_{1}=\\frac{\\sqrt{5}}{5},\\alpha_{2}=-\\frac{\\sqrt{5}}{5}$，于是斐波那契数列的通项公式为：$$f_{n}=\\frac{\\sqrt{5}}{5}\\left(\\frac{1+\\sqrt{5}}{5}\\right)^{n}-\\frac{\\sqrt{5}}{5}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n}$$ 当存在二重特征根的时候，定理1不再适用。如果遇到这种情况，当 $r_{0}$ 是特征方程的一个二重根时，那么 $a_{n}=nr_{0}^{n}$ 是递推关系的另一个解。 定理2：设 $c_{1}$ 和 $c_{2}$ 是实数。假设 $r_{2}-c_{1}r-c_{2}=0$ 只有一个根 $r_{0}$。数列 $\\left{a_{n}\\right}$ 是递推关系 $a_{n}=c_{1}a_{n-1}+c_{2}a_{n-2}$ 的解，当且仅当 $a_{n}=\\alpha_{1}\\cdot r_{0}^{n}+\\alpha_{2}\\cdot n\\cdot r_{0}^{n},n=0,1,2,\\cdots$，其中 $\\alpha_{1}$ 和 $\\alpha_{2}$ 是常数。 例4：数列 $\\left\\{a_{n}\\right\\}$ 满足 $a_{n}=6a_{n-1}-9a_{n-2}$，且$a_{1}=6，a_{2}=27$，求数列 $\\left\\{a_{n}\\right\\}$ 的通项公式。 解：$r^{2}-6r+9=0$ 唯一的根是 $r=3$。因此这个递推关系的解是 $$a_{n}=\\alpha_{1}\\cdot 3^{n}+\\alpha_{2}\\cdot n\\cdot 3_{n}$$ 其中 $\\alpha_{1},\\alpha_{2}$ 是常数。使用初始条件得 $\\alpha_{1}=\\alpha_{2}=1$，所以 $\\left\\{a_{n}\\right\\}$ 的通项公式为 $$a_{n}=3^{n}+n\\cdot 3^{n}$$ 例5：求满足 $a_{1}=5,a_{2}=15,a_{3}=47$ 的递推关系 $a_{n}=6a_{n-1}-11a_{n-2}+6a_{n-3}$ 的通项公式。 解：有这个递推关系的特征方程 $r^{3}-6r^{2}+11r-6=0$ 得到三个特征根 $r_{1}=1,r_{2}=2,r_{3}=3$，于是递推关系的解的形式为：$$a_{n}=\\alpha_{1}\\cdot 1^{n}+\\alpha_{2}\\cdot 2^{n}+\\alpha_{3}\\cdot 3^{n}$$ 通过初始条件得到 $\\alpha_{1}=1,\\alpha_{2}=-1,\\alpha_{3}=2$。于是通项公式为：$$a_{n}=1-2^{n}+2\\cdot 3^{n}$$ ","date":"2013-07-12","objectID":"/2013/07/%E6%B5%85%E8%B0%88%E6%95%B0%E5%88%97%E4%B8%AD%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B1%82%E8%A7%A3/:0:0","tags":["常系数线性齐次递推关系"],"title":"浅谈数列中常系数线性齐次递推关系的求解","uri":"/2013/07/%E6%B5%85%E8%B0%88%E6%95%B0%E5%88%97%E4%B8%AD%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E6%B1%82%E8%A7%A3/"},{"categories":["余音绕梁"],"content":"歌词如下： 春天的花开秋天的风，以及冬天的落阳 忧郁的青春年少的我，曾经无知的这么想 风车在四季轮回的歌里，它天天的流转 风花雪月的诗句里，我在年年的成长 流水它带走光阴的故事，改变了一个人 就在那多愁善感而初次，等待的青春 发黄的相片古老的信，以及褪色的圣诞卡 年轻时为你写的歌，恐怕你早已忘了吧 过去的誓言，就像那课本里缤纷的书签 刻划着多少美丽的诗，可是终究是一阵烟 流水它带走光阴的故事，改变了三个人 就在那多愁善感而初次，流泪的青春 遥远的路程昨日的梦，以及远去的笑声 再次的见面我们，又历经了多少的路程 不再是旧日熟悉的我，有着旧日狂热的梦 也不是旧日熟悉的你，有着依然的笑容 流水它带走光阴的故事，改变了我们 就在那多愁善感而初次，回忆的青春 流水它带走光阴的故事，改变了我们 就在那多愁善感而初次，回忆的青春 很珍惜这种感觉，和喜欢的歌不期而遇。 这首歌应该算是真正的老歌了，小时候听只是感觉好听，现在却更喜欢这其中一股淡淡的忧伤。 “流水它带走光阴的故事”句一下子化抽象记忆为形象可感的流水，还是可谓妙喻。 ","date":"2013-06-28","objectID":"/2013/06/%E5%85%89%E9%98%B4%E7%9A%84%E6%95%85%E4%BA%8B/:0:0","tags":null,"title":"光阴的故事","uri":"/2013/06/%E5%85%89%E9%98%B4%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["浮生杂记"],"content":"好久没来打理博客了，一直没时间。有时候想要写些文字也就这样耽搁了。比如说《谁是少数幸福的人——读\u003c红与黑\u003e有感》，这篇文章我写在了随笔本上，却一直没时间把它发到博客上来。慢慢发现现在我们自由支配的时间越来越少了，想要安安静静地阅读名家大作也就成了一种奢望。 高考三天在学校上课，我们在图文信息楼四楼最西边的小教室里。根据张伟兴的暗示，隔壁就成了食堂和棋牌室。三天上课，我们一共吃了三顿东池。中午休息的时候看电影，躲在心缘爱心社玩。还差点被周汉东抓到。高一的就没这么幸运了，第一天晚自习就吵得不得了，被王胖子轻而易举地抓了现行，揪去见张新宇了。然后王胖子带着他的战利品笑嘻嘻的来到我们教室说：高二的和高一的就是不一样，到底是有追求的了。 三天做了很多题目，其中最有趣的，被我们改编成课余娱乐项目的便是这道题目： 桌上放有$n$根火柴，甲乙二人轮流从中取走火柴。甲先取，第一次可取走至多$n-1$根火柴，此后没人每次至少取走1根火柴。但是不超过对方刚才取走火柴数目的2倍。取得最后一根火柴者获胜。问：当$n=100$时，甲是否有获胜策略？请详细说明理由。 但是每次玩的时候总是遇到一些小意外，明明处在必胜态，却一不小心走向了必败态。大家有兴趣的可以玩玩。 三天上课，也给了我近距离接触高考的机会。每场考试结束以后，我们可以近距离的接触考生，听他们谈论题目，甚至可以和他们进行一些交流。最激动人心的莫过于听了一次高考英语听力，当时走廊里站满了高二搞竞赛的人，努力的捕捉广播里蹦出的每一个词句。听完听力，我却有些迷惘了。是啊，我们马上就要高三了，要准备自主招生，准备高考。事情越来越多，任务也越来越繁重了。我也不知道高考那天我会是发挥的怎么样，或许命运的神奇之处就在于它的不可捉摸吧。 我最近时常在想一件事情，究竟什么才能够使得一个人获得真正的快乐。曾经在心理学的书中看到过这个问题，它所给出的解答是一种被誉为“自我实现”的马斯洛理论，也就是需求层次理论。以前我对于这一理论是非常认同的，不过现在我的想法开始有了些细微的改变。在我很小的时候，大概是小学吧，我总是喜欢和别人分享自己取得的成绩，获得的荣誉。或许这就是所谓的“自我实现”。但是现在我却更愿意藏巧于拙，将有才能的一方面隐藏起来，而显露出一些比较拙劣的方面。也不知道为什么，陈季伦总是叫我大神，搞得我不知所措。也有人说我是信息学大神，但是我却不是很喜欢这个头衔，所以每次有人问到我关于计算机方面的问题，除非特殊情况，我都会向他推荐李老师。有时候取得了一些小小的成绩，总想和朋友们一起分享，但是却发现大家都很忙，也就只好作罢了。 更多的时候，我在思考这样一件事情，为什么我和同龄的一些人差距这么大呢。为什么我不像他们一样好玩，为什么我不像他们一样喜欢玩游戏，为什么我不像他们一样满脑低俗的思想······相比之下，我却喜欢看各种书籍、资料，有时候甚至对他们的生存状态嗤之以鼻，究竟那种才是真正的，属于我们现在的，符合我们年龄的生存状态呢？并没有谁对谁错，谁是谁非，后来想想，仅仅是个人的选择不一样罢了。但我相信，十年后，二十年后，我不会为我现在所选择的不堕落的向上的生存状态而后悔，而他们，却谁也说不准。 最近发现了自己身上一个很大的毛病，我也不知道如何用语言来描述。或者可以称之为——不成熟。遇人遇事，处理的不够好，就比如说那次和舍管阿姨的争执。完全没必要那么激动。当然，也没惹出什么后果，甚至我开始怀疑那舍管阿姨是想自己讹点钱。因为如果真是学校要求我们赔偿，那么她没有理由不再来向我要钱。但是既然过去了，也就不管它了。但是有的是还是不能太冲动，做事不能不考虑后果。 言归正传，又瞎扯了好多，本来想好好规划一下接下来的极为珍贵的一年时光。 首先是在七月份的数学复赛，前几天和朱宇聊了聊，听他所说，通过这次选拔并不难，只需要做出那道平几。尽人事，听天命。很多事情都是这样的。 接下来当然是自主招生，根据近几年的招生简章，我应该是选择数学、物理这两门考试科目。对于数学学科，现在在数学组上课，接下来又要去扬州培训，这样下来，对于自主招生问题应该不会很大，只要平时在多刷刷题。物理却有点难度，因为物理竞赛的书很难啃啊。也不知道自主招生物理竞赛内容会占多大比例。 目前比较现实的学习方面的计划就是这两个了。 路漫漫其修远兮，吾将上下而求索！ ","date":"2013-06-12","objectID":"/2013/06/%E5%91%93%E8%AF%AD%E4%B8%89%E5%BD%B7%E5%BE%A8/:0:0","tags":["高中生活"],"title":"呓语（三）：彷徨","uri":"/2013/06/%E5%91%93%E8%AF%AD%E4%B8%89%E5%BD%B7%E5%BE%A8/"},{"categories":["数学之美"],"content":"前几天在数学组听课的时候，做平面几何的题目，遇到了塞瓦定理。当时赵诚宇给我讲了一遍，现在再把它整理一下。 塞瓦定理：在 $\\triangle ABC$ 中，若线段 $AD$、$BE$、$CF$ 通过同一点 $O$，则 $\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} =1$。 塞瓦定理逆定理：在 $\\triangle ABC$ 中，若点 $D$、$E$、$F$ 分别在边 $AD$、$BE$、$CF$ 上，且满足 $\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} =1$，则线段 $AD$、$BE$、$CF$ 共点或彼此平行。（我们在此只研究共点的情形） Ceva 定理示意图\" Ceva 定理示意图 证明如下： 首先 $$\\frac {BD} {DC}=\\frac {S_{\\triangle ABD}}{S_{\\triangle ADC}}=\\frac {S_{\\triangle OBD}}{S_{\\triangle ODC}} \\Rightarrow \\frac {BD} {DC}=\\frac {S_{\\triangle ABD}-S_{\\triangle OBD}}{S_{\\triangle ADC}-S_{\\triangle ODC}}=\\frac {S_{\\triangle ABO}}{S_{\\triangle CAO}}$$ 同理 $$\\frac {CE} {EA}=\\frac {S_{\\triangle BCO}}{S_{\\triangle ABO}},\\frac {AF} {FB}=\\frac {S_{\\triangle CAO}}{S_{\\triangle BCO}}$$ 因此 $$\\frac {BD} {DC} \\cdot \\frac {CE} {EA} \\cdot \\frac {AF} {FB} = \\frac{S_{\\triangle ABO}}{S_{\\triangle CAO}} \\cdot \\frac{S_{\\triangle BCO}}{S_{\\triangle ABO}} \\cdot \\frac{S_{\\triangle CAO}}{S_{\\triangle BCO}}=1$$ 证毕。 例：在筝形 $ABCD$ 中，$AB=AD$，$BC=CD$，经 $AC$、$BD$ 的交点 $O$ 任做两条直线，分别交 $AD$ 于 $E$，交 $CD$ 于 $H$。$GF$、$EH$ 分别交 $BD$ 于 $I$，$J$。求证：$IO=OJ$。 Ceva 定理例题图\" Ceva 定理例题图 证明如下： 作 $\\triangle ABC$ 的关于 $AC$ 的对称图形，记 $E^{'}H^{'} \\cap BB=M$ 设 $\\angle GOB=\\angle BOH^{'}=\\alpha,\\angle E^{'}OG=\\angle FOH^{'}=\\beta$ 则有：$$\\frac{E^{'}G}{GB} \\cdot \\frac{BH^{'}}{H^{'}F} \\cdot \\frac{FM}{ME^{'}}=\\frac{OE^{'}\\sin \\beta}{OB \\sin \\alpha} \\cdot \\frac{OB \\sin \\alpha}{OF \\sin \\beta} \\cdot \\frac{OF \\sin \\left ( \\alpha + \\beta \\right )}{OE^{'} \\sin \\left ( \\alpha + \\beta \\right )}=1$$ 由塞瓦定理得：$MB$、$E^{'}H^{'}$、$GF$ 共点，因此 $IO=OJ$。证毕。 ","date":"2013-06-01","objectID":"/2013/06/%E6%B5%85%E8%B0%88%E5%A1%9E%E7%93%A6%E5%AE%9A%E7%90%86%E5%9C%A8%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["塞瓦定理"],"title":"浅谈塞瓦定理在平面几何中的应用","uri":"/2013/06/%E6%B5%85%E8%B0%88%E5%A1%9E%E7%93%A6%E5%AE%9A%E7%90%86%E5%9C%A8%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["浮生杂记"],"content":"NOIP 2012 获奖证书\" NOIP 2012 获奖证书 上面这张证书是星期四下午拿到的，至此 NOIP 2012 画上了一个不完美但却圆满的句号。 由于最近的一系列事件，加之以徐丹的高压政策下，我们被迫交出了机房的钥匙。一开始当然不会同意，但最后还是交出了钥匙。因为想明白了一些事情。首先，钥匙交给我们保管，是为了让我们在老师不在的时候可以进入机房得到联系。信息学不像数理化，只要一本题典，一堆草稿纸就可以应付的。但是，如果我们在机房，并不能干很多事情，并不能把时间全部高效利用，并不能 AC 更多的题目，而更多的时候是在磨洋工。那么这把钥匙给了我们，又有什么积极用处呢？在上交钥匙的时候，便决定以后周六、周日不再踏入机房。而周四，本来还想去联合电子看看的。不过徐丹非要把我们押在那里，看来计划又要有变化了。对于徐丹，并不是不尊重，而是她有时候说话的气焰太嚣张了。一个连 C++ 语法都讲不连贯的人，居然妄想着辅导我们算法，简直是可笑不自量。 本来打算彻底退出竞赛编制，自己在家里有空的时候刷题，毕竟距离初赛还有很长一段时间。但一时不知道怎么开口。至于原因，请允许我使用历史学科教导我的方法来简要分析一下：直接原因是徐丹索要钥匙事件；根本原因是对于竞赛时间不能得到合理利用的难以容忍，在此不一一例证。这样一来，便可心如不系之舟了。至于高三的竞赛，张兴老师希望我可以继续努力，争取拿到国一。只是担心那时候是否有足够的精力和时间，或者有没有别的优惠政策。毕竟取消报送，不论自己是否热爱这门竞赛，在高考这座大山的压迫下，还是会或多或少的丧失一点积极性的。 对于高一到高二复赛结束，这段竞赛经历将成为我永久的记忆。从中学到的领悟到的，远比寒窗十年所得要多得多。这一点，或许同样搞竞赛的人会有同感吧。接下来的内容是对于那段过往的一些回忆。 说起信息学竞赛，不得不提一提冯璞。我记得那时在高一上学期刚开学的时候，有一天中午和她聊天，说到赵之赫在跟一个老师（张兴）学编程，问我要不要一起去。说实话，我并不需要学，因为那些早就会了，只是对于这个话题比较感兴趣，所以就答应了。于是她把赵之赫妈妈的电话给了我。于是我便和赵之赫妈妈取得了联系，她又给了我张兴老师的电话，就这样，辗转多方，终于和张兴老师取得了联系。他和我说让我第二天下午早点去和他谈谈。 第一次，跑到信息楼三楼，等候在网管室门口。由于紧张，甚至误将一名学生认做了老师，搞得好尴尬。终于，张兴老师到了，给我第一印象是高级知识分子，技术宅，再后来的接触过程中也印证了我的想法。那天他和我谈了好多，关于编程，设计，美学…… 就这样，我通过非正当途径，成为了信息组的一员。那时候的信息组还是非常强大的，例如缪晓伟、张宇辰、周弋渊、王俊涛（《坐在生活的前排》范文的作者之一），这是我印象中高三神犇。在当时，高二的选手还欠火候，例如项业成、王意天、胡宇涛。不过有一点让我非常钦佩，他们在没有老师的情况下，都在认真刷题，也是由于受到他们的影响，为了竞赛，我戒了游戏。自此以后，再也没有碰过任何游戏。 第一次初赛，说实话，大家都没重视。毕竟只有高一嘛，还有机会。于是乎，差了 7 分出线，两道选择题。不过对我来说已经是一个非常好的成绩了。因为我是在十一长假七天内飞快的看完一本初赛书，就这样去裸考的。再加上一些自己曾经写代码的经验。几个辅导竞赛的老师大吃一惊，甚至说后悔当初没有考前专门辅导一下我。 初赛结束以后，距离信息组正式报名还有一段时间，这段时间内，我便在张兴老师的办公室内，有时候和他聊聊天，有时候他教我一些基本的算法。下学期，开始了正式的上课。内容分为三大块：C++、数据结构、算法。C++ 部分还是很轻松的，我还上了几节课。数据结构就不好说了，深似海啊。在讲到树、图的时候，已经缴械投降了。而且带着侥幸的想法，认为这就是最难的内容了。不过当时老师安慰我们说我们暑假要去常州培训，那个时候他们会给你们讲清楚的。 就这样，我们一直上课到暑假。期间我还去数学组客串了几节课，本想去听数论的，结果张伟兴就是不讲。到了暑假里，八月份的时候，我们又集中起来上课，每天晚上在机房里对着电脑调试代码到九点半。期间自称蒟蒻的神犇缪晓伟来给我们上了半天课。项业成给我们讲了并查集。后来又把我叫到准备室，给我讲了 DFS。 接下来就是振奋人心的常州之行。本以为可以疯玩了，结果除了第一天下午张春华老师带着我们参观了一个公园，以后就每天六点半起，十二点半睡，其余时间都在写代码，持续了一个星期。到最后整个人都瘫掉了。不过还是觉得很开心，因为学到了很多，见到了很多神犇。 就这样，迎来了初赛。在初赛前，抽了几节晚自习复习。初赛前一天本来是放假，但我还是留了下来，和项业成、王意天、胡宇涛一起复习，就这样看书看到第二天一点。初赛启程。2 个小时一会儿就过去了。我记得的玉米是第一个交卷的，不过出来的成绩并不理想。玉米和项业成都挺可惜的。我和胡宇涛过了初赛，接下来就是暗无天日的复赛刷题了。 停课刷题，我记得在短短的十几天里，我们一共刷了上百道题目。把前几年的复赛都做过了，并且立志要拿一等。在出征前，张春华老师还请我们吃了一顿饭，虽然是在学校食堂吃的，不过这份心意还是领了。 南航，淅淅沥沥的小雨。我们两个学生，加上张兴，三个人走在大道上，显得尤为渺小。复赛很快就结束了，唯一留下印象的，是南航极其优越的伙食。 等待结果是一个非常揪心的过程，因为有所期待。最后出来是二等，失落是肯定的，不过那个时候已经完全看透了。 随着高三神犇的离开，现在的信息组毫无生机，都是一些像我这样的蒟蒻。不堪回首。 ","date":"2013-05-18","objectID":"/2013/05/to-noip/:0:0","tags":["NOIP"],"title":"To NOIP","uri":"/2013/05/to-noip/"},{"categories":["数学之美"],"content":"我记得在计算机复赛前一天晚上本想看看同余方程的解法，结果第二天就考到了。明天是数学竞赛初赛，简略的复习一下线性同余及中国剩余定理，顺便记下一些笔记。 定理1：令 $m$ 为正整数。若 $\\begin{cases} a \\equiv b \\pmod m \\\\ c \\equiv d \\pmod m \\end{cases}$，那么 $\\begin{cases} a+c \\equiv b+d \\pmod m \\\\ ac \\equiv bd \\pmod m\\end{cases}$。 证明：因为 $\\begin{cases} a \\equiv b \\pmod m \\\\ c \\equiv d \\pmod m\\end{cases}$，所以有整数 $s$ 和 $t$ 使 $\\begin{cases} b=a+sm \\\\ d=c+tm\\end{cases}$。于是 $$ \\begin{cases} b+d=(a+sm)+(c+tm)=(a+c)+m(s+t)\\\\ bd=(a+sm)(c+tm)=ac+m(at+cs+stm) \\end{cases} \\Rightarrow \\begin{cases} a+c \\equiv b+d \\pmod m \\\\ ac \\equiv bd \\pmod m \\end{cases}$$ 例：由于 $\\begin{cases} 7 \\equiv 2 \\pmod 5 \\\\ 11 \\equiv 1 \\pmod 5\\end{cases}$，从定理1知 $\\begin{cases} 18 = 7+11 \\equiv 2+1=3 \\pmod 5 \\\\ 77 = 7 \\cdot 11 \\equiv 2 \\cdot 1=2 \\pmod 5\\end{cases}$。 定理2：如果 $a$ 和 $m$ 为互素的整数，$m \u003e 1$，则存在 $a$ 的模 $m$ 的逆。而且这个逆模 $m$ 是唯一的。（即有小于 $m$ 的唯一正整数 $\\overline{a}$，如果这样的 $\\overline{a}$ 存在的话。这样的 $\\overline{a}$ 称为 $a$ 模 $m$ 逆，且 $a$ 的任何别的模 $m$ 逆均和 $\\overline{a}$ 模 $m$ 同余。） 证明：由定理 1 及 $\\gcd \\left ( a,m \\right )=1$ 知，有整数 $s$ 和 $t$ 使 $$sa+tm=1$$ 于是 $$sa+tm \\equiv 1 \\pmod m$$ 由于 $tm \\equiv 0 \\pmod m$，所以 $$sa \\equiv 1 \\pmod m$$ 结论是 $s$ 为 $a$ 的模 $m$ 逆。 例：求 $3$ 的模 $7$ 逆。 解：由于 $\\gcd \\left ( 3,7 \\right )=1$，定理 3 说明存在 $3$ 模 $7$ 的逆。若用欧几里得算法求 $3$ 和 $7$ 的最大公约数，算法很快结束：$$7=2 \\cdot 3 + 1$$ 从这一等式看到 $$-2 \\cdot 3 + 1 \\cdot 7=1$$ 这说明 -2 是 3 模 7 的一个逆。（注意，模 $7$ 同余于 $-2$ 的每个整数也是 $3$ 的逆，例如 $5,-9,12$ 等。） 例：求线性同余 $3x \\equiv 4 \\pmod 7$ 的解。 解：易知 $-2$ 是 $3$ 模 $7$ 的逆。在同余式的两边同乘以 $-2$ 得 $$-2 \\cdot 3x \\equiv -2 \\cdot 4 \\pmod 7$$ 因为 $\\begin{cases} -6 \\equiv 1 \\pmod 7 \\\\ -8 \\equiv 6 \\pmod 7\\end{cases}$，所以若 $x$ 是解，必有 $$x \\equiv -8 \\equiv 6 \\pmod 7$$ 于是由定理 1，有 $$3x \\equiv 3 \\cdot 6 \\equiv 18 \\equiv 4 \\pmod 7 $$ 这说明所有这种 $x$ 满足问题中的同余式。结论是，同余方程的解是使 $x \\equiv 6 \\pmod 7$ 的整数。 从有关线性同余系统的中国古典问题而得名的中国剩余定理，可以这样叙述：只要线性同余系统的模数两两互素，则该系统有解，而且以所有模数之乘积取模，解是唯一的。 定理3（中国剩余定理）：令 $m_{1},m_{2},\\cdots,m_{n}$ 为两两互素的正整数，则同余方程组 $$ \\begin{cases} x \\equiv a_{1} \\pmod {m_{1}}\\\\ x \\equiv a_{2} \\pmod {m_{2}}\\\\ \\vdots \\\\ x \\equiv a_{1} \\pmod {m_{n}} \\end{cases}$$ 唯一的模 $m=m_{1}m_{2} \\cdots m_{n}$ 解。（即有一个解 $x$，使 $0 \\leq x \\leq m$，且所有其他的解均与此解模 $m$ 同余。） 证明：要建立这一定理，需要证明有一个解存在，而且是模 $m$ 唯一的。下面将给出构造这样一个解的方法以证明解的存在。 要构造一个适合各方程的解，首先对 $k=1,2, \\cdots ,n$，令 $M_{k}=\\frac{m}{m_{k}}$，即 $M_{k}$ 是除 $m_{k}$ 以外所有模数的乘积。由于 $i \\neq k$ 时，$m_{i}$ 和 $m_{k}$ 没有大于 1 的公因子，所以 $\\gcd \\left ( m_{k},M_{k} \\right )=1$。从而由定理 2 知有整数 $y_{k}$，即 $M_{k}$ 模 $m_{k}$ 的逆，使得 $$M_{k}y_{k} \\equiv 1 \\pmod {m_{k}}$$ 要得到适合所有方程的解，令 $$x=a_{1}M_{1}y_{1}+a_{2}M_{2}y_{2}+\\cdots+a_{n}M_{n}y_{n}$$ 现要证明 $x$ 就是这样一个解。 首先注意，由于只要 $j \\neq k$，就有 $M_{j} \\equiv 0 \\pmod {m_{k}}$，在 $x$ 的求和表达式中除第 $k$ 项以外的各项模 $m_{k}$ 均同余于 $0$。由于 $M_{k}y_{k} \\equiv 1 \\pmod {m_{k}}$，可以看出对 $k=1,2, \\cdots ,n$，均有 $$x \\equiv a_{n}M_{n}y_{n} \\equiv a_{k} \\pmod {m_{k}}$$。这就证明了 $x$ 是这 $n$ 个同余方程的公共解。 例：求同余方程组 $\\begin{cases} x \\equiv 2 \\pmod 3\\\\ x \\equiv 3 \\pmod 5\\\\ x \\equiv 2 \\pmod 7 \\end{cases}$ 的解。 解：首先令 $m=3 \\cdot 5 \\cdot 7=105$，$M_{1}=\\frac {m} {3}=35$，$M_{2}=\\frac {m} {5}=21$，$M_{3}=\\frac {m} {7}=15$。可看到 $2$ 是 $M_{1}=35$ 的模 $3$ 逆，因为 $35 \\equiv 2 \\pmod 3$；$1$ 是 $M_{2}=21$ 的模 $5$ 逆，因为 $21 \\equiv 1 \\pmod 5$；$1$ 也是 $M_{3}=15$ 的模 $7$ 逆，因为 $15 \\equiv -1 \\pmod 4$。于是这一方程组的解是满足下列式子的那些 $x$： $$ x \\equiv a_{1}M_{1}y_{1}+a_{2}M_{2}y_{2}+a_{3}M_{3}y_{3}=2 \\cdot 35 \\cdot 2 + 3 \\cdot 21 \\cdot 1 + 2 \\cdot 15 \\cdot 1=233 \\equiv 23 \\pmod {105} $$ 可以见 $23$ 是所有解当中最小的正整数。结论是 $23$ 是最小的正整数，除以 $3$ 时余 $2$，除以 $5$ 时余 $3$，除以 $7$ 时余 $2$。 ","date":"2013-05-04","objectID":"/2013/05/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E5%8F%8A%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/:0:0","tags":["线性同余"],"title":"浅谈线性同余及中国剩余定理","uri":"/2013/05/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E5%8F%8A%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"},{"categories":["浮生杂记"],"content":"向生命的来处张望，不禁唏嘘，时光竟如此匆匆流过。 现在的我已是一名高二的学生，想想明年就要高考，却和理想的大学相差一些距离。前一阵子看了一本书，讲的是一个英语成绩班级倒数的人通过三年的努力成为全省第五的故事。当时感到了一股强大的正能量，过了几天，我根据自己的情况，也制定了一份计划，把刷英语由原来的自发变成了自觉。最近各门科目，尤其是理科上课教的非常快。似乎老师们都认为，把知识讲完了，通过做题就可以把那些没弄懂的都巩固了。这种思维固然不错，但是却显露着填压式教育的影子。 最近慢慢的，真的懂得了学习。以前就好比是在黑暗的泥泞中摸着石头过河，却总是失足落水。我们的学习并不是为了老师，并不是为了父母，抑或其他。不认真便是对自己的不负责任。但是尽力的，却另当别论。但是科学研究表明，人类的潜力是非常巨大的，所以对于这五门学科，只要肯下工夫，并不存在任何问题。但是如果把所有的经历都放在了这上面，生活就未免有些单调。对我来说，也是不现实的。 喜欢在闲暇的午后，泡上一杯茶，预约一本好书。对于这个信息爆炸的时代，基本上任何人都可以写上一本书。但是那些所谓所谓的作家也仅仅是徒有其表。我对于书籍一直有一种纯净的观念，认为那些毫无思考力的言情玄幻等根本无法称作是书籍。否则，为什么历史上没有流传下来任何类似的书籍呢。个人比较倾向于文学，哲学，历史。这里不得不提一提历史方面的书籍，自从当年明月的《明朝那些事》出版以后，各种类似的书就层出不穷，质量也是良莠不齐。我觉得对于这种现代人改写的历史小说，一定程度上加入了作者自己的观点和看法，并不能很好的还原事情的真实面貌。由于吃过几次这样的亏。所以对于历史方面，我便倾向于看二十四史。虽然是拗口难懂的文言文，但是读上去比那些白话文的改编版清爽多了。 最近很喜欢品茶。一来它可以提神醒脑，而且不像咖啡一样对神经系统具有副作用；二来它可以是一个人静下来，更可以洗净一个人内心的浮躁与污垢。感觉灵魂更加纯洁，高尚。周红娟戏称为养生，或许这也是一个原因吧。但对于我来说，最重要的是第二点。最近总有些莫名其妙的浮躁，可能是气温升高了，功课也比较繁重，这主观与客观的交汇导致的吧。 最近在看《红与黑》，目前为止看完了上卷，却给了我很深的思考。让我联想到了当初学习《周易》时候的一句话： 看到的都是表象。 我们在这个世界，看到的是不是也都是表象？我来创造一个词，暂且叫作“快餐式友情”。我想大家身边都不缺乏朋友，而且我们也可以很快的和陌生人聊得很好，成为朋友。但是，你们之间有足够的信任吗？不要急着给出答案，仔细思考。 最近自己变得不怎么喜欢说话了，追根溯源，竟是张兴曾经和我说过的一句话： 不要和那些人一样，整天谈那些无聊没用的东西。说话要一针见血。 要忍住寂寞，才能成功。 这两句话给我的影响的确很大，本来我就感觉自己和他们在讨论一些无聊的话题时很不自在。不讨论反倒好多了。这样也就有更多的精力去考虑别的我感兴趣的事情了。对于第二句话，应该是放之四海皆准的真理吧，纵观古今之外，哪一个成功的人不是如此？如果有例外，那一定是他不够成功。 本来有很多想写的，写到这突然没了思绪了，那就到这吧。 ","date":"2013-04-29","objectID":"/2013/04/%E5%91%93%E8%AF%AD%E4%BA%8C%E6%84%9F%E6%82%9F/:0:0","tags":["高中生活"],"title":"呓语（二）：感悟","uri":"/2013/04/%E5%91%93%E8%AF%AD%E4%BA%8C%E6%84%9F%E6%82%9F/"},{"categories":["数学之美"],"content":"最近数学课上讲了矩阵，很久以前便对矩阵很有兴趣，但由于一些原因没有深入学习。正好趁这个机会，有思考了一下关于矩阵的内容。目前应用较广的应该是运用逆矩阵求解线性方程组，尤其对于三元一次方程组，运用逆矩阵求解会非常方便。 一个方形矩阵的伴随矩阵是一个类似于逆矩阵的概念。如果矩阵可逆，那么它的逆矩阵和它的伴随矩阵之间只差一个系数。然而，伴随矩阵对不可逆的矩阵也有定义，并且不需要用到除法。我们对这种情况不做深入讨论。 引理1：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，以及两个整数 $i,j$，其中 $1\\leq i,j\\leq n$。去掉 $\\mathbf{A}$ 的第 $i$ 行以及第 $j$ 列，得到一个 $n-1$ 阶子矩阵。记这个子矩阵的行列式为 $\\mathbf{M}_{ij}$。称为余子式。 引理2：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，代数余子式是余子式 $\\mathbf{M}_{ij}$ 与 $\\left ( -1 \\right )^{i+j}$ 的乘积，记作 $\\mathbf{C}_{ij}$。 例：对于矩阵 $\\begin{bmatrix} 1 \u0026 4 \u0026 7\\\\ 3 \u0026 0 \u0026 5\\\\ -1 \u0026 9 \u0026 11 \\end{bmatrix} $，计算它的代数余子式 $\\mathbf{C}_{23}$。 解：首先计算余子式 $\\mathbf{M}_{23}$，即原矩阵去掉第二行以及第三行所得的矩阵的行列式：$ \\begin{bmatrix} 1 \u0026 4 \u0026 \\bigcirc \\\\ \\bigcirc \u0026 \\bigcirc \u0026 \\bigcirc \\\\ -1 \u0026 9 \u0026 \\bigcirc \\end{bmatrix} $，即 $ \\begin{vmatrix} 1 \u0026 4\\\\ -1 \u0026 9 \\end{vmatrix} = \\left ( 9-\\left ( -4 \\right ) \\right )=13 $。因此 $ \\mathbf{C}_{23}=\\left ( -1 \\right )^{2+3}\\cdot M_{23}=-13$。 引理3：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，由代数余子式组成的新的矩阵，称为该矩阵的余子矩阵。记作 $\\mathbf{C}$。 引理4：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，定义它的转置矩阵 $\\mathbf{A^{T}}$。转置矩阵 $\\mathbf{A^{T}}$ 可以通过下列操作得到：把 $\\mathbf{A}$ 的横行写为 $\\mathbf{A^{T}}$ 的纵行，把 $\\mathbf{A}$ 的纵行写为 $\\mathbf{A^{T}}$ 的横行。 例：$ \\begin{bmatrix} 1 \u0026 2\\\\ 3 \u0026 4 \\end{bmatrix}^{T}=\\begin{bmatrix} 1 \u0026 3\\\\ 2 \u0026 4 \\end{bmatrix} $。 引理5：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，它的余子矩阵 $\\mathbf{C}$ 的转置矩阵称为矩阵 $\\mathbf{A}$ 的伴随矩阵。记作 $\\mathbf{A^{*}}=\\mathbf{C^{T}}$。 例：对于矩阵 $ \\mathbf{A}=\\begin{bmatrix} a \u0026 b\\\\ c \u0026 d \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。 解：$ \\mathbf{A^{*}}=\\begin{bmatrix} \\mathbf{C}_{11} \u0026 \\mathbf{C}_{12}\\\\ \\mathbf{C}_{21} \u0026 \\mathbf{C}_{22} \\end{bmatrix}^{T}=\\begin{bmatrix} \\mathbf{M}_{11} \u0026 -\\mathbf{M}_{12}\\\\ -\\mathbf{M}_{21} \u0026 \\mathbf{M}_{22} \\end{bmatrix}^{T}=\\begin{bmatrix} d \u0026 -c\\\\ -b \u0026 a \\end{bmatrix}^{T}=\\begin{bmatrix} d \u0026 -b\\\\ -c \u0026 a \\end{bmatrix}$。 例：对于矩阵$ \\mathbf{A}=\\begin{bmatrix} a_{11} \u0026 a_{12} \u0026 a_{13}\\\\ a_{21} \u0026 a_{22} \u0026 a_{23}\\\\ a_{31} \u0026 a_{32} \u0026 a_{33} \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。 解：$$\\begin{align*} \\mathbf{A^{*}} \u0026=\\begin{bmatrix} \\mathbf{C}_{11} \u0026 \\mathbf{C}_{12} \u0026 \\mathbf{C}_{13}\\\\ \\mathbf{C}_{21} \u0026 \\mathbf{C}_{22} \u0026 \\mathbf{C}_{23}\\\\ \\mathbf{C}_{31} \u0026 \\mathbf{C}_{32} \u0026 \\mathbf{C}_{33} \\end{bmatrix}^{T}\\\\ \u0026=\\begin{bmatrix} \\mathbf{M}_{11} \u0026 -\\mathbf{M}_{12} \u0026 \\mathbf{M}_{13}\\\\ -\\mathbf{M}_{21} \u0026 \\mathbf{M}_{22} \u0026 -\\mathbf{M}_{23}\\\\ \\mathbf{M}_{31} \u0026 -\\mathbf{M}_{32} \u0026 \\mathbf{M}_{33} \\end{bmatrix}^{T} \\\\ \u0026= \\begin{bmatrix} \\begin{vmatrix} a_{22} \u0026 a_{23}\\\\ a_{32} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{21} \u0026 a_{23}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{21} \u0026 a_{22}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix}\\\\ -\\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{32} \u0026 a_{33} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix}\\\\ \\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{22} \u0026 a_{23} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{21} \u0026 a_{23} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{21} \u0026 a_{22} \\end{vmatrix} \\end{bmatrix}^{T}\\\\ \u0026=\\begin{bmatrix} \\begin{vmatrix} a_{22} \u0026 a_{23}\\\\ a_{32} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{32} \u0026 a_{33}\\end{vmatrix} \u0026 \\begin{vmatrix} a_{12} \u0026 a_{13}\\\\ a_{22} \u0026 a_{23} \\end{vmatrix}\\\\ -\\begin{vmatrix} a_{21} \u0026 a_{23}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{31} \u0026 a_{33} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{13}\\\\ a_{21} \u0026 a_{23} \\end{vmatrix}\\\\ \\begin{vmatrix} a_{21} \u0026 a_{22}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix} \u0026 -\\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{31} \u0026 a_{32} \\end{vmatrix} \u0026 \\begin{vmatrix} a_{11} \u0026 a_{12}\\\\ a_{21} \u0026 a_{22} \\end{vmatrix} \\end{bmatrix} \\end{align*} $$ 其中 $\\begin{vmatrix} a_{im} \u0026 a_{in}\\\\ a_{jm} \u0026 a_{jn} \\end{vmatrix}=a_{im}\\cdot a_{jn}-a_{in}\\cdot a_{jm}$。 例：对于矩阵 $\\mathbf{A}=\\begin{bmatrix}-3 \u0026 2 \u0026 -5\\\\ -1 \u0026 0 \u0026 -2\\\\ 3 \u0026 -4 \u0026 1 \\end{bmatrix}$，求它的伴随矩阵 $\\mathbf{A^{*}}$。 解：通过计算不难得出 $\\mathbf{A^{*}}=\\begin{bmatrix} -8 \u0026 18 \u0026 -4\\\\ -5 \u0026 12 \u0026 -1\\\\ 4 \u0026 -6 \u0026 2 \\end{bmatrix}$。 引理6：对于一个 $n$ 阶矩阵 $\\mathbf{A}$，它的逆矩阵 $","date":"2013-04-29","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5%E5%9C%A8%E9%80%86%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["伴随矩阵"],"title":"浅谈伴随矩阵在逆矩阵求解中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5%E5%9C%A8%E9%80%86%E7%9F%A9%E9%98%B5%E6%B1%82%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"前几天在做化学竞赛初赛试题时遇到一道关于富勒烯衍生物的习题。大意是求 $\\mathrm{C_{50}Cl_{10}}$ 中单键的个数。但是去问浦建芳，她把施锦元叫了上来，大师兄便给我讲了欧拉公式。当天晚上没有完全弄清楚，回家谷歌以后，现在将内容整理如下。（以 $\\mathrm{C_{50}Cl_{10}}$ 为例） ","date":"2013-04-21","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["富勒烯"],"title":"浅谈欧拉公式在富勒烯及其衍生物中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"1、求 $\\mathrm{C_{50}Cl_{10}}$ 中五边形以及六边形的个数 这类题目可以应用欧拉公式，设 $\\mathrm{C_{50}Cl_{10}}$ 中存在 $x$ 个五边形及 $y$ 个六边形。由欧拉公式可以得到结果： $$ \\begin{cases} 50+x+y=\\frac{5x+6y}{2}+2 \\\\ 50\\times \\frac{3}{2}=\\frac{5x+6y}{2} \\end{cases}\\Rightarrow \\begin{cases}x=12 \\\\ y=15\\end{cases} $$ ","date":"2013-04-21","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:1:0","tags":["富勒烯"],"title":"浅谈欧拉公式在富勒烯及其衍生物中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["数学之美"],"content":"2、求 $\\mathrm{C_{50}Cl_{10}}$ 中单键的个数 对于这类题目，可以考虑这样的一个加成反应：$\\mathrm{C_{50}+5Cl_{2}} \\rightarrow \\mathrm{C_{50}Cl_{10}}$。这样的话，我们可以首先考虑 $\\mathrm{C_{50}}$，根据（1）中方法求出其中五边形以及六边形的个数。从而得到一共有 75 根碳碳键。 考虑到 $\\mathrm{C_{50}}$ 中每个碳原子边上有两个碳碳单键一根碳碳双键，即可得到碳碳单键数目是碳碳双键数目的两倍。这样可以确定 $\\mathrm{C_{50}}$ 中有 50 根碳碳单键，25 根碳碳双键。 接着考虑加成的过程，在上述加成反应的过程中，断开了 5 根碳碳双键，这样就新形成了 5 根碳碳单键，从而得到 $\\mathrm{C_{50}Cl_{10}}$ 中共有碳碳单键 55 根。 ","date":"2013-04-21","objectID":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/:2:0","tags":["富勒烯"],"title":"浅谈欧拉公式在富勒烯及其衍生物中的应用","uri":"/2013/04/%E6%B5%85%E8%B0%88%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E5%9C%A8%E5%AF%8C%E5%8B%92%E7%83%AF%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%89%A9%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["浮生杂记"],"content":"好久没更新博客了。英语课上把博客地址写在了黑板上，不知道郭华老师和周红娟老师会不会光临这么一个小角落。第一反应是博客的访问量可能会增加，接着就想到：如果周红娟老师看到我写的这些文章，岂不是贻笑大方。 先来说说卖泡面的事情吧。经过一个寒假的考虑和筹划。准备这个学期搞得稍微正规点。所以在开学的时候准备发行债券，无奈去年出现一例质量问题，所以没人敢买债券。既然这条融资途径无效，那么只能自己先垫出一部分。于是乎，昨天又去进货了，而且列了进货清单。还得感谢 Microsoft OneNote——这款平时用来记笔记的软件，在这种情况下也可以用来记录销售情况。 前段时间给自己的小卖部起了个名字——斯凯泰。开发了一个网上订购系统，主要解决有的时候同学来买泡面，却发现水不够了，或者卖完了。通过网上订购系统，可以提前预订，这样就可以预留出订购者所需要的数目。网站做的很简单，只是实现了基本功能。 对于卖泡面，完全没有什么资本家的意思。只是为了娱乐一番，同时积累积累经验。所以这学期价格会有所下调。 时间过得好快，转眼一年又过去了。昨天晚上黄旸洋打来电话，聊了好久。彼此好久没联系了，但还是感觉那么亲近，或许这就是王勃所说的“海内存知己，天涯若比邻。”吧。聊的内容自然无外乎那几样，只是感觉大家似乎变了，似乎又没变。他还提起了很久以前的一个项目，重新做一下初中的毕业视频。他说，为了这个，他在学 PS, PR, AE。一直有这么一个想法，只是心有余而力不足。现在总算空下来了，也该把这个未完成的项目继续下去。 通知： 烦请张家港市常青藤实验中学 2011 级初三（3）班的同学将你们对于接下来我和黄旸洋合作的这一毕业视频提供可行性建议以及必要的素材。建议包括整体构思，画面效果等；素材包括图片，声音，文字，视频等。一切内容请发到邮箱：admin@ivy-end.com，发送时请注明姓名。 小高考结束以后，的确像玉米他们所说，很空。数学，化学，生物三门竞赛的轮番轰炸让人喘不过气来。对于生物竞赛，没有资料，也未曾深入了解，所以只能作罢。对于数学和化学，倒是有希望出线。但是一节晚自习只能做两道不等式或者 15 道化学选择题。这的确让人感到无奈。 化学很多内容没教过，工艺流程完全不会。而且化学反应平衡和离子反应都没讲，很多以前学过的都忘记了。不过想想也对，如果这么简单就让我们过了初赛，那岂不是太看不起化学竞赛了。只是一点想不通，为什么数理化生初赛学校都会派出分母，而我们信息学却完全没有。而且我们的试卷费只要 10 元。 这段比较空闲的时间应该规划一下，好好利用。语文上的古诗，的确挺诗情画意的，但是我们却始终无法达到唐人的那种境界，只能以一种仰望的姿态去欣赏。首先当然是数学竞赛，好好准备一下吧。其次，最近冒出一个很奇怪的想法，想系统的看一下关于中医方面的书。或许只是想法吧。 宿舍又扣分了，作为室长的我免不了背黑锅。权利和义务是相统一的嘛。 古人云：一日三省吾身。最近又冒出一个想法，还是关于理性和感性的问题。或许大多数在不涉及原则问题的情况下还是感性比理性更为好吧。很多事情没必要寻根问底。以前可能太过于理性了吧。有个称呼叫死理性派。这样不好。 我也不知道自己写了些什么，感觉最近一段时间，想说的内容很多，却发现写不下来什么了。 好吧，先到这。 ","date":"2013-04-04","objectID":"/2013/04/%E6%9D%82%E8%AE%B020130404/:0:0","tags":["高中生活"],"title":"杂记（20130404）","uri":"/2013/04/%E6%9D%82%E8%AE%B020130404/"},{"categories":["浮生杂记"],"content":"高中的一个重要的转折点——小高考，就这样过去了。写下一篇日志来记录一下小高考复习期间的一些感受和想法。打点计时器真可谓是人类一项伟大的发明。 这段时间，思考了很多，体会了很多，感悟了很多。且听我慢慢道来。 江畔何人初见月？江月何年初照人？ 人生代代无穷已，江月年年只相似。 短短的四句诗，却透出了人生渺小宇宙无限的感慨。我们终究是很渺小的，微不足道，试问千万年后，我们又在哪里呢？生命是那么渺小，于己，对于这个世界，我们有多大的意义呢？或许最大的意义就是不要让生命留下遗憾吧。于他，我们又为何要让俗世凡尘的喧杂打搅了平静的内心呢。或许庄子是正确的，我们的确应该逍遥游。感觉很多事情是没有结果的，很多事情是徒劳无功的。是我超脱了，还是我才是真正蒙在鼓里的人。或许我们都只是上帝的玩偶，不幸的是，上帝喜欢掷骰子。突然想起一首诗： 虞美人·听雨 —宋·蒋捷 少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低断雁叫西风。 而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前点滴到天明。 人生无常，总有许多美好的事物，在你还没来得及珍惜的时候悄然逝去，不论是亲人，信念，抑或其他。而对于我们，所能做的，也唯有好好珍惜每一天吧。一直很欣赏乔布斯的一句话“记住你即将死去。”，但是我始终无法做到。或许是因为他的经历使然吧。 对于人生的思考大概就是这样了，接下里就是对马克思主义哲学的怀疑了。 首先，根据“矛盾是普遍的。我们要用一分为二的观点看问题。”那么，马克思主义哲学是否具有另一面呢。这不禁引起了我的思考。后来，对这一原理越来越感到不可信，事事有矛盾，时时有矛盾。而且还要求我们用联系，发展，全面的观点看问题，试问，这样一来，岂不是陷入了相对主义的泥潭？再者，马克思主义哲学中的辩证法是从黑格尔那里继承下来的。大家都知道，黑格尔是近代西方唯心主义的集大成者。而对于这一继承，居然只是简简单单的说“马克思主义哲学剔除了黑格尔辩证法中唯心主义的成分”，这显然是不现实的。所以说辩证法有唯心主义的漏洞，这也就很容易解释为什么它会陷入相对主义了。 对于世界观这一方面，我比较倾向于老子。对于庄子也有些可借鉴之处。 以上便是我最近思想方面的记录了。下面主要来谈谈生活和学习方面的吧。 最让我感到吃惊的是历史成绩吧，从一模 53 到二模 77 再到三模 85 。该怎么评价这件事情呢，该说我有潜力呢，还是该说我以前根本不认真呢。刚开始觉得半个月背书一定很无趣，没想到还真挺充实的。因为一根弦紧绷着，就没时间去管别的了。 考试前一天，感冒了，到了晚上发烧。幸好及时吃了退烧药。虽然考试的时候没有头痛，但还是感到很困。不过到了下午考生物的时候已经基本清醒了，至于政治，其实没什么区别，因为用不着动脑子，只要把背的搬上去。总之，小高考已经考完了，对于过程，无怨无悔。至于结果怎么样，还是得看运气。 越来越有种感觉，考试结果，和水平没有太大的关系，最主要的是运气。就好比上次有一场比赛，一位神犇辛辛苦苦花了一个多小时写了几百行代码，0 分；一位蒟蒻，几分钟写了个随机数，100 分。这就是运气。我们无法把握，因为是上帝在掷骰子。人生的戏剧性就在于，你可以努力的很多很多，虽然它占据了 99% 的比例，但取决定作用的 1% 却在上帝手中。就好比爱迪生的名言“成功是 99% 的勤奋加上 1% 的天才，但往往那 1% 是最重要的”。 以后我再也不用知道如何促进我国国民经济又好又快发展了 以后我再也不用知道如何正确看待反经济全球化了 以后我再也不用知道如何防治我国西北荒漠化了 以后我再也不用知道生一个即患白化又患色盲的孩子的概率了 这究竟是福是祸，以后我们就再也见不到小四门老师了。马静华，翟玉明，盛费兵，张书玉。学了那么多仅仅是为了一场考试？突然想起中考，是淡淡的忧伤吗？ 不管怎么说吧，既然考完了，也就过去了。感觉一个人突然松了下来。又发现还有很多事情等着我去处理，不管是生活，学习，竞赛。是该好好缕缕了。接下来应该要开始准备自招吧。也不知道玉米考的咋样，到现在也不透个风声。为了吸取了玉米来不及准备的经验，所以过一段时间就开始吧。至于竞赛，张兴让我给高一竞赛的上课。所以还要做课件。讲课对于自己巩固所学，的确很有帮助。主要讲数据结构。 好了，就这样吧。 接下来的道路会更崎岖。 ","date":"2013-03-17","objectID":"/2013/03/%E4%B8%BA%E5%B0%8F%E9%AB%98%E8%80%83%E6%89%93%E4%B8%AA%E7%82%B9/:0:0","tags":["高中生活"],"title":"为小高考打个点","uri":"/2013/03/%E4%B8%BA%E5%B0%8F%E9%AB%98%E8%80%83%E6%89%93%E4%B8%AA%E7%82%B9/"},{"categories":["浮生杂记"],"content":"先来谈谈最近很火的《新笑傲江湖》吧。抱着对金庸小说《笑傲江湖》的喜爱，尝试得看了第一集，细细的看了第二集，忍耐的看了第三集，然后，就没有然后了。 首先引用一些外界评论吧： 看于正才知张纪中厚道 大家都知道，张纪中拍摄的《新西游记》对原著改变有点大，所以放映出来大家反应很强烈。当时也尝试性得看了几集《新西游记》，还可以接受一部分。但是《新笑傲江湖》简直无法直视。没看到几个原著中的剧情。还有人物塑造方面，就拿令狐冲来说吧，毫无洒脱、侠义之气，说文明些，完全就是一个嬉皮士。当然这是由于我们和编剧的世界观差异导致的。最主要的问题是色彩绚丽，华而不实，毫无一点武侠的痕迹。而且很多台词不符合客观规律。不论是改编的内容还是剧中传递出来的一种精神，都与原著差距甚远。可能编剧只是考虑到了部分受众的喜好以及经济利益吧。 再来看看很久以前金庸接受南方周末采访的记录，虽然是家比较早，但却可以看出金老先生对改编电视剧的态度： 南方周末：您的作品大部分被改成了电视剧和电影，早期的香港版追求娱乐性，台湾版追求煽情，大陆版看重的是小说的道德意识和精神高度，正剧色彩比较浓，您喜欢哪一种风格的改编？ 金庸：小说是当文学作品来看的，人家都说文学作品有真、善、美的追求，在作品里我只追求美的范畴，跟真、善没有关系，把我所喜好的所见的美好融到作品里面去。两岸三地拍电视剧我不关心，他们追求什么样的风格，和他们的市场有关，跟我没有关系，人家喜欢拍就拍，我只关注电视剧是否忠实于小说原著，这一点我比较在乎。 再引用金庸以前接受采访时说过的一句话： 那些作品都好比是我的儿子，而改编就好比他要出远门，把儿子托付给别人照顾，结果回家时发现儿子被打得面目全非。 对于一部电视剧的看法与个人世界观以及以往接触的人、事、物都有关系，所以对于《新笑傲江湖》，虽然不喜欢看，但它总有存在的意义，或积极，或消极。如若想真正品味《笑傲江湖》，还是推荐看原著。至于这本书，我的感想很多，有很多细枝末节的感触，大体就像《笑傲江湖李亚鹏版》的插曲《天地作合》所描述的那样吧——凌万物而超脱。 扯远了。最近在思考一些问题，好像有点宽泛而且不切实际，却着实让自己感到迷茫。算是哲学范畴的吧——我们如何才能在这个世界上活得更有意义？ 只有献身社会，才能找出那实际上最短暂而有风险的生命的意义。——爱因斯坦 人的意义在于为社会创造出价值，从而以人类的进步推动社会的进步。——马克思 生命是有限的，但为人民服务是无限的，我要把有限的生命投入到无限的为人民服务之中去。——雷锋 类似的话语还有很多，那么当时间以万亿年为尺度向前行进，那么现在的人类社会又会在哪里呢？我们对社会的贡献、付出有在哪里呢？难道我们就应该享受生活，放任自流？整日这样的生活未免像一潭死水，太无趣。那我们到底在追求什么呢？或许这就是短暂生命和永恒宇宙的矛盾吧。我们该怎么做呢，思前想后，还是感到活在当下，不留遗憾最为实际。至于怎么活，Steven Jobs 的观点十分值得借鉴： Follow your heart. Stay hungry, stay foolish. 或许思考这些没有太多的现实意义，但的确可以让自己找到一点方向。每天，太阳还是依旧升起，一切还是依旧，所以也就没必要想那么多了。接着再来说一些感悟吧。假期不知不觉就过去了，曾经在《呓语（一）：无题》中引用过一句话： 而放假绝不是最终的出路，因为我们并没有假期，所谓的假期也只是自我欺骗。 当时仅仅觉得这句话很有意味，这几天却突然领悟了。人生就像一场旅行，我们需要不断拼搏，所谓的假期，只是另外一种形式的奋斗罢了。这些动力，并不仅仅是为了 4A。 再说说前几天修改的网站副标题——“上善若水，大道至简。”。第二句很容易理解，主要谈谈第一句： 上善若水。水善利万物而不争，处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，政善治，事善能，动善时。夫唯不争，故无尤。——老子《道德经》 翻译想必是没有必要了。其中几句值得斟酌，“处众人之所恶，故几于道”。是因为“处众人之所恶”导致了“故几于道”还是“故几于道”引起了“处众人之所恶”？个人认为可能是后者，在当代社会中，毕竟糊涂人远多于明白人，而明白人中又有糊涂人。所以说真正的明白人才可以达到“故几于道”的境界。但这样又产生了一个问题，我们首先参考一下马克思主义哲学的相关内容： 物质决定意识，意识对物质具有反作用。 价值观作为一种社会意识，对社会存在具有重大的反作用，对人们的行为具有重要的驱动、制约和导向作用。 价值观对人们认识世界和改造世界的活动具有重要的导向作用。 价值观对人生道路的选择具有重要的导向作用。 有了这些内容作为指导，我们不难得出，当那些真正的明白人到达一定境界时，所作所为就会与常人不同。而这时候人们却常常鄙夷的称他们清高。岂不冤哉？（排除某些故意装作清高之人，此类人无法称之为明白人）这类问题在生活中经常出现，两个世界观不同的人争论问题是毫无意义的。世界观在不违背到的前提下本没有对错。面对这些，还是那句老话： 穷则独善其身，达则兼济天下。 有个比较远的话题吧——人生漫漫长路，会遇到很多人，很多事，我们怎么面对现在呢？欢迎来这里讨论。 扯了好多，这也许就是我目前的思想状态吧。 最后推荐几个网站吧： 果壳网·科技真有意思 SegmentFault Stack Overflow ","date":"2013-02-21","objectID":"/2013/02/%E6%9D%82%E8%AE%B020130221/:0:0","tags":["高中生活"],"title":"杂记（20130221）","uri":"/2013/02/%E6%9D%82%E8%AE%B020130221/"},{"categories":["码志"],"content":"由于各种各样的原因，之前很多次向 Linux 迁移的计划未能实现。主要是因为有些程序只能在 Windows 上运行，比如我们最常用的 QQ。此次迁移的主要原因和以往大致相同： Windows 系列的系统臃肿而且不实用，很多东西华而不实。 Windows 系列的系统及其程序属于商业行为，为了追求自由、共享和开源。 我选择的是 Ubuntu 12.04 LTS，主要还是看中了 LTS（Long Term Support），这样可以获取更长时间的技术支持。 安装过程就略过不提了。我采用的是 USB 安装，毕竟刻录光盘很奢侈。将移动硬盘分出一个 4GB 的分区，然后用 Universal USB Installer 写了启动引导，接下去的过程就很简单了，因为都是 GUI 界面，相对容易些。 装完系统就是折腾了，Linux 就是用来折腾的。下面慢慢介绍。 ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:0:0","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"换上 Gnome3 由于 Ubuntu 自带的 Unity 界面非常不稳定，主要是个人不喜欢那种风格。所以毅然决然的换了 Gnome3。由于 Ubuntu 早已将其加入到了软件源中，所以直接 apt-get 就可以了。 sudo apt-get install gnome-shell 安装结束以后就可以使用了。可能是个人癖好吧，我还是把 Unity 删了，命令如下： sudo apt-get --auto-remove purge unity sudo apt-get --auto-remove purge unity-commonp sudo apt-get --auto-remove purge unity-lens* sudo apt-get --auto-remove purge unity-services sudo apt-get --auto-remove purge unity-asset-pool 切记不可使用这条命令： sudo apt-get --auto-remove purge unity* 因为把所有关于 Unity 的东西都删除以后会无法进入系统。这样就基本完成了桌面的更换，为了操作方便，我们还需安装一个软件来配置 Gnome3 桌面： sudo apt-get install gnome-tweak-tool ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:1:0","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"软件整理 这个方面主要包括卸载一些不必要的软件以及安装一些必要的软件。卸载就不多说了，这是个智者见智，仁者见仁的事情。主要将一下软件安装。 浏览器使用谷歌的 Chromium，输入法也使用了谷歌的 googlepinyin。个人很喜欢谷歌，简洁而且功能强大。 接下去主要讲解一下在 Ubuntu 上使用 QQ 的方法——不用整天网页挂 WebQQ，不用 Wine。 众所周知，在 Linux 下有一款支持多种即时通讯账户的软件叫做——Pidgin，默认不支持 QQ，我们只需要安装一个插件就行了。 ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:0","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"Step 1：安装 Pidgin sudo apt-get install pidgin ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:1","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"Step 2：安装插件 pidgin-lwqq sudo add-apt-repository ppa:lainme/pidgin-lwqq sudo apt-get update sudo apt-get install libpurple0 pidgin-lwqq ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:2","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["码志"],"content":"Step 3：Enjoy it! 不得不说，Pidgin 真是解决了一个大难题，因为很多同学都在用 QQ，所以不用 QQ 也很难取得联系。有了这款软件就方便多了。接下来是下载软件，我选择了 aria2。一来是终端模式的，看起来舒服；二来支持断点续传；这两样加起来也足够了。而且速度也很快。安装方法： sudo apt-get aria2 使用方法： #一般使用 aria2c #分段下载 为分段数目，取值介于1~5之间 aria2c -s #断点续传 aria2c -c #下载BitTorrent文件 aria2c -o 至于编程，已经做好放弃 VS 之类的准备了，转战 QT。主要方面应该是跨平台应用和网页开发吧。 ","date":"2013-02-18","objectID":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/:2:3","tags":["Linux"],"title":"Linux 迁移记（一）","uri":"/2013/02/linux-%E8%BF%81%E7%A7%BB%E8%AE%B0%E4%B8%80/"},{"categories":["余音绕梁"],"content":"歌词如下： 莽莽苍苍兮群山巍峨 日月光照兮纷纭错落 丝竹共振兮执节者歌 行云流水兮用心无多 求大道以弭兵兮凌万物而超脱 觅知音固难得兮唯天地与作合 求大道以弭兵兮凌万物而超脱 觅知音固难得兮唯天地与作合 这首歌是《笑傲江湖》的一首插曲，它与令狐冲的一系列行为都非常的映衬，真实而准确地传递出了这部书的灵魂。 ","date":"2013-02-11","objectID":"/2013/02/%E5%A4%A9%E5%9C%B0%E4%BD%9C%E5%90%88/:0:0","tags":null,"title":"天地作合","uri":"/2013/02/%E5%A4%A9%E5%9C%B0%E4%BD%9C%E5%90%88/"},{"categories":["浮生杂记"],"content":"其实这应该是很早以前写的，但是一直没时间静下来。 NOIP 2012 复赛备战期间，让我体会到了什么是真正的刷题，这远比期末每天好几张的试卷来的恐怖。刷题，不仅仅是整日做题目，这只是基础。重要的是对于每道做过的题目做完后探寻更简便的方法来解决它。而且刷题注重的是效率，一道题刷过就必须 Accepted。任何不起眼的错误导致的 Wrong Answer 都必须避免。回想起那段刷题时光，现在的状态与那时相比，恐怕相差甚远。 对于作业，还有些话要讲，首先引用一位神犇的分析： 做作业的悲剧性在于，我们用有限的生命，去完成无限的作业。更可悲的是，速度或快或慢都无济于事——或因一日的拖延便往后日日无法完成当日作业，抑或是日日赶超但仍需要完成作业。悲剧的根源在于，以我们的微薄之力，一日完成的作业量不变，但所发作业却以亘古不变的步伐一日一日向前迈进。我们终究无法完成所有作业，终究会明白，最好不过是今日完成今日的作业，而所谓「急功近利」地积极完成明日作业，在作业们眼中看来，不过是可笑的雕虫小技。 而放假绝不是最终的出路，因为我们并没有假期，所谓的假期也只是自我欺骗。 但终有一日，什么都不会有意义，这也正是我们所恐惧地期盼之日。 因此，每次发完作业，总是没日没夜做作业的，不能称之为刷题，而只能说是在运行程序罢了，因为他们沿着作业预算好的轨迹低头拉车，却从未抬头看天。仔细想来，低头拉车，抬头看天，本是一对客观矛盾。根据马克思主义哲学的科学指导，不难的出，在不同条件下，矛盾主次双方可以相互转化。我们不能一味低头拉车，这样只能成为程序，也不能一味抬头看天，这样只是好高骛远。由此得出，在适当的条件下，做适当的转化是非常有必要的。所谓“独阴不生，独阳不长”大概也可以从这个角度来理解吧。 所谓假期，只是不受学校朝六晚十的时间约束，可以自由安排时间罢了。除去此项，或许放假与不放假也没头太大区别吧。但是，这项确是非常重要的。当然，自由安排也是“仁者见仁，智者见智”。自从两年前和游戏断绝以来，唯一可以打发时间的事情便成了阅读。这两年也发现，阅读，确实给了我们一片非常广阔的天地。一个午后，一本书，一杯水，就可以打发一个下午。在诸多类别的书籍中，个人尤爱哲学、历史。哲学的书总是给人对生命的思索，不停的回答着同样的问题：人生的意义何在？史书则可以不断给人以思索，唐太宗说到“以史为镜可以知兴替”。在 21 世纪的今天，我们虽然不用经历古代的战火纷飞，但是历史仍然给我们以启发，教给我们以做人的道理和是非的标准。文学类的文本个人觉得更多的是呼唤我们对于周围生活的关注。这些不能也不该成为炫耀的资本，而应该作为一种个人内在的修养积淀下来。看着别人大谈《孙子兵法》，批判老庄，笑而不语。一来他们在意的不是你说的道理，而是你不同意他们的观点，二来既然他们得出这种观点，那么以他们目前的阅读积累应该无法理解你的看法。 在《苏东坡传》上看到林语堂老先生的一个观点，这里只能大致叙述一下了。世界上有两种人，一种市侩小人，整日说结论性话语；一种正人君子，会先分析问题，再给出参考性方案。但是现在社会太“急”，人们只在乎结果，而完全不注意过程，也就导致了小人横行，君子遭贬。这也是一件好事，因为小人，君子自此各司其职，都不违背各自的心愿。小人喜欢势利，居庙堂之高；君子独善其身，处江湖之远。结果只可能是朝政败坏，改朝换代。把这个观点运用到当代社会，或许大家也就明白一二了。无奈的是国民就是喜欢结果，就是喜欢听结论性话语。 再来说说“友谊”吧。关于这个话题，仅仅是个人看法，不全面，因为无法将各个方面详尽表述出来。 以前还是挺相信友情的，当然，也不是说现在不相信了。也交了很多朋友。当时大家都挺聊得来的，一些小事也可以相信的。但是，似乎忽视了中国古代劳动人民的思想成果“路遥知马力，日久见人心”、“患难见真情”。很多很多所谓的朋友，到后来，在你最关键的时刻，过河拆桥算是留情面了，有时会突然在背后捅你一刀。这又可以分为两种，一种是十分明显的，真刀实干。第二种是放冷箭，所谓“明枪易躲，暗箭难防”。这个从很多武侠小说中也可以得到证明，就比如《笑傲江湖》吧，定逸师太被岳不群杀死时，说的是“是你？”，显然，她也是被暗算了。如果她不认识凶手，应该说的是“你是？”。这样也就造成了许许多多的逢场作戏。对于此类问题，还是玉米的方法比较有效“你若对我报以真诚的微笑，我也回应你真诚的微笑；你若对我报以虚假的微笑，我也回应你真诚的微笑。”，有时候，心胸还是应该开阔，所谓“退一步海阔天空”，这些事情只不过给了我们一个看清事实真相的途径罢了。“害人之心不可有，防人之心不可无”。 很多所谓“朋友”都只是逢场作戏罢了。冲突就发生在做戏的一方被看穿且毫不留情面的揭露出来，此人一定暴跳如雷，而且到处宣扬你的种种恶迹，毕竟“欲加之罪，何患无辞”。对于这些，笑笑罢了，“笑世间可笑之人，笑世间可笑之事”。因为任何一个人的评价，都必须由后世之人来评定，所有的当代人都只是当局者迷，当然也不排除自身个体。 友情，还有一种同化功能，所谓“近朱者赤，近墨者黑”。一个个原本优秀的人因为善恶不分，交友不善，荒废了一生，这种事例实在多见。所以，择友时有一点很重要：慎重！ 好吧，到这里，呓语显现出来了，其实我也没看懂自己到底写了些什么。 最后，还是想提一下张贤明，这个已经远离我们一年多的名字。 以前想起他，想到的是他教育我们的各种阴损招数，以及他惩罚我们的种种办法。后来想起他，想到的是和他在一起的快乐时光，每节语文课，班会课。如今想起他，想到的是他说的那些话，突然感觉很有道理，很值得揣摩，推敲。 印象最深的，莫过于“输不丢人，怕才丢人。”这句话，每每想到，都会想起 Steven Jobs 的名言“听从你内心的声音”，或许很多事情前思后想，只会是顾此失彼。看似不明智的奋力一搏，可能收获意想不到的结果。 就到这吧。 ","date":"2013-02-04","objectID":"/2013/02/%E5%91%93%E8%AF%AD%E4%B8%80%E6%97%A0%E9%A2%98/:0:0","tags":["计划"],"title":"呓语（一）：无题","uri":"/2013/02/%E5%91%93%E8%AF%AD%E4%B8%80%E6%97%A0%E9%A2%98/"},{"categories":["浮生杂记"],"content":"迷迷糊糊，期末复习，小高考补课就这么过去了。不得不提一下数学，没想到啊。就这样，迎来了这一不寻常的寒假。最后一天突然下起了雨，似乎把一切繁杂和浮躁都冲洗而去。 仔细算来，从今天到开学前一共还有 23 天。时间不容我们挥霍。像以往一样制定一个计划吧（当然不是学校里那种按天数来划的），以前总是写在纸上，这次就直接发到博客上吧。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:0:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"寒假作业 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"语文 练字（黑色钢笔）。 专题摘抄 3000 字，并写一篇书评。 预习《唐诗宋词选读》，背诵 14 篇，熟读 2 篇。 关注时事，写一篇社会评论。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:1","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"数学 复习必修 2、选修 2-1、选修 2-2。 寒假作业（好像只要做几张综合卷）。 综合练习。 附加题练习。 自选一本与本学期有关试题。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:2","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"英语 暂无。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:3","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"物理 暂无。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:4","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"化学 复习《有机化学基础》、《物质结构与性质》。 预习《化学反应原理》。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:5","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"小四门（政、史、地、生） 背诵。 完成考点等练习。 由于开学后离学业水平测试只有十多天，所以小四门成为了寒假的主要矛盾。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:1:6","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"学习计划 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"语文 按要求完成作业。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:1","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"数学 按要求完成作业。 加强运算能力。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:2","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"英语 作业日：一篇阅读、一篇完形、若干单选。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:3","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"物理 无。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:4","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"化学 预习《化学反应原理》。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:5","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"小四门（政、史、地、生） 作业日：认真背诵，完成练习。 争取小四门 4A 吧。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:2:6","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"阅读计划 史记（中华书局 1959 年版） 数学（甲种本） 代数 第一册 电子技术基础 准备开始看二十四史，不知道能不能坚持下去。《史记》作为二十四史之首，而且和上学期教学内容相近，所以先看。甲种本的数学，纯粹是兴趣，也算是为了自招吧。电子技术基础，总是在电脑上写程序也挺没意思的，所以要和单片机结合起来。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:3:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"OI 计划 怎么说了，没什么动力了。没保送，去年拿了个全国复赛二等奖，自招资格是有了。所以 OI 也就放下来了。高三的话，看运气吧。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:4:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"EE 计划 制作 AM/FM 调频收音机。 DIY 太阳能便携式充电器。 制作摄像小车。 第三项可能来不及。 ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:5:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["浮生杂记"],"content":"杂项 坚持每周更新 blog。 其他的想到再说吧。 寒假就这么开始了…… ","date":"2013-02-02","objectID":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/:6:0","tags":["计划"],"title":"寒假，来了！","uri":"/2013/02/%E5%AF%92%E5%81%87%E6%9D%A5%E4%BA%86/"},{"categories":["鉴于往事"],"content":"本文主要整理了《中国通史：诸葛亮治蜀》的解说稿。 东汉末年，各个地方势力，各据一方，天下大乱。公元 208 年，在曹操百万大军的高压下，刘备派诸葛亮出使山东，与孙权结盟。孙刘联军在赤壁大破曹军，魏、蜀、吴三分天下之势初步形成。公元 219 年，刘备北伐，孙权偷袭荆州，杀死关羽，刘备北伐失败。公元 221 年，刘备亲率数万大军讨伐孙权，双方在夷陵相持。第二年，刘备被孙权的军队连连击败。夷陵之战惨败，刘备忧愤成疾。弥留之际，刘备将儿子刘禅，托付给诸葛亮，随即病逝。后主刘禅，封诸葛亮为武乡侯，领益州牧1，总理朝政。自此，举国重任，落在诸葛亮一人肩上。 这是一条使命之船，船上的主人名叫邓芝2，在蜀汉政权中担任尚书。蜀汉建兴元年十月，也就是夷陵之战的第二年，邓芝受诸葛亮的委派，前往东吴。孙权背盟，偷袭荆州，按照一般的情理，蜀汉与东吴从此应该结下不共戴天的深仇大恨。然而，这时的诸葛亮，却做出了一个惊人的决策——再次与东吴结盟。 赞曰：国家利益是国际关系的决定因素，只有永远的利益。面对强大的曹魏政权，蜀汉也只有和东吴结盟才得存活下去。 这个时候的东吴政权，跟曹魏政权仍旧藕断丝连，是否接见邓芝，孙权心中犹豫不决。邓芝便给孙权写了封信，信中说道，自己今天来到这里，不仅是为了蜀汉的利益，也是为了东吴的利益。孙权读到这句话受到触动，决定接见邓芝。见面后，邓芝依照诸葛亮的嘱托，详细分析了当前的形势，阐明了吴与蜀唇亡齿寒的道理。很快，孙权跟曹魏断绝了藩属3关系，转而与蜀汉结为盟友。 沈伯俊：蜀汉的开国君主，刘备去世以后，诸葛亮就面临着如何治理蜀汉的艰巨任务。经过荆州之失，夷陵之败，蜀汉的疆域，只剩下了一个益州。精兵良将折损过半，开国元勋逐步凋零，吴蜀同盟不复存在，就像诸葛亮后来在《出师表》里边讲的，天下三分，益州疲弊，此诚危急存亡之秋也。 然而，就在所有人以为，蜀汉和东吴从此将和平相处，再无战事的时候，一个震惊天下的消息突然从东吴传来。这一次，诸葛亮的外交策略即将遭到前所未有的挑战。公元 229 年，孙权经过多年的犹豫后决定称帝。为了让自己这个皇帝能够得到蜀汉的认可，孙权决定先将此事通报蜀汉。消息传到蜀汉，一石激起千层浪，朝中群臣一片愤慨。自古天无二日，国无二主，只有蜀汉才是天下正统。曹贼窃国，必须诛而伐之。现在，孙权也要称帝，更是大逆不道，蜀汉应与之绝交，并且立即出兵讨伐。 赞曰：孙权这一招妙极。此这个时候提出称帝，对于蜀汉来说从原则上是绝对不能接受的，但是又不得不接受。毕竟在这种时刻，生存才是蜀汉的主要矛盾。而孙权正好抓住了这一点。 孙权称帝，到底应该如何应对，对于诸葛亮来说，这是一个两难的决定。如果要承认孙权这个皇帝，等于损害了蜀汉自身的正统性与合法性。如果不接受，那么两国将重新回到敌对状态，之前的努力将付之东流。然而，对于现在的蜀汉来说，根本无力承受任何一场大规模的军事行动。这是诸葛亮总理朝政以来，面临的最大的一次考验。 楼劲：在一个通达的政治家看起来，你的意识形态立场，是要服从于你的现实利益的立场。这个时候他是为自我的生存着想。你要生存下去，你必须跟孙权、必须跟东吴政权保持一种联手的关系。否则你无法抗住北方的压力，因为北方现在越来越强大。 愤怒的群臣终于被诸葛亮说服了。随后诸葛亮派出使臣，祝贺孙权称帝。孙权闻讯大喜，随即决定于蜀汉升坛歃盟，对天发誓，戮力同心，同讨魏贼。这样的结果，是蜀汉和东吴都很渴求的，而对于蜀汉来说，却显得更加重要。因为，当外部环境基本平稳之后，诸葛亮终于可以腾出手来，去解决一个令蜀汉头疼多年的问题，那就是，南中叛乱。 这里是云南省西盟佤族自治县。这里居住着一支中国西南最古老的少数民族之一——佤族。每逢重大的民族节日，佤族人都会敲起木鼓，挥舞着战刀，跳着世代传承下来的舞蹈，以此纪念祖先的勇敢和不屈不挠的战斗精神。三国时期，整个云南、贵州和四川西南部都隶属于蜀汉政权，统称南中。南中地区世代居住着众多少数民族。东汉末年，腐败政权对南中地区搜刮无度，很多民众不断反抗，一些豪强趁机煽动叛乱，企图割据称雄。刘备当政时形势本有所好转，但在他病逝之后，一些豪强再次趁机叛乱。 赞曰：典型的官逼民反。而且中国民众普遍思想意识落后，很容易被一些有非分之想的人利用，造反也就自然了。 北有曹魏政权重压，南有豪强叛乱，南中之乱不平，蜀汉将两面受敌。诸葛亮决定亲自征讨南方。蜀汉建兴三年春三月，几万蜀兵，在诸葛亮的亲自率领下，浩浩荡荡地向南中地区进发。然而，要想征服这片广袤的荒蛮之地绝非易事。广大南中地区山高林密，危险重重，瘴疠之乡，到处都有充满敌意的眼睛。佤族人历来骁勇善战，每一次战胜敌人，他们都会用特别的仪式进行庆祝。然而，当诸葛亮进入南中之后，向来以凶悍著称的叛乱部队，却没有得到庆祝胜利的机会。他们在训练有素的蜀汉正规军面前，一触即溃，蜀汉大军很快向叛军首领孟获展开攻击，并最终将孟获擒住。让孟获想不到的是，诸葛亮虽然擒住了他，却并没有伤害他的意思，而是请他观看汉军阵营，孟获不以为然，对诸葛亮说，如果能放他回去再决一战，他一定可以打败诸葛亮。诸葛亮哈哈一笑，将孟获放走，约他择日再战。其实，在诸葛亮的心中，平定叛乱，绝不是依靠武力杀伐这么简单。对于南中，诸葛亮有着一个更为长远的打算。史书记载，诸葛亮七擒孟获，七纵孟获，最后，孟获输得心服口服，诸葛亮还要放他，孟获再也不肯回去了，说：公，天威也，南人不复反矣。 赞曰：得民心者得天下。 沈伯俊：诸葛亮在军事上发展非常顺利，因为他赢得了民心。得到了少数（民）族民众的欢迎，史书记载，建兴三年春南征，其秋悉平。到了秋天就全部平定了。 收服孟获之后，南中各个部族纷纷归附。佤族人说，他们的祖先还与诸葛亮结下誓盟，生生世世镇守边关，永不叛乱。不过，结束叛乱只是平定南中的第一步。接下来，诸葛亮要真正开始实施自己对于南中的计划了。 这里是云南省西盟佤族自治县爬街村。 1970 年代，尼桑老人，作为西盟民族工作队队长，被派到这里，帮助村民们发展农业生产。老人至今还记得，比他更老的老人们给他讲的关于诸葛亮的故事。 尼桑：我主要是跟一个名字叫艾初（音）的一个老人，死了可能是十多年吧，还有一个叫艾桑（音）的，死了可能五六年了。按照他们说那些，佤族（语）说，也就是两千年以前，就在这个时候呢，因为（粮食）产量很低，他（诸葛亮）就教（我们）如何耕种，如何选种，如何把这个种子管好。 约一千八百年前，一些蜀汉的官员被诸葛亮派到这里。他们带来了当时最先进的农耕技术，教会了南中人民盖房子，种水稻，使用耕牛，植桑养蚕，纺纱织布，改变了这里刀耕火种的原始生产方式。 这里是云南省普洱市，是闻名中外的普洱茶的最主要的产地之一。相传，当年正是诸葛亮在这里大规模的推广茶叶种植，才有了后来的普洱茶。今天，普洱茶已经是中国人最日常的生活茶饮之一。为了纪念诸葛亮，与其他地区不同，这里的人们奉诸葛亮为茶祖。像这样的关于诸葛亮的故事，在广大的西南地区有很多，这些美丽的故事，宛若普洱茶的茶香，越是经历久远的年代，越是厚重，香醇。 赞曰：至此，诸葛亮对与南中的改革也就差不多了，农业是立根之本。而茶叶又可以带来一定的经济利益，使人民安居乐业。 沈伯俊：早在《隆中对》中，诸葛亮就提出了他的治理南中的原则，南抚夷越。既然是南抚夷越，那他的原则就是，但欲服其心，不欲灭其类也。 七擒孟获，南抚夷越，最终让这里的人们过上真正稳定的生活。这才是诸葛亮心中真正的队南中的平定。经过几年的努力，蜀汉政权终于拥有了一个相对和平安稳的环境。而此时，诸葛亮所推行的内政改革\u003e ，也已经全面展开。 内政，第一位重要的因素，就是人才。诸葛亮选拔人才，不拘资历，不拘地域，尤其注重德才兼备。张裔，益州太守，在南中叛乱时期，被反叛首领抓获献给了孙权。在这之后的数年里，诸葛亮的心里一直牵挂着这个才识过人的张裔，后来，在邓芝出使东吴期间，邓芝遵照诸葛亮的嘱托，向孙权提出，希望能够放张裔回蜀。适逢两国重新修好，孙权痛快答应了邓芝的要求，然而，事后孙权很快发现，张裔是一位博学多才之士。十分后悔放虎归山，于是立即派人去追，而张裔早已连夜返回蜀地去了。张裔归来，诸葛亮立即委以重任，蜀汉又有了一位得力的官员。蒋琬，费祎，董允，王连，陈震，张裔，费诗，秦宓等等，像这样被诸葛亮发现并任用的官员数不胜数。一时间，人尽其才，才尽其用，巴蜀地区有才能的人才争相为国家效劳。 沈伯俊：他善于发现人才，诸葛亮本人就是刘备慧眼识才才走上政治舞台的。诸葛亮怎么识才？怎么衡量一个才？他始终坚持德才兼备。 内政建设，除了需要得力的人才，更需要建立一套完善的法律体系。诸葛亮亲自主持制定了蜀汉的国家法典《蜀科》。以法治蜀，从严治国。公元 228 年，这一天，蜀汉的刑场周围挤满了文武群臣和围观的百姓。行刑时间将至，只见一个人缓缓来到刑场，这个人正是诸葛亮最疼爱的谋士，马谡。马谡，因为违反军令，导致战略要地街亭失守，兵败失守后，马谡又临阵逃脱，论罪当斩。临刑前，马谡给诸葛亮写信，信中，他视诸葛亮为自己的父亲，并将一家老小托付给诸葛亮，围观的百姓无不动容流泪，群臣纷纷向诸葛亮求情，然而，此时的马谡却十分清楚，自己罪无可赦，丞相绝不会姑息。马谡被斩首后，诸葛亮伤心欲绝，久久难以平复。 法律面前，人人平等。在诸葛亮所惩处的人里面，既有亲贵，也有功臣，无论是什么人，一旦触犯刑律，诸葛亮一律严办，绝不偏袒。然而，诸葛亮的以法治蜀，绝不是依靠简单的严刑酷法，而是建立在教化的基础上，并充满了人性关怀。同为先帝托孤大臣的李严4，因为弄权而贻误军机，被诸葛亮弹劾流放。之后，诸葛亮给李严的儿子李丰写了一封信，信中，诸葛亮诚恳地说明了流放的理由，并希望李丰能够说服他的父亲，充分认识到自己的错误","date":"2013-01-26","objectID":"/2013/01/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E7%BA%AA%E5%BD%95%E7%89%87031-%E8%AF%B8%E8%91%9B%E4%BA%AE%E6%B2%BB%E8%9C%80/:0:0","tags":["《中国通史》纪录片"],"title":"《中国通史》纪录片：031 诸葛亮治蜀","uri":"/2013/01/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E7%BA%AA%E5%BD%95%E7%89%87031-%E8%AF%B8%E8%91%9B%E4%BA%AE%E6%B2%BB%E8%9C%80/"},{"categories":["浮生杂记"],"content":"2013\" 2013 充满传奇色彩的 2012 年就这样过去了。自从上了高中以后，总觉得时间好快，有种跟不上节奏的感觉。 先简单总结一下过去的一年。高一下学期，为了一个信念努力拼搏，虽然如愿以偿，但总是觉得怪怪的。高二，一直被一种莫名的情绪笼罩。 可能是因为生活节奏太快的缘故，对于很多事情都没有什么记忆了。以至于周五回想周一的事情都感觉过了好久。推究这种感觉的原因，可能是被迫习惯了这些不习惯的事实吧。这一年也对我的思想转变起了很大的影响。下面主要讲几件事例吧，也不可能面面俱到。 申明：本人对下述事件所涉及的个人或集体不带任何恶意。 一开始来到新班级，有点诧异。没过几天，就感觉很不习惯。对于自己以前所在班级的留恋无可非议，每天在走廊里搞聚会，利用优势地理位置也无可厚非，但是大声喧哗，影响公共秩序好像不太好吧。 课间我们在走廊里乘凉，看着一群男男女女大吵大叫，玩一些不上大雅之堂的游戏或者说些带着痞子气的话语，只能说，他们没事干吧。或许我们根本不了解他们才下的这个结论吧。不过这样的印象谁又敢去了解呢。 对于一些人，尤其是男生，都高二了，遇到事情推卸责任，耍脾气，真是不可理喻，在此也不想指出，毕竟，他们早晚会为自己的行为付出代价。也许只有这样他们才会明白吧。 还有个不得不提的话题，为什么现在的女生会如此随意呢，对此，只能是敬而远之了。 上评论可能是从我个人想法出发吧。当初建立世界观的时候受老子、周易的影响较大，所以有些思想比较传统吧，对于这些过于现代的元素感到无法接受吧。有了上述的事例，自然就造成了现在自己宁可一个人看看课外书，刷刷作业，也不想去接触外界那些令人无法接受的事情。就好像文化夜市我和张程晔、子敬兄、昊阳兄一起在教室刷作业，然后去小店解决了晚饭。 对于日后，我想我还是会坚持我的世界观不动摇吧，毕竟现在看到的事情不会也不可能会是社会的走向。所以，必须坚定信念。 另外一件对于我影响比较大的事情是一个人的一句话，大意是，不一定朋友就一定会是非常好的，也可能是没办法的。这也就好比戴着面具生活，只是要记得对谁带着面具，对谁毫无掩饰。虽然说这样做可以建立和谐的人际关系，但是总觉得有点违背个人内心道德，但是有时候还不得不这样。 思想上的转变大致如上所述，经历了很大的斗争，最终结果是，坚持自己以往的根本思想，对于一些新思想，取精去糟的吸收。 再讲讲 NOIP 吧，这是个不得不提的话题，虽然竞赛过去几个月了，成绩也已经尘埃落定，但是这次比赛却给我很大的启发。做人做事就好比代码。有时候一步走错，满盘皆输；有时候贪心的选择了自己不熟练的算法，可能直接导致了 0 分；有时候把问题复杂化，结果只能是 0 分。虽然过程非常艰辛，但是拿到了全国复赛二等奖的通知还是挺开心的。不知道能不能获得 Winter Camp 的资格。 对于新班主任，郭华。宿舍扣分扣得我都不好意思见她了。进入高二，总感觉数学不对劲，明明都是会的内容，却不是算错，就是没过程。 最近在宿舍里做起了泡面生意，到目前一共卖出了 12 箱，也有了些盈利。主要还是为了积累经验。做生意的确很苦，每天要去泡开水，风雨无阻。 2013，新年快乐。 ","date":"2012-12-31","objectID":"/2012/12/%E5%A3%AC%E8%BE%B0%E5%BF%972012-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/:0:0","tags":["年度总结"],"title":"壬辰志（2012 年度总结）","uri":"/2012/12/%E5%A3%AC%E8%BE%B0%E5%BF%972012-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"categories":["浮生杂记"],"content":"网站终于好了，在 2012 年的最后一天写下第一篇文章。 搭建网站的想法很早就有了，由于一些事情耽搁了，主要是经济来源问题。由于前段时间在宿舍中卖泡面赚了些钱，所以才搭起了这个网站。搭建这个网站也不容易，从申请域名，设置 A 记录，配置 DNS 服务器，域名解析到空间的选择等，可以说又是一次历练吧。现在的网站还非常简陋，以后会慢慢完善。 有人问我，什么不用 QQ 空间。我想还是因为这里比较自由吧。主要还是写一些关于生活的文章，包括一些杂感、竞赛，抑或其他。 关于 Ivy - End，前者是我的母校，后者是我的 QQ 昵称。但现在有了更多的意义。将来也是。 附上一段代码： #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello World\" \u003c\u003c endl; return 0; } ","date":"2012-12-31","objectID":"/2012/12/hello-world/:0:0","tags":["建站"],"title":"Hello World","uri":"/2012/12/hello-world/"}]